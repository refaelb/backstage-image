{"version":3,"file":"static/module-json-schema-library.d7dd6567.js","mappings":"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","sources":["webpack://app/../../node_modules/json-schema-library/dist/module/lib/config/strings.js","webpack://app/../../node_modules/json-schema-library/dist/module/lib/utils/render.js","webpack://app/../../node_modules/json-schema-library/dist/module/lib/utils/__.js","webpack://app/../../node_modules/json-schema-library/dist/module/lib/utils/createCustomError.js","webpack://app/../../node_modules/json-schema-library/dist/module/lib/getTypeOf.js","webpack://app/../../node_modules/json-schema-library/dist/module/lib/types.js","webpack://app/../../node_modules/json-schema-library/dist/module/lib/utils/filter.js","webpack://app/../../node_modules/json-schema-library/dist/module/lib/utils/flattenArray.js","webpack://app/../../node_modules/json-schema-library/dist/module/lib/config/settings.js","webpack://app/../../node_modules/json-schema-library/dist/module/lib/resolveOneOf.strict.js","webpack://app/../../node_modules/json-schema-library/dist/module/lib/utils/copy.js","webpack://app/../../node_modules/json-schema-library/dist/module/lib/utils/merge.js","webpack://app/../../node_modules/json-schema-library/dist/module/lib/resolveAllOf.js","webpack://app/../../node_modules/json-schema-library/dist/module/lib/resolveOneOf.fuzzy.js","webpack://app/../../node_modules/json-schema-library/dist/module/lib/getSchema.js","webpack://app/../../node_modules/json-schema-library/dist/module/lib/resolveRef.merge.js","webpack://app/../../node_modules/json-schema-library/dist/module/lib/addRemoteSchema.js","webpack://app/../../node_modules/json-schema-library/dist/module/lib/schema/types.js","webpack://app/../../node_modules/json-schema-library/dist/module/lib/schema/getTypeId.js","webpack://app/../../node_modules/json-schema-library/dist/module/lib/schema/getTypeDefs.js","webpack://app/../../node_modules/json-schema-library/dist/module/lib/eachSchema.js","webpack://app/../../node_modules/json-schema-library/dist/module/lib/compile/joinScope.js","webpack://app/../../node_modules/json-schema-library/dist/module/lib/compile/splitRef.js","webpack://app/../../node_modules/json-schema-library/dist/module/lib/compile/getRef.js","webpack://app/../../node_modules/json-schema-library/dist/module/lib/draft06/compile/index.js","webpack://app/../../node_modules/json-schema-library/dist/module/lib/each.js","webpack://app/../../node_modules/json-schema-library/dist/module/lib/validation/errors.js","webpack://app/../../node_modules/json-schema-library/dist/module/lib/validation/format.js","webpack://app/../../node_modules/json-schema-library/dist/module/lib/utils/isEmpty.js","webpack://app/../../node_modules/json-schema-library/dist/module/lib/getTemplate.js","webpack://app/../../node_modules/json-schema-library/dist/module/lib/isValid.js","webpack://app/../../node_modules/json-schema-library/dist/module/lib/utils/deepCompare.js","webpack://app/../../node_modules/json-schema-library/dist/module/lib/utils/punycode.ucs2decode.js","webpack://app/../../node_modules/json-schema-library/dist/module/lib/validation/keyword.js","webpack://app/../../node_modules/json-schema-library/dist/module/lib/draft06/validation/keyword.js","webpack://app/../../node_modules/json-schema-library/dist/module/lib/resolveAnyOf.js","webpack://app/../../node_modules/json-schema-library/dist/module/lib/resolveRef.strict.js","webpack://app/../../node_modules/json-schema-library/dist/module/lib/createSchemaOf.js","webpack://app/../../node_modules/json-schema-library/dist/module/lib/getChildSchemaSelection.js","webpack://app/../../node_modules/json-schema-library/dist/module/lib/step.js","webpack://app/../../node_modules/json-schema-library/dist/module/lib/draft06/validation/type.js","webpack://app/../../node_modules/json-schema-library/dist/module/lib/validate.js","webpack://app/../../node_modules/json-schema-library/dist/module/lib/draft/index.js","webpack://app/../../node_modules/json-schema-library/dist/module/lib/draft07/index.js","webpack://app/../../node_modules/json-schema-library/dist/module/lib/jsoneditor/index.js","webpack://app/../../node_modules/json-schema-library/dist/module/lib/SchemaService.js","webpack://app/../../node_modules/json-schema-library/dist/module/lib/compile/index.js","webpack://app/../../node_modules/json-schema-library/dist/module/lib/draft04/index.js","webpack://app/../../node_modules/json-schema-library/dist/module/lib/validation/type.js","webpack://app/../../node_modules/json-schema-library/dist/module/lib/compileSchema.js","webpack://app/../../node_modules/json-schema-library/dist/module/lib/draft06/index.js","webpack://app/../../node_modules/json-schema-library/dist/module/index.js"],"sourcesContent":["/* eslint max-len: 0 */\nexport default {\n    // validation errors\n    AdditionalItemsError: \"Array at `{{pointer}}` may not have an additional item `{{key}}`\",\n    AdditionalPropertiesError: \"Additional property `{{property}}` on `{{pointer}}` does not match schema `{{schema}}`\",\n    AllOfError: \"Value `{{value}}` at `{{pointer}}` does not match schema of `{{allOf}}`\",\n    AnyOfError: \"Value `{{value}}` at `{{pointer}}` does not match any schema of `{{anyOf}}`\",\n    ConstError: \"Expected value at `{{pointer}}` to be `{{expected}}`, but value given is `{{value}}`\",\n    containsAnyError: \"The array at `{{pointer}}` must contain at least one item\",\n    ContainsArrayError: \"The property at `{{pointer}}` must not be an array\",\n    ContainsError: \"The array at `{{pointer}}` must contain an element that matches `{{schema}}`\",\n    EnumError: \"Expected given value `{{value}}` in `{{pointer}}` to be one of `{{values}}`\",\n    FormatDateError: \"Value `{{value}}` at `{{pointer}}` is not a valid date\",\n    FormatDateTimeError: \"Value `{{value}}` at `{{pointer}}` is not a valid date-time\",\n    FormatEmailError: \"Value `{{value}}` at `{{pointer}}` is not a valid email\",\n    FormatHostnameError: \"Value `{{value}}` at `{{pointer}}` is not a valid hostname\",\n    FormatIPV4Error: \"Value `{{value}}` at `{{pointer}}` is not a valid IPv4 address\",\n    FormatIPV4LeadingZeroError: \"IPv4 addresses starting with zero are invalid, since they are interpreted as octals\",\n    FormatIPV6Error: \"Value `{{value}}` at `{{pointer}}` is not a valid IPv6 address\",\n    FormatIPV6LeadingZeroError: \"IPv6 addresses starting with zero are invalid, since they are interpreted as octals\",\n    FormatJSONPointerError: \"Value `{{value}}` at `{{pointer}}` is not a valid json-pointer\",\n    FormatRegExError: \"Value `{{value}}` at `{{pointer}}` is not a valid regular expression\",\n    FormatTimeError: \"Value `{{value}}` at `{{pointer}}` is not a valid time\",\n    FormatURIError: \"Value `{{value}}` at `{{pointer}}` is not a valid uri\",\n    FormatURIReferenceError: \"Value `{{value}}` at `{{pointer}}` is not a valid uri-reference\",\n    FormatURITemplateError: \"Value `{{value}}` at `{{pointer}}` is not a valid uri-template\",\n    FormatURLError: \"Value `{{value}}` at `{{pointer}}` is not a valid url\",\n    InvalidDataError: \"No value may be specified in `{{pointer}}`\",\n    InvalidPropertyNameError: \"Invalid property name `{{property}}` at `{{pointer}}`\",\n    MaximumError: \"Value in `{{pointer}}` is `{{length}}`, but should be `{{maximum}}` at maximum\",\n    MaxItemsError: \"Too many items in `{{pointer}}`, should be `{{maximum}}` at most, but got `{{length}}`\",\n    MaxLengthError: \"Value `{{pointer}}` should have a maximum length of `{{maxLength}}`, but got `{{length}}`.\",\n    MaxPropertiesError: \"Too many properties in `{{pointer}}`, should be `{{maximum}}` at most, but got `{{length}}`\",\n    MinimumError: \"Value in `{{pointer}}` is `{{length}}`, but should be `{{minimum}}` at minimum\",\n    MinItemsError: \"Too few items in `{{pointer}}`, should be at least `{{minimum}}`, but got `{{length}}`\",\n    MinItemsOneError: \"At least one item is required in `{{pointer}}`\",\n    MinLengthError: \"Value `{{pointer}}` should have a minimum length of `{{minLength}}`, but got `{{length}}`.\",\n    MinLengthOneError: \"A value is required in `{{pointer}}`\",\n    MinPropertiesError: \"Too few properties in `{{pointer}}`, should be at least `{{minimum}}`, but got `{{length}}`\",\n    MissingDependencyError: \"The required propery '{{missingProperty}}' in `{{pointer}}` is missing\",\n    MissingOneOfPropertyError: \"Value at `{{pointer}}` property: `{{property}}`\",\n    MultipleOfError: \"Expected `{{value}}` in `{{pointer}}` to be multiple of `{{multipleOf}}`\",\n    MultipleOneOfError: \"Value `{{value}}` should not match multiple schemas in oneOf `{{matches}}`\",\n    NoAdditionalPropertiesError: \"Additional property `{{property}}` in `{{pointer}}` is not allowed\",\n    NotError: \"Value `{{value}}` at pointer should not match schema `{{not}}`\",\n    OneOfError: \"Value `{{value}}` in `{{pointer}}` does not match any given oneof schema\",\n    OneOfPropertyError: \"Failed finding a matching oneOfProperty schema in `{{pointer}}` where `{{property}}` matches `{{value}}`\",\n    PatternError: \"Value in `{{pointer}}` should match `{{description}}`, but received `{{received}}`\",\n    PatternPropertiesError: \"Property `{{key}}` does not match any patterns in `{{pointer}}`. Valid patterns are: {{patterns}}\",\n    RequiredPropertyError: \"The required property `{{key}}` is missing at `{{pointer}}`\",\n    TypeError: \"Expected `{{value}}` ({{received}}) in `{{pointer}}` to be of type `{{expected}}`\",\n    UndefinedValueError: \"Value must not be undefined in `{{pointer}}`\",\n    UniqueItemsError: \"Expected unique items in {{pointer}}: duplicate value `{{value}}` found at {{itemPointer}} and {{duplicatePointer}}\",\n    UnknownPropertyError: \"Could not find a valid schema for property `{{pointer}}` within object\",\n    ValueNotEmptyError: \"A value for `{{property}}` is required at `{{pointer}}`\"\n};\n","/**\n * Renders data into a string by {{variables}}.\n * Given a template string, removes all {{property}} substrings and replaces them with the property in the given data\n *\n * @param template - template string containing variables in handelbars/mustache style\n * @param data - flat object containing properties matching variables\n * @return rendered string\n */\nexport default function render(template, data = {}) {\n    return template.replace(/\\{\\{\\w+\\}\\}/g, match => data[match.replace(/[{}]/g, \"\")]);\n}\n","import strings from \"../config/strings\";\nimport render from \"./render\";\n/**\n * Renders the given string as defined in __@see config/strings.js__\n * @param keyword\n * @param data - template data\n * @param fallback - fallback template\n * @return resulting string\n */\nexport default function __(keyword, data, fallback = keyword) {\n    const template = strings[keyword] || fallback;\n    return render(template, data);\n}\n","import __ from \"./__\";\nfunction dashCase(text) {\n    return text.replace(/([a-z])([A-Z])/g, \"$1-$2\").toLowerCase();\n}\nexport function createError(name, data) {\n    return {\n        type: \"error\",\n        name,\n        code: dashCase(name),\n        message: __(name, data),\n        data\n    };\n}\n/**\n * Creates a custom Error-Constructor which instances may be identified by `customError instanceof Error`. Its messages\n * are defined by strings-object @see config/strings.ts\n *\n * @param name - id of error (camelcased)\n * @return error constructor function\n */\nexport function createCustomError(name) {\n    return createError.bind(null, name);\n}\n","const toString = Object.prototype.toString;\nexport default function getTypeOf(value) {\n    const type = toString\n        .call(value)\n        .match(/\\s([^\\]]+)\\]/)\n        .pop()\n        .toLowerCase();\n    if (type === \"file\") {\n        return \"object\";\n    }\n    return type;\n}\n","/**\n * ts type guard for json error\n * @returns true if passed type is a JSONError\n */\nexport function isJSONError(error) {\n    return (error === null || error === void 0 ? void 0 : error.type) === \"error\";\n}\n","import { isJSONError } from \"../types\";\nexport function isPromise(obj) {\n    return obj instanceof Promise;\n}\nexport function errorOrPromise(error) {\n    return isJSONError(error) || isPromise(error);\n}\nexport function errorsOnly(error) {\n    return isJSONError(error);\n}\n","export default function flattenArray(list, result = []) {\n    for (let i = 0; i < list.length; i += 1) {\n        const item = list[i];\n        if (Array.isArray(item)) {\n            flattenArray(item, result);\n        }\n        else {\n            result.push(item);\n        }\n    }\n    return result;\n}\n","export default {\n    DECLARATOR_ONEOF: \"oneOfProperty\",\n    GET_TEMPLATE_RECURSION_LIMIT: 1,\n    floatingPointPrecision: 10000,\n    propertyBlacklist: [\"_id\"]\n};\n","import { errorOrPromise } from \"./utils/filter\";\nimport flattenArray from \"./utils/flattenArray\";\nimport settings from \"./config/settings\";\nimport { isJSONError } from \"./types\";\nconst { DECLARATOR_ONEOF } = settings;\n/**\n * Selects and returns a oneOf schema for the given data\n *\n * @param core - validator\n * @param data\n * @param schema - current json schema containing property oneOf\n * @param pointer - json pointer to data\n * @return oneOf schema or an error\n */\nexport default function resolveOneOf(core, data, schema = core.rootSchema, pointer = \"#\") {\n    // !keyword: oneOfProperty\n    // an additional <DECLARATOR_ONEOF> (default `oneOfProperty`) on the schema will exactly determine the\n    // oneOf value (if set in data)\n    // @fixme\n    // abort if no data is given an DECLARATOR_ONEOF is set (used by getChildSchemaSelection)\n    // this case (data != null) should not be necessary\n    if (data != null && schema[DECLARATOR_ONEOF]) {\n        const errors = [];\n        const oneOfProperty = schema[DECLARATOR_ONEOF];\n        const oneOfValue = data[schema[DECLARATOR_ONEOF]];\n        if (oneOfValue === undefined) {\n            return core.errors.missingOneOfPropertyError({ property: oneOfProperty, pointer });\n        }\n        for (let i = 0; i < schema.oneOf.length; i += 1) {\n            const one = core.resolveRef(schema.oneOf[i]);\n            const oneOfPropertySchema = core.step(oneOfProperty, one, data, pointer);\n            if (isJSONError(oneOfPropertySchema)) {\n                return oneOfPropertySchema;\n            }\n            let result = flattenArray(core.validate(oneOfValue, oneOfPropertySchema, pointer));\n            result = result.filter(errorOrPromise);\n            if (result.length > 0) {\n                errors.push(...result);\n            }\n            else {\n                return one; // return resolved schema\n            }\n        }\n        return core.errors.oneOfPropertyError({\n            property: oneOfProperty,\n            value: oneOfValue,\n            pointer,\n            errors\n        });\n    }\n    const matches = [];\n    const errors = [];\n    for (let i = 0; i < schema.oneOf.length; i += 1) {\n        const one = core.resolveRef(schema.oneOf[i]);\n        let result = flattenArray(core.validate(data, one, pointer));\n        result = result.filter(errorOrPromise);\n        if (result.length > 0) {\n            errors.push(...result);\n        }\n        else {\n            matches.push(one);\n        }\n    }\n    if (matches.length === 1) {\n        return matches[0];\n    }\n    if (matches.length > 1) {\n        return core.errors.multipleOneOfError({\n            value: data,\n            pointer,\n            matches\n        });\n    }\n    return core.errors.oneOfError({\n        value: JSON.stringify(data),\n        pointer,\n        oneOf: schema.oneOf,\n        errors\n    });\n}\n","export default (value) => JSON.parse(JSON.stringify(value));\n","import deepmerge from \"deepmerge\";\nconst overwriteMerge = (destinationArray, sourceArray) => sourceArray;\n/**\n * returns a new json-schema, where properties are combined and arrays are replaced\n */\nexport default (a, b) => deepmerge(a, b, { arrayMerge: overwriteMerge });\n// var d = c.filter((item, pos) => c.indexOf(item) === pos)\nconst mergeUniqueItems = (destinationArray, sourceArray) => {\n    const all = destinationArray.concat(sourceArray);\n    return all.filter((item, pos) => all.indexOf(item) === pos);\n};\n/**\n * returns a new json-schema, where properties are combined and arrays are replaced\n */\nexport const mergeArraysUnique = (a, b) => deepmerge(a, b, { arrayMerge: mergeUniqueItems });\n","/**\n * resolveAllOf is tricky:\n *\n * resolve all merges all schemas altough each schema in the list must be used\n * for validation. But to use this as a template schema to create data and a\n * resolved schema, structural data must be merged. Currently, it is merged in\n * all case, but separately validated and resolved. This will break at some\n * point, requiring us to be more specific on our current intent (validation\n * vs get (resolved) schema)\n */\nimport copy from \"./utils/copy\";\nimport { mergeArraysUnique } from \"./utils/merge\";\n/**\n * resolves schema\n * when complete this will have much duplication to step.object etc\n */\nfunction resolveSchema(draft, schemaToResolve, data) {\n    var _a;\n    const schema = { ...((_a = draft.resolveRef(schemaToResolve)) !== null && _a !== void 0 ? _a : {}) };\n    // @draft >= 07\n    if (schema.if && (schema.then || schema.else)) {\n        const isValid = draft.isValid(data, schema.if);\n        if (isValid && schema.then) {\n            return resolveSchema(draft, schema.then, data);\n        }\n        if (!isValid && schema.else) {\n            return resolveSchema(draft, schema.else, data);\n        }\n        delete schema.if;\n        delete schema.then;\n        delete schema.else;\n    }\n    return schema;\n}\nexport default function resolveAllOf(draft, data, schema = draft.rootSchema, pointer = \"#\") {\n    let mergedSchema = copy(schema);\n    for (let i = 0; i < schema.allOf.length; i += 1) {\n        const allOfSchema = resolveSchema(draft, schema.allOf[i], data);\n        mergedSchema = mergeArraysUnique(mergedSchema, allOfSchema);\n        data = draft.getTemplate(data, mergedSchema);\n    }\n    delete mergedSchema.allOf;\n    return mergedSchema;\n}\n","import { errorOrPromise } from \"./utils/filter\";\nimport flattenArray from \"./utils/flattenArray\";\nimport getTypeOf from \"./getTypeOf\";\nimport settings from \"./config/settings\";\nimport { isJSONError } from \"./types\";\nconst { DECLARATOR_ONEOF } = settings;\n/**\n * Returns a ranking for the data and given schema\n *\n * @param core\n * @param - json schema type: object\n * @param data\n * @param [pointer]\n * @return ranking value (higher is better)\n */\nfunction fuzzyObjectValue(core, one, data, pointer) {\n    if (data == null || one.properties == null) {\n        return -1;\n    }\n    let value = 0;\n    const keys = Object.keys(one.properties);\n    for (let i = 0; i < keys.length; i += 1) {\n        const key = keys[i];\n        if (data[key] != null && core.isValid(data[key], one.properties[key], pointer)) {\n            value += 1;\n        }\n    }\n    return value;\n}\n/**\n * Selects and returns a oneOf schema for the given data\n *\n * @param core\n * @param data\n * @param [schema] - current json schema containing property oneOf\n * @param [pointer] - json pointer to data\n * @return oneOf schema or an error\n */\nexport default function resolveOneOf(core, data, schema = core.rootSchema, pointer = \"#\") {\n    // !keyword: oneOfProperty\n    // an additional <DECLARATOR_ONEOF> (default `oneOfProperty`) on the schema will exactly determine the\n    // oneOf value (if set in data)\n    // @fixme\n    // abort if no data is given an DECLARATOR_ONEOF is set (used by getChildSchemaSelection)\n    // this case (data != null) should not be necessary\n    if (data != null && schema[DECLARATOR_ONEOF]) {\n        const errors = [];\n        const oneOfProperty = schema[DECLARATOR_ONEOF];\n        const oneOfValue = data[schema[DECLARATOR_ONEOF]];\n        if (oneOfValue === undefined) {\n            return core.errors.missingOneOfPropertyError({ property: oneOfProperty, pointer });\n        }\n        for (let i = 0; i < schema.oneOf.length; i += 1) {\n            const one = core.resolveRef(schema.oneOf[i]);\n            const oneOfPropertySchema = core.step(oneOfProperty, one, data, pointer);\n            if (isJSONError(oneOfPropertySchema)) {\n                return oneOfPropertySchema;\n            }\n            let result = flattenArray(core.validate(oneOfValue, oneOfPropertySchema, pointer));\n            result = result.filter(errorOrPromise);\n            if (result.length > 0) {\n                errors.push(...result);\n            }\n            else {\n                return one; // return resolved schema\n            }\n        }\n        return core.errors.oneOfPropertyError({\n            property: oneOfProperty,\n            value: oneOfValue,\n            pointer,\n            errors\n        });\n    }\n    // keyword: oneOf\n    const matches = [];\n    for (let i = 0; i < schema.oneOf.length; i += 1) {\n        const one = core.resolveRef(schema.oneOf[i]);\n        if (core.isValid(data, one, pointer)) {\n            matches.push(one);\n        }\n    }\n    if (matches.length === 1) {\n        return matches[0];\n    }\n    // fuzzy match oneOf\n    if (getTypeOf(data) === \"object\") {\n        let schemaOfItem;\n        let fuzzyGreatest = 0;\n        for (let i = 0; i < schema.oneOf.length; i += 1) {\n            const one = core.resolveRef(schema.oneOf[i]);\n            const fuzzyValue = fuzzyObjectValue(core, one, data);\n            if (fuzzyGreatest < fuzzyValue) {\n                fuzzyGreatest = fuzzyValue;\n                schemaOfItem = schema.oneOf[i];\n            }\n        }\n        if (schemaOfItem === undefined) {\n            return core.errors.oneOfError({\n                value: JSON.stringify(data),\n                pointer,\n                oneOf: schema.oneOf\n            });\n        }\n        return schemaOfItem;\n    }\n    if (matches.length > 1) {\n        return core.errors.multipleOneOfError({ matches, data, pointer });\n    }\n    return core.errors.oneOfError({ value: JSON.stringify(data), pointer, oneOf: schema.oneOf });\n}\n","import gp from \"@sagold/json-pointer\";\nimport { isJSONError } from \"./types\";\nconst emptyObject = {};\n/**\n * Returns the json-schema of a data-json-pointer.\n *\n *  Notes\n *      - Uses draft.step to walk through data and schema\n *\n * @param draft\n * @param pointer - json pointer in data to get the json schema for\n * @param [data] - the data object, which includes the json pointers value. This is optional, as\n *    long as no oneOf, anyOf, etc statement is part of the pointers schema\n * @param [schema] - the json schema to iterate. Defaults to draft.rootSchema\n * @return json schema object of the json-pointer or an error\n */\nexport default function getSchema(draft, pointer, data, schema = draft.rootSchema) {\n    const frags = gp.split(pointer);\n    schema = draft.resolveRef(schema);\n    return _get(draft, schema, frags, pointer, data);\n}\nfunction _get(draft, schema, frags, pointer, data = emptyObject) {\n    if (frags.length === 0) {\n        return draft.resolveRef(schema);\n    }\n    const key = frags.shift(); // step key\n    schema = draft.step(key, schema, data, pointer); // step schema\n    if (isJSONError(schema)) {\n        return schema;\n    }\n    // @ts-ignore\n    data = data[key]; // step data\n    return _get(draft, schema, frags, `${pointer}/${key}`, data);\n}\n","export default function resolveRefMerge(schema, rootSchema) {\n    if (schema == null || schema.$ref == null) {\n        return schema;\n    }\n    const resolvedSchema = rootSchema.getRef(schema);\n    const mergedSchema = Object.assign({}, resolvedSchema, schema);\n    delete mergedSchema.$ref;\n    // @todo the following might not be safe nor incomplete\n    Object.defineProperty(mergedSchema, \"__ref\", { enumerable: false, value: schema.__ref });\n    Object.defineProperty(mergedSchema, \"getRoot\", { enumerable: false, value: schema.getRoot });\n    return mergedSchema;\n}\n","/**\n * register a json-schema to be referenced from another json-schema\n * @param url    base-url of json-schema (aka id)\n * @param schema\n */\nexport default function addRemoteSchema(draft, url, schema) {\n    schema.id = schema.id || url;\n    draft.remotes[url] = draft.compileSchema(schema);\n}\n","const Types = {\n    $ref: {\n        type: false\n    },\n    allOf: {\n        type: false,\n        definitions: [\"allOf/*\"]\n    },\n    anyOf: {\n        type: false,\n        definitions: [\"anyOf/*\"]\n    },\n    array: {\n        type: true,\n        // ignore additionalItems:TypeDef, when items:TypeDef\n        definitions: [\n            \"allOf/*\",\n            \"anyOf/*\",\n            \"oneOf/*\",\n            \"not\",\n            \"items\",\n            \"items/*\",\n            \"additionalItems\"\n        ],\n        validationKeywords: [\"minItems\", \"maxItems\", \"uniqueItems\"],\n        keywords: [\"items\", \"additionalItems\", \"minItems\", \"maxItems\", \"uniqueItems\"]\n    },\n    boolean: {\n        type: true\n    },\n    enum: {\n        type: false\n    },\n    integer: {\n        type: true,\n        definitions: [\"allOf/*\", \"anyOf/*\", \"oneOf/*\", \"not\"],\n        validationKeywords: [\"minimum\", \"maximum\", \"multipleOf\"]\n    },\n    not: {\n        type: false,\n        definitions: [\"not\"]\n    },\n    number: {\n        type: true,\n        definitions: [\"allOf/*\", \"anyOf/*\", \"oneOf/*\", \"not\"],\n        validationKeywords: [\"minimum\", \"maximum\", \"multipleOf\"]\n    },\n    null: {\n        type: true\n    },\n    object: {\n        type: true,\n        // patternProperties also validate properties\n        // dependencies:(string, TypeDef) extend current TypeDef\n        // additional Properties validate only remaining properties (after properties & pattern)\n        definitions: [\n            \"allOf/*\",\n            \"anyOf/*\",\n            \"oneOf/*\",\n            \"not\",\n            \"properties/*\",\n            \"additionalProperties\",\n            \"patternProperties/*\",\n            \"dependencies/*\"\n        ],\n        validationKeywords: [\"minProperties\", \"maxProperties\", \"required\"],\n        keywords: [\n            \"properties\",\n            \"additionalProperties\",\n            \"patternProperties\",\n            \"dependencies\",\n            \"minProperties\",\n            \"maxProperties\",\n            \"required\"\n        ]\n    },\n    oneOf: {\n        type: false,\n        definitions: [\"oneOf/*\"]\n    },\n    string: {\n        type: true,\n        definitions: [\"allOf/*\", \"anyOf/*\", \"oneOf/*\", \"not\"],\n        validationKeywords: [\"minLength\", \"maxLength\", \"pattern\"]\n    }\n};\nexport default Types;\n","import types from \"./types\";\nconst isObject = (value) => Object.prototype.toString.call(value) === \"[object Object]\";\nconst typeKeywords = Object.keys(types).filter((id) => types[id].type === false);\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\n/**\n * @throws Error    on multiple matches (invalid schema)\n *\n * Returns the type id of a schema object\n * @param schema\n * @return type id, if found\n */\nexport default function getTypeId(schema) {\n    if (isObject(schema) === false) {\n        return undefined;\n    }\n    if (schema.enum) {\n        return \"enum\";\n    }\n    // @ts-ignore\n    if (types[schema.type] || Array.isArray(schema.type)) {\n        return schema.type;\n    }\n    const ids = typeKeywords.filter((type) => schema[type]);\n    if (ids.length === 1) {\n        return ids[0];\n    }\n    if (ids.length === 0) {\n        // @expensive, guess type object\n        for (let i = 0, l = types.object.keywords.length; i < l; i += 1) {\n            const keyword = types.object.keywords[i];\n            if (hasOwnProperty.call(schema, keyword)) {\n                // eslint-disable-line\n                return \"object\";\n            }\n        }\n        // @expensive, guess type array\n        for (let i = 0, l = types.array.keywords.length; i < l; i += 1) {\n            const keyword = types.array.keywords[i];\n            if (hasOwnProperty.call(schema, keyword)) {\n                // eslint-disable-line\n                return \"array\";\n            }\n        }\n        return undefined;\n    }\n    throw new Error(`Mutiple typeIds [${ids.join(\", \")}] matched in ${JSON.stringify(schema)}`);\n}\n","import gp from \"@sagold/json-pointer\";\nimport { get } from \"@sagold/json-query\";\nimport getTypeId from \"./getTypeId\";\nimport types from \"./types\";\nconst isObject = (value) => Object.prototype.toString.call(value) === \"[object Object]\";\n/**\n * Returns a list of all (direct) type definitions from the given schema\n * @param schema\n * @return list of type definition, given as { pointer, def }\n */\nexport default function getTypeDefs(schema) {\n    const defs = [];\n    const id = getTypeId(schema);\n    if (id == null) {\n        return defs;\n    }\n    let type;\n    if (Array.isArray(id)) {\n        // since types can also be declared as a set of types, merge the definitions\n        // maybe this will require a more sophisticated approach\n        type = {};\n        for (let i = 0, l = id.length; i < l; i += 1) {\n            Object.assign(type, types[id[i]]);\n        }\n    }\n    else {\n        type = types[id];\n    }\n    if (type.definitions == null) {\n        return defs;\n    }\n    type.definitions.forEach((query) => {\n        get(schema, query, (value, key, parent, pointer) => {\n            if (isObject(value) && getTypeId(value)) {\n                defs.push({ pointer: gp.join(gp.split(pointer), false), def: value });\n            }\n        });\n    });\n    return defs;\n}\n","import gp from \"@sagold/json-pointer\";\nimport getTypeDefs from \"./schema/getTypeDefs\";\nconst isObject = (value) => Object.prototype.toString.call(value) === \"[object Object]\";\nfunction nextTypeDefs(schema, pointer) {\n    if (this.callback(schema, pointer) === true) {\n        // eslint-disable-line no-invalid-this\n        return; // stop iteration\n    }\n    const defs = getTypeDefs(schema);\n    // eslint-disable-next-line no-invalid-this\n    defs.forEach((next) => this.nextTypeDefs(next.def, gp.join(pointer, next.pointer, false)));\n}\nfunction eachDefinition(walk, schema, pointer, key = \"definitions\") {\n    const defs = schema[key];\n    Object.keys(defs).forEach((defId) => {\n        if (defs[defId] === false || isObject(defs[defId])) {\n            walk.nextTypeDefs(defs[defId], gp.join(pointer, key, defId, false));\n            return;\n        }\n        // console.log(`Invalid schema in ${pointer}/${key}/${defId}`);\n    });\n}\nexport function eachSchema(schema, callback, pointer = \"#\") {\n    const walk = { callback, nextTypeDefs };\n    walk.nextTypeDefs(schema, pointer);\n    if (schema.definitions != null) {\n        walk.callback = (defschema, schemaPointer) => {\n            callback(defschema, schemaPointer);\n            if (defschema.definitions != null) {\n                eachDefinition(walk, defschema, schemaPointer);\n            }\n        };\n        eachDefinition(walk, schema, pointer);\n    }\n    if (schema.$defs != null) {\n        walk.callback = (defschema, schemaPointer) => {\n            callback(defschema, schemaPointer);\n            if (defschema.definitions != null) {\n                eachDefinition(walk, defschema, schemaPointer);\n            }\n        };\n        eachDefinition(walk, schema, pointer, \"$defs\");\n    }\n}\n","/* eslint max-statements-per-line: [\"error\", { \"max\": 2 }] */\nconst suffixes = /(#|\\/)+$/;\nconst trailingHash = /#$/;\nconst isDomain = /^[^:]+:\\/\\/[^/]+\\//;\nconst trailingFragments = /\\/[^/]*$/;\nconst idAndPointer = /#.*$/;\nexport default function joinScope(previous, id) {\n    if (previous == null && id == null) {\n        return \"#\";\n    }\n    if (id == null) {\n        return previous.replace(trailingHash, \"\");\n    }\n    if (previous == null) {\n        return id.replace(trailingHash, \"\");\n    }\n    if (id[0] === \"#\") {\n        return `${previous.replace(idAndPointer, \"\")}${id.replace(suffixes, \"\")}`;\n    }\n    if (isDomain.test(id)) {\n        return id.replace(trailingHash, \"\");\n    }\n    return `${previous.replace(trailingFragments, \"\")}/${id.replace(trailingHash, \"\")}`;\n}\n","const suffixes = /(#|\\/)+$/g;\nconst emptyValues = [\"\", null, \"#\"];\nexport default function splitRef($ref) {\n    if (emptyValues.includes($ref)) {\n        return [];\n    }\n    $ref = $ref.replace(suffixes, \"\");\n    if ($ref.indexOf(\"#\") === -1) {\n        return [$ref.replace(suffixes, \"\")];\n    }\n    if ($ref.indexOf(\"#\") === 0) {\n        return [$ref.replace(suffixes, \"\")];\n    }\n    const result = $ref.split(\"#\");\n    result[0] = result[0].replace(suffixes, \"\");\n    result[1] = `#${result[1].replace(suffixes, \"\")}`;\n    return result;\n}\n","import { get } from \"@sagold/json-pointer\";\nimport splitRef from \"./splitRef\";\nimport getTypeOf from \"../getTypeOf\";\nconst suffixes = /(#|\\/)+$/g;\nconst isObject = (val) => getTypeOf(val) === \"object\";\n// 1. combined is known\n// 2. base or pointer is known\n// 3. base + pointer is known\nexport default function getRef(context, rootSchema, $ref) {\n    if (isObject($ref)) {\n        $ref = $ref.__ref || $ref.$ref;\n    }\n    if ($ref == null) {\n        return rootSchema;\n    }\n    let schema;\n    // is it a known $ref?\n    const $remote = $ref.replace(suffixes, \"\");\n    if (context.remotes[$remote]) {\n        schema = context.remotes[$remote];\n        if (schema && schema.$ref) {\n            return getRef(context, rootSchema, schema.$ref);\n        }\n        return schema;\n    }\n    if (context.ids[$ref]) {\n        schema = get(rootSchema, context.ids[$ref]);\n        if (schema && schema.$ref) {\n            return getRef(context, rootSchema, schema.$ref);\n        }\n        return schema;\n    }\n    // is it a ref with host/pointer?\n    const fragments = splitRef($ref);\n    if (fragments.length === 0) {\n        return rootSchema;\n    }\n    if (fragments.length === 1) {\n        $ref = fragments[0];\n        if (context.remotes[$ref]) {\n            schema = context.remotes[$ref];\n            return getRef(context, rootSchema, schema.$ref);\n        }\n        if (context.ids[$ref]) {\n            schema = get(rootSchema, context.ids[$ref]);\n            if (schema && schema.$ref) {\n                return getRef(context, rootSchema, schema.$ref);\n            }\n            return schema;\n        }\n    }\n    if (fragments.length === 2) {\n        const base = fragments[0];\n        $ref = fragments[1];\n        if (context.remotes[base]) {\n            if (context.remotes[base].getRef) {\n                return context.remotes[base].getRef($ref);\n            }\n            // console.log(\"warning: uncompiled remote - context may be wrong\", base);\n            return getRef(context, context.remotes[base], $ref);\n        }\n        if (context.ids[base]) {\n            return getRef(context, get(rootSchema, context.ids[base]), $ref);\n        }\n    }\n    schema = get(rootSchema, context.ids[$ref] || $ref);\n    if (schema && schema.$ref) {\n        return getRef(context, rootSchema, schema.$ref);\n    }\n    return schema;\n}\n","import { eachSchema } from \"../../eachSchema\";\n// import remotes from \"../../../remotes\";\nimport joinScope from \"../../compile/joinScope\";\nimport getRef from \"../../compile/getRef\";\nimport { get } from \"@sagold/json-pointer\";\nconst COMPILED = \"__compiled\";\nconst COMPILED_REF = \"__ref\";\nconst GET_REF = \"getRef\";\nconst GET_ROOT = \"getRoot\";\nconst suffixes = /(#|\\/)+$/g;\n/**\n * @draft starting with _draft 06_ keyword `id` has been renamed to `$id`\n *\n * compiles the input root schema for $ref resolution and returns it again\n * @attention this modifies input schema but maintains object-structure\n *\n * for a compiled json-schema you can call getRef on any contained schema (location of type).\n * this resolves a $ref target to a valid schema (for a valid $ref)\n *\n * @param rootSchema root json-schema ($id, defs, ... ) to compile\n * @param [force] = false force compile json-schema\n * @return compiled json-schema\n */\nexport default function compileSchema(draft, schemaToCompile, rootSchema = schemaToCompile, force = false) {\n    // @ts-ignore\n    if (schemaToCompile === true || schemaToCompile === false || schemaToCompile === undefined) {\n        return schemaToCompile;\n    }\n    if (schemaToCompile[COMPILED] !== undefined) {\n        return schemaToCompile;\n    } // eslint-disable-line\n    const context = { ids: {}, remotes: draft.remotes };\n    const rootSchemaAsString = JSON.stringify(schemaToCompile);\n    const compiledSchema = JSON.parse(rootSchemaAsString);\n    Object.defineProperty(compiledSchema, COMPILED, { enumerable: false, value: true });\n    Object.defineProperty(compiledSchema, GET_REF, {\n        enumerable: false,\n        value: getRef.bind(null, context, compiledSchema)\n    });\n    // bail early, when no $refs are defined\n    if (force === false && rootSchemaAsString.includes(\"$ref\") === false) {\n        return compiledSchema;\n    }\n    // compile this schema under rootSchema, making definitions available to $ref-resolution\n    if (compiledSchema !== rootSchema) {\n        Object.defineProperty(compiledSchema, \"$defs\", {\n            enumerable: true,\n            value: Object.assign({}, rootSchema.definitions, rootSchema.$defs, compiledSchema.definitions, compiledSchema.$defs)\n        });\n    }\n    const scopes = {};\n    const getRoot = () => compiledSchema;\n    eachSchema(compiledSchema, (schema, pointer) => {\n        var _a;\n        if (schema.$id) {\n            // if this is a schema being merged on root object, we cannot override\n            // parents locations, but must reuse it\n            if (schema.$id.startsWith(\"http\") && /(allOf|anyOf|oneOf)\\/\\d+$/.test(pointer)) {\n                const parentPointer = pointer.replace(/\\/(allOf|anyOf|oneOf)\\/\\d+$/, \"\");\n                const parentSchema = get(compiledSchema, parentPointer);\n                schema.$id = (_a = parentSchema.$id) !== null && _a !== void 0 ? _a : schema.$id;\n            }\n            context.ids[schema.$id.replace(suffixes, \"\")] = pointer;\n        }\n        // build up scopes and add them to $ref-resolution map\n        pointer = `#${pointer}`.replace(/##+/, \"#\");\n        const previousPointer = pointer.replace(/\\/[^/]+$/, \"\");\n        const parentPointer = pointer.replace(/\\/[^/]+\\/[^/]+$/, \"\");\n        const previousScope = scopes[previousPointer] || scopes[parentPointer];\n        const scope = joinScope(previousScope, schema.$id);\n        scopes[pointer] = scope;\n        if (context.ids[scope] == null) {\n            context.ids[scope] = pointer;\n        }\n        if (schema.$ref && !schema[COMPILED_REF]) {\n            Object.defineProperty(schema, COMPILED_REF, {\n                enumerable: false,\n                value: joinScope(scope, schema.$ref)\n            });\n            // @todo currently not used:\n            Object.defineProperty(schema, GET_ROOT, { enumerable: false, value: getRoot });\n            // console.log(\"compiled ref\", scope, schema.$ref, \"=>\", joinScope(scope, schema.$ref));\n        }\n    });\n    return compiledSchema;\n}\n","import getTypeOf from \"./getTypeOf\";\n/**\n * Iterates over data, retrieving its schema\n *\n * @param core - validator\n * @param data - the data to iterate\n * @param callback - will be called with (schema, data, pointer) on each item\n * @param [schema] - the schema matching the data. Defaults to rootSchema\n * @param [pointer] - pointer to current data. Default to rootPointer\n */\nexport function each(core, data, callback, schema = core.rootSchema, pointer = \"#\") {\n    schema = core.resolveRef(schema);\n    callback(schema, data, pointer);\n    const dataType = getTypeOf(data);\n    if (dataType === \"object\") {\n        Object.keys(data).forEach((key) => {\n            const nextSchema = core.step(key, schema, data, pointer); // not save\n            const next = data[key]; // save\n            core.each(next, callback, nextSchema, `${pointer}/${key}`);\n        });\n    }\n    else if (dataType === \"array\") {\n        data.forEach((next, key) => {\n            const nextSchema = core.step(key, schema, data, pointer);\n            core.each(next, callback, nextSchema, `${pointer}/${key}`);\n        });\n    }\n}\n","/* eslint no-invalid-this: 0 */\nimport { createCustomError } from \"../utils/createCustomError\";\nconst errors = {\n    additionalItemsError: createCustomError(\"AdditionalItemsError\"),\n    additionalPropertiesError: createCustomError(\"AdditionalPropertiesError\"),\n    anyOfError: createCustomError(\"AnyOfError\"),\n    allOfError: createCustomError(\"AllOfError\"),\n    constError: createCustomError(\"ConstError\"),\n    containsError: createCustomError(\"ContainsError\"),\n    containsArrayError: createCustomError(\"ContainsArrayError\"),\n    containsAnyError: createCustomError(\"ContainsAnyError\"),\n    enumError: createCustomError(\"EnumError\"),\n    formatURLError: createCustomError(\"FormatURLError\"),\n    formatURIError: createCustomError(\"FormatURIError\"),\n    formatURIReferenceError: createCustomError(\"FormatURIReferenceError\"),\n    formatURITemplateError: createCustomError(\"FormatURITemplateError\"),\n    formatDateError: createCustomError(\"FormatDateaError\"),\n    formatDateTimeError: createCustomError(\"FormatDateTimeError\"),\n    formatEmailError: createCustomError(\"FormatEmailError\"),\n    formatHostnameError: createCustomError(\"FormatHostnameError\"),\n    formatIPV4Error: createCustomError(\"FormatIPV4Error\"),\n    formatIPV4LeadingZeroError: createCustomError(\"FormatIPV4LeadingZeroError\"),\n    formatIPV6Error: createCustomError(\"FormatIPV6Error\"),\n    formatIPV6LeadingZeroError: createCustomError(\"FormatIPV6LeadingZeroError\"),\n    formatJSONPointerError: createCustomError(\"FormatJSONPointerError\"),\n    formatRegExError: createCustomError(\"FormatRegExError\"),\n    formatTimeError: createCustomError(\"FormatTimeError\"),\n    invalidSchemaError: createCustomError(\"InvalidSchemaError\"),\n    invalidDataError: createCustomError(\"InvalidDataError\"),\n    invalidTypeError: createCustomError(\"InvalidTypeError\"),\n    invalidPropertyNameError: createCustomError(\"InvalidPropertyNameError\"),\n    maximumError: createCustomError(\"MaximumError\"),\n    maxItemsError: createCustomError(\"MaxItemsError\"),\n    maxLengthError: createCustomError(\"MaxLengthError\"),\n    maxPropertiesError: createCustomError(\"MaxPropertiesError\"),\n    minimumError: createCustomError(\"MinimumError\"),\n    minItemsError: createCustomError(\"MinItemsError\"),\n    minItemsOneError: createCustomError(\"MinItemsOneError\"),\n    minLengthError: createCustomError(\"MinLengthError\"),\n    minLengthOneError: createCustomError(\"MinLengthOneError\"),\n    minPropertiesError: createCustomError(\"MinPropertiesError\"),\n    missingDependencyError: createCustomError(\"MissingDependencyError\"),\n    missingOneOfPropertyError: createCustomError(\"MissingOneOfPropertyError\"),\n    multipleOfError: createCustomError(\"MultipleOfError\"),\n    multipleOneOfError: createCustomError(\"MultipleOneOfError\"),\n    noAdditionalPropertiesError: createCustomError(\"NoAdditionalPropertiesError\"),\n    notError: createCustomError(\"NotError\"),\n    oneOfError: createCustomError(\"OneOfError\"),\n    oneOfPropertyError: createCustomError(\"OneOfPropertyError\"),\n    patternError: createCustomError(\"PatternError\"),\n    patternPropertiesError: createCustomError(\"PatternPropertiesError\"),\n    requiredPropertyError: createCustomError(\"RequiredPropertyError\"),\n    typeError: createCustomError(\"TypeError\"),\n    undefinedValueError: createCustomError(\"UndefinedValueError\"),\n    uniqueItemsError: createCustomError(\"UniqueItemsError\"),\n    unknownPropertyError: createCustomError(\"UnknownPropertyError\"),\n    valueNotEmptyError: createCustomError(\"ValueNotEmptyError\")\n};\nexport default errors;\n","/* eslint-disable max-len, no-control-regex */\nimport errors from \"./errors\";\nimport validUrl from \"valid-url\";\n// referenced\n// https://github.com/cfworker/cfworker/blob/main/packages/json-schema/src/format.ts\n// https://gist.github.com/marcelotmelo/b67f58a08bee6c2468f8\nconst isValidDateTime = new RegExp(\"^([0-9]+)-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01])[Tt]([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]|60)(\\\\.[0-9]+)?(([Zz])|([\\\\+|\\\\-]([01][0-9]|2[0-3]):[0-5][0-9]))$\");\nconst isValidIPV4 = /^(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)$/;\nconst isValidIPV6 = /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:)))$/i;\nconst isValidHostname = /^(?=.{1,255}$)[0-9A-Za-z](?:(?:[0-9A-Za-z]|-){0,61}[0-9A-Za-z])?(?:\\.[0-9A-Za-z](?:(?:[0-9A-Za-z]|-){0,61}[0-9A-Za-z])?)*\\.?$/;\nconst matchDate = /^(\\d\\d\\d\\d)-(\\d\\d)-(\\d\\d)$/;\nconst matchTime = /^(\\d\\d):(\\d\\d):(\\d\\d)(\\.\\d+)?(z|[+-]\\d\\d(?::?\\d\\d)?)?$/i;\nconst DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\nconst isValidJSONPointer = /^(?:\\/(?:[^~/]|~0|~1)*)*$/;\nconst isValidRelativeJSONPointer = /^(?:0|[1-9][0-9]*)(?:#|(?:\\/(?:[^~/]|~0|~1)*)*)$/;\nconst isValidURIRef = /^(?:[a-z][a-z0-9+\\-.]*:)?(?:\\/?\\/(?:(?:[a-z0-9\\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\\.[a-z0-9\\-._~!$&'()*+,;=:]+)\\]|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)|(?:[a-z0-9\\-._~!$&'\"()*+,;=]|%[0-9a-f]{2})*)(?::\\d*)?(?:\\/(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})*)*|\\/(?:(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\\?(?:[a-z0-9\\-._~!$&'\"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\\-._~!$&'\"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;\n// uri-template: https://tools.ietf.org/html/rfc6570\nconst isValidURITemplate = /^(?:(?:[^\\x00-\\x20\"'<>%\\\\^`{|}]|%[0-9a-f]{2})|\\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\\*)?)*\\})*$/i;\n// Default JSON-Schema formats: date-time, email, hostname, ipv4, ipv6, uri, uriref\nconst formatValidators = {\n    date: (core, schema, value, pointer) => {\n        if (typeof value !== \"string\") {\n            return undefined;\n        }\n        // https://github.com/cfworker/cfworker/blob/main/packages/json-schema/src/format.ts\n        // full-date from http://tools.ietf.org/html/rfc3339#section-5.6\n        const matches = value.match(matchDate);\n        if (!matches) {\n            return errors.formatDateTimeError({ value, pointer });\n        }\n        const year = +matches[1];\n        const month = +matches[2];\n        const day = +matches[3];\n        // https://tools.ietf.org/html/rfc3339#appendix-C\n        const isLeapYear = year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);\n        if (month >= 1 &&\n            month <= 12 &&\n            day >= 1 &&\n            day <= (month == 2 && isLeapYear ? 29 : DAYS[month])) {\n            return undefined;\n        }\n        return errors.formatDateError({ value, pointer });\n    },\n    \"date-time\": (core, schema, value, pointer) => {\n        if (typeof value !== \"string\") {\n            return undefined;\n        }\n        if (value === \"\" || isValidDateTime.test(value)) {\n            if (new Date(value).toString() === \"Invalid Date\") {\n                return errors.formatDateTimeError({ value, pointer });\n            }\n            return undefined;\n        }\n        return errors.formatDateTimeError({ value, pointer });\n    },\n    email: (core, schema, value, pointer) => {\n        // taken from https://github.com/ExodusMovement/schemasafe/blob/master/src/formats.js\n        if (typeof value !== \"string\") {\n            return undefined;\n        }\n        if (value[0] === '\"') {\n            return errors.formatEmailError({ value, pointer });\n        }\n        const [name, host, ...rest] = value.split(\"@\");\n        if (!name || !host || rest.length !== 0 || name.length > 64 || host.length > 253) {\n            return errors.formatEmailError({ value, pointer });\n        }\n        if (name[0] === \".\" || name.endsWith(\".\") || name.includes(\"..\")) {\n            return errors.formatEmailError({ value, pointer });\n        }\n        if (!/^[a-z0-9.-]+$/i.test(host) || !/^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+$/i.test(name)) {\n            return errors.formatEmailError({ value, pointer });\n        }\n        if (!host.split(\".\").every((part) => /^[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?$/i.test(part))) {\n            return errors.formatEmailError({ value, pointer });\n        }\n        return undefined;\n    },\n    hostname: (core, schema, value, pointer) => {\n        if (typeof value !== \"string\") {\n            return undefined;\n        }\n        if (value === \"\" || isValidHostname.test(value)) {\n            return undefined;\n        }\n        return errors.formatHostnameError({ value, pointer });\n    },\n    ipv4: (core, schema, value, pointer) => {\n        if (typeof value !== \"string\" || value === \"\") {\n            return undefined;\n        }\n        if (value && value[0] === \"0\") {\n            // leading zeroes should be rejected, as they are treated as octals\n            return errors.formatIPV4LeadingZeroError({ value, pointer });\n        }\n        if (value.length <= 15 && isValidIPV4.test(value)) {\n            return undefined;\n        }\n        return errors.formatIPV4Error({ value, pointer });\n    },\n    ipv6: (core, schema, value, pointer) => {\n        if (typeof value !== \"string\" || value === \"\") {\n            return undefined;\n        }\n        if (value && value[0] === \"0\") {\n            // leading zeroes should be rejected, as they are treated as octals\n            return errors.formatIPV6LeadingZeroError({ value, pointer });\n        }\n        if (value.length <= 45 && isValidIPV6.test(value)) {\n            return undefined;\n        }\n        return errors.formatIPV6Error({ value, pointer });\n    },\n    \"json-pointer\": (core, schema, value, pointer) => {\n        if (typeof value !== \"string\" || value === \"\") {\n            return undefined;\n        }\n        if (isValidJSONPointer.test(value)) {\n            return undefined;\n        }\n        return errors.formatJSONPointerError({ value, pointer });\n    },\n    \"relative-json-pointer\": (core, schema, value, pointer) => {\n        if (typeof value !== \"string\" || value === \"\") {\n            return undefined;\n        }\n        if (isValidRelativeJSONPointer.test(value)) {\n            return undefined;\n        }\n        return errors.formatJSONPointerError({ value, pointer });\n    },\n    regex: (core, schema, value, pointer) => {\n        if (typeof value === \"string\" && /\\\\Z$/.test(value) === false) {\n            try {\n                new RegExp(value);\n                return undefined;\n            }\n            catch (e) { } // eslint-disable-line no-empty\n            return errors.formatRegExError({ value, pointer });\n        }\n        // v7 tests, ignore non-regex values\n        if (typeof value === \"object\" || typeof value === \"number\" || Array.isArray(value)) {\n            return undefined;\n        }\n        return errors.formatRegExError({ value, pointer });\n    },\n    time: (core, schema, value, pointer) => {\n        if (typeof value !== \"string\") {\n            return undefined;\n        }\n        // https://github.com/cfworker/cfworker/blob/main/packages/json-schema/src/format.ts\n        const matches = value.match(matchTime);\n        if (!matches) {\n            return errors.formatDateTimeError({ value, pointer });\n        }\n        const hour = +matches[1];\n        const minute = +matches[2];\n        const second = +matches[3];\n        const timeZone = !!matches[5];\n        if (((hour <= 23 && minute <= 59 && second <= 59) ||\n            (hour == 23 && minute == 59 && second == 60)) &&\n            timeZone) {\n            return undefined;\n        }\n        return errors.formatTimeError({ value, pointer });\n    },\n    uri: (core, schema, value, pointer) => {\n        if (typeof value !== \"string\" || value === \"\") {\n            return undefined;\n        }\n        if (validUrl.isUri(value)) {\n            return undefined;\n        }\n        return errors.formatURIError({ value, pointer });\n    },\n    \"uri-reference\": (core, schema, value, pointer) => {\n        if (typeof value !== \"string\" || value === \"\") {\n            return undefined;\n        }\n        if (isValidURIRef.test(value)) {\n            return undefined;\n        }\n        return errors.formatURIReferenceError({ value, pointer });\n    },\n    \"uri-template\": (core, schema, value, pointer) => {\n        if (typeof value !== \"string\" || value === \"\") {\n            return undefined;\n        }\n        if (isValidURITemplate.test(value)) {\n            return undefined;\n        }\n        return errors.formatURITemplateError({ value, pointer });\n    },\n    url: (core, schema, value, pointer) => {\n        if (value === \"\" || validUrl.isWebUri(value)) {\n            return undefined;\n        }\n        return errors.formatURLError({ value, pointer });\n    }\n};\nexport default formatValidators;\n","import getTypeOf from \"../getTypeOf\";\nexport function isEmpty(v) {\n    const type = getTypeOf(v);\n    switch (type) {\n        case \"string\":\n        case \"array\":\n            // @ts-ignore\n            return v.length === 0;\n        case \"null\":\n        case \"undefined\":\n            return true;\n        case \"object\":\n            return Object.keys(v).length === 0;\n        default:\n            return false;\n    }\n}\n","/* eslint quote-props: 0, max-statements-per-line: [\"error\", { \"max\": 2 }] */\nimport resolveOneOfFuzzy from \"./resolveOneOf.fuzzy\";\nimport getTypeOf from \"./getTypeOf\";\nimport merge from \"./utils/merge\";\nimport copy from \"./utils/copy\";\nimport settings from \"./config/settings\";\nimport { isJSONError } from \"./types\";\nimport { isEmpty } from \"./utils/isEmpty\";\nconst defaultOptions = {\n    addOptionalProps: true,\n    removeInvalidData: false\n};\nlet cache;\nfunction shouldResolveRef(schema, pointer) {\n    const { $ref } = schema;\n    if ($ref == null) {\n        return true;\n    }\n    const value = cache[pointer] == null || cache[pointer][$ref] == null ? 0 : cache[pointer][$ref];\n    return value < settings.GET_TEMPLATE_RECURSION_LIMIT;\n}\nfunction resolveRef(core, schema, pointer) {\n    // ensure we refactored consistently\n    if (pointer == null) {\n        throw new Error(`missing pointer ${pointer}`);\n    }\n    const { $ref } = schema;\n    if ($ref == null) {\n        return schema;\n    }\n    // @todo pointer + ref is redundant?\n    cache[pointer] = cache[pointer] || {};\n    cache[pointer][$ref] = cache[pointer][$ref] || 0;\n    cache[pointer][$ref] += 1;\n    return core.resolveRef(schema);\n}\nfunction convertValue(type, value) {\n    if (type === \"string\") {\n        return JSON.stringify(value);\n    }\n    else if (typeof value !== \"string\") {\n        return null;\n    }\n    try {\n        value = JSON.parse(value);\n        if (typeof value === type) {\n            return value;\n        }\n    }\n    catch (e) { } // eslint-disable-line no-empty\n    return null;\n}\n/**\n * Resolves $ref, allOf and anyOf schema-options, returning a combined json-schema.\n * Also returns a pointer-property on schema, that must be used as current pointer.\n * @param core\n * @param schema\n * @param data\n * @param pointer\n * @return resolved json-schema or input-schema\n */\nfunction createTemplateSchema(core, schema, data, pointer) {\n    // invalid schema\n    if (getTypeOf(schema) !== \"object\") {\n        return Object.assign({ pointer }, schema);\n    }\n    // return if reached recursion limit\n    if (shouldResolveRef(schema, pointer) === false && data == null) {\n        return false;\n    }\n    // resolve $ref and copy schema\n    let templateSchema = copy(resolveRef(core, schema, pointer));\n    if (Array.isArray(schema.anyOf) && schema.anyOf.length > 0) {\n        // test if we may resolve\n        if (shouldResolveRef(schema.anyOf[0], `${pointer}/anyOf/0`)) {\n            const resolvedAnyOf = resolveRef(core, schema.anyOf[0], `${pointer}/anyOf/0`);\n            templateSchema = merge(templateSchema, resolvedAnyOf);\n            // add pointer return-value, if any\n            templateSchema.pointer = schema.anyOf[0].$ref || templateSchema.pointer;\n        }\n        delete templateSchema.anyOf;\n    }\n    // resolve allOf\n    if (Array.isArray(schema.allOf)) {\n        for (let i = 0, l = schema.allOf.length; i < l; i += 1) {\n            // test if we may resolve\n            if (shouldResolveRef(schema.allOf[i], `${pointer}/allOf/${i}`)) {\n                templateSchema = merge(templateSchema, resolveRef(core, schema.allOf[i], `${pointer}/allOf/${i}`));\n                // add pointer return-value, if any\n                templateSchema.pointer = schema.allOf[i].$ref || templateSchema.pointer;\n            }\n        }\n        delete templateSchema.allOf;\n    }\n    templateSchema.pointer = templateSchema.pointer || schema.$ref || pointer;\n    return templateSchema;\n}\nconst isJSONSchema = (template) => template && typeof template === \"object\";\n/**\n * Create data object matching the given schema\n *\n * @param core - json schema core\n * @param [data] - optional template data\n * @param [schema] - json schema, defaults to rootSchema\n * @return created template data\n */\nfunction getTemplate(core, data, _schema, pointer, opts) {\n    if (_schema == null) {\n        throw new Error(`getTemplate: missing schema for data: ${JSON.stringify(data)}`);\n    }\n    if (pointer == null) {\n        throw new Error(\"Missing pointer\");\n    }\n    // resolve $ref references, allOf and first anyOf definitions\n    let schema = createTemplateSchema(core, _schema, data, pointer);\n    if (!isJSONSchema(schema)) {\n        return undefined;\n    }\n    pointer = schema.pointer;\n    if (schema === null || schema === void 0 ? void 0 : schema.const) {\n        return schema.const;\n    }\n    if (Array.isArray(schema.oneOf)) {\n        if (isEmpty(data)) {\n            const type = schema.oneOf[0].type ||\n                schema.type ||\n                (schema.const && typeof schema.const) ||\n                getTypeOf(data);\n            schema = { ...schema.oneOf[0], type };\n        }\n        else {\n            // find correct schema for data\n            const resolvedSchema = resolveOneOfFuzzy(core, data, schema);\n            if (isJSONError(resolvedSchema)) {\n                if (data != null && opts.removeInvalidData !== true) {\n                    return data;\n                }\n                // override\n                schema = schema.oneOf[0];\n                data = undefined;\n            }\n            else {\n                schema = resolvedSchema;\n            }\n        }\n    }\n    // @todo Array.isArray(schema.type)\n    // -> hasDefault? return\n    // if not -> pick first types\n    if (!isJSONSchema(schema) || schema.type == null) {\n        return undefined;\n    }\n    const type = Array.isArray(schema.type)\n        ? selectType(schema.type, data, schema.default)\n        : schema.type;\n    // reset invalid type\n    const dataType = getTypeOf(data);\n    if (data != null && dataType !== type && !(dataType === \"number\" && type === \"integer\")) {\n        data = convertValue(type, data);\n    }\n    if (TYPE[type] == null) {\n        // in case we could not resolve the type\n        // (schema-type could not be resolved and returned an error)\n        if (opts.removeInvalidData) {\n            return undefined;\n        }\n        return data;\n    }\n    const templateData = TYPE[type](core, schema, data, pointer, opts);\n    return templateData;\n}\nfunction selectType(types, data, defaultValue) {\n    if (data == undefined) {\n        if (defaultValue != null) {\n            const defaultType = getTypeOf(defaultValue);\n            if (types.includes(defaultType)) {\n                return defaultType;\n            }\n        }\n        return types[0];\n    }\n    const dataType = getTypeOf(data);\n    if (types.includes(dataType)) {\n        return dataType;\n    }\n    return types[0];\n}\nconst TYPE = {\n    null: (core, schema, data) => getDefault(schema, data, null),\n    string: (core, schema, data) => getDefault(schema, data, \"\"),\n    number: (core, schema, data) => getDefault(schema, data, 0),\n    integer: (core, schema, data) => getDefault(schema, data, 0),\n    boolean: (core, schema, data) => getDefault(schema, data, false),\n    object: (core, schema, data, pointer, opts) => {\n        var _a;\n        const template = schema.default === undefined ? {} : schema.default;\n        const d = {}; // do not assign data here, to keep ordering from json-schema\n        const required = (_a = schema.required) !== null && _a !== void 0 ? _a : [];\n        if (schema.properties) {\n            Object.keys(schema.properties).forEach((key) => {\n                const value = data == null || data[key] == null ? template[key] : data[key];\n                const isRequired = required.includes(key);\n                // Omit adding a property if it is not required or optional props should be added\n                if (value != null || isRequired || opts.addOptionalProps) {\n                    d[key] = getTemplate(core, value, schema.properties[key], `${pointer}/properties/${key}`, opts);\n                }\n            });\n        }\n        if (schema.dependencies) {\n            Object.keys(schema.dependencies).forEach((key) => {\n                if (d[key] === undefined) {\n                    return;\n                }\n                const dependency = schema.dependencies[key];\n                // dependencyRequired: { key: ['prop1', 'prop2'] }\n                if (Array.isArray(dependency)) {\n                    dependency.forEach((prop) => {\n                        d[prop] = getTemplate(core, d[prop], schema.properties[prop], `${pointer}/properties/${prop}`, opts);\n                    });\n                    return;\n                }\n                if (getTypeOf(dependency) !== \"object\") {\n                    return;\n                }\n                const result = getTemplate(core, data, {\n                    ...dependency,\n                    // required: Object.keys(dependency.properties || {}).concat(\n                    //     dependency.required ?? []\n                    // ),\n                    type: \"object\"\n                }, `${pointer}/dependencies/${key}`, opts);\n                if (result && !isJSONError(result)) {\n                    Object.assign(d, result);\n                }\n            });\n        }\n        if (data) {\n            // merge any missing data (additionals) to resulting object\n            Object.keys(data).forEach((key) => d[key] == null && (d[key] = data[key]));\n        }\n        if (schema.if && (schema.then || schema.else)) {\n            const isValid = core.isValid(d, schema.if);\n            if (isValid && schema.then) {\n                const additionalData = core.getTemplate(d, { type: \"object\", ...schema.then }, opts);\n                Object.assign(d, additionalData);\n            }\n            else if (!isValid && schema.else) {\n                const additionalData = core.getTemplate(d, { type: \"object\", ...schema.else }, opts);\n                Object.assign(d, additionalData);\n            }\n        }\n        // returns object, which is ordered by json-schema\n        return d;\n    },\n    // build array type of items, ignores additionalItems\n    array: (core, schema, data, pointer, opts) => {\n        var _a, _b, _c;\n        const template = schema.default === undefined ? [] : schema.default;\n        schema.minItems = schema.minItems || 0;\n        const d = data || [];\n        // items are undefined\n        if (schema.items == null) {\n            return d;\n        }\n        // build defined set of items\n        if (Array.isArray(schema.items)) {\n            for (let i = 0, l = Math.max((_a = schema.minItems) !== null && _a !== void 0 ? _a : 0, (_c = (_b = schema.items) === null || _b === void 0 ? void 0 : _b.length) !== null && _c !== void 0 ? _c : 0); i < l; i += 1) {\n                d[i] = getTemplate(core, d[i] == null ? template[i] : d[i], schema.items[i], `${pointer}/items/${i}`, opts);\n            }\n            return d;\n        }\n        // abort if the schema is invalid\n        if (getTypeOf(schema.items) !== \"object\") {\n            return d;\n        }\n        // resolve allOf and first anyOf definition\n        const templateSchema = createTemplateSchema(core, schema.items, data, pointer);\n        if (templateSchema === false) {\n            return d;\n        }\n        pointer = templateSchema.pointer || pointer;\n        // build oneOf\n        if (templateSchema.oneOf && d.length === 0) {\n            const oneOfSchema = templateSchema.oneOf[0];\n            for (let i = 0; i < schema.minItems; i += 1) {\n                d[i] = getTemplate(core, d[i] == null ? template[i] : d[i], oneOfSchema, `${pointer}/oneOf/0`, opts);\n            }\n            return d;\n        }\n        if (templateSchema.oneOf && d.length > 0) {\n            const itemCount = Math.max(schema.minItems, d.length);\n            for (let i = 0; i < itemCount; i += 1) {\n                let value = d[i] == null ? template[i] : d[i];\n                let one = resolveOneOfFuzzy(core, value, templateSchema);\n                if (one == null || isJSONError(one)) {\n                    // schema could not be resolved or data is invalid\n                    if (value != null && opts.removeInvalidData !== true) {\n                        // keep invalid value\n                        d[i] = value;\n                    }\n                    else {\n                        // replace invalid value\n                        value = undefined;\n                        one = templateSchema.oneOf[0];\n                        d[i] = getTemplate(core, value, one, `${pointer}/oneOf/${i}`, opts);\n                    }\n                }\n                else {\n                    // schema is valid\n                    d[i] = getTemplate(core, value, one, `${pointer}/oneOf/${i}`, opts);\n                }\n            }\n            return d;\n        }\n        // build items-definition\n        if (templateSchema.type) {\n            for (let i = 0, l = Math.max(schema.minItems, d.length); i < l; i += 1) {\n                d[i] = getTemplate(core, d[i] == null ? template[i] : d[i], templateSchema, `${pointer}/items`, opts);\n            }\n            return d;\n        }\n        return d;\n    }\n};\nfunction getDefault(schema, templateValue, initValue) {\n    if (templateValue != null) {\n        return templateValue;\n    }\n    else if (schema.const) {\n        return schema.const;\n    }\n    else if (schema.default === undefined && Array.isArray(schema.enum)) {\n        return schema.enum[0];\n    }\n    else if (schema.default === undefined) {\n        return initValue;\n    }\n    return schema.default;\n}\nexport default (core, data, schema = core.rootSchema, opts = defaultOptions) => {\n    cache = { mi: {} };\n    return getTemplate(core, data, schema, \"#\", opts);\n};\n","/**\n * Test if the data is valid according to the given schema\n *\n * @param core - validator\n * @param value - value to validate\n * @param [schema] - json schema\n * @param [pointer] - json pointer pointing to value\n * @return if schema does match given value\n */\nexport default function isValid(core, value, schema = core.rootSchema, pointer = \"#\") {\n    return core.validate(value, schema, pointer).length === 0;\n}\n","/**\n * deep comparison of javascript types. Better handling than using\n * JSON.stringify, where property order is accounted for\n *\n * @returns true, if data types are deep equal\n */\nexport default function deepCompareStrict(a, b) {\n    const typeofa = typeof a;\n    if (typeofa !== typeof b) {\n        return false;\n    }\n    if (Array.isArray(a)) {\n        if (!Array.isArray(b)) {\n            return false;\n        }\n        const length = a.length;\n        if (length !== b.length) {\n            return false;\n        }\n        for (let i = 0; i < length; i++) {\n            if (!deepCompareStrict(a[i], b[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    if (typeofa === \"object\") {\n        if (!a || !b) {\n            return a === b;\n        }\n        const aKeys = Object.keys(a);\n        const bKeys = Object.keys(b);\n        const length = aKeys.length;\n        if (length !== bKeys.length) {\n            return false;\n        }\n        for (const k of aKeys) {\n            if (!deepCompareStrict(a[k], b[k])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    return a === b;\n}\n","/* eslint no-bitwise: 0 */\n/**\n * taken from punycode@2.1.0\n *\n * Creates an array containing the numeric code points of each Unicode\n * character in the string. While JavaScript uses UCS-2 internally,\n * this function will convert a pair of surrogate halves (each of which\n * UCS-2 exposes as separate characters) into a single code point,\n * matching UTF-16.\n * @see `punycode.ucs2.encode`\n * @see <https://mathiasbynens.be/notes/javascript-encoding>\n * @memberOf punycode.ucs2\n * @name decode\n * @param string The Unicode input string (UCS-2).\n * @returns The new array of code points.\n */\nexport default function ucs2decode(string) {\n    const output = [];\n    let counter = 0;\n    const length = string.length;\n    while (counter < length) {\n        const value = string.charCodeAt(counter++);\n        if (value >= 0xd800 && value <= 0xdbff && counter < length) {\n            // It's a high surrogate, and there is a next character.\n            const extra = string.charCodeAt(counter++);\n            // eslint-disable-next-line eqeqeq\n            if ((extra & 0xfc00) == 0xdc00) {\n                // Low surrogate.\n                output.push(((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000);\n            }\n            else {\n                // It's an unmatched surrogate; only append this code unit, in case the\n                // next code unit is the high surrogate of a surrogate pair.\n                output.push(value);\n                counter--;\n            }\n        }\n        else {\n            output.push(value);\n        }\n    }\n    return output;\n}\n","import getTypeOf from \"../getTypeOf\";\nimport isSame from \"../utils/deepCompare\";\nimport settings from \"../config/settings\";\nimport ucs2decode from \"../utils/punycode.ucs2decode\";\nimport { isJSONError } from \"../types\";\nconst FPP = settings.floatingPointPrecision;\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\nconst hasProperty = (value, property) => !(value[property] === undefined || !hasOwnProperty.call(value, property));\n// list of validation keywords: http://json-schema.org/latest/json-schema-validation.html#rfc.section.5\nconst KeywordValidation = {\n    additionalProperties: (core, schema, value, pointer) => {\n        if (schema.additionalProperties === true || schema.additionalProperties == null) {\n            return undefined;\n        }\n        if (getTypeOf(schema.patternProperties) === \"object\" &&\n            schema.additionalProperties === false) {\n            // this is an arrangement with patternProperties. patternProperties validate before additionalProperties:\n            // https://spacetelescope.github.io/understanding-json-schema/reference/object.html#index-5\n            return undefined;\n        }\n        const errors = [];\n        let receivedProperties = Object.keys(value).filter((prop) => settings.propertyBlacklist.includes(prop) === false);\n        const expectedProperties = Object.keys(schema.properties || {});\n        if (getTypeOf(schema.patternProperties) === \"object\") {\n            // filter received properties by matching patternProperties\n            const patterns = Object.keys(schema.patternProperties).map((pattern) => new RegExp(pattern));\n            receivedProperties = receivedProperties.filter((prop) => {\n                for (let i = 0; i < patterns.length; i += 1) {\n                    if (patterns[i].test(prop)) {\n                        return false; // remove\n                    }\n                }\n                return true;\n            });\n        }\n        // adds an error for each an unexpected property\n        for (let i = 0, l = receivedProperties.length; i < l; i += 1) {\n            const property = receivedProperties[i];\n            if (expectedProperties.indexOf(property) === -1) {\n                const isObject = typeof schema.additionalProperties === \"object\";\n                // additionalProperties { oneOf: [] }\n                if (isObject && Array.isArray(schema.additionalProperties.oneOf)) {\n                    const result = core.resolveOneOf(value[property], schema.additionalProperties, `${pointer}/${property}`);\n                    if (isJSONError(result)) {\n                        errors.push(core.errors.additionalPropertiesError({\n                            schema: schema.additionalProperties,\n                            property: receivedProperties[i],\n                            properties: expectedProperties,\n                            pointer,\n                            // pass all validation errors\n                            errors: result.data.errors\n                        }));\n                    }\n                    else {\n                        errors.push(...core.validate(value[property], result, pointer));\n                    }\n                    // additionalProperties {}\n                }\n                else if (isObject) {\n                    errors.push(...core.validate(value[property], schema.additionalProperties, `${pointer}/${property}`));\n                }\n                else {\n                    errors.push(core.errors.noAdditionalPropertiesError({\n                        property: receivedProperties[i],\n                        properties: expectedProperties,\n                        pointer\n                    }));\n                }\n            }\n        }\n        return errors;\n    },\n    allOf: (core, schema, value, pointer) => {\n        if (Array.isArray(schema.allOf) === false) {\n            return undefined;\n        }\n        const errors = [];\n        schema.allOf.forEach((subSchema) => {\n            errors.push(...core.validate(value, subSchema, pointer));\n        });\n        return errors;\n    },\n    anyOf: (core, schema, value, pointer) => {\n        if (Array.isArray(schema.anyOf) === false) {\n            return undefined;\n        }\n        for (let i = 0; i < schema.anyOf.length; i += 1) {\n            if (core.isValid(value, schema.anyOf[i])) {\n                return undefined;\n            }\n        }\n        return core.errors.anyOfError({ anyOf: schema.anyOf, value, pointer });\n    },\n    dependencies: (core, schema, value, pointer) => {\n        if (getTypeOf(schema.dependencies) !== \"object\") {\n            return undefined;\n        }\n        const errors = [];\n        Object.keys(value).forEach((property) => {\n            if (schema.dependencies[property] === undefined) {\n                return;\n            }\n            // @draft >= 6 boolean schema\n            if (schema.dependencies[property] === true) {\n                return;\n            }\n            if (schema.dependencies[property] === false) {\n                errors.push(core.errors.missingDependencyError({ pointer }));\n                return;\n            }\n            let dependencyErrors;\n            const type = getTypeOf(schema.dependencies[property]);\n            if (type === \"array\") {\n                dependencyErrors = schema.dependencies[property]\n                    .filter((dependency) => value[dependency] === undefined)\n                    .map((missingProperty) => core.errors.missingDependencyError({ missingProperty, pointer }));\n            }\n            else if (type === \"object\") {\n                dependencyErrors = core.validate(value, schema.dependencies[property], pointer);\n            }\n            else {\n                throw new Error(`Invalid dependency definition for ${pointer}/${property}. Must be list or schema`);\n            }\n            errors.push(...dependencyErrors);\n        });\n        return errors.length > 0 ? errors : undefined;\n    },\n    enum: (core, schema, value, pointer) => {\n        const type = getTypeOf(value);\n        if (type === \"object\" || type === \"array\") {\n            const valueStr = JSON.stringify(value);\n            for (let i = 0; i < schema.enum.length; i += 1) {\n                if (JSON.stringify(schema.enum[i]) === valueStr) {\n                    return undefined;\n                }\n            }\n        }\n        else if (schema.enum.includes(value)) {\n            return undefined;\n        }\n        return core.errors.enumError({ values: schema.enum, value, pointer });\n    },\n    format: (core, schema, value, pointer) => {\n        if (core.validateFormat[schema.format]) {\n            const errors = core.validateFormat[schema.format](core, schema, value, pointer);\n            return errors;\n        }\n        // fail silently if given format is not defined\n        return undefined;\n    },\n    items: (core, schema, value, pointer) => {\n        // @draft >= 7 bool schema\n        if (schema.items === false) {\n            if (Array.isArray(value) && value.length === 0) {\n                return undefined;\n            }\n            return core.errors.invalidDataError({ pointer, value });\n        }\n        const errors = [];\n        for (let i = 0; i < value.length; i += 1) {\n            const itemData = value[i];\n            // @todo reevaluate: incomplete schema is created here\n            const itemSchema = core.step(i, schema, value, pointer);\n            if (isJSONError(itemSchema)) {\n                return [itemSchema];\n            }\n            const itemErrors = core.validate(itemData, itemSchema, `${pointer}/${i}`);\n            errors.push(...itemErrors);\n        }\n        return errors;\n    },\n    maximum: (core, schema, value, pointer) => {\n        if (isNaN(schema.maximum)) {\n            return undefined;\n        }\n        if (schema.maximum && schema.maximum < value) {\n            return core.errors.maximumError({ maximum: schema.maximum, length: value, pointer });\n        }\n        if (schema.maximum && schema.exclusiveMaximum === true && schema.maximum === value) {\n            return core.errors.maximumError({ maximum: schema.maximum, length: value, pointer });\n        }\n        return undefined;\n    },\n    maxItems: (core, schema, value, pointer) => {\n        if (isNaN(schema.maxItems)) {\n            return undefined;\n        }\n        if (schema.maxItems < value.length) {\n            return core.errors.maxItemsError({\n                maximum: schema.maxItems,\n                length: value.length,\n                pointer\n            });\n        }\n        return undefined;\n    },\n    maxLength: (core, schema, value, pointer) => {\n        if (isNaN(schema.maxLength)) {\n            return undefined;\n        }\n        const lengthOfString = ucs2decode(value).length;\n        if (schema.maxLength < lengthOfString) {\n            return core.errors.maxLengthError({\n                maxLength: schema.maxLength,\n                length: lengthOfString,\n                pointer\n            });\n        }\n        return undefined;\n    },\n    maxProperties: (core, schema, value, pointer) => {\n        const propertyCount = Object.keys(value).length;\n        if (isNaN(schema.maxProperties) === false && schema.maxProperties < propertyCount) {\n            return core.errors.maxPropertiesError({\n                maxProperties: schema.maxProperties,\n                length: propertyCount,\n                pointer\n            });\n        }\n        return undefined;\n    },\n    minLength: (core, schema, value, pointer) => {\n        if (isNaN(schema.minLength)) {\n            return undefined;\n        }\n        const lengthOfString = ucs2decode(value).length;\n        if (schema.minLength > lengthOfString) {\n            if (schema.minLength === 1) {\n                return core.errors.minLengthOneError({\n                    minLength: schema.minLength,\n                    length: lengthOfString,\n                    pointer\n                });\n            }\n            return core.errors.minLengthError({\n                minLength: schema.minLength,\n                length: lengthOfString,\n                pointer\n            });\n        }\n        return undefined;\n    },\n    minimum: (core, schema, value, pointer) => {\n        if (isNaN(schema.minimum)) {\n            return undefined;\n        }\n        if (schema.minimum > value) {\n            return core.errors.minimumError({ minimum: schema.minimum, length: value, pointer });\n        }\n        if (schema.exclusiveMinimum === true && schema.minimum === value) {\n            return core.errors.minimumError({ minimum: schema.minimum, length: value, pointer });\n        }\n        return undefined;\n    },\n    minItems: (core, schema, value, pointer) => {\n        if (isNaN(schema.minItems)) {\n            return undefined;\n        }\n        if (schema.minItems > value.length) {\n            if (schema.minItems === 1) {\n                return core.errors.minItemsOneError({\n                    minItems: schema.minItems,\n                    length: value.length,\n                    pointer\n                });\n            }\n            return core.errors.minItemsError({\n                minItems: schema.minItems,\n                length: value.length,\n                pointer\n            });\n        }\n        return undefined;\n    },\n    minProperties: (core, schema, value, pointer) => {\n        if (isNaN(schema.minProperties)) {\n            return undefined;\n        }\n        const propertyCount = Object.keys(value).length;\n        if (schema.minProperties > propertyCount) {\n            return core.errors.minPropertiesError({\n                minProperties: schema.minProperties,\n                length: propertyCount,\n                pointer\n            });\n        }\n        return undefined;\n    },\n    multipleOf: (core, schema, value, pointer) => {\n        if (isNaN(schema.multipleOf)) {\n            return undefined;\n        }\n        // https://github.com/cfworker/cfworker/blob/master/packages/json-schema/src/validate.ts#L1061\n        // https://github.com/ExodusMovement/schemasafe/blob/master/src/compile.js#L441\n        if (((value * FPP) % (schema.multipleOf * FPP)) / FPP !== 0) {\n            return core.errors.multipleOfError({ multipleOf: schema.multipleOf, value, pointer });\n        }\n        // also check https://stackoverflow.com/questions/1815367/catch-and-compute-overflow-during-multiplication-of-two-large-integers\n        return undefined;\n    },\n    not: (core, schema, value, pointer) => {\n        const errors = [];\n        if (core.validate(value, schema.not, pointer).length === 0) {\n            errors.push(core.errors.notError({ value, not: schema.not, pointer }));\n        }\n        return errors;\n    },\n    oneOf: (core, schema, value, pointer) => {\n        if (Array.isArray(schema.oneOf) === false) {\n            return undefined;\n        }\n        schema = core.resolveOneOf(value, schema, pointer);\n        if (isJSONError(schema)) {\n            return schema;\n        }\n        return undefined;\n    },\n    pattern: (core, schema, value, pointer) => {\n        const pattern = new RegExp(schema.pattern, \"u\");\n        if (pattern.test(value) === false) {\n            return core.errors.patternError({\n                pattern: schema.pattern,\n                description: schema.patternExample || schema.pattern,\n                received: value,\n                pointer\n            });\n        }\n        return undefined;\n    },\n    patternProperties: (core, schema, value, pointer) => {\n        const properties = schema.properties || {};\n        const pp = schema.patternProperties;\n        if (getTypeOf(pp) !== \"object\") {\n            return undefined;\n        }\n        const errors = [];\n        const keys = Object.keys(value);\n        const patterns = Object.keys(pp).map((expr) => ({\n            regex: new RegExp(expr),\n            patternSchema: pp[expr]\n        }));\n        keys.forEach((key) => {\n            let patternFound = false;\n            for (let i = 0, l = patterns.length; i < l; i += 1) {\n                if (patterns[i].regex.test(key)) {\n                    patternFound = true;\n                    const valErrors = core.validate(value[key], patterns[i].patternSchema, `${pointer}/${key}`);\n                    if (valErrors && valErrors.length > 0) {\n                        errors.push(...valErrors);\n                    }\n                }\n            }\n            if (properties[key]) {\n                return;\n            }\n            if (patternFound === false && schema.additionalProperties === false) {\n                // this is an arrangement with additionalProperties\n                errors.push(core.errors.patternPropertiesError({\n                    key,\n                    pointer,\n                    patterns: Object.keys(pp).join(\",\")\n                }));\n            }\n        });\n        return errors;\n    },\n    properties: (core, schema, value, pointer) => {\n        const errors = [];\n        const keys = Object.keys(schema.properties || {});\n        for (let i = 0; i < keys.length; i += 1) {\n            const key = keys[i];\n            if (hasProperty(value, key)) {\n                const itemSchema = core.step(key, schema, value, pointer);\n                const keyErrors = core.validate(value[key], itemSchema, `${pointer}/${key}`);\n                errors.push(...keyErrors);\n            }\n        }\n        return errors;\n    },\n    // @todo move to separate file: this is custom keyword validation for JsonEditor.properties keyword\n    propertiesRequired: (core, schema, value, pointer) => {\n        const errors = [];\n        const keys = Object.keys(schema.properties || {});\n        for (let i = 0; i < keys.length; i += 1) {\n            const key = keys[i];\n            if (value[key] === undefined) {\n                errors.push(core.errors.requiredPropertyError({ key, pointer }));\n            }\n            else {\n                const itemSchema = core.step(key, schema, value, pointer);\n                const keyErrors = core.validate(value[key], itemSchema, `${pointer}/${key}`);\n                errors.push(...keyErrors);\n            }\n        }\n        return errors;\n    },\n    required: (core, schema, value, pointer) => {\n        if (Array.isArray(schema.required) === false) {\n            return undefined;\n        }\n        return schema.required.map((property) => {\n            if (!hasProperty(value, property)) {\n                return core.errors.requiredPropertyError({ key: property, pointer });\n            }\n            return undefined;\n        });\n    },\n    // @todo move to separate file: this is custom keyword validation for JsonEditor.required keyword\n    requiredNotEmpty: (core, schema, value, pointer) => {\n        if (Array.isArray(schema.required) === false) {\n            return undefined;\n        }\n        return schema.required.map((property) => {\n            if (value[property] == null || value[property] === \"\") {\n                return core.errors.valueNotEmptyError({\n                    property,\n                    pointer: `${pointer}/${property}`\n                });\n            }\n            return undefined;\n        });\n    },\n    uniqueItems: (core, schema, value, pointer) => {\n        if ((Array.isArray(value) && schema.uniqueItems) === false) {\n            return undefined;\n        }\n        const errors = [];\n        value.forEach((item, index) => {\n            for (let i = index + 1; i < value.length; i += 1) {\n                if (isSame(item, value[i])) {\n                    errors.push(core.errors.uniqueItemsError({\n                        pointer,\n                        itemPointer: `${pointer}/${index}`,\n                        duplicatePointer: `${pointer}/${i}`,\n                        value: JSON.stringify(item)\n                    }));\n                }\n            }\n        });\n        return errors;\n    }\n};\nexport default KeywordValidation;\n","import Keywords from \"../../validation/keyword\";\nimport getTypeOf from \"../../getTypeOf\";\nconst KeywordValidation = {\n    ...Keywords,\n    // @draft >= 6\n    contains: (core, schema, value, pointer) => {\n        if (schema.contains === false) {\n            return core.errors.containsArrayError({ pointer, value });\n        }\n        if (schema.contains === true) {\n            if (Array.isArray(value) && value.length === 0) {\n                return core.errors.containsAnyError({ pointer });\n            }\n            return undefined;\n        }\n        if (getTypeOf(schema.contains) !== \"object\") {\n            // ignore invalid schema\n            return undefined;\n        }\n        for (let i = 0; i < value.length; i += 1) {\n            if (core.isValid(value[i], schema.contains)) {\n                return undefined;\n            }\n        }\n        return core.errors.containsError({ pointer, schema: JSON.stringify(schema.contains) });\n    },\n    exclusiveMaximum: (core, schema, value, pointer) => {\n        if (isNaN(schema.exclusiveMaximum)) {\n            return undefined;\n        }\n        if (schema.exclusiveMaximum <= value) {\n            return core.errors.maximumError({\n                maximum: schema.exclusiveMaximum,\n                length: value,\n                pointer\n            });\n        }\n        return undefined;\n    },\n    exclusiveMinimum: (core, schema, value, pointer) => {\n        if (isNaN(schema.exclusiveMinimum)) {\n            return undefined;\n        }\n        if (schema.exclusiveMinimum >= value) {\n            return core.errors.minimumError({\n                minimum: schema.exclusiveMinimum,\n                length: value,\n                pointer\n            });\n        }\n        return undefined;\n    },\n    if: (core, schema, value, pointer) => {\n        if (schema.if == null) {\n            return undefined;\n        }\n        const ifErrors = core.validate(value, schema.if, pointer);\n        // console.log(\"if Errors\", value, ifErrors);\n        if (ifErrors.length === 0 && schema.then) {\n            return core.validate(value, schema.then, pointer);\n        }\n        if (ifErrors.length !== 0 && schema.else) {\n            return core.validate(value, schema.else, pointer);\n        }\n    },\n    maximum: (core, schema, value, pointer) => {\n        if (isNaN(schema.maximum)) {\n            return undefined;\n        }\n        if (schema.maximum && schema.maximum < value) {\n            return core.errors.maximumError({ maximum: schema.maximum, length: value, pointer });\n        }\n        return undefined;\n    },\n    minimum: (core, schema, value, pointer) => {\n        if (isNaN(schema.minimum)) {\n            return undefined;\n        }\n        if (schema.minimum > value) {\n            return core.errors.minimumError({ minimum: schema.minimum, length: value, pointer });\n        }\n        return undefined;\n    },\n    patternProperties: (core, schema, value, pointer) => {\n        const properties = schema.properties || {};\n        const pp = schema.patternProperties;\n        if (getTypeOf(pp) !== \"object\") {\n            return undefined;\n        }\n        const errors = [];\n        const keys = Object.keys(value);\n        const patterns = Object.keys(pp).map((expr) => ({\n            regex: new RegExp(expr),\n            patternSchema: pp[expr]\n        }));\n        keys.forEach((key) => {\n            let patternFound = false;\n            for (let i = 0, l = patterns.length; i < l; i += 1) {\n                if (patterns[i].regex.test(key)) {\n                    patternFound = true;\n                    // for a boolean schema `false`, always invalidate\n                    if (patterns[i].patternSchema === false) {\n                        errors.push(core.errors.patternPropertiesError({\n                            key,\n                            pointer,\n                            patterns: Object.keys(pp).join(\",\")\n                        }));\n                        return;\n                    }\n                    const valErrors = core.validate(value[key], patterns[i].patternSchema, `${pointer}/${key}`);\n                    if (valErrors && valErrors.length > 0) {\n                        errors.push(...valErrors);\n                    }\n                }\n            }\n            if (properties[key]) {\n                return;\n            }\n            if (patternFound === false && schema.additionalProperties === false) {\n                // this is an arrangement with additionalProperties\n                errors.push(core.errors.patternPropertiesError({\n                    key,\n                    pointer,\n                    patterns: Object.keys(pp).join(\",\")\n                }));\n            }\n        });\n        return errors;\n    },\n    // @draft >= 6\n    propertyNames: (core, schema, value, pointer) => {\n        // bool schema\n        if (schema.propertyNames === false) {\n            // empty objects are valid\n            if (Object.keys(value).length === 0) {\n                return undefined;\n            }\n            return core.errors.invalidPropertyNameError({\n                property: Object.keys(value),\n                pointer,\n                value\n            });\n        }\n        if (schema.propertyNames === true) {\n            return undefined;\n        }\n        if (getTypeOf(schema.propertyNames) !== \"object\") {\n            // ignore invalid schema\n            return undefined;\n        }\n        const errors = [];\n        const properties = Object.keys(value);\n        const propertySchema = { ...schema.propertyNames, type: \"string\" };\n        properties.forEach((prop) => {\n            const validationResult = core.validate(prop, propertySchema, `${pointer}/${prop}`);\n            if (validationResult.length > 0) {\n                errors.push(core.errors.invalidPropertyNameError({\n                    property: prop,\n                    pointer,\n                    validationError: validationResult[0],\n                    value: value[prop]\n                }));\n            }\n        });\n        return errors;\n    }\n};\nexport default KeywordValidation;\n","import copy from \"./utils/copy\";\nimport merge from \"./utils/merge\";\nimport errors from \"./validation/errors\";\nexport default function resolveAnyOf(core, data, schema = core.rootSchema, pointer = \"#\") {\n    let found = false;\n    let mergedSchema = copy(schema);\n    for (let i = 0; i < schema.anyOf.length; i += 1) {\n        const anyOfSchema = core.resolveRef(schema.anyOf[i]);\n        if (core.isValid(data, schema.anyOf[i], pointer)) {\n            found = true;\n            mergedSchema = merge(mergedSchema, anyOfSchema);\n        }\n    }\n    if (found === false) {\n        return errors.anyOfError({ value: data, pointer, anyOf: JSON.stringify(schema.anyOf) });\n    }\n    delete mergedSchema.anyOf;\n    return mergedSchema;\n}\n","export default function resolveRef(schema, rootSchema) {\n    if (schema == null || schema.$ref == null) {\n        return schema;\n    }\n    if (schema.getRoot) {\n        // we actually always need to resolve the schema like this, since returned subschemas\n        // must resolve relative from their schema\n        const resolvedSchema = schema.getRoot().getRef(schema);\n        // console.log(schema.$ref, \"=>\", resolvedSchema);\n        return resolvedSchema;\n    }\n    // tryout - this should never be called, except we missed something\n    const resolvedSchema = rootSchema.getRef(schema);\n    return resolvedSchema;\n}\n","import getTypeOf from \"./getTypeOf\";\n/**\n * Create a simple json schema for the given input data\n * @param  data - data to get json schema for\n * @return schema\n */\nexport default function createSchemaOf(data) {\n    const schema = {\n        type: getTypeOf(data)\n    };\n    if (schema.type === \"object\") {\n        schema.properties = {};\n        Object.keys(data).forEach((key) => (schema.properties[key] = createSchemaOf(data[key])));\n    }\n    if (schema.type === \"array\" && data.length === 1) {\n        schema.items = createSchemaOf(data[0]);\n    }\n    else if (schema.type === \"array\") {\n        schema.items = data.map(createSchemaOf);\n    }\n    return schema;\n}\n","import { isJSONError } from \"./types\";\n/**\n * Returns a list of possible child-schemas for the given property key. In case of a oneOf selection, multiple schemas\n * could be added at the given property (e.g. item-index), thus an array of options is returned. In all other cases\n * a list with a single item will be returned\n *\n * @param core        - core to use\n * @param property    - parent schema of following property\n * @param [schema]    - parent schema of following property\n * @return\n */\nexport default function getChildSchemaSelection(core, property, schema = core.rootSchema) {\n    const result = core.step(property, schema, {}, \"#\");\n    if (isJSONError(result)) {\n        if (result.code === \"one-of-error\") {\n            return result.data.oneOf.map((item) => core.resolveRef(item));\n        }\n        return result;\n    }\n    return [result];\n}\n","import getTypeOf from \"./getTypeOf\";\nimport createSchemaOf from \"./createSchemaOf\";\nimport errors from \"./validation/errors\";\nimport merge from \"./utils/merge\";\nimport { isJSONError } from \"./types\";\nconst stepType = {\n    array: (core, key, schema, data, pointer) => {\n        const itemsType = getTypeOf(schema.items);\n        if (itemsType === \"object\") {\n            // oneOf\n            if (Array.isArray(schema.items.oneOf)) {\n                return core.resolveOneOf(data[key], schema.items, pointer);\n            }\n            // anyOf\n            if (Array.isArray(schema.items.anyOf)) {\n                // schema of current object\n                return core.resolveAnyOf(data[key], schema.items, pointer);\n            }\n            // allOf\n            if (Array.isArray(schema.items.allOf)) {\n                return core.resolveAllOf(data[key], schema.items, pointer);\n            }\n            // spec: ignore additionalItems, when items is schema-object\n            return core.resolveRef(schema.items);\n        }\n        if (itemsType === \"array\") {\n            // @draft >= 7 bool schema, items:[true, false]\n            if (schema.items[key] === true) {\n                return createSchemaOf(data[key]);\n            }\n            // @draft >= 7 bool schema, items:[true, false]\n            if (schema.items[key] === false) {\n                return errors.invalidDataError({\n                    key,\n                    value: data[key],\n                    pointer\n                });\n            }\n            if (schema.items[key]) {\n                return core.resolveRef(schema.items[key]);\n            }\n            if (schema.additionalItems === false) {\n                return errors.additionalItemsError({\n                    key,\n                    value: data[key],\n                    pointer\n                });\n            }\n            if (schema.additionalItems === true || schema.additionalItems === undefined) {\n                return createSchemaOf(data[key]);\n            }\n            if (getTypeOf(schema.additionalItems) === \"object\") {\n                return schema.additionalItems;\n            }\n            throw new Error(`Invalid schema ${JSON.stringify(schema, null, 4)} for ${JSON.stringify(data, null, 4)}`);\n        }\n        if (schema.additionalItems !== false && data[key]) {\n            // @todo reevaluate: incomplete schema is created here\n            // @todo support additionalItems: {schema}\n            return createSchemaOf(data[key]);\n        }\n        return new Error(`Invalid array schema for ${key} at ${pointer}`);\n    },\n    object: (core, key, schema, data, pointer) => {\n        if (Array.isArray(schema.oneOf)) {\n            // update current schema\n            const oneOfSchema = core.resolveOneOf(data, schema, pointer);\n            // resolveOneOf does currently not apply merge with base schema\n            schema = merge(schema, oneOfSchema);\n            if (isJSONError(schema)) {\n                return schema;\n            }\n        }\n        if (Array.isArray(schema.anyOf)) {\n            // update current schema\n            schema = core.resolveAnyOf(data, schema, pointer);\n            if (isJSONError(schema)) {\n                return schema;\n            }\n        }\n        if (Array.isArray(schema.allOf)) {\n            // update current schema\n            schema = core.resolveAllOf(data, schema, pointer);\n            if (isJSONError(schema)) {\n                return schema;\n            }\n        }\n        let targetSchema;\n        // step into object-properties\n        if (schema.properties && schema.properties[key] !== undefined) {\n            // @todo patternProperties also validate properties\n            targetSchema = core.resolveRef(schema.properties[key]);\n            if (isJSONError(targetSchema)) {\n                return targetSchema;\n            }\n            // check if there is a oneOf selection, which must be resolved\n            if (targetSchema && Array.isArray(targetSchema.oneOf)) {\n                // @special case: this is a mix of a schema and optional definitions\n                // we resolve the schema here and add the original schema to `oneOfSchema`\n                let resolvedSchema = core.resolveOneOf(data[key], targetSchema, `${pointer}/${key}`);\n                const oneOfIndex = targetSchema.oneOf.findIndex((s) => s === resolvedSchema);\n                resolvedSchema.variableSchema = true;\n                resolvedSchema.oneOfIndex = oneOfIndex;\n                resolvedSchema.oneOfSchema = targetSchema;\n                return resolvedSchema;\n            }\n            // resolved schema or error\n            if (targetSchema) {\n                return targetSchema;\n            }\n        }\n        // @draft <= 07\n        const { dependencies } = schema;\n        if (getTypeOf(dependencies) === \"object\") {\n            const dependentProperties = Object.keys(dependencies).filter((propertyName) => \n            // data[propertyName] !== undefined &&\n            getTypeOf(dependencies[propertyName]) === \"object\");\n            for (let i = 0, l = dependentProperties.length; i < l; i += 1) {\n                const dependentProperty = dependentProperties[i];\n                const schema = step(core, key, dependencies[dependentProperty], data, `${pointer}/${dependentProperty}`);\n                if (!isJSONError(schema)) {\n                    return schema;\n                }\n            }\n        }\n        // @draft >= 07\n        if (schema.if && (schema.then || schema.else)) {\n            // console.log(\"test if-then-else\");\n            const isValid = core.isValid(data, schema.if);\n            if (isValid && schema.then) {\n                const resolvedThen = step(core, key, schema.then, data, pointer);\n                if (typeof resolvedThen.type === \"string\" && resolvedThen.type !== \"error\") {\n                    return resolvedThen;\n                }\n            }\n            if (!isValid && schema.else) {\n                const resolvedElse = step(core, key, schema.else, data, pointer);\n                if (typeof resolvedElse.type === \"string\" && resolvedElse.type !== \"error\") {\n                    return resolvedElse;\n                }\n            }\n        }\n        // find matching property key\n        if (getTypeOf(schema.patternProperties) === \"object\") {\n            let regex;\n            const patterns = Object.keys(schema.patternProperties);\n            for (let i = 0, l = patterns.length; i < l; i += 1) {\n                regex = new RegExp(patterns[i]);\n                if (regex.test(key)) {\n                    return schema.patternProperties[patterns[i]];\n                }\n            }\n        }\n        if (getTypeOf(schema.additionalProperties) === \"object\") {\n            return schema.additionalProperties;\n        }\n        if (schema.additionalProperties === true) {\n            return createSchemaOf(data[key]);\n        }\n        return errors.unknownPropertyError({\n            property: key,\n            value: data,\n            // pointer: `${pointer}/${key}`,\n            pointer: `${pointer}`\n        });\n    }\n};\n/**\n * Returns the json-schema of the given object property or array item.\n * e.g. it steps by one key into the data\n *\n *  This helper determines the location of the property within the schema (additional properties, oneOf, ...) and\n *  returns the correct schema.\n *\n * @param  core      - validator\n * @param  key       - property-name or array-index\n * @param  schema    - json schema of current data\n * @param  data      - parent of key\n * @param  [pointer] - pointer to schema and data (parent of key)\n * @return Schema or Error if failed resolving key\n */\nexport default function step(core, key, schema, data, pointer = \"#\") {\n    // @draft >= 4 ?\n    if (Array.isArray(schema.type)) {\n        const dataType = getTypeOf(data);\n        if (schema.type.includes(dataType)) {\n            // @ts-ignore\n            return stepType[dataType](core, `${key}`, schema, data, pointer);\n        }\n        return core.errors.typeError({\n            value: data,\n            pointer,\n            expected: schema.type,\n            received: dataType\n        });\n    }\n    const expectedType = schema.type || getTypeOf(data);\n    // @ts-ignore\n    const stepFunction = stepType[expectedType];\n    if (stepFunction) {\n        return stepFunction(core, `${key}`, schema, data, pointer);\n    }\n    return new Error(`Unsupported schema type ${schema.type} for key ${key}`);\n}\n","/**\n * @todo: type is also a keyword, as is properties, items, etc\n *\n * An instance has one of six primitive types (http://json-schema.org/latest/json-schema-core.html#rfc.section.4.2)\n * or seven in case of ajv https://github.com/epoberezkin/ajv/blob/master/KEYWORDS.md#type\n * 1 null, 2 boolean, 3 object, 4 array, 5 number, 6 string (7 integer)\n */\nconst validationType = {\n    array: (core, schema, value, pointer) => core.typeKeywords.array\n        .filter((key) => schema && schema[key] != null)\n        .map((key) => core.validateKeyword[key](core, schema, value, pointer)),\n    object: (core, schema, value, pointer) => core.typeKeywords.object\n        .filter((key) => schema && schema[key] != null)\n        .map((key) => core.validateKeyword[key](core, schema, value, pointer)),\n    string: (core, schema, value, pointer) => core.typeKeywords.string\n        .filter((key) => schema && schema[key] != null)\n        .map((key) => core.validateKeyword[key](core, schema, value, pointer)),\n    integer: (core, schema, value, pointer) => core.typeKeywords.number\n        .filter((key) => schema && schema[key] != null)\n        .map((key) => core.validateKeyword[key](core, schema, value, pointer)),\n    number: (core, schema, value, pointer) => core.typeKeywords.number\n        .filter((key) => schema && schema[key] != null)\n        .map((key) => core.validateKeyword[key](core, schema, value, pointer)),\n    boolean: (core, schema, value, pointer) => core.typeKeywords.boolean\n        .filter((key) => schema && schema[key] != null)\n        .map((key) => core.validateKeyword[key](core, schema, value, pointer)),\n    null: (core, schema, value, pointer) => core.typeKeywords.null\n        .filter((key) => schema && schema[key] != null)\n        .map((key) => core.validateKeyword[key](core, schema, value, pointer))\n};\nexport default validationType;\n","import getTypeOf from \"./getTypeOf\";\nimport { errorOrPromise } from \"./utils/filter\";\nimport flattenArray from \"./utils/flattenArray\";\nimport { isJSONError } from \"./types\";\nimport equal from \"fast-deep-equal\";\nfunction getJsonSchemaType(value, expectedType) {\n    const jsType = getTypeOf(value);\n    if (jsType === \"number\" &&\n        (expectedType === \"integer\" ||\n            (Array.isArray(expectedType) && expectedType.includes(\"integer\")))) {\n        return Number.isInteger(value) || isNaN(value) ? \"integer\" : \"number\";\n    }\n    return jsType;\n}\n/**\n * Validate data by a json schema\n *\n * @param core - validator\n * @param value - value to validate\n * @param [schema] - json schema, defaults to rootSchema\n * @param [pointer] - json pointer pointing to value (used for error-messages only)\n * @return list of errors or empty\n */\nexport default function validate(core, value, schema = core.rootSchema, pointer = \"#\") {\n    schema = core.resolveRef(schema);\n    // @draft >= 07\n    if (getTypeOf(schema) === \"boolean\") {\n        if (schema) {\n            return [];\n        }\n        return [core.errors.invalidDataError({ value, pointer })];\n    }\n    if (isJSONError(schema)) {\n        return [schema];\n    }\n    // @draft >= 6 const\n    if (schema.const !== undefined) {\n        if (equal(schema.const, value)) {\n            return [];\n        }\n        return [core.errors.constError({ value, expected: schema.const, pointer })];\n    }\n    const receivedType = getJsonSchemaType(value, schema.type);\n    const expectedType = schema.type || receivedType;\n    if (receivedType !== expectedType &&\n        (!Array.isArray(expectedType) || !expectedType.includes(receivedType))) {\n        return [\n            core.errors.typeError({\n                received: receivedType,\n                expected: expectedType,\n                value,\n                pointer\n            })\n        ];\n    }\n    if (core.validateType[receivedType] == null) {\n        return [core.errors.invalidTypeError({ receivedType, pointer })];\n    }\n    const errors = flattenArray(core.validateType[receivedType](core, schema, value, pointer));\n    // also promises may be passed along (validateAsync)\n    // @ts-ignore\n    return errors.filter(errorOrPromise);\n}\n","export class Draft {\n    constructor(config, schema) {\n        /** cache for remote schemas */\n        this.remotes = {};\n        /** error creators by id */\n        this.errors = {};\n        /** map for valid keywords of a type  */\n        this.typeKeywords = {};\n        /** keyword validators  */\n        this.validateKeyword = {};\n        /** type validators  */\n        this.validateType = {};\n        /** format validators  */\n        this.validateFormat = {};\n        this.config = config;\n        this.typeKeywords = JSON.parse(JSON.stringify(config.typeKeywords));\n        this.validateKeyword = Object.assign({}, config.validateKeyword);\n        this.validateType = Object.assign({}, config.validateType);\n        this.validateFormat = Object.assign({}, config.validateFormat);\n        this.errors = Object.assign({}, config.errors);\n        this.setSchema(schema);\n    }\n    get rootSchema() {\n        return this.__rootSchema;\n    }\n    set rootSchema(rootSchema) {\n        if (rootSchema == null) {\n            return;\n        }\n        this.__rootSchema = this.config.compileSchema(this, rootSchema);\n    }\n    /**\n     * register a json-schema to be referenced from another json-schema\n     * @param url - base-url of json-schema (aka id)\n     * @param schema - json-schema root\n     */\n    addRemoteSchema(url, schema) {\n        this.config.addRemoteSchema(this, url, schema);\n    }\n    compileSchema(schema) {\n        var _a;\n        return this.config.compileSchema(this, schema, (_a = this.rootSchema) !== null && _a !== void 0 ? _a : schema);\n    }\n    createSchemaOf(data) {\n        return this.config.createSchemaOf(data);\n    }\n    /**\n     * Iterates over data, retrieving its schema\n     *\n     * @param data - the data to iterate\n     * @param callback - will be called with (schema, data, pointer) on each item\n     * @param [schema] - the schema matching the data. Defaults to rootSchema\n     * @param [pointer] - pointer to current data. Default to rootPointer\n     */\n    each(data, callback, schema, pointer) {\n        return this.config.each(this, data, callback, schema, pointer);\n    }\n    eachSchema(callback, schema = this.rootSchema) {\n        return this.config.eachSchema(schema, callback);\n    }\n    getChildSchemaSelection(property, schema) {\n        return this.config.getChildSchemaSelection(this, property, schema);\n    }\n    /**\n     * Returns the json-schema of a data-json-pointer.\n     * Notes\n     *   - Uses core.step to walk through data and schema\n     *\n     * @param pointer - json pointer in data to get the json schema for\n     * @param [data] - the data object, which includes the json pointers value. This is optional, as\n     *    long as no oneOf, anyOf, etc statement is part of the pointers schema\n     * @param [schema] - the json schema to iterate. Defaults to core.rootSchema\n     * @return json schema object of the json-pointer or an error\n     */\n    getSchema(pointer = \"#\", data, schema) {\n        return this.config.getSchema(this, pointer, data, schema);\n    }\n    /**\n     * Create data object matching the given schema\n     *\n     * @param [data] - optional template data\n     * @param [schema] - json schema, defaults to rootSchema\n     * @return created template data\n     */\n    getTemplate(data, schema, opts) {\n        return this.config.getTemplate(this, data, schema, opts);\n    }\n    isValid(data, schema, pointer) {\n        return this.config.isValid(this, data, schema, pointer);\n    }\n    resolveAnyOf(data, schema, pointer) {\n        return this.config.resolveAnyOf(this, data, schema, pointer);\n    }\n    resolveAllOf(data, schema, pointer) {\n        return this.config.resolveAllOf(this, data, schema, pointer);\n    }\n    resolveRef(schema) {\n        return this.config.resolveRef(schema, this.rootSchema);\n    }\n    resolveOneOf(data, schema, pointer) {\n        return this.config.resolveOneOf(this, data, schema, pointer);\n    }\n    setSchema(schema) {\n        this.rootSchema = schema;\n    }\n    /**\n     * Returns the json-schema of the given object property or array item.\n     * e.g. it steps by one key into the data\n     *\n     *  This helper determines the location of the property within the schema (additional properties, oneOf, ...) and\n     *  returns the correct schema.\n     *\n     * @param  key       - property-name or array-index\n     * @param  schema    - json schema of current data\n     * @param  data      - parent of key\n     * @param  [pointer] - pointer to schema and data (parent of key)\n     * @return Schema or Error if failed resolving key\n     */\n    step(key, schema, data, pointer) {\n        return this.config.step(this, key, schema, data, pointer);\n    }\n    /**\n     * Validate data by a json schema\n     *\n     * @param value - value to validate\n     * @param [schema] - json schema, defaults to rootSchema\n     * @param [pointer] - json pointer pointing to value (used for error-messages only)\n     * @return list of errors or empty\n     */\n    validate(data, schema, pointer) {\n        return this.config.validate(this, data, schema, pointer);\n    }\n}\n","import addRemoteSchema from \"../addRemoteSchema\";\nimport compileSchema from \"../draft06/compile\";\nimport { each } from \"../each\";\nimport { eachSchema } from \"../eachSchema\";\nimport ERRORS from \"../validation/errors\";\nimport FORMATS from \"../validation/format\";\nimport getSchema from \"../getSchema\";\nimport getTemplate from \"../getTemplate\";\nimport isValid from \"../isValid\";\nimport KEYWORDS from \"../draft06/validation/keyword\";\nimport merge from \"../utils/merge\";\nimport resolveAllOf from \"../resolveAllOf\";\nimport resolveAnyOf from \"../resolveAnyOf\";\nimport resolveOneOf from \"../resolveOneOf.strict\";\nimport resolveRef from \"../resolveRef.strict\";\nimport createSchemaOf from \"../createSchemaOf\";\nimport getChildSchemaSelection from \"../getChildSchemaSelection\";\nimport step from \"../step\";\nimport TYPES from \"../draft06/validation/type\";\nimport validate from \"../validate\";\nimport { Draft } from \"../draft\";\nconst draft07Config = {\n    typeKeywords: {\n        array: [\n            \"allOf\",\n            \"anyOf\",\n            \"contains\",\n            \"enum\",\n            \"if\",\n            \"items\",\n            \"maxItems\",\n            \"minItems\",\n            \"not\",\n            \"oneOf\",\n            \"uniqueItems\"\n        ],\n        boolean: [\"allOf\", \"anyOf\", \"enum\", \"not\", \"oneOf\"],\n        object: [\n            \"additionalProperties\",\n            \"allOf\",\n            \"anyOf\",\n            \"dependencies\",\n            \"enum\",\n            \"format\",\n            \"if\",\n            \"maxProperties\",\n            \"minProperties\",\n            \"not\",\n            \"oneOf\",\n            \"patternProperties\",\n            \"properties\",\n            \"propertyNames\",\n            \"required\"\n        ],\n        string: [\n            \"allOf\",\n            \"anyOf\",\n            \"enum\",\n            \"format\",\n            \"if\",\n            \"maxLength\",\n            \"minLength\",\n            \"not\",\n            \"oneOf\",\n            \"pattern\"\n        ],\n        number: [\n            \"allOf\",\n            \"anyOf\",\n            \"enum\",\n            \"exclusiveMaximum\",\n            \"exclusiveMinimum\",\n            \"format\",\n            \"if\",\n            \"maximum\",\n            \"minimum\",\n            \"multipleOf\",\n            \"not\",\n            \"oneOf\"\n        ],\n        null: [\"allOf\", \"anyOf\", \"enum\", \"format\", \"not\", \"oneOf\"]\n    },\n    validateKeyword: KEYWORDS,\n    validateType: TYPES,\n    validateFormat: FORMATS,\n    errors: ERRORS,\n    addRemoteSchema,\n    compileSchema,\n    createSchemaOf,\n    each,\n    eachSchema,\n    getChildSchemaSelection,\n    getSchema,\n    getTemplate,\n    isValid,\n    resolveAllOf,\n    resolveAnyOf,\n    resolveOneOf,\n    resolveRef,\n    step,\n    validate\n};\nclass Draft07 extends Draft {\n    constructor(schema, config = {}) {\n        super(merge(draft07Config, config), schema);\n    }\n}\nexport { Draft07, draft07Config };\n","import merge from \"../utils/merge\";\nimport resolveOneOf from \"../resolveOneOf.fuzzy\";\nimport resolveRef from \"../resolveRef.merge\";\nimport { Draft } from \"../draft\";\nimport { draft07Config } from \"../draft07\";\nconst draftJsonEditorConfig = {\n    ...draft07Config,\n    resolveOneOf,\n    resolveRef\n};\nclass JsonEditor extends Draft {\n    constructor(schema, config = {}) {\n        super(merge(draftJsonEditorConfig, config), schema);\n    }\n}\nexport { JsonEditor, draftJsonEditorConfig };\n","import getSchema from \"./getSchema\";\nimport { JsonEditor as Core } from \"./jsoneditor\";\nimport gp from \"@sagold/json-pointer\";\nimport copy from \"./utils/copy\";\nexport default class SchemaService {\n    constructor(schema, data) {\n        this.core = new Core(schema);\n        this.schema = schema;\n        this.data = data;\n        this.cache = {};\n    }\n    updateData(data) {\n        this.data = data;\n        this.cache = {};\n    }\n    updateSchema(schema) {\n        this.schema = schema;\n        this.core.setSchema(schema);\n        this.cache = {};\n    }\n    get(pointer, data) {\n        if (data) {\n            // possibly separate entry point\n            const schema = getSchema(this.core, pointer, data, this.schema);\n            return copy(schema);\n        }\n        if (pointer === \"#\") {\n            // root\n            return this.schema;\n        }\n        if (this.cache[pointer]) {\n            // return cached result\n            return this.cache[pointer];\n        }\n        const parentPointer = gp.join(pointer, \"..\");\n        let parentSchema = this.cache[parentPointer];\n        if (parentSchema == null) {\n            // store parent (major performance improvement if its within oneof)\n            parentSchema = getSchema(this.core, parentPointer, this.data, this.schema);\n            if (parentSchema.variableSchema !== true) {\n                this.cache[parentPointer] = copy(parentSchema);\n            }\n        }\n        // step from parent to child\n        const key = gp.split(pointer).pop();\n        let schema = getSchema(this.core, key, gp.get(this.data, parentPointer), this.cache[parentPointer]);\n        schema = copy(schema);\n        if (schema.variableSchema !== true) {\n            this.cache[pointer] = schema;\n        }\n        return schema;\n    }\n}\n","/* eslint max-statements-per-line: [\"error\", { \"max\": 2 }] */\nimport { eachSchema } from \"../eachSchema\";\nimport joinScope from \"./joinScope\";\nimport getRef from \"./getRef\";\nimport { get } from \"@sagold/json-pointer\";\nconst COMPILED = \"__compiled\";\nconst COMPILED_REF = \"__ref\";\nconst GET_REF = \"getRef\";\nconst GET_ROOT = \"getRoot\";\nconst suffixes = /(#|\\/)+$/g;\n/**\n * compiles the input root schema for `$ref` resolution and returns it again\n * @attention this modifies input schema but maintains data-structure and thus returns\n * the same object with JSON.stringify\n *\n * for a compiled json-schema you can call getRef on any contained schema (location of type).\n * this resolves a $ref target to a valid schema (for a valid $ref)\n *\n * @param draft\n * @param schemaToCompile - json-schema to compile\n * @param [rootSchema] - compiled root json-schema to use for definitions resolution\n * @param [force] = false - force compile json-schema\n * @return compiled input json-schema\n */\nexport default function compileSchema(draft, schemaToCompile, rootSchema = schemaToCompile, force = false) {\n    if (!schemaToCompile || schemaToCompile[COMPILED] !== undefined) {\n        return schemaToCompile;\n    }\n    const context = { ids: {}, remotes: draft.remotes };\n    const rootSchemaAsString = JSON.stringify(schemaToCompile);\n    const compiledSchema = JSON.parse(rootSchemaAsString);\n    // flag this schema as compiled\n    Object.defineProperty(compiledSchema, COMPILED, { enumerable: false, value: true });\n    // add getRef-helper to this object\n    Object.defineProperty(compiledSchema, GET_REF, {\n        enumerable: false,\n        value: getRef.bind(null, context, compiledSchema)\n    });\n    // bail early, when no $refs are defined\n    if (force === false && rootSchemaAsString.includes(\"$ref\") === false) {\n        return compiledSchema;\n    }\n    // compile this schema under rootSchema, making definitions available to $ref-resolution\n    if (schemaToCompile !== rootSchema) {\n        Object.defineProperty(compiledSchema, \"definitions\", {\n            enumerable: false,\n            value: Object.assign({}, rootSchema.definitions, rootSchema.$defs, schemaToCompile.definitions, schemaToCompile.$defs)\n        });\n    }\n    const scopes = {};\n    const getRoot = () => compiledSchema;\n    eachSchema(compiledSchema, (schema, pointer) => {\n        var _a;\n        if (schema.id) {\n            // if this is a schema being merged on root object, we cannot override\n            // parents locations, but must reuse it\n            if (schema.id.startsWith(\"http\") && /(allOf|anyOf|oneOf)\\/\\d+$/.test(pointer)) {\n                const parentPointer = pointer.replace(/\\/(allOf|anyOf|oneOf)\\/\\d+$/, \"\");\n                const parentSchema = get(compiledSchema, parentPointer);\n                schema.id = (_a = parentSchema.id) !== null && _a !== void 0 ? _a : schema.id;\n            }\n            context.ids[schema.id.replace(suffixes, \"\")] = pointer;\n        }\n        // build up scopes and add them to $ref-resolution map\n        pointer = `#${pointer}`.replace(/##+/, \"#\");\n        const previousPointer = pointer.replace(/\\/[^/]+$/, \"\");\n        const parentPointer = pointer.replace(/\\/[^/]+\\/[^/]+$/, \"\");\n        const previousScope = scopes[previousPointer] || scopes[parentPointer];\n        const scope = joinScope(previousScope, schema.id);\n        scopes[pointer] = scope;\n        if (context.ids[scope] == null) {\n            context.ids[scope] = pointer;\n        }\n        if (schema.$ref && !schema[COMPILED_REF]) {\n            Object.defineProperty(schema, COMPILED_REF, {\n                enumerable: false,\n                value: joinScope(scope, schema.$ref)\n            });\n            // @todo currently not used:\n            Object.defineProperty(schema, GET_ROOT, { enumerable: false, value: getRoot });\n            // console.log(\"compiled ref\", scope, schema.$ref, \"=>\", joinScope(scope, schema.$ref));\n        }\n    });\n    // console.log(JSON.stringify(context.ids, null, 2));\n    return compiledSchema;\n}\n","import addRemoteSchema from \"../addRemoteSchema\";\nimport compileSchema from \"../compileSchema\";\nimport { each } from \"../each\";\nimport { eachSchema } from \"../eachSchema\";\nimport ERRORS from \"../validation/errors\";\nimport FORMATS from \"../validation/format\";\nimport getSchema from \"../getSchema\";\nimport getTemplate from \"../getTemplate\";\nimport isValid from \"../isValid\";\nimport KEYWORDS from \"../validation/keyword\";\nimport merge from \"../utils/merge\";\nimport resolveAllOf from \"../resolveAllOf\";\nimport resolveAnyOf from \"../resolveAnyOf\";\nimport resolveOneOf from \"../resolveOneOf.strict\";\nimport resolveRef from \"../resolveRef.strict\";\nimport step from \"../step\";\nimport createSchemaOf from \"../createSchemaOf\";\nimport getChildSchemaSelection from \"../getChildSchemaSelection\";\nimport TYPES from \"../validation/type\";\nimport validate from \"../validate\";\nimport { Draft } from \"../draft\";\nconst draft04Config = {\n    typeKeywords: {\n        array: [\n            \"allOf\",\n            \"anyOf\",\n            \"enum\",\n            \"items\",\n            \"maxItems\",\n            \"minItems\",\n            \"not\",\n            \"oneOf\",\n            \"uniqueItems\"\n        ],\n        boolean: [\"enum\", \"not\", \"allOf\", \"anyOf\", \"oneOf\"],\n        object: [\n            \"additionalProperties\",\n            \"dependencies\",\n            \"enum\",\n            \"format\",\n            \"minProperties\",\n            \"maxProperties\",\n            \"patternProperties\",\n            \"properties\",\n            \"required\",\n            \"not\",\n            \"oneOf\",\n            \"allOf\",\n            \"anyOf\"\n        ],\n        string: [\n            \"allOf\",\n            \"anyOf\",\n            \"enum\",\n            \"format\",\n            \"maxLength\",\n            \"minLength\",\n            \"not\",\n            \"oneOf\",\n            \"pattern\"\n        ],\n        number: [\n            \"allOf\",\n            \"anyOf\",\n            \"enum\",\n            \"format\",\n            \"maximum\",\n            \"minimum\",\n            \"multipleOf\",\n            \"not\",\n            \"oneOf\"\n        ],\n        null: [\"allOf\", \"anyOf\", \"enum\", \"format\", \"not\", \"oneOf\"]\n    },\n    validateKeyword: KEYWORDS,\n    validateType: TYPES,\n    validateFormat: FORMATS,\n    errors: ERRORS,\n    addRemoteSchema,\n    compileSchema,\n    createSchemaOf,\n    each,\n    eachSchema,\n    getChildSchemaSelection,\n    getSchema,\n    getTemplate,\n    isValid,\n    resolveAllOf,\n    resolveAnyOf,\n    resolveOneOf,\n    resolveRef,\n    step,\n    validate\n};\nclass Draft04 extends Draft {\n    constructor(schema, config = {}) {\n        super(merge(draft04Config, config), schema);\n    }\n}\nexport { Draft04, draft04Config };\n","/**\n * @todo: type is also a keyword, as is properties, items, etc\n *\n * An instance has one of six primitive types (http://json-schema.org/latest/json-schema-core.html#rfc.section.4.2)\n * or seven in case of ajv https://github.com/epoberezkin/ajv/blob/master/KEYWORDS.md#type\n * 1 null, 2 boolean, 3 object, 4 array, 5 number, 6 string (7 integer)\n */\nconst typeValidators = {\n    array: (core, schema, value, pointer) => core.typeKeywords.array\n        .filter(key => schema && schema[key] != null)\n        .map(key => core.validateKeyword[key](core, schema, value, pointer)),\n    object: (core, schema, value, pointer) => core.typeKeywords.object\n        .filter(key => schema && schema[key] != null)\n        .map(key => core.validateKeyword[key](core, schema, value, pointer)),\n    string: (core, schema, value, pointer) => core.typeKeywords.string\n        .filter(key => schema && schema[key] != null)\n        .map(key => core.validateKeyword[key](core, schema, value, pointer)),\n    integer: (core, schema, value, pointer) => core.typeKeywords.number\n        .filter(key => schema && schema[key] != null)\n        .map(key => core.validateKeyword[key](core, schema, value, pointer)),\n    number: (core, schema, value, pointer) => core.typeKeywords.number\n        .filter(key => schema && schema[key] != null)\n        .map(key => core.validateKeyword[key](core, schema, value, pointer)),\n    \"boolean\": (core, schema, value, pointer) => core.typeKeywords.boolean\n        .filter(key => schema && schema[key] != null)\n        .map(key => core.validateKeyword[key](core, schema, value, pointer)),\n    \"null\": (core, schema, value, pointer) => core.typeKeywords.null\n        .filter(key => schema && schema[key] != null)\n        .map(key => core.validateKeyword[key](core, schema, value, pointer))\n};\nexport default typeValidators;\n","import compile from \"./compile\";\nexport default compile;\n","import addRemoteSchema from \"../addRemoteSchema\";\nimport compileSchema from \"../draft06/compile\";\nimport { each } from \"../each\";\nimport { eachSchema } from \"../eachSchema\";\nimport ERRORS from \"../validation/errors\";\nimport FORMATS from \"../validation/format\";\nimport getSchema from \"../getSchema\";\nimport getTemplate from \"../getTemplate\";\nimport isValid from \"../isValid\";\nimport KEYWORDS from \"../draft06/validation/keyword\";\nimport merge from \"../utils/merge\";\nimport resolveAllOf from \"../resolveAllOf\";\nimport resolveAnyOf from \"../resolveAnyOf\";\nimport resolveOneOf from \"../resolveOneOf.strict\";\nimport resolveRef from \"../resolveRef.strict\";\nimport createSchemaOf from \"../createSchemaOf\";\nimport getChildSchemaSelection from \"../getChildSchemaSelection\";\nimport step from \"../step\";\nimport TYPES from \"../draft06/validation/type\";\nimport validate from \"../validate\";\nimport { Draft } from \"../draft\";\nconst draft06Config = {\n    typeKeywords: {\n        array: [\n            \"allOf\",\n            \"anyOf\",\n            \"contains\",\n            \"enum\",\n            \"if\",\n            \"items\",\n            \"maxItems\",\n            \"minItems\",\n            \"not\",\n            \"oneOf\",\n            \"uniqueItems\"\n        ],\n        boolean: [\"allOf\", \"anyOf\", \"enum\", \"not\", \"oneOf\"],\n        object: [\n            \"additionalProperties\",\n            \"allOf\",\n            \"anyOf\",\n            \"dependencies\",\n            \"enum\",\n            \"format\",\n            \"if\",\n            \"maxProperties\",\n            \"minProperties\",\n            \"not\",\n            \"oneOf\",\n            \"patternProperties\",\n            \"properties\",\n            \"propertyNames\",\n            \"required\"\n        ],\n        string: [\n            \"allOf\",\n            \"anyOf\",\n            \"enum\",\n            \"format\",\n            \"if\",\n            \"maxLength\",\n            \"minLength\",\n            \"not\",\n            \"oneOf\",\n            \"pattern\"\n        ],\n        number: [\n            \"enum\",\n            \"exclusiveMaximum\",\n            \"exclusiveMinimum\",\n            \"format\",\n            \"maximum\",\n            \"minimum\",\n            \"multipleOf\",\n            \"not\",\n            \"oneOf\",\n            \"allOf\",\n            \"anyOf\",\n            \"if\"\n        ],\n        null: [\"allOf\", \"anyOf\", \"enum\", \"format\", \"not\", \"oneOf\"]\n    },\n    validateKeyword: KEYWORDS,\n    validateType: TYPES,\n    validateFormat: FORMATS,\n    errors: ERRORS,\n    addRemoteSchema,\n    compileSchema,\n    createSchemaOf,\n    each,\n    eachSchema,\n    getChildSchemaSelection,\n    getSchema,\n    getTemplate,\n    isValid,\n    resolveAllOf,\n    resolveAnyOf,\n    resolveOneOf,\n    resolveRef,\n    step,\n    validate\n};\nclass Draft06 extends Draft {\n    constructor(schema, config = {}) {\n        super(merge(draft06Config, config), schema);\n    }\n}\nexport { Draft06, draft06Config };\n","import { createError, createCustomError } from \"./lib/utils/createCustomError\";\nimport getTypeOf from \"./lib/getTypeOf\";\nimport resolveOneOf from \"./lib/resolveOneOf.strict\";\nimport resolveAllOf from \"./lib/resolveAllOf\";\nimport resolveOneOfFuzzy from \"./lib/resolveOneOf.fuzzy\";\nimport resolveRef from \"./lib/resolveRef.strict\";\nimport resolveRefMerge from \"./lib/resolveRef.merge\";\nimport SchemaService from \"./lib/SchemaService\";\nimport settings from \"./lib/config/settings\";\nimport strings from \"./lib/config/strings\";\nimport validateAsync from \"./lib/validateAsync\";\nimport render from \"./lib/utils/render\";\nimport { Draft } from \"./lib/draft\";\nimport { Draft04, draft04Config } from \"./lib/draft04\";\nimport { Draft06, draft06Config } from \"./lib/draft06\";\nimport { Draft07, draft07Config } from \"./lib/draft07\";\nimport { JsonEditor, draftJsonEditorConfig } from \"./lib/jsoneditor\";\nimport { isJSONError } from \"./lib/types\";\nconst config = { strings };\nexport { config, Draft, Draft04, // core implementing draft04 specs\ndraft04Config, // config implementing draft04 specs\nDraft06, // core implementing draft06 specs\ndraft06Config, // config implementing draft06 specs\nDraft07, // core implementing draft07 specs\ndraft07Config, // config implementing draft07 specs\nJsonEditor, // adjusted core of draft04 to better support the json-editor\ndraftJsonEditorConfig, // adjusted config of draft04 to better support the json-editor\ncreateError, createCustomError, getTypeOf, // returns the javascript datatype\nisJSONError, render, resolveAllOf, resolveRef, resolveRefMerge, resolveOneOf, resolveOneOfFuzzy, settings, SchemaService, validateAsync // async validation of data by a schema\n };\n"],"names":["render","template","data","match","__","keyword","fallback","strings","dashCase","text","createError","name","createCustomError","getTypeOf","value","type","error","isPromise","obj","errorOrPromise","errorsOnly","flattenArray","list","result","i","item","DECLARATOR_ONEOF","settings","resolveOneOf","core","schema","pointer","errors","oneOfProperty","oneOfValue","one","oneOfPropertySchema","matches","overwriteMerge","destinationArray","sourceArray","a","b","mergeUniqueItems","all","pos","mergeArraysUnique","resolveSchema","draft","schemaToResolve","_a","isValid","resolveAllOf","mergedSchema","allOfSchema","fuzzyObjectValue","keys","key","schemaOfItem","fuzzyGreatest","fuzzyValue","emptyObject","frags","_get","resolveRefMerge","rootSchema","resolvedSchema","addRemoteSchema","url","isObject","typeKeywords","types","id","getTypeId","ids","l","getTypeDefs","defs","query","parent","nextTypeDefs","next","eachDefinition","walk","defId","eachSchema","callback","defschema","schemaPointer","suffixes","trailingHash","isDomain","trailingFragments","idAndPointer","joinScope","previous","emptyValues","splitRef","$ref","val","getRef","context","$remote","fragments","base","COMPILED","COMPILED_REF","GET_REF","GET_ROOT","compileSchema","schemaToCompile","force","rootSchemaAsString","compiledSchema","scopes","getRoot","parentPointer","parentSchema","previousPointer","previousScope","scope","each","dataType","nextSchema","isValidDateTime","isValidIPV4","isValidIPV6","isValidHostname","matchDate","matchTime","DAYS","isValidJSONPointer","isValidRelativeJSONPointer","isValidURIRef","isValidURITemplate","year","month","day","isLeapYear","host","rest","part","hour","minute","second","timeZone","isEmpty","v","defaultOptions","cache","shouldResolveRef","resolveRef","convertValue","createTemplateSchema","templateSchema","resolvedAnyOf","isJSONSchema","getTemplate","_schema","opts","selectType","TYPE","defaultValue","defaultType","getDefault","d","required","isRequired","dependency","prop","additionalData","_b","_c","oneOfSchema","itemCount","templateValue","initValue","deepCompareStrict","typeofa","length","aKeys","bKeys","k","ucs2decode","string","output","counter","extra","FPP","hasProperty","property","receivedProperties","expectedProperties","patterns","pattern","subSchema","dependencyErrors","missingProperty","valueStr","itemData","itemSchema","itemErrors","lengthOfString","propertyCount","properties","pp","expr","patternFound","valErrors","keyErrors","index","ifErrors","propertySchema","validationResult","resolveAnyOf","found","anyOfSchema","createSchemaOf","getChildSchemaSelection","stepType","itemsType","targetSchema","oneOfIndex","s","dependencies","dependentProperties","propertyName","dependentProperty","step","resolvedThen","resolvedElse","regex","expectedType","stepFunction","getJsonSchemaType","jsType","validate","receivedType","config","draft07Config","Draft07","draftJsonEditorConfig","JsonEditor","SchemaService","draft04Config","Draft04","draft06Config","Draft06"],"sourceRoot":""}