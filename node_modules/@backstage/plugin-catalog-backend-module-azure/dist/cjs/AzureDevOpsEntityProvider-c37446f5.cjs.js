'use strict';

var integration = require('@backstage/integration');
var pluginCatalogNode = require('@backstage/plugin-catalog-node');
var backendTasks = require('@backstage/backend-tasks');
var uuid = require('uuid');
var fetch = require('node-fetch');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var uuid__namespace = /*#__PURE__*/_interopNamespace(uuid);
var fetch__default = /*#__PURE__*/_interopDefaultLegacy(fetch);

const isCloud = (host) => host === "dev.azure.com";
const PAGE_SIZE = 1e3;
async function codeSearch(credentialsProvider, azureConfig, org, project, repo, path, branch) {
  const searchBaseUrl = isCloud(azureConfig.host) ? "https://almsearch.dev.azure.com" : `https://${azureConfig.host}`;
  const searchUrl = `${searchBaseUrl}/${org}/_apis/search/codesearchresults?api-version=6.0-preview.1`;
  let items = [];
  let hasMorePages = true;
  do {
    const credentials = await credentialsProvider.getCredentials({
      url: `https://${azureConfig.host}/${org}`
    });
    const searchRequestBody = {
      searchText: `path:${path} repo:${repo || "*"} proj:${project || "*"}`,
      $orderBy: [
        {
          field: "path",
          sortOrder: "ASC"
        }
      ],
      $skip: items.length,
      $top: PAGE_SIZE
    };
    if (branch) {
      searchRequestBody.filters = { Branch: [branch] };
    }
    const response = await fetch__default["default"](searchUrl, {
      headers: {
        ...credentials == null ? void 0 : credentials.headers,
        "Content-Type": "application/json"
      },
      method: "POST",
      body: JSON.stringify(searchRequestBody)
    });
    if (response.status !== 200) {
      throw new Error(
        `Azure DevOps search failed with response status ${response.status}`
      );
    }
    const body = await response.json();
    items = [...items, ...body.results];
    hasMorePages = body.count > items.length;
  } while (hasMorePages);
  return items;
}

function readAzureDevOpsConfigs(config) {
  const configs = [];
  const providerConfigs = config.getOptionalConfig(
    "catalog.providers.azureDevOps"
  );
  if (!providerConfigs) {
    return configs;
  }
  for (const id of providerConfigs.keys()) {
    configs.push(readAzureDevOpsConfig(id, providerConfigs.getConfig(id)));
  }
  return configs;
}
function readAzureDevOpsConfig(id, config) {
  const organization = config.getString("organization");
  const project = config.getString("project");
  const host = config.getOptionalString("host") || "dev.azure.com";
  const repository = config.getOptionalString("repository") || "*";
  const branch = config.getOptionalString("branch");
  const path = config.getOptionalString("path") || "/catalog-info.yaml";
  const schedule = config.has("schedule") ? backendTasks.readTaskScheduleDefinitionFromConfig(config.getConfig("schedule")) : void 0;
  return {
    id,
    host,
    organization,
    project,
    repository,
    branch,
    path,
    schedule
  };
}

var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
class AzureDevOpsEntityProvider {
  constructor(config, integration, credentialsProvider, logger, taskRunner) {
    this.config = config;
    this.integration = integration;
    this.credentialsProvider = credentialsProvider;
    __publicField(this, "logger");
    __publicField(this, "scheduleFn");
    __publicField(this, "connection");
    this.logger = logger.child({
      target: this.getProviderName()
    });
    this.scheduleFn = this.createScheduleFn(taskRunner);
  }
  static fromConfig(configRoot, options) {
    const providerConfigs = readAzureDevOpsConfigs(configRoot);
    const scmIntegrations = integration.ScmIntegrations.fromConfig(configRoot);
    const credentialsProvider = integration.DefaultAzureDevOpsCredentialsProvider.fromIntegrations(scmIntegrations);
    if (!options.schedule && !options.scheduler) {
      throw new Error("Either schedule or scheduler must be provided.");
    }
    return providerConfigs.map((providerConfig) => {
      var _a;
      const integration$1 = integration.ScmIntegrations.fromConfig(configRoot).azure.byHost(
        providerConfig.host
      );
      if (!integration$1) {
        throw new Error(
          `There is no Azure integration for host ${providerConfig.host}. Please add a configuration entry for it under integrations.azure`
        );
      }
      if (!options.schedule && !providerConfig.schedule) {
        throw new Error(
          `No schedule provided neither via code nor config for AzureDevOpsEntityProvider:${providerConfig.id}.`
        );
      }
      const taskRunner = (_a = options.schedule) != null ? _a : options.scheduler.createScheduledTaskRunner(providerConfig.schedule);
      return new AzureDevOpsEntityProvider(
        providerConfig,
        integration$1,
        credentialsProvider,
        options.logger,
        taskRunner
      );
    });
  }
  createScheduleFn(taskRunner) {
    return async () => {
      const taskId = `${this.getProviderName()}:refresh`;
      return taskRunner.run({
        id: taskId,
        fn: async () => {
          const logger = this.logger.child({
            class: AzureDevOpsEntityProvider.prototype.constructor.name,
            taskId,
            taskInstanceId: uuid__namespace.v4()
          });
          try {
            await this.refresh(logger);
          } catch (error) {
            logger.error(
              `${this.getProviderName()} refresh failed, ${error}`,
              error
            );
          }
        }
      });
    };
  }
  /** {@inheritdoc @backstage/plugin-catalog-backend#EntityProvider.getProviderName} */
  getProviderName() {
    return `AzureDevOpsEntityProvider:${this.config.id}`;
  }
  /** {@inheritdoc @backstage/plugin-catalog-backend#EntityProvider.connect} */
  async connect(connection) {
    this.connection = connection;
    await this.scheduleFn();
  }
  async refresh(logger) {
    if (!this.connection) {
      throw new Error("Not initialized");
    }
    logger.info("Discovering Azure DevOps catalog files");
    const files = await codeSearch(
      this.credentialsProvider,
      this.integration.config,
      this.config.organization,
      this.config.project,
      this.config.repository,
      this.config.path,
      this.config.branch || ""
    );
    logger.info(`Discovered ${files.length} catalog files`);
    const targets = files.map((key) => this.createObjectUrl(key));
    const locations = Array.from(new Set(targets)).map(
      (key) => this.createLocationSpec(key)
    );
    await this.connection.applyMutation({
      type: "full",
      entities: locations.map((location) => {
        return {
          locationKey: this.getProviderName(),
          entity: pluginCatalogNode.locationSpecToLocationEntity({ location })
        };
      })
    });
    logger.info(
      `Committed ${locations.length} locations for AzureDevOps catalog files`
    );
  }
  createLocationSpec(target) {
    return {
      type: "url",
      target,
      presence: "required"
    };
  }
  createObjectUrl(file) {
    const baseUrl = `https://${this.config.host}/${this.config.organization}/${file.project.name}`;
    let fullUrl = `${baseUrl}/_git/${file.repository.name}?path=${file.path}`;
    if (this.config.branch) {
      fullUrl += `&version=GB${this.config.branch}`;
    }
    return encodeURI(fullUrl);
  }
}

exports.AzureDevOpsEntityProvider = AzureDevOpsEntityProvider;
exports.codeSearch = codeSearch;
//# sourceMappingURL=AzureDevOpsEntityProvider-c37446f5.cjs.js.map
