'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var integration = require('@backstage/integration');
var pluginCatalogNode = require('@backstage/plugin-catalog-node');
var AzureDevOpsEntityProvider = require('./cjs/AzureDevOpsEntityProvider-c37446f5.cjs.js');
require('@backstage/backend-tasks');
require('uuid');
require('node-fetch');

var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
class AzureDevOpsDiscoveryProcessor {
  constructor(options) {
    __publicField(this, "integrations");
    __publicField(this, "credentialsProvider");
    __publicField(this, "logger");
    this.integrations = options.integrations;
    this.logger = options.logger;
    this.credentialsProvider = integration.DefaultAzureDevOpsCredentialsProvider.fromIntegrations(
      options.integrations
    );
  }
  static fromConfig(config, options) {
    const integrations = integration.ScmIntegrations.fromConfig(config);
    return new AzureDevOpsDiscoveryProcessor({
      ...options,
      integrations
    });
  }
  getProcessorName() {
    return "AzureDevOpsDiscoveryProcessor";
  }
  async readLocation(location, _optional, emit) {
    var _a;
    if (location.type !== "azure-discovery") {
      return false;
    }
    const azureConfig = (_a = this.integrations.azure.byUrl(location.target)) == null ? void 0 : _a.config;
    if (!azureConfig) {
      throw new Error(
        `There is no Azure integration that matches ${location.target}. Please add a configuration entry for it under integrations.azure`
      );
    }
    const { baseUrl, org, project, repo, catalogPath, branch } = parseUrl(
      location.target
    );
    this.logger.info(
      `Reading Azure DevOps repositories from ${location.target}`
    );
    const files = await AzureDevOpsEntityProvider.codeSearch(
      this.credentialsProvider,
      azureConfig,
      org,
      project,
      repo,
      catalogPath,
      branch
    );
    this.logger.debug(
      `Found ${files.length} files in Azure DevOps from ${location.target}.`
    );
    for (const file of files) {
      let target = `${baseUrl}/${org}/${project}/_git/${file.repository.name}?path=${file.path}`;
      if (branch) {
        target += `&version=GB${branch}`;
      }
      emit(
        pluginCatalogNode.processingResult.location({
          type: "url",
          target,
          // Not all locations may actually exist, since the user defined them as a wildcard pattern.
          // Thus, we emit them as optional and let the downstream processor find them while not outputting
          // an error if it couldn't.
          presence: "optional"
        })
      );
    }
    return true;
  }
}
function parseUrl(urlString) {
  const url = new URL(urlString);
  const path = url.pathname.slice(1).split("/");
  const catalogPath = url.searchParams.get("path") || "/catalog-info.yaml";
  let branch = url.searchParams.get("version") || "";
  if (branch.startsWith("GB")) {
    branch = branch.slice(2);
  }
  if (path.length === 2 && path[0].length && path[1].length) {
    return {
      baseUrl: url.origin,
      org: decodeURIComponent(path[0]),
      project: decodeURIComponent(path[1]),
      repo: "",
      catalogPath,
      branch
    };
  } else if (path.length === 4 && path[0].length && path[1].length && path[2].length && path[3].length) {
    return {
      baseUrl: url.origin,
      org: decodeURIComponent(path[0]),
      project: decodeURIComponent(path[1]),
      repo: decodeURIComponent(path[3]),
      catalogPath,
      branch
    };
  }
  throw new Error(`Failed to parse ${urlString}`);
}

exports.AzureDevOpsEntityProvider = AzureDevOpsEntityProvider.AzureDevOpsEntityProvider;
exports.AzureDevOpsDiscoveryProcessor = AzureDevOpsDiscoveryProcessor;
//# sourceMappingURL=index.cjs.js.map
