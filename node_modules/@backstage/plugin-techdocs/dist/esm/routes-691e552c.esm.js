import { ResponseError, NotFoundError } from '@backstage/errors';
import { EventSourcePolyfill } from 'event-source-polyfill';
import { createRouteRef } from '@backstage/core-plugin-api';

var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
class TechDocsClient {
  constructor(options) {
    __publicField(this, "configApi");
    __publicField(this, "discoveryApi");
    __publicField(this, "fetchApi");
    this.configApi = options.configApi;
    this.discoveryApi = options.discoveryApi;
    this.fetchApi = options.fetchApi;
  }
  async getApiOrigin() {
    return await this.discoveryApi.getBaseUrl("techdocs");
  }
  /**
   * Retrieve TechDocs metadata.
   *
   * When docs are built, we generate a techdocs_metadata.json and store it along with the generated
   * static files. It includes necessary data about the docs site. This method requests techdocs-backend
   * which retrieves the TechDocs metadata.
   *
   * @param entityId - Object containing entity data like name, namespace, etc.
   */
  async getTechDocsMetadata(entityId) {
    const { kind, namespace, name } = entityId;
    const apiOrigin = await this.getApiOrigin();
    const requestUrl = `${apiOrigin}/metadata/techdocs/${namespace}/${kind}/${name}`;
    const request = await this.fetchApi.fetch(`${requestUrl}`);
    if (!request.ok) {
      throw await ResponseError.fromResponse(request);
    }
    return await request.json();
  }
  /**
   * Retrieve metadata about an entity.
   *
   * This method requests techdocs-backend which uses the catalog APIs to respond with filtered
   * information required here.
   *
   * @param entityId - Object containing entity data like name, namespace, etc.
   */
  async getEntityMetadata(entityId) {
    const { kind, namespace, name } = entityId;
    const apiOrigin = await this.getApiOrigin();
    const requestUrl = `${apiOrigin}/metadata/entity/${namespace}/${kind}/${name}`;
    const request = await this.fetchApi.fetch(`${requestUrl}`);
    if (!request.ok) {
      throw await ResponseError.fromResponse(request);
    }
    return await request.json();
  }
}
class TechDocsStorageClient {
  constructor(options) {
    __publicField(this, "configApi");
    __publicField(this, "discoveryApi");
    __publicField(this, "identityApi");
    __publicField(this, "fetchApi");
    this.configApi = options.configApi;
    this.discoveryApi = options.discoveryApi;
    this.identityApi = options.identityApi;
    this.fetchApi = options.fetchApi;
  }
  async getApiOrigin() {
    return await this.discoveryApi.getBaseUrl("techdocs");
  }
  async getStorageUrl() {
    var _a;
    return (_a = this.configApi.getOptionalString("techdocs.storageUrl")) != null ? _a : `${await this.discoveryApi.getBaseUrl("techdocs")}/static/docs`;
  }
  async getBuilder() {
    return this.configApi.getString("techdocs.builder");
  }
  /**
   * Fetch HTML content as text for an individual docs page in an entity's docs site.
   *
   * @param entityId - Object containing entity data like name, namespace, etc.
   * @param path - The unique path to an individual docs page e.g. overview/what-is-new
   * @returns HTML content of the docs page as string
   * @throws Throws error when the page is not found.
   */
  async getEntityDocs(entityId, path) {
    const { kind, namespace, name } = entityId;
    const storageUrl = await this.getStorageUrl();
    const url = `${storageUrl}/${namespace}/${kind}/${name}/${path}`;
    const request = await this.fetchApi.fetch(
      `${url.endsWith("/") ? url : `${url}/`}index.html`
    );
    let errorMessage = "";
    switch (request.status) {
      case 404:
        errorMessage = "Page not found. ";
        if (!path) {
          errorMessage += "This could be because there is no index.md file in the root of the docs directory of this repository.";
        }
        throw new NotFoundError(errorMessage);
      case 500:
        errorMessage = "Could not generate documentation or an error in the TechDocs backend. ";
        throw new Error(errorMessage);
    }
    return request.text();
  }
  /**
   * Check if docs are on the latest version and trigger rebuild if not
   *
   * @param entityId - Object containing entity data like name, namespace, etc.
   * @param logHandler - Callback to receive log messages from the build process
   * @returns Whether documents are currently synchronized to newest version
   * @throws Throws error on error from sync endpoint in TechDocs Backend
   */
  async syncEntityDocs(entityId, logHandler = () => {
  }) {
    const { kind, namespace, name } = entityId;
    const apiOrigin = await this.getApiOrigin();
    const url = `${apiOrigin}/sync/${namespace}/${kind}/${name}`;
    const { token } = await this.identityApi.getCredentials();
    return new Promise((resolve, reject) => {
      const source = new EventSourcePolyfill(url, {
        withCredentials: true,
        headers: token ? { Authorization: `Bearer ${token}` } : {}
      });
      source.addEventListener("log", (e) => {
        if (e.data) {
          logHandler(JSON.parse(e.data));
        }
      });
      source.addEventListener("finish", (e) => {
        let updated = false;
        if (e.data) {
          ({ updated } = JSON.parse(e.data));
        }
        resolve(updated ? "updated" : "cached");
      });
      source.onerror = (e) => {
        source.close();
        switch (e.status) {
          case 404:
            reject(new NotFoundError(e.message));
            return;
          default:
            reject(new Error(e.data));
            return;
        }
      };
    });
  }
  async getBaseUrl(oldBaseUrl, entityId, path) {
    const { kind, namespace, name } = entityId;
    const apiOrigin = await this.getApiOrigin();
    const newBaseUrl = `${apiOrigin}/static/docs/${namespace}/${kind}/${name}/${path}`;
    return new URL(
      oldBaseUrl,
      newBaseUrl.endsWith("/") ? newBaseUrl : `${newBaseUrl}/`
    ).toString();
  }
}

const rootRouteRef = createRouteRef({
  id: "techdocs:index-page"
});
const rootDocsRouteRef = createRouteRef({
  id: "techdocs:reader-page",
  params: ["namespace", "kind", "name"]
});
const rootCatalogDocsRouteRef = createRouteRef({
  id: "techdocs:catalog-reader-view"
});

export { TechDocsClient as T, TechDocsStorageClient as a, rootDocsRouteRef as b, rootCatalogDocsRouteRef as c, rootRouteRef as r };
//# sourceMappingURL=routes-691e552c.esm.js.map
