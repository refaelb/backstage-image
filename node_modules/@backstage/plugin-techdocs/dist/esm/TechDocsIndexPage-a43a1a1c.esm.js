import React, { useEffect } from 'react';
import { useOutlet } from 'react-router-dom';
import { SubvalueCell, Link, Table, EmptyState, LinkButton, WarningPanel, CodeSnippet, PageWithHeader, Content, ContentHeader, SupportButton } from '@backstage/core-components';
import { EntityRefLinks, getEntityRelations, humanizeEntityRef, useEntityList, useStarredEntities, CATALOG_FILTER_EXISTS, EntityListProvider, CatalogFilterLayout, UserListPicker, EntityOwnerPicker, EntityTagPicker } from '@backstage/plugin-catalog-react';
import { useRouteRef, useApi, configApiRef } from '@backstage/core-plugin-api';
import useCopyToClipboard from 'react-use/lib/useCopyToClipboard';
import { capitalize } from 'lodash';
import { RELATION_OWNED_BY } from '@backstage/catalog-model';
import { b as rootDocsRouteRef } from './routes-691e552c.esm.js';
import ShareIcon from '@material-ui/icons/Share';
import { withStyles } from '@material-ui/styles';
import Star from '@material-ui/icons/Star';
import StarBorder from '@material-ui/icons/StarBorder';

function toLowerMaybe(str, config) {
  return config.getOptionalBoolean(
    "techdocs.legacyUseCaseSensitiveTripletPaths"
  ) ? str : str.toLocaleLowerCase("en-US");
}

const YellowStar = withStyles({
  root: {
    color: "#f3ba37"
  }
})(Star);
const actionFactories = {
  createCopyDocsUrlAction(copyToClipboard) {
    return (row) => {
      return {
        icon: () => /* @__PURE__ */ React.createElement(ShareIcon, { fontSize: "small" }),
        tooltip: "Click to copy documentation link to clipboard",
        onClick: () => copyToClipboard(`${window.location.origin}${row.resolved.docsUrl}`)
      };
    };
  },
  createStarEntityAction(isStarredEntity, toggleStarredEntity) {
    return (row) => {
      const entity = row.entity;
      const isStarred = isStarredEntity(entity);
      return {
        cellStyle: { paddingLeft: "1em" },
        icon: () => isStarred ? /* @__PURE__ */ React.createElement(YellowStar, null) : /* @__PURE__ */ React.createElement(StarBorder, null),
        tooltip: isStarred ? "Remove from favorites" : "Add to favorites",
        onClick: () => toggleStarredEntity(entity)
      };
    };
  }
};

function customTitle(entity) {
  return entity.metadata.title || entity.metadata.name;
}
const columnFactories = {
  createNameColumn() {
    return {
      title: "Document",
      field: "entity.metadata.name",
      highlight: true,
      render: (row) => /* @__PURE__ */ React.createElement(
        SubvalueCell,
        {
          value: /* @__PURE__ */ React.createElement(Link, { to: row.resolved.docsUrl }, customTitle(row.entity)),
          subvalue: row.entity.metadata.description
        }
      )
    };
  },
  createOwnerColumn() {
    return {
      title: "Owner",
      field: "resolved.ownedByRelationsTitle",
      render: ({ resolved }) => /* @__PURE__ */ React.createElement(
        EntityRefLinks,
        {
          entityRefs: resolved.ownedByRelations,
          defaultKind: "group"
        }
      )
    };
  },
  createKindColumn() {
    return {
      title: "Kind",
      field: "entity.kind"
    };
  },
  createTypeColumn() {
    return {
      title: "Type",
      field: "entity.spec.type"
    };
  }
};

const DocsTable = (props) => {
  const { entities, title, loading, columns, actions, options } = props;
  const [, copyToClipboard] = useCopyToClipboard();
  const getRouteToReaderPageFor = useRouteRef(rootDocsRouteRef);
  const config = useApi(configApiRef);
  if (!entities)
    return null;
  const documents = entities.map((entity) => {
    var _a;
    const ownedByRelations = getEntityRelations(entity, RELATION_OWNED_BY);
    return {
      entity,
      resolved: {
        docsUrl: getRouteToReaderPageFor({
          namespace: toLowerMaybe(
            (_a = entity.metadata.namespace) != null ? _a : "default",
            config
          ),
          kind: toLowerMaybe(entity.kind, config),
          name: toLowerMaybe(entity.metadata.name, config)
        }),
        ownedByRelations,
        ownedByRelationsTitle: ownedByRelations.map((r) => humanizeEntityRef(r, { defaultKind: "group" })).join(", ")
      }
    };
  });
  const defaultColumns = [
    columnFactories.createNameColumn(),
    columnFactories.createOwnerColumn(),
    columnFactories.createKindColumn(),
    columnFactories.createTypeColumn()
  ];
  const defaultActions = [
    actionFactories.createCopyDocsUrlAction(copyToClipboard)
  ];
  const pageSize = 20;
  const paging = documents && documents.length > pageSize;
  return /* @__PURE__ */ React.createElement(React.Fragment, null, loading || documents && documents.length > 0 ? /* @__PURE__ */ React.createElement(
    Table,
    {
      isLoading: loading,
      options: {
        paging,
        pageSize,
        search: true,
        actionsColumnIndex: -1,
        ...options
      },
      data: documents,
      columns: columns || defaultColumns,
      actions: actions || defaultActions,
      title: title ? `${title} (${documents.length})` : `All (${documents.length})`
    }
  ) : /* @__PURE__ */ React.createElement(
    EmptyState,
    {
      missing: "data",
      title: "No documents to show",
      description: "Create your own document. Check out our Getting Started Information",
      action: /* @__PURE__ */ React.createElement(
        LinkButton,
        {
          color: "primary",
          to: "https://backstage.io/docs/features/techdocs/getting-started",
          variant: "contained"
        },
        "DOCS"
      )
    }
  ));
};
DocsTable.columns = columnFactories;
DocsTable.actions = actionFactories;

const EntityListDocsTable = (props) => {
  var _a, _b;
  const { columns, actions, options } = props;
  const { loading, error, entities, filters } = useEntityList();
  const { isStarredEntity, toggleStarredEntity } = useStarredEntities();
  const [, copyToClipboard] = useCopyToClipboard();
  const title = capitalize((_b = (_a = filters.user) == null ? void 0 : _a.value) != null ? _b : "all");
  const defaultActions = [
    actionFactories.createCopyDocsUrlAction(copyToClipboard),
    actionFactories.createStarEntityAction(
      isStarredEntity,
      toggleStarredEntity
    )
  ];
  if (error) {
    return /* @__PURE__ */ React.createElement(
      WarningPanel,
      {
        severity: "error",
        title: "Could not load available documentation."
      },
      /* @__PURE__ */ React.createElement(CodeSnippet, { language: "text", text: error.toString() })
    );
  }
  return /* @__PURE__ */ React.createElement(
    DocsTable,
    {
      title,
      entities,
      loading,
      actions: actions || defaultActions,
      columns,
      options
    }
  );
};
EntityListDocsTable.columns = columnFactories;
EntityListDocsTable.actions = actionFactories;

const TechDocsPageWrapper = (props) => {
  var _a;
  const { children } = props;
  const configApi = useApi(configApiRef);
  const generatedSubtitle = `Documentation available in ${(_a = configApi.getOptionalString("organization.name")) != null ? _a : "Backstage"}`;
  return /* @__PURE__ */ React.createElement(
    PageWithHeader,
    {
      title: "Documentation",
      subtitle: generatedSubtitle,
      themeId: "documentation"
    },
    children
  );
};

class TechDocsFilter {
  getCatalogFilters() {
    return {
      "metadata.annotations.backstage.io/techdocs-ref": CATALOG_FILTER_EXISTS
    };
  }
}
const TechDocsPicker = () => {
  const { updateFilters } = useEntityList();
  useEffect(() => {
    updateFilters({
      techdocs: new TechDocsFilter()
    });
  }, [updateFilters]);
  return null;
};

const DefaultTechDocsHome = (props) => {
  const { initialFilter = "owned", columns, actions } = props;
  return /* @__PURE__ */ React.createElement(TechDocsPageWrapper, null, /* @__PURE__ */ React.createElement(Content, null, /* @__PURE__ */ React.createElement(ContentHeader, { title: "" }, /* @__PURE__ */ React.createElement(SupportButton, null, "Discover documentation in your ecosystem.")), /* @__PURE__ */ React.createElement(EntityListProvider, null, /* @__PURE__ */ React.createElement(CatalogFilterLayout, null, /* @__PURE__ */ React.createElement(CatalogFilterLayout.Filters, null, /* @__PURE__ */ React.createElement(TechDocsPicker, null), /* @__PURE__ */ React.createElement(UserListPicker, { initialFilter }), /* @__PURE__ */ React.createElement(EntityOwnerPicker, null), /* @__PURE__ */ React.createElement(EntityTagPicker, null)), /* @__PURE__ */ React.createElement(CatalogFilterLayout.Content, null, /* @__PURE__ */ React.createElement(EntityListDocsTable, { actions, columns }))))));
};

const TechDocsIndexPage = (props) => {
  const outlet = useOutlet();
  return outlet || /* @__PURE__ */ React.createElement(DefaultTechDocsHome, { ...props });
};

var TechDocsIndexPage$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  TechDocsIndexPage: TechDocsIndexPage
});

export { DocsTable as D, EntityListDocsTable as E, TechDocsPageWrapper as T, DefaultTechDocsHome as a, TechDocsPicker as b, TechDocsIndexPage as c, TechDocsIndexPage$1 as d, toLowerMaybe as t };
//# sourceMappingURL=TechDocsIndexPage-a43a1a1c.esm.js.map
