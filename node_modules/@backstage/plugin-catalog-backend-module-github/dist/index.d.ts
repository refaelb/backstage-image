import * as _backstage_catalog_model from '@backstage/catalog-model';
import { Entity, UserEntity } from '@backstage/catalog-model';
import { GithubCredentialsProvider, ScmIntegrationRegistry, GithubIntegrationConfig } from '@backstage/integration';
import { ScmLocationAnalyzer, AnalyzeOptions, CatalogProcessor, LocationSpec, CatalogProcessorEmit, EntityProvider, EntityProviderConnection } from '@backstage/plugin-catalog-node';
import { PluginEndpointDiscovery, TokenManager } from '@backstage/backend-common';
import { Config } from '@backstage/config';
import { Logger } from 'winston';
import { graphql } from '@octokit/graphql';
import { TaskRunner, PluginTaskScheduler } from '@backstage/backend-tasks';
import { EventSubscriber, EventParams, EventBroker } from '@backstage/plugin-events-node';

/** @public */
type GithubLocationAnalyzerOptions = {
    config: Config;
    discovery: PluginEndpointDiscovery;
    tokenManager: TokenManager;
    githubCredentialsProvider?: GithubCredentialsProvider;
};
/** @public */
declare class GithubLocationAnalyzer implements ScmLocationAnalyzer {
    private readonly catalogClient;
    private readonly githubCredentialsProvider;
    private readonly integrations;
    private readonly tokenManager;
    constructor(options: GithubLocationAnalyzerOptions);
    supports(url: string): boolean;
    analyze(options: AnalyzeOptions): Promise<{
        existing: {
            location: {
                type: string;
                target: string;
            };
            isRegistered: boolean;
            entity: _backstage_catalog_model.Entity;
        }[];
    }>;
}

/**
 * Extracts repositories out of a GitHub org.
 *
 * The following will create locations for all projects which have a catalog-info.yaml
 * on the default branch. The first is shorthand for the second.
 *
 *    target: "https://github.com/backstage"
 *    or
 *    target: https://github.com/backstage/*\/blob/-/catalog-info.yaml
 *
 * You may also explicitly specify the source branch:
 *
 *    target: https://github.com/backstage/*\/blob/main/catalog-info.yaml
 *
 * @public
 */
declare class GithubDiscoveryProcessor implements CatalogProcessor {
    private readonly integrations;
    private readonly logger;
    private readonly githubCredentialsProvider;
    static fromConfig(config: Config, options: {
        logger: Logger;
        githubCredentialsProvider?: GithubCredentialsProvider;
    }): GithubDiscoveryProcessor;
    constructor(options: {
        integrations: ScmIntegrationRegistry;
        logger: Logger;
        githubCredentialsProvider?: GithubCredentialsProvider;
    });
    getProcessorName(): string;
    readLocation(location: LocationSpec, _optional: boolean, emit: CatalogProcessorEmit): Promise<boolean>;
}

/**
 * The configuration parameters for a multi-org GitHub processor.
 * @public
 */
type GithubMultiOrgConfig = Array<{
    /**
     * The name of the GitHub org to process.
     */
    name: string;
    /**
     * The namespace of the group created for this org.
     */
    groupNamespace: string;
    /**
     * The namespace of the users created for this org. If not specified defaults to undefined.
     */
    userNamespace: string | undefined;
}>;

/**
 * Context passed to Transformers
 *
 * @public
 */
interface TransformerContext {
    client: typeof graphql;
    query: string;
    org: string;
}
/**
 * Transformer for GitHub users to an Entity
 *
 * @public
 */
type UserTransformer = (item: GithubUser, ctx: TransformerContext) => Promise<Entity | undefined>;
/**
 * Transformer for GitHub Team to an Entity
 *
 * @public
 */
type TeamTransformer = (item: GithubTeam, ctx: TransformerContext) => Promise<Entity | undefined>;
/**
 * Default transformer for GitHub users to UserEntity
 *
 * @public
 */
declare const defaultUserTransformer: (item: GithubUser, _ctx: TransformerContext) => Promise<UserEntity | undefined>;
/**
 * Default transformer for GitHub Team to GroupEntity
 *
 * @public
 */
declare const defaultOrganizationTeamTransformer: TeamTransformer;

/**
 * Github User
 *
 * @public
 */
type GithubUser = {
    login: string;
    bio?: string;
    avatarUrl?: string;
    email?: string;
    name?: string;
    organizationVerifiedDomainEmails?: string[];
};
/**
 * Github Team
 *
 * @public
 */
type GithubTeam = {
    slug: string;
    combinedSlug: string;
    name?: string;
    description?: string;
    avatarUrl?: string;
    editTeamUrl?: string;
    parentTeam?: GithubTeam;
    members: GithubUser[];
};

/**
 * Extracts teams and users out of a multiple GitHub orgs namespaced per org.
 *
 * Be aware that this processor may not be compatible with future org structures in the catalog.
 *
 * @public
 */
declare class GithubMultiOrgReaderProcessor implements CatalogProcessor {
    private options;
    private readonly integrations;
    private readonly orgs;
    private readonly logger;
    private readonly githubCredentialsProvider;
    static fromConfig(config: Config, options: {
        logger: Logger;
        githubCredentialsProvider?: GithubCredentialsProvider;
        userTransformer?: UserTransformer;
        teamTransformer?: TeamTransformer;
    }): GithubMultiOrgReaderProcessor;
    constructor(options: {
        integrations: ScmIntegrationRegistry;
        logger: Logger;
        orgs: GithubMultiOrgConfig;
        githubCredentialsProvider?: GithubCredentialsProvider;
        userTransformer?: UserTransformer;
        teamTransformer?: TeamTransformer;
    });
    getProcessorName(): string;
    readLocation(location: LocationSpec, _optional: boolean, emit: CatalogProcessorEmit): Promise<boolean>;
    private getAllOrgs;
}

/**
 * Extracts teams and users out of a GitHub org.
 *
 * @remarks
 *
 * Consider using {@link GithubOrgEntityProvider} instead.
 *
 * @public
 */
declare class GithubOrgReaderProcessor implements CatalogProcessor {
    private readonly integrations;
    private readonly logger;
    private readonly githubCredentialsProvider;
    static fromConfig(config: Config, options: {
        logger: Logger;
        githubCredentialsProvider?: GithubCredentialsProvider;
    }): GithubOrgReaderProcessor;
    constructor(options: {
        integrations: ScmIntegrationRegistry;
        logger: Logger;
        githubCredentialsProvider?: GithubCredentialsProvider;
    });
    getProcessorName(): string;
    readLocation(location: LocationSpec, _optional: boolean, emit: CatalogProcessorEmit): Promise<boolean>;
    private createClient;
}

/**
 * Discovers catalog files located in [GitHub](https://github.com).
 * The provider will search your GitHub account and register catalog files matching the configured path
 * as Location entity and via following processing steps add all contained catalog entities.
 * This can be useful as an alternative to static locations or manually adding things to the catalog.
 *
 * @public
 */
declare class GithubEntityProvider implements EntityProvider, EventSubscriber {
    private readonly config;
    private readonly logger;
    private readonly integration;
    private readonly scheduleFn;
    private connection?;
    private readonly githubCredentialsProvider;
    static fromConfig(config: Config, options: {
        logger: Logger;
        schedule?: TaskRunner;
        scheduler?: PluginTaskScheduler;
    }): GithubEntityProvider[];
    private constructor();
    /** {@inheritdoc @backstage/plugin-catalog-backend#EntityProvider.getProviderName} */
    getProviderName(): string;
    /** {@inheritdoc @backstage/plugin-catalog-backend#EntityProvider.connect} */
    connect(connection: EntityProviderConnection): Promise<void>;
    private createScheduleFn;
    refresh(logger: Logger): Promise<void>;
    private findCatalogFiles;
    private matchesFilters;
    private createLocationUrl;
    private static toLocationSpec;
    /** {@inheritdoc @backstage/plugin-events-node#EventSubscriber.onEvent} */
    onEvent(params: EventParams): Promise<void>;
    /** {@inheritdoc @backstage/plugin-events-node#EventSubscriber.supportsEventTopics} */
    supportsEventTopics(): string[];
    private onRepoPush;
    private collectDeferredEntitiesFromCommit;
    private collectFilesFromCommit;
    private toDeferredEntities;
}

/**
 * Options for {@link GithubMultiOrgEntityProvider}.
 *
 * @public
 */
interface GithubMultiOrgEntityProviderOptions {
    /**
     * A unique, stable identifier for this provider.
     *
     * @example "production"
     */
    id: string;
    /**
     * The target that this provider should consume.
     *
     * @example "https://mycompany.github.com"
     */
    githubUrl: string;
    /**
     * The list of the GitHub orgs to consume. By default will consume all accessible
     * orgs on the given GitHub instance (support for GitHub App integration only).
     */
    orgs?: string[];
    /**
     * The refresh schedule to use.
     *
     * @defaultValue "manual"
     * @remarks
     *
     * If you pass in 'manual', you are responsible for calling the `read` method
     * manually at some interval.
     *
     * But more commonly you will pass in the result of
     * {@link @backstage/backend-tasks#PluginTaskScheduler.createScheduledTaskRunner}
     * to enable automatic scheduling of tasks.
     */
    schedule?: 'manual' | TaskRunner;
    /**
     * The logger to use.
     */
    logger: Logger;
    /**
     * Optionally supply a custom credentials provider, replacing the default one.
     */
    githubCredentialsProvider?: GithubCredentialsProvider;
    /**
     * Optionally include a user transformer for transforming from GitHub users to User Entities
     */
    userTransformer?: UserTransformer;
    /**
     * Optionally include a team transformer for transforming from GitHub teams to Group Entities.
     * By default groups will be namespaced according to their GitHub org.
     */
    teamTransformer?: TeamTransformer;
    /**
     * An EventBroker to subscribe this provider to GitHub events to trigger delta mutations
     */
    eventBroker?: EventBroker;
}
/**
 * Ingests org data (users and groups) from GitHub.
 *
 * @public
 */
declare class GithubMultiOrgEntityProvider implements EntityProvider {
    private readonly options;
    private connection?;
    private scheduleFn?;
    static fromConfig(config: Config, options: GithubMultiOrgEntityProviderOptions): GithubMultiOrgEntityProvider;
    constructor(options: {
        id: string;
        gitHubConfig: GithubIntegrationConfig;
        githubCredentialsProvider: GithubCredentialsProvider;
        githubUrl: string;
        logger: Logger;
        orgs?: string[];
        userTransformer?: UserTransformer;
        teamTransformer?: TeamTransformer;
    });
    /** {@inheritdoc @backstage/plugin-catalog-backend#EntityProvider.getProviderName} */
    getProviderName(): string;
    /** {@inheritdoc @backstage/plugin-catalog-backend#EntityProvider.connect} */
    connect(connection: EntityProviderConnection): Promise<void>;
    /**
     * Runs one single complete ingestion. This is only necessary if you use
     * manual scheduling.
     */
    read(options?: {
        logger?: Logger;
    }): Promise<void>;
    private supportsEventTopics;
    private onEvent;
    private onInstallationChange;
    private onMemberChangeInOrganization;
    private onTeamChangeInOrganization;
    private onTeamEditedInOrganization;
    private onMembershipChangedInTeam;
    private schedule;
    private defaultMultiOrgTeamTransformer;
    private getAllOrgs;
    private createAddEntitiesOperation;
    private createRemoveEntitiesOperation;
}

/**
 * Options for {@link GithubOrgEntityProvider}.
 *
 * @public
 */
interface GithubOrgEntityProviderOptions {
    /**
     * A unique, stable identifier for this provider.
     *
     * @example "production"
     */
    id: string;
    /**
     * The target that this provider should consume.
     *
     * @example "https://github.com/backstage"
     */
    orgUrl: string;
    /**
     * The refresh schedule to use.
     *
     * @defaultValue "manual"
     * @remarks
     *
     * If you pass in 'manual', you are responsible for calling the `read` method
     * manually at some interval.
     *
     * But more commonly you will pass in the result of
     * {@link @backstage/backend-tasks#PluginTaskScheduler.createScheduledTaskRunner}
     * to enable automatic scheduling of tasks.
     */
    schedule?: 'manual' | TaskRunner;
    /**
     * The logger to use.
     */
    logger: Logger;
    /**
     * Optionally supply a custom credentials provider, replacing the default one.
     */
    githubCredentialsProvider?: GithubCredentialsProvider;
    /**
     * Optionally include a user transformer for transforming from GitHub users to User Entities
     */
    userTransformer?: UserTransformer;
    /**
     * Optionally include a team transformer for transforming from GitHub teams to Group Entities
     */
    teamTransformer?: TeamTransformer;
}
/**
 * Ingests org data (users and groups) from GitHub.
 *
 * @public
 */
declare class GithubOrgEntityProvider implements EntityProvider, EventSubscriber {
    private options;
    private readonly credentialsProvider;
    private connection?;
    private scheduleFn?;
    static fromConfig(config: Config, options: GithubOrgEntityProviderOptions): GithubOrgEntityProvider;
    constructor(options: {
        id: string;
        orgUrl: string;
        gitHubConfig: GithubIntegrationConfig;
        logger: Logger;
        githubCredentialsProvider?: GithubCredentialsProvider;
        userTransformer?: UserTransformer;
        teamTransformer?: TeamTransformer;
    });
    /** {@inheritdoc @backstage/plugin-catalog-backend#EntityProvider.getProviderName} */
    getProviderName(): string;
    /** {@inheritdoc @backstage/plugin-catalog-backend#EntityProvider.connect} */
    connect(connection: EntityProviderConnection): Promise<void>;
    /**
     * Runs one single complete ingestion. This is only necessary if you use
     * manual scheduling.
     */
    read(options?: {
        logger?: Logger;
    }): Promise<void>;
    /** {@inheritdoc @backstage/plugin-events-node#EventSubscriber.onEvent} */
    onEvent(params: EventParams): Promise<void>;
    /** {@inheritdoc @backstage/plugin-events-node#EventSubscriber.supportsEventTopics} */
    supportsEventTopics(): string[];
    private onTeamEditedInOrganization;
    private onMembershipChangedInOrganization;
    private onTeamChangeInOrganization;
    private onMemberChangeInOrganization;
    private schedule;
}

/**
 * @public
 * @deprecated Use {@link GithubOrgEntityProvider} instead.
 */
declare class GitHubOrgEntityProvider extends GithubOrgEntityProvider {
    static fromConfig(config: Config, options: GitHubOrgEntityProviderOptions): GitHubOrgEntityProvider;
}
/**
 * @public
 * @deprecated Use {@link GithubOrgEntityProviderOptions} instead.
 */
type GitHubOrgEntityProviderOptions = GithubOrgEntityProviderOptions;
/**
 * @public
 * @deprecated Use {@link GithubEntityProvider} instead.
 */
declare class GitHubEntityProvider implements EntityProvider {
    private readonly delegate;
    static fromConfig(config: Config, options: {
        logger: Logger;
        schedule?: TaskRunner;
        scheduler?: PluginTaskScheduler;
    }): GitHubEntityProvider[];
    private constructor();
    connect(connection: EntityProviderConnection): Promise<void>;
    getProviderName(): string;
    refresh(logger: Logger): Promise<void>;
}

export { GitHubEntityProvider, GitHubOrgEntityProvider, GitHubOrgEntityProviderOptions, GithubDiscoveryProcessor, GithubEntityProvider, GithubLocationAnalyzer, GithubLocationAnalyzerOptions, GithubMultiOrgConfig, GithubMultiOrgEntityProvider, GithubMultiOrgEntityProviderOptions, GithubMultiOrgReaderProcessor, GithubOrgEntityProvider, GithubOrgEntityProviderOptions, GithubOrgReaderProcessor, GithubTeam, GithubUser, TeamTransformer, TransformerContext, UserTransformer, defaultOrganizationTeamTransformer, defaultUserTransformer };
