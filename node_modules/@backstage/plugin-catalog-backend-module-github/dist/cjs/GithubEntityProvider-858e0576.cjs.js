'use strict';

var integration = require('@backstage/integration');
var pluginCatalogNode = require('@backstage/plugin-catalog-node');
var graphql = require('@octokit/graphql');
var uuid = require('uuid');
var backendTasks = require('@backstage/backend-tasks');
var catalogModel = require('@backstage/catalog-model');
var lodash = require('lodash');
var minimatch = require('minimatch');

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var uuid__namespace = /*#__PURE__*/_interopNamespace(uuid);

const ANNOTATION_GITHUB_USER_LOGIN = "github.com/user-login";
const ANNOTATION_GITHUB_TEAM_SLUG = "github.com/team-slug";

const defaultUserTransformer = async (item, _ctx) => {
  const entity = {
    apiVersion: "backstage.io/v1alpha1",
    kind: "User",
    metadata: {
      name: item.login,
      annotations: {
        [ANNOTATION_GITHUB_USER_LOGIN]: item.login
      }
    },
    spec: {
      profile: {},
      memberOf: []
    }
  };
  if (item.bio)
    entity.metadata.description = item.bio;
  if (item.name)
    entity.spec.profile.displayName = item.name;
  if (item.email)
    entity.spec.profile.email = item.email;
  if (item.avatarUrl)
    entity.spec.profile.picture = item.avatarUrl;
  return entity;
};
const defaultOrganizationTeamTransformer = async (team) => {
  const annotations = {
    [ANNOTATION_GITHUB_TEAM_SLUG]: team.combinedSlug
  };
  if (team.editTeamUrl) {
    annotations["backstage.io/edit-url"] = team.editTeamUrl;
  }
  const entity = {
    apiVersion: "backstage.io/v1alpha1",
    kind: "Group",
    metadata: {
      name: team.slug,
      annotations
    },
    spec: {
      type: "team",
      profile: {},
      children: []
    }
  };
  if (team.description) {
    entity.metadata.description = team.description;
  }
  if (team.name) {
    entity.spec.profile.displayName = team.name;
  }
  if (team.avatarUrl) {
    entity.spec.profile.picture = team.avatarUrl;
  }
  if (team.parentTeam) {
    entity.spec.parent = team.parentTeam.slug;
  }
  entity.spec.members = team.members.map((user) => user.login);
  return entity;
};

function parseGithubOrgUrl(urlString) {
  const path = new URL(urlString).pathname.slice(1).split("/");
  if (path.length === 1 && path[0].length) {
    return { org: decodeURIComponent(path[0]) };
  }
  throw new Error(`Expected a URL pointing to /<org>`);
}
function satisfiesTopicFilter(topics, topicFilter) {
  var _a, _b, _c, _d;
  if (!topicFilter)
    return true;
  if (!topicFilter.include && !topicFilter.exclude)
    return true;
  if (!((_a = topicFilter.include) == null ? void 0 : _a.length) && !((_b = topicFilter.exclude) == null ? void 0 : _b.length))
    return true;
  if (((_c = topicFilter.include) == null ? void 0 : _c.length) && !topicFilter.exclude) {
    for (const topic of topics) {
      if (topicFilter.include.includes(topic))
        return true;
    }
    return false;
  }
  if (!topicFilter.include && ((_d = topicFilter.exclude) == null ? void 0 : _d.length)) {
    if (!topics.length)
      return true;
    for (const topic of topics) {
      if (topicFilter.exclude.includes(topic))
        return false;
    }
    return true;
  }
  if (topicFilter.include && topicFilter.exclude) {
    const matchesInclude = satisfiesTopicFilter(topics, {
      include: topicFilter.include
    });
    const matchesExclude = !satisfiesTopicFilter(topics, {
      exclude: topicFilter.exclude
    });
    if (matchesExclude)
      return false;
    return matchesInclude;
  }
  return true;
}
function satisfiesForkFilter(allowForks, isFork) {
  if (!allowForks && isFork)
    return false;
  return true;
}
function splitTeamSlug(slug) {
  const parts = slug.split("/");
  if (parts.length !== 2) {
    throw new Error(
      `Github team slug '${slug}' was not in the expected format <organisation>/<team>`
    );
  }
  return [parts[0], parts[1]];
}
function satisfiesVisibilityFilter(visibilities, visibility) {
  if (!visibilities.length) {
    return true;
  }
  const lowerCaseVisibilities = visibilities.map(
    (v) => v.toLocaleLowerCase("en-US")
  );
  const lowerCaseVisibility = visibility.toLocaleLowerCase("en-US");
  return lowerCaseVisibilities.includes(lowerCaseVisibility);
}

function withLocations(baseUrl, org, entity) {
  var _a, _b;
  const login = ((_a = entity.metadata.annotations) == null ? void 0 : _a[ANNOTATION_GITHUB_USER_LOGIN]) || entity.metadata.name;
  let team = entity.metadata.name;
  const slug = (_b = entity.metadata.annotations) == null ? void 0 : _b[ANNOTATION_GITHUB_TEAM_SLUG];
  if (slug) {
    const [_, slugTeam] = splitTeamSlug(slug);
    team = slugTeam;
  }
  const location = entity.kind === "Group" ? `url:${baseUrl}/orgs/${org}/teams/${team}` : `url:${baseUrl}/${login}`;
  return lodash.merge(
    {
      metadata: {
        annotations: {
          [catalogModel.ANNOTATION_LOCATION]: location,
          [catalogModel.ANNOTATION_ORIGIN_LOCATION]: location
        }
      }
    },
    entity
  );
}

async function getOrganizationUsers(client, org, tokenType, userTransformer = defaultUserTransformer) {
  const query = `
    query users($org: String!, $email: Boolean!, $cursor: String) {
      organization(login: $org) {
        membersWithRole(first: 100, after: $cursor) {
          pageInfo { hasNextPage, endCursor }
          nodes {
            avatarUrl,
            bio,
            email @include(if: $email),
            login,
            name,
            organizationVerifiedDomainEmails(login: $org)
          }
        }
      }
    }`;
  const users = await queryWithPaging(
    client,
    query,
    org,
    (r) => {
      var _a;
      return (_a = r.organization) == null ? void 0 : _a.membersWithRole;
    },
    userTransformer,
    {
      org,
      email: tokenType === "token"
    }
  );
  return { users };
}
async function getOrganizationTeams(client, org, teamTransformer = defaultOrganizationTeamTransformer) {
  const query = `
    query teams($org: String!, $cursor: String) {
      organization(login: $org) {
        teams(first: 100, after: $cursor) {
          pageInfo { hasNextPage, endCursor }
          nodes {
            slug
            combinedSlug
            name
            description
            avatarUrl
            editTeamUrl
            parentTeam { slug }
            members(first: 100, membership: IMMEDIATE) {
              pageInfo { hasNextPage }
              nodes {
                avatarUrl,
                bio,
                email,
                login,
                name,
                organizationVerifiedDomainEmails(login: $org)
               }
            }
          }
        }
      }
    }`;
  const materialisedTeams = async (item, ctx) => {
    const memberNames = [];
    if (!item.members.pageInfo.hasNextPage) {
      for (const user of item.members.nodes) {
        memberNames.push(user);
      }
    } else {
      const { members } = await getTeamMembers(ctx.client, ctx.org, item.slug);
      for (const userLogin of members) {
        memberNames.push(userLogin);
      }
    }
    const team = {
      ...item,
      members: memberNames
    };
    return await teamTransformer(team, ctx);
  };
  const teams = await queryWithPaging(
    client,
    query,
    org,
    (r) => {
      var _a;
      return (_a = r.organization) == null ? void 0 : _a.teams;
    },
    materialisedTeams,
    { org }
  );
  return { teams };
}
async function getOrganizationTeamsFromUsers(client, org, userLogins, teamTransformer = defaultOrganizationTeamTransformer) {
  const query = `
   query teams($org: String!, $cursor: String, $userLogins: [String!] = "") {
  organization(login: $org) {
    teams(first: 100, after: $cursor, userLogins: $userLogins) {
      pageInfo {
        hasNextPage
        endCursor
      }
      nodes {
        slug
        combinedSlug
        name
        description
        avatarUrl
        editTeamUrl
        parentTeam {
          slug
        }
        members(first: 100, membership: IMMEDIATE) {
          pageInfo {
            hasNextPage
          }
          nodes {
            avatarUrl,
            bio,
            email,
            login,
            name,
            organizationVerifiedDomainEmails(login: $org)
          }
        }
      }
    }
  }
}`;
  const materialisedTeams = async (item, ctx) => {
    const memberNames = [];
    if (!item.members.pageInfo.hasNextPage) {
      for (const user of item.members.nodes) {
        memberNames.push(user);
      }
    } else {
      const { members } = await getTeamMembers(ctx.client, ctx.org, item.slug);
      for (const userLogin of members) {
        memberNames.push(userLogin);
      }
    }
    const team = {
      ...item,
      members: memberNames
    };
    return await teamTransformer(team, ctx);
  };
  const teams = await queryWithPaging(
    client,
    query,
    org,
    (r) => {
      var _a;
      return (_a = r.organization) == null ? void 0 : _a.teams;
    },
    materialisedTeams,
    { org, userLogins }
  );
  return { teams };
}
async function getOrganizationsFromUser(client, user) {
  const query = `
  query orgs($user: String!) {
    user(login: $user) {
      organizations(first: 100) {
        nodes { login }
        pageInfo { hasNextPage, endCursor }
      }
    }
  }`;
  const orgs = await queryWithPaging(
    client,
    query,
    "",
    (r) => {
      var _a;
      return (_a = r.user) == null ? void 0 : _a.organizations;
    },
    async (o) => o.login,
    { user }
  );
  return { orgs };
}
async function getOrganizationTeam(client, org, teamSlug, teamTransformer = defaultOrganizationTeamTransformer) {
  var _a, _b;
  const query = `
  query teams($org: String!, $teamSlug: String!) {
      organization(login: $org) {
        team(slug:$teamSlug) {
            slug
            combinedSlug
            name
            description
            avatarUrl
            editTeamUrl
            parentTeam { slug }
            members(first: 100, membership: IMMEDIATE) {
              pageInfo { hasNextPage }
              nodes { login }
            }
        }
      }
    }`;
  const materialisedTeam = async (item, ctx) => {
    const memberNames = [];
    if (!item.members.pageInfo.hasNextPage) {
      for (const user of item.members.nodes) {
        memberNames.push(user);
      }
    } else {
      const { members } = await getTeamMembers(ctx.client, ctx.org, item.slug);
      for (const userLogin of members) {
        memberNames.push(userLogin);
      }
    }
    const team2 = {
      ...item,
      members: memberNames
    };
    return await teamTransformer(team2, ctx);
  };
  const response = await client(query, {
    org,
    teamSlug
  });
  if (!((_a = response.organization) == null ? void 0 : _a.team))
    throw new Error(`Found no match for team ${teamSlug}`);
  const team = await materialisedTeam((_b = response.organization) == null ? void 0 : _b.team, {
    query,
    client,
    org
  });
  if (!team)
    throw new Error(`Can't transform for team ${teamSlug}`);
  return { team };
}
async function getOrganizationRepositories(client, org, catalogPath) {
  let relativeCatalogPathRef;
  if (catalogPath.startsWith("/")) {
    relativeCatalogPathRef = catalogPath.substring(1);
  } else {
    relativeCatalogPathRef = catalogPath;
  }
  const catalogPathRef = `HEAD:${relativeCatalogPathRef}`;
  const query = `
    query repositories($org: String!, $catalogPathRef: String!, $cursor: String) {
      repositoryOwner(login: $org) {
        login
        repositories(first: 50, after: $cursor) {
          nodes {
            name
            catalogInfoFile: object(expression: $catalogPathRef) {
              __typename
              ... on Blob {
                id
                text
              }
            }
            url
            isArchived
            isFork
            visibility
            repositoryTopics(first: 100) {
              nodes {
                ... on RepositoryTopic {
                  topic {
                    name
                  }
                }
              }
            }
            defaultBranchRef {
              name
            }
          }
          pageInfo {
            hasNextPage
            endCursor
          }
        }
      }
    }`;
  const repositories = await queryWithPaging(
    client,
    query,
    org,
    (r) => {
      var _a;
      return (_a = r.repositoryOwner) == null ? void 0 : _a.repositories;
    },
    async (x) => x,
    { org, catalogPathRef }
  );
  return { repositories };
}
async function getTeamMembers(client, org, teamSlug) {
  const query = `
    query members($org: String!, $teamSlug: String!, $cursor: String) {
      organization(login: $org) {
        team(slug: $teamSlug) {
          members(first: 100, after: $cursor, membership: IMMEDIATE) {
            pageInfo { hasNextPage, endCursor }
            nodes { login }
          }
        }
      }
    }`;
  const members = await queryWithPaging(
    client,
    query,
    org,
    (r) => {
      var _a, _b;
      return (_b = (_a = r.organization) == null ? void 0 : _a.team) == null ? void 0 : _b.members;
    },
    async (user) => user,
    { org, teamSlug }
  );
  return { members };
}
async function queryWithPaging(client, query, org, connection, transformer, variables) {
  const result = [];
  const sleep = (ms) => new Promise((r) => setTimeout(r, ms));
  let cursor = void 0;
  for (let j = 0; j < 1e3; ++j) {
    const response = await client(query, {
      ...variables,
      cursor
    });
    const conn = connection(response);
    if (!conn) {
      throw new Error(`Found no match for ${JSON.stringify(variables)}`);
    }
    for (const node of conn.nodes) {
      const transformedNode = await transformer(node, {
        client,
        query,
        org
      });
      if (transformedNode) {
        result.push(transformedNode);
      }
    }
    if (!conn.pageInfo.hasNextPage) {
      break;
    } else {
      await sleep(1e3);
      cursor = conn.pageInfo.endCursor;
    }
  }
  return result;
}
const createAddEntitiesOperation = (id, host) => (org, entities) => ({
  removed: [],
  added: entities.map((entity) => ({
    locationKey: `github-org-provider:${id}`,
    entity: withLocations(`https://${host}`, org, entity)
  }))
});
const createRemoveEntitiesOperation = (id, host) => (org, entities) => ({
  added: [],
  removed: entities.map((entity) => ({
    locationKey: `github-org-provider:${id}`,
    entity: withLocations(`https://${host}`, org, entity)
  }))
});
const createReplaceEntitiesOperation = (id, host) => (org, entities) => {
  const entitiesToReplace = entities.map((entity) => ({
    locationKey: `github-org-provider:${id}`,
    entity: withLocations(`https://${host}`, org, entity)
  }));
  return {
    removed: entitiesToReplace,
    added: entitiesToReplace
  };
};

const DEFAULT_CATALOG_PATH = "/catalog-info.yaml";
const DEFAULT_PROVIDER_ID = "default";
function readProviderConfigs(config) {
  const providersConfig = config.getOptionalConfig("catalog.providers.github");
  if (!providersConfig) {
    return [];
  }
  if (providersConfig.has("organization")) {
    return [readProviderConfig(DEFAULT_PROVIDER_ID, providersConfig)];
  }
  return providersConfig.keys().map((id) => {
    const providerConfig = providersConfig.getConfig(id);
    return readProviderConfig(id, providerConfig);
  });
}
function readProviderConfig(id, config) {
  var _a, _b, _c, _d;
  const organization = config.getString("organization");
  const catalogPath = (_a = config.getOptionalString("catalogPath")) != null ? _a : DEFAULT_CATALOG_PATH;
  const host = (_b = config.getOptionalString("host")) != null ? _b : "github.com";
  const repositoryPattern = config.getOptionalString("filters.repository");
  const branchPattern = config.getOptionalString("filters.branch");
  const allowForks = (_c = config.getOptionalBoolean("filters.allowForks")) != null ? _c : true;
  const topicFilterInclude = config == null ? void 0 : config.getOptionalStringArray(
    "filters.topic.include"
  );
  const topicFilterExclude = config == null ? void 0 : config.getOptionalStringArray(
    "filters.topic.exclude"
  );
  const validateLocationsExist = (_d = config == null ? void 0 : config.getOptionalBoolean("validateLocationsExist")) != null ? _d : false;
  const catalogPathContainsWildcard = catalogPath.includes("*");
  const visibilityFilterInclude = config == null ? void 0 : config.getOptionalStringArray("filters.visibility");
  if (validateLocationsExist && catalogPathContainsWildcard) {
    throw Error(
      `Error while processing GitHub provider config. The catalog path ${catalogPath} contains a wildcard, which is incompatible with validation of locations existing before emitting them. Ensure that validateLocationsExist is set to false.`
    );
  }
  const schedule = config.has("schedule") ? backendTasks.readTaskScheduleDefinitionFromConfig(config.getConfig("schedule")) : void 0;
  return {
    id,
    catalogPath,
    organization,
    host,
    filters: {
      repository: repositoryPattern ? compileRegExp(repositoryPattern) : void 0,
      branch: branchPattern || void 0,
      allowForks,
      topic: {
        include: topicFilterInclude,
        exclude: topicFilterExclude
      },
      visibility: visibilityFilterInclude
    },
    schedule,
    validateLocationsExist
  };
}
function compileRegExp(pattern) {
  let fullLinePattern = pattern;
  if (!fullLinePattern.startsWith("^")) {
    fullLinePattern = `^${fullLinePattern}`;
  }
  if (!fullLinePattern.endsWith("$")) {
    fullLinePattern = `${fullLinePattern}$`;
  }
  return new RegExp(fullLinePattern);
}

var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
const TOPIC_REPO_PUSH = "github.push";
class GithubEntityProvider {
  constructor(config, integration$1, logger, taskRunner) {
    __publicField(this, "config");
    __publicField(this, "logger");
    __publicField(this, "integration");
    __publicField(this, "scheduleFn");
    __publicField(this, "connection");
    __publicField(this, "githubCredentialsProvider");
    this.config = config;
    this.integration = integration$1.config;
    this.logger = logger.child({
      target: this.getProviderName()
    });
    this.scheduleFn = this.createScheduleFn(taskRunner);
    this.githubCredentialsProvider = integration.SingleInstanceGithubCredentialsProvider.create(integration$1.config);
  }
  static fromConfig(config, options) {
    if (!options.schedule && !options.scheduler) {
      throw new Error("Either schedule or scheduler must be provided.");
    }
    const integrations = integration.ScmIntegrations.fromConfig(config);
    return readProviderConfigs(config).map((providerConfig) => {
      var _a;
      const integrationHost = providerConfig.host;
      const integration = integrations.github.byHost(integrationHost);
      if (!integration) {
        throw new Error(
          `There is no GitHub config that matches host ${integrationHost}. Please add a configuration entry for it under integrations.github`
        );
      }
      if (!options.schedule && !providerConfig.schedule) {
        throw new Error(
          `No schedule provided neither via code nor config for github-provider:${providerConfig.id}.`
        );
      }
      const taskRunner = (_a = options.schedule) != null ? _a : options.scheduler.createScheduledTaskRunner(providerConfig.schedule);
      return new GithubEntityProvider(
        providerConfig,
        integration,
        options.logger,
        taskRunner
      );
    });
  }
  /** {@inheritdoc @backstage/plugin-catalog-backend#EntityProvider.getProviderName} */
  getProviderName() {
    return `github-provider:${this.config.id}`;
  }
  /** {@inheritdoc @backstage/plugin-catalog-backend#EntityProvider.connect} */
  async connect(connection) {
    this.connection = connection;
    return await this.scheduleFn();
  }
  createScheduleFn(taskRunner) {
    return async () => {
      const taskId = `${this.getProviderName()}:refresh`;
      return taskRunner.run({
        id: taskId,
        fn: async () => {
          const logger = this.logger.child({
            class: GithubEntityProvider.prototype.constructor.name,
            taskId,
            taskInstanceId: uuid__namespace.v4()
          });
          try {
            await this.refresh(logger);
          } catch (error) {
            logger.error(
              `${this.getProviderName()} refresh failed, ${error}`,
              error
            );
          }
        }
      });
    };
  }
  async refresh(logger) {
    if (!this.connection) {
      throw new Error("Not initialized");
    }
    const targets = await this.findCatalogFiles();
    const matchingTargets = this.matchesFilters(targets);
    const entities = matchingTargets.map((repository) => this.createLocationUrl(repository)).map(GithubEntityProvider.toLocationSpec).map((location) => {
      return {
        locationKey: this.getProviderName(),
        entity: pluginCatalogNode.locationSpecToLocationEntity({ location })
      };
    });
    await this.connection.applyMutation({
      type: "full",
      entities
    });
    logger.info(
      `Read ${targets.length} GitHub repositories (${entities.length} matching the pattern)`
    );
  }
  // go to the server and get all of the repositories
  async findCatalogFiles() {
    const organization = this.config.organization;
    const host = this.integration.host;
    const catalogPath = this.config.catalogPath;
    const orgUrl = `https://${host}/${organization}`;
    const { headers } = await this.githubCredentialsProvider.getCredentials({
      url: orgUrl
    });
    const client = graphql.graphql.defaults({
      baseUrl: this.integration.apiBaseUrl,
      headers
    });
    const { repositories: repositoriesFromGithub } = await getOrganizationRepositories(client, organization, catalogPath);
    const repositories = repositoriesFromGithub.map((r) => {
      var _a, _b;
      return {
        url: r.url,
        name: r.name,
        defaultBranchRef: (_a = r.defaultBranchRef) == null ? void 0 : _a.name,
        repositoryTopics: r.repositoryTopics.nodes.map((t) => t.topic.name),
        isArchived: r.isArchived,
        isFork: r.isFork,
        isCatalogInfoFilePresent: ((_b = r.catalogInfoFile) == null ? void 0 : _b.__typename) === "Blob" && r.catalogInfoFile.text !== "",
        visibility: r.visibility
      };
    });
    if (this.config.validateLocationsExist) {
      return repositories.filter(
        (repository) => repository.isCatalogInfoFilePresent
      );
    }
    return repositories;
  }
  matchesFilters(repositories) {
    var _a, _b, _c, _d, _e, _f;
    const repositoryFilter = (_a = this.config.filters) == null ? void 0 : _a.repository;
    const topicFilters = (_b = this.config.filters) == null ? void 0 : _b.topic;
    const allowForks = (_d = (_c = this.config.filters) == null ? void 0 : _c.allowForks) != null ? _d : true;
    const visibilities = (_f = (_e = this.config.filters) == null ? void 0 : _e.visibility) != null ? _f : [];
    const matchingRepositories = repositories.filter((r) => {
      const repoTopics = r.repositoryTopics;
      return !r.isArchived && (!repositoryFilter || repositoryFilter.test(r.name)) && satisfiesTopicFilter(repoTopics, topicFilters) && satisfiesForkFilter(allowForks, r.isFork) && satisfiesVisibilityFilter(visibilities, r.visibility) && r.defaultBranchRef;
    });
    return matchingRepositories;
  }
  createLocationUrl(repository) {
    var _a;
    const branch = ((_a = this.config.filters) == null ? void 0 : _a.branch) || repository.defaultBranchRef || "-";
    const catalogFile = this.config.catalogPath.startsWith("/") ? this.config.catalogPath.substring(1) : this.config.catalogPath;
    return `${repository.url}/blob/${branch}/${catalogFile}`;
  }
  static toLocationSpec(target) {
    return {
      type: "url",
      target,
      presence: "optional"
    };
  }
  /** {@inheritdoc @backstage/plugin-events-node#EventSubscriber.onEvent} */
  async onEvent(params) {
    this.logger.debug(`Received event from ${params.topic}`);
    if (params.topic !== TOPIC_REPO_PUSH) {
      return;
    }
    await this.onRepoPush(params.eventPayload);
  }
  /** {@inheritdoc @backstage/plugin-events-node#EventSubscriber.supportsEventTopics} */
  supportsEventTopics() {
    return [TOPIC_REPO_PUSH];
  }
  async onRepoPush(event) {
    var _a;
    if (!this.connection) {
      throw new Error("Not initialized");
    }
    if (this.config.organization !== event.repository.organization) {
      this.logger.debug(
        `skipping push event from organization ${event.repository.organization}`
      );
      return;
    }
    const repoName = event.repository.name;
    const repoUrl = event.repository.url;
    this.logger.debug(`handle github:push event for ${repoName} - ${repoUrl}`);
    const branch = ((_a = this.config.filters) == null ? void 0 : _a.branch) || event.repository.default_branch;
    if (!event.ref.includes(branch)) {
      this.logger.debug(`skipping push event from ref ${event.ref}`);
      return;
    }
    const repository = {
      url: event.repository.url,
      name: event.repository.name,
      defaultBranchRef: event.repository.default_branch,
      repositoryTopics: event.repository.topics,
      isArchived: event.repository.archived,
      isFork: event.repository.fork,
      // we can consider this file present because
      // only the catalog file will be recovered from the commits
      isCatalogInfoFilePresent: true,
      visibility: event.repository.visibility
    };
    const matchingTargets = this.matchesFilters([repository]);
    if (matchingTargets.length === 0) {
      this.logger.debug(
        `skipping push event from repository ${repoName} because didn't match provider filters`
      );
      return;
    }
    const added = this.collectDeferredEntitiesFromCommit(
      event.repository.url,
      branch,
      event.commits,
      (commit) => [...commit.added]
    );
    const removed = this.collectDeferredEntitiesFromCommit(
      event.repository.url,
      branch,
      event.commits,
      (commit) => [...commit.removed]
    );
    const modified = this.collectFilesFromCommit(
      event.commits,
      (commit) => [...commit.modified]
    );
    if (modified.length > 0) {
      await this.connection.refresh({
        keys: [
          ...modified.map(
            (filePath) => `url:${event.repository.url}/tree/${branch}/${filePath}`
          ),
          ...modified.map(
            (filePath) => `url:${event.repository.url}/blob/${branch}/${filePath}`
          )
        ]
      });
    }
    if (added.length > 0 || removed.length > 0) {
      await this.connection.applyMutation({
        type: "delta",
        added,
        removed
      });
    }
    this.logger.info(
      `Processed Github push event: added ${added.length} - removed ${removed.length} - modified ${modified.length}`
    );
  }
  collectDeferredEntitiesFromCommit(repositoryUrl, branch, commits, transformOperation) {
    const catalogFiles = this.collectFilesFromCommit(
      commits,
      transformOperation
    );
    return this.toDeferredEntities(
      catalogFiles.map(
        (filePath) => `${repositoryUrl}/blob/${branch}/${filePath}`
      )
    );
  }
  collectFilesFromCommit(commits, transformOperation) {
    const catalogFile = this.config.catalogPath.startsWith("/") ? this.config.catalogPath.substring(1) : this.config.catalogPath;
    const matcher = new minimatch.Minimatch(catalogFile);
    return commits.map(transformOperation).flat().filter((file) => matcher.match(file));
  }
  toDeferredEntities(targets) {
    return targets.map((target) => {
      const location = GithubEntityProvider.toLocationSpec(target);
      return pluginCatalogNode.locationSpecToLocationEntity({ location });
    }).map((entity) => {
      return {
        locationKey: this.getProviderName(),
        entity
      };
    });
  }
}

exports.ANNOTATION_GITHUB_TEAM_SLUG = ANNOTATION_GITHUB_TEAM_SLUG;
exports.ANNOTATION_GITHUB_USER_LOGIN = ANNOTATION_GITHUB_USER_LOGIN;
exports.GithubEntityProvider = GithubEntityProvider;
exports.createAddEntitiesOperation = createAddEntitiesOperation;
exports.createRemoveEntitiesOperation = createRemoveEntitiesOperation;
exports.createReplaceEntitiesOperation = createReplaceEntitiesOperation;
exports.defaultOrganizationTeamTransformer = defaultOrganizationTeamTransformer;
exports.defaultUserTransformer = defaultUserTransformer;
exports.getOrganizationRepositories = getOrganizationRepositories;
exports.getOrganizationTeam = getOrganizationTeam;
exports.getOrganizationTeams = getOrganizationTeams;
exports.getOrganizationTeamsFromUsers = getOrganizationTeamsFromUsers;
exports.getOrganizationUsers = getOrganizationUsers;
exports.getOrganizationsFromUser = getOrganizationsFromUser;
exports.parseGithubOrgUrl = parseGithubOrgUrl;
exports.splitTeamSlug = splitTeamSlug;
exports.withLocations = withLocations;
//# sourceMappingURL=GithubEntityProvider-858e0576.cjs.js.map
