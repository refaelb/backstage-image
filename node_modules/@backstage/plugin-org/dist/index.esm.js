import { createExternalRouteRef, createPlugin, createComponentExtension, useApi, useApp, alertApiRef, useRouteRef, identityApiRef } from '@backstage/core-plugin-api';
import { stringifyEntityRef, DEFAULT_NAMESPACE, RELATION_PARENT_OF, RELATION_CHILD_OF, ANNOTATION_LOCATION, ANNOTATION_EDIT_URL, RELATION_MEMBER_OF, parseEntityRef, getCompoundEntityRef } from '@backstage/catalog-model';
import { getEntityRelations, useEntity, catalogApiRef, EntityRefLink, EntityRefLinks, humanizeEntityRef, entityRouteRef } from '@backstage/plugin-catalog-react';
import { makeStyles, createStyles, Box, Typography, Grid, Switch, Divider, ListItem, ListItemIcon, ListItemText, IconButton, List, Tooltip, ListItemSecondaryAction } from '@material-ui/core';
import Pagination from '@material-ui/lab/Pagination';
import React, { useState, useCallback, useEffect } from 'react';
import useAsync from 'react-use/lib/useAsync';
import { Progress, ResponseErrorPanel, InfoCard, Avatar, Link, OverflowTooltip, SidebarItem, SidebarSubmenu, SidebarSubmenuItem } from '@backstage/core-components';
import AccountTreeIcon from '@material-ui/icons/AccountTree';
import Alert from '@material-ui/lab/Alert';
import CachedIcon from '@material-ui/icons/Cached';
import EditIcon from '@material-ui/icons/Edit';
import EmailIcon from '@material-ui/icons/Email';
import GroupIcon from '@material-ui/icons/Group';
import LanguageIcon from '@material-ui/icons/Language';
import { useEntityPermission } from '@backstage/plugin-catalog-react/alpha';
import { catalogEntityRefreshPermission } from '@backstage/plugin-catalog-common/alpha';
import PersonIcon from '@material-ui/icons/Person';
import pluralize from 'pluralize';
import limiterFactory from 'p-limit';
import qs from 'qs';
import { uniq } from 'lodash';

const catalogIndexRouteRef = createExternalRouteRef({
  id: "catalog-index"
});

const orgPlugin = createPlugin({
  id: "org",
  externalRoutes: {
    catalogIndex: catalogIndexRouteRef
  }
});
const EntityGroupProfileCard = orgPlugin.provide(
  createComponentExtension({
    name: "EntityGroupProfileCard",
    component: {
      lazy: () => import('./esm/index-9172d7e6.esm.js').then((m) => m.GroupProfileCard)
    }
  })
);
const EntityMembersListCard = orgPlugin.provide(
  createComponentExtension({
    name: "EntityMembersListCard",
    component: {
      lazy: () => import('./esm/index-9172d7e6.esm.js').then((m) => m.MembersListCard)
    }
  })
);
const EntityOwnershipCard = orgPlugin.provide(
  createComponentExtension({
    name: "EntityOwnershipCard",
    component: {
      lazy: () => import('./esm/index-9172d7e6.esm.js').then((m) => m.OwnershipCard)
    }
  })
);
const EntityUserProfileCard = orgPlugin.provide(
  createComponentExtension({
    name: "EntityUserProfileCard",
    component: {
      lazy: () => import('./esm/index-9172d7e6.esm.js').then((m) => m.UserProfileCard)
    }
  })
);

const getMembersFromGroups = async (groups, catalogApi) => {
  const membersList = groups.length === 0 ? { items: [] } : await catalogApi.getEntities({
    filter: {
      kind: "User",
      "relations.memberof": groups.map(
        (group) => stringifyEntityRef({
          kind: "group",
          namespace: group.namespace.toLocaleLowerCase("en-US"),
          name: group.name.toLocaleLowerCase("en-US")
        })
      )
    }
  });
  return membersList.items;
};
const getDescendantGroupsFromGroup = async (group, catalogApi) => {
  var _a;
  const alreadyQueuedOrExpandedGroupNames = /* @__PURE__ */ new Map();
  const groupRef = {
    kind: group.kind,
    namespace: (_a = group.metadata.namespace) != null ? _a : DEFAULT_NAMESPACE,
    name: group.metadata.name
  };
  const groupQueue = [groupRef];
  const resultantGroupRefs = [];
  while (groupQueue.length > 0) {
    const activeGroupRef = groupQueue.shift();
    const activeGroup = await catalogApi.getEntityByRef(activeGroupRef);
    alreadyQueuedOrExpandedGroupNames.set(
      stringifyEntityRef(activeGroupRef),
      true
    );
    const childGroups = getEntityRelations(activeGroup, RELATION_PARENT_OF, {
      kind: "Group"
    }).filter(
      (currentGroup) => !alreadyQueuedOrExpandedGroupNames.has(
        stringifyEntityRef(currentGroup)
      )
    );
    childGroups.forEach(
      (childGroup) => alreadyQueuedOrExpandedGroupNames.set(
        stringifyEntityRef(childGroup),
        true
      )
    );
    groupQueue.push(...childGroups);
    resultantGroupRefs.push(...childGroups);
  }
  return resultantGroupRefs;
};
const getAllDesendantMembersForGroupEntity = async (groupEntity, catalogApi) => getMembersFromGroups(
  await getDescendantGroupsFromGroup(groupEntity, catalogApi),
  catalogApi
);
const removeDuplicateEntitiesFrom = (entityArray) => {
  const seenEntities = /* @__PURE__ */ new Map();
  return entityArray.filter((entity) => {
    const stringifiedEntity = stringifyEntityRef(entity);
    const isDuplicate = seenEntities.has(stringifiedEntity);
    seenEntities.set(stringifiedEntity, true);
    return !isDuplicate;
  });
};

const useStyles$2 = makeStyles(
  (theme) => createStyles({
    card: {
      border: `1px solid ${theme.palette.divider}`,
      boxShadow: theme.shadows[2],
      borderRadius: "4px",
      overflow: "visible",
      position: "relative",
      margin: theme.spacing(4, 1, 1),
      flex: "1",
      minWidth: "0px"
    }
  })
);
const MemberComponent = (props) => {
  var _a;
  const classes = useStyles$2();
  const {
    metadata: { name: metaName, description },
    spec: { profile }
  } = props.member;
  const displayName = (_a = profile == null ? void 0 : profile.displayName) != null ? _a : metaName;
  return /* @__PURE__ */ React.createElement(Box, { className: classes.card }, /* @__PURE__ */ React.createElement(
    Box,
    {
      display: "flex",
      flexDirection: "column",
      m: 3,
      alignItems: "center",
      justifyContent: "center"
    },
    /* @__PURE__ */ React.createElement(
      Avatar,
      {
        displayName,
        picture: profile == null ? void 0 : profile.picture,
        customStyles: {
          position: "absolute",
          top: "-2rem"
        }
      }
    ),
    /* @__PURE__ */ React.createElement(
      Box,
      {
        pt: 2,
        sx: {
          width: "100%"
        },
        textAlign: "center"
      },
      /* @__PURE__ */ React.createElement(Typography, { variant: "h6" }, /* @__PURE__ */ React.createElement(
        EntityRefLink,
        {
          "data-testid": "user-link",
          entityRef: props.member,
          title: displayName
        }
      )),
      (profile == null ? void 0 : profile.email) && /* @__PURE__ */ React.createElement(Link, { to: `mailto:${profile.email}` }, /* @__PURE__ */ React.createElement(OverflowTooltip, { text: profile.email })),
      description && /* @__PURE__ */ React.createElement(Typography, { variant: "subtitle2" }, description)
    )
  ));
};
const useListStyles = makeStyles((theme) => ({
  root: {
    height: "100%"
  },
  cardContent: {
    overflow: "auto"
  },
  memberList: {
    display: "grid",
    gap: theme.spacing(1.5),
    gridTemplateColumns: `repeat(auto-fit, minmax(auto, ${theme.spacing(
      34
    )}px))`
  }
}));
const MembersListCard = (props) => {
  var _a;
  const {
    memberDisplayTitle = "Members",
    pageSize = 50,
    showAggregateMembersToggle
  } = props;
  const classes = useListStyles();
  const { entity: groupEntity } = useEntity();
  const {
    metadata: { name: groupName, namespace: grpNamespace },
    spec: { profile }
  } = groupEntity;
  const catalogApi = useApi(catalogApiRef);
  const displayName = (_a = profile == null ? void 0 : profile.displayName) != null ? _a : groupName;
  const groupNamespace = grpNamespace || DEFAULT_NAMESPACE;
  const [page, setPage] = React.useState(1);
  const pageChange = (_, pageIndex) => {
    setPage(pageIndex);
  };
  const [showAggregateMembers, setShowAggregateMembers] = useState(false);
  const { loading: loadingDescendantMembers, value: descendantMembers } = useAsync(async () => {
    if (!showAggregateMembersToggle) {
      return [];
    }
    return await getAllDesendantMembersForGroupEntity(
      groupEntity,
      catalogApi
    );
  }, [catalogApi, groupEntity, showAggregateMembersToggle]);
  const {
    loading,
    error,
    value: directMembers
  } = useAsync(async () => {
    const membersList = await catalogApi.getEntities({
      filter: {
        kind: "User",
        "relations.memberof": [
          stringifyEntityRef({
            kind: "group",
            namespace: groupNamespace.toLocaleLowerCase("en-US"),
            name: groupName.toLocaleLowerCase("en-US")
          })
        ]
      }
    });
    return membersList.items;
  }, [catalogApi, groupEntity]);
  const members = removeDuplicateEntitiesFrom(
    [
      ...directMembers != null ? directMembers : [],
      ...descendantMembers && showAggregateMembers ? descendantMembers : []
    ].sort(
      (a, b) => stringifyEntityRef(a).localeCompare(stringifyEntityRef(b))
    )
  );
  if (loading) {
    return /* @__PURE__ */ React.createElement(Progress, null);
  } else if (error) {
    return /* @__PURE__ */ React.createElement(ResponseErrorPanel, { error });
  }
  const nbPages = Math.ceil(((members == null ? void 0 : members.length) || 0) / pageSize);
  const paginationLabel = nbPages < 2 ? "" : `, page ${page} of ${nbPages}`;
  const pagination = /* @__PURE__ */ React.createElement(
    Pagination,
    {
      count: nbPages,
      page,
      onChange: pageChange,
      showFirstButton: true,
      showLastButton: true
    }
  );
  let memberList;
  if (members && members.length > 0) {
    memberList = /* @__PURE__ */ React.createElement(Box, { className: classes.memberList }, members.slice(pageSize * (page - 1), pageSize * page).map((member) => /* @__PURE__ */ React.createElement(MemberComponent, { member, key: member.metadata.uid })));
  } else {
    memberList = /* @__PURE__ */ React.createElement(Box, { p: 2 }, /* @__PURE__ */ React.createElement(Typography, null, "This group has no ", memberDisplayTitle.toLocaleLowerCase(), "."));
  }
  return /* @__PURE__ */ React.createElement(Grid, { item: true, className: classes.root }, /* @__PURE__ */ React.createElement(
    InfoCard,
    {
      title: `${memberDisplayTitle} (${(members == null ? void 0 : members.length) || 0}${paginationLabel})`,
      subheader: `of ${displayName}`,
      ...nbPages <= 1 ? {} : { actions: pagination },
      className: classes.root,
      cardClassName: classes.cardContent
    },
    showAggregateMembersToggle && /* @__PURE__ */ React.createElement(React.Fragment, null, "Direct Members", /* @__PURE__ */ React.createElement(
      Switch,
      {
        color: "primary",
        checked: showAggregateMembers,
        onChange: () => {
          setShowAggregateMembers(!showAggregateMembers);
        },
        inputProps: { "aria-label": "Users Type Switch" }
      }
    ), "Aggregated Members"),
    showAggregateMembers && loadingDescendantMembers ? /* @__PURE__ */ React.createElement(Progress, null) : memberList
  ));
};

const WebLink = ({
  href,
  Icon,
  text
}) => /* @__PURE__ */ React.createElement(ListItem, { key: href }, /* @__PURE__ */ React.createElement(ListItemIcon, null, Icon ? /* @__PURE__ */ React.createElement(Icon, null) : /* @__PURE__ */ React.createElement(LanguageIcon, null)), /* @__PURE__ */ React.createElement(ListItemText, null, /* @__PURE__ */ React.createElement(Link, { to: href }, text)));
const LinksGroup = ({ links }) => {
  const app = useApp();
  const iconResolver = (key) => {
    var _a;
    return key ? (_a = app.getSystemIcon(key)) != null ? _a : LanguageIcon : LanguageIcon;
  };
  if (links === void 0) {
    return null;
  }
  return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(Divider, null), links.map((link) => {
    return /* @__PURE__ */ React.createElement(
      WebLink,
      {
        key: link.url,
        href: link.url,
        text: link.title,
        Icon: iconResolver(link.icon)
      }
    );
  }));
};

const CardTitle$1 = (props) => /* @__PURE__ */ React.createElement(Box, { display: "flex", alignItems: "center" }, /* @__PURE__ */ React.createElement(GroupIcon, { fontSize: "inherit" }), /* @__PURE__ */ React.createElement(Box, { ml: 1 }, props.title));
const GroupProfileCard = (props) => {
  var _a, _b, _c;
  const catalogApi = useApi(catalogApiRef);
  const alertApi = useApi(alertApiRef);
  const { entity: group } = useEntity();
  const { allowed: canRefresh } = useEntityPermission(
    catalogEntityRefreshPermission
  );
  const refreshEntity = useCallback(async () => {
    await catalogApi.refreshEntity(stringifyEntityRef(group));
    alertApi.post({
      message: "Refresh scheduled",
      severity: "info",
      display: "transient"
    });
  }, [catalogApi, alertApi, group]);
  if (!group) {
    return /* @__PURE__ */ React.createElement(Alert, { severity: "error" }, "Group not found");
  }
  const {
    metadata: { name, description, title, annotations, links },
    spec: { profile }
  } = group;
  const childRelations = getEntityRelations(group, RELATION_PARENT_OF, {
    kind: "Group"
  });
  const parentRelations = getEntityRelations(group, RELATION_CHILD_OF, {
    kind: "group"
  });
  const entityLocation = annotations == null ? void 0 : annotations[ANNOTATION_LOCATION];
  const allowRefresh = (entityLocation == null ? void 0 : entityLocation.startsWith("url:")) || (entityLocation == null ? void 0 : entityLocation.startsWith("file:"));
  const entityMetadataEditUrl = (_a = group.metadata.annotations) == null ? void 0 : _a[ANNOTATION_EDIT_URL];
  const displayName = (_c = (_b = profile == null ? void 0 : profile.displayName) != null ? _b : title) != null ? _c : name;
  const emailHref = (profile == null ? void 0 : profile.email) ? `mailto:${profile.email}` : "#";
  const infoCardAction = entityMetadataEditUrl ? /* @__PURE__ */ React.createElement(
    IconButton,
    {
      "aria-label": "Edit",
      title: "Edit Metadata",
      component: Link,
      to: entityMetadataEditUrl
    },
    /* @__PURE__ */ React.createElement(EditIcon, null)
  ) : /* @__PURE__ */ React.createElement(IconButton, { "aria-label": "Edit", disabled: true, title: "Edit Metadata" }, /* @__PURE__ */ React.createElement(EditIcon, null));
  return /* @__PURE__ */ React.createElement(
    InfoCard,
    {
      title: /* @__PURE__ */ React.createElement(CardTitle$1, { title: displayName }),
      subheader: description,
      variant: props.variant,
      action: /* @__PURE__ */ React.createElement(React.Fragment, null, allowRefresh && canRefresh && /* @__PURE__ */ React.createElement(
        IconButton,
        {
          "aria-label": "Refresh",
          title: "Schedule entity refresh",
          onClick: refreshEntity
        },
        /* @__PURE__ */ React.createElement(CachedIcon, null)
      ), infoCardAction)
    },
    /* @__PURE__ */ React.createElement(Grid, { container: true, spacing: 3 }, /* @__PURE__ */ React.createElement(Grid, { item: true, xs: 12, sm: 2, xl: 1 }, /* @__PURE__ */ React.createElement(Avatar, { displayName, picture: profile == null ? void 0 : profile.picture })), /* @__PURE__ */ React.createElement(Grid, { item: true, md: 10, xl: 11 }, /* @__PURE__ */ React.createElement(List, null, (profile == null ? void 0 : profile.email) && /* @__PURE__ */ React.createElement(ListItem, null, /* @__PURE__ */ React.createElement(ListItemIcon, null, /* @__PURE__ */ React.createElement(Tooltip, { title: "Email" }, /* @__PURE__ */ React.createElement(EmailIcon, null))), /* @__PURE__ */ React.createElement(
      ListItemText,
      {
        primary: /* @__PURE__ */ React.createElement(Link, { to: emailHref }, profile.email),
        secondary: "Email"
      }
    )), /* @__PURE__ */ React.createElement(ListItem, null, /* @__PURE__ */ React.createElement(ListItemIcon, null, /* @__PURE__ */ React.createElement(Tooltip, { title: "Parent Group" }, /* @__PURE__ */ React.createElement(AccountTreeIcon, null))), /* @__PURE__ */ React.createElement(
      ListItemText,
      {
        primary: parentRelations.length ? /* @__PURE__ */ React.createElement(
          EntityRefLinks,
          {
            entityRefs: parentRelations,
            defaultKind: "Group"
          }
        ) : "N/A",
        secondary: "Parent Group"
      }
    )), /* @__PURE__ */ React.createElement(ListItem, null, /* @__PURE__ */ React.createElement(ListItemIcon, null, /* @__PURE__ */ React.createElement(Tooltip, { title: "Child Groups" }, /* @__PURE__ */ React.createElement(GroupIcon, null))), /* @__PURE__ */ React.createElement(
      ListItemText,
      {
        primary: childRelations.length ? /* @__PURE__ */ React.createElement(
          EntityRefLinks,
          {
            entityRefs: childRelations,
            defaultKind: "Group"
          }
        ) : "N/A",
        secondary: "Child Groups"
      }
    )), (props == null ? void 0 : props.showLinks) && /* @__PURE__ */ React.createElement(LinksGroup, { links }))))
  );
};

const CardTitle = (props) => props.title ? /* @__PURE__ */ React.createElement(Box, { display: "flex", alignItems: "center" }, /* @__PURE__ */ React.createElement(PersonIcon, { fontSize: "inherit" }), /* @__PURE__ */ React.createElement(Box, { ml: 1 }, props.title)) : null;
const UserProfileCard = (props) => {
  var _a, _b;
  const { entity: user } = useEntity();
  if (!user) {
    return /* @__PURE__ */ React.createElement(Alert, { severity: "error" }, "User not found");
  }
  const entityMetadataEditUrl = (_a = user.metadata.annotations) == null ? void 0 : _a[ANNOTATION_EDIT_URL];
  const {
    metadata: { name: metaName, description, links },
    spec: { profile }
  } = user;
  const displayName = (_b = profile == null ? void 0 : profile.displayName) != null ? _b : metaName;
  const emailHref = (profile == null ? void 0 : profile.email) ? `mailto:${profile.email}` : void 0;
  const memberOfRelations = getEntityRelations(user, RELATION_MEMBER_OF, {
    kind: "Group"
  });
  return /* @__PURE__ */ React.createElement(
    InfoCard,
    {
      title: /* @__PURE__ */ React.createElement(CardTitle, { title: displayName }),
      subheader: description,
      variant: props.variant,
      action: /* @__PURE__ */ React.createElement(React.Fragment, null, entityMetadataEditUrl && /* @__PURE__ */ React.createElement(
        IconButton,
        {
          "aria-label": "Edit",
          title: "Edit Metadata",
          component: Link,
          to: entityMetadataEditUrl
        },
        /* @__PURE__ */ React.createElement(EditIcon, null)
      ))
    },
    /* @__PURE__ */ React.createElement(Grid, { container: true, spacing: 3, alignItems: "flex-start" }, /* @__PURE__ */ React.createElement(Grid, { item: true, xs: 12, sm: 2, xl: 1 }, /* @__PURE__ */ React.createElement(Avatar, { displayName, picture: profile == null ? void 0 : profile.picture })), /* @__PURE__ */ React.createElement(Grid, { item: true, md: 10, xl: 11 }, /* @__PURE__ */ React.createElement(List, null, (profile == null ? void 0 : profile.email) && /* @__PURE__ */ React.createElement(ListItem, null, /* @__PURE__ */ React.createElement(ListItemIcon, null, /* @__PURE__ */ React.createElement(Tooltip, { title: "Email" }, /* @__PURE__ */ React.createElement(EmailIcon, null))), /* @__PURE__ */ React.createElement(ListItemText, null, /* @__PURE__ */ React.createElement(Link, { to: emailHref != null ? emailHref : "" }, profile.email))), /* @__PURE__ */ React.createElement(ListItem, null, /* @__PURE__ */ React.createElement(ListItemIcon, null, /* @__PURE__ */ React.createElement(Tooltip, { title: "Member of" }, /* @__PURE__ */ React.createElement(GroupIcon, null))), /* @__PURE__ */ React.createElement(ListItemText, null, /* @__PURE__ */ React.createElement(
      EntityRefLinks,
      {
        entityRefs: memberOfRelations,
        defaultKind: "Group"
      }
    ))), (props == null ? void 0 : props.showLinks) && /* @__PURE__ */ React.createElement(LinksGroup, { links }))))
  );
};

const limiter = limiterFactory(10);
const getQueryParams = (ownersEntityRef, selectedEntity) => {
  const { kind, type } = selectedEntity;
  const owners = ownersEntityRef.map(
    (owner) => humanizeEntityRef(parseEntityRef(owner), { defaultKind: "group" })
  );
  const filters = {
    kind: kind.toLocaleLowerCase("en-US"),
    type,
    owners,
    user: "all"
  };
  return qs.stringify({ filters }, { arrayFormat: "repeat" });
};
const getMemberOfEntityRefs = (owner) => {
  const parentGroups = getEntityRelations(owner, RELATION_MEMBER_OF, {
    kind: "Group"
  });
  const ownerGroupsNames = parentGroups.map(
    ({ kind, namespace, name }) => stringifyEntityRef({
      kind,
      namespace,
      name
    })
  );
  return [...ownerGroupsNames, stringifyEntityRef(owner)];
};
const isEntity = (entity) => entity !== void 0;
const getChildOwnershipEntityRefs = async (entity, catalogApi, alreadyRetrievedParentRefs = []) => {
  const childGroups = getEntityRelations(entity, RELATION_PARENT_OF, {
    kind: "Group"
  });
  const hasChildGroups = childGroups.length > 0;
  const entityRef = stringifyEntityRef(entity);
  if (hasChildGroups) {
    const entityRefs = childGroups.map((r) => stringifyEntityRef(r));
    const childGroupResponse = await catalogApi.getEntitiesByRefs({
      fields: ["kind", "metadata.namespace", "metadata.name", "relations"],
      entityRefs
    });
    const childGroupEntities = childGroupResponse.items.filter(isEntity);
    const unknownChildren = childGroupEntities.filter(
      (childGroupEntity) => !alreadyRetrievedParentRefs.includes(
        stringifyEntityRef(childGroupEntity)
      )
    );
    const childrenRefs = (await Promise.all(
      unknownChildren.map(
        (childGroupEntity) => limiter(
          () => getChildOwnershipEntityRefs(childGroupEntity, catalogApi, [
            ...alreadyRetrievedParentRefs,
            entityRef
          ])
        )
      )
    )).flatMap((aggregated) => aggregated);
    return uniq([...childrenRefs, entityRef]);
  }
  return [entityRef];
};
const getOwners = async (entity, relations, catalogApi) => {
  const isGroup = entity.kind === "Group";
  const isAggregated = relations === "aggregated";
  const isUserEntity = entity.kind === "User";
  if (isAggregated && isGroup) {
    return getChildOwnershipEntityRefs(entity, catalogApi);
  }
  if (isAggregated && isUserEntity) {
    return getMemberOfEntityRefs(entity);
  }
  return [stringifyEntityRef(entity)];
};
const getOwnedEntitiesByOwners = (owners, kinds, catalogApi) => catalogApi.getEntities({
  filter: [
    {
      kind: kinds,
      "relations.ownedBy": owners
    }
  ],
  fields: [
    "kind",
    "metadata.name",
    "metadata.namespace",
    "spec.type",
    "relations"
  ]
});
function useGetEntities(entity, relations, entityFilterKind, entityLimit = 6) {
  const catalogApi = useApi(catalogApiRef);
  const kinds = entityFilterKind != null ? entityFilterKind : ["Component", "API", "System"];
  const {
    loading,
    error,
    value: componentsWithCounters
  } = useAsync(async () => {
    const owners = await getOwners(entity, relations, catalogApi);
    const ownedEntitiesList = await getOwnedEntitiesByOwners(
      owners,
      kinds,
      catalogApi
    );
    const counts = ownedEntitiesList.items.reduce(
      (acc, ownedEntity) => {
        var _a, _b;
        const match = acc.find(
          (x) => {
            var _a2;
            return x.kind === ownedEntity.kind && x.type === ((_a2 = ownedEntity.spec) == null ? void 0 : _a2.type);
          }
        );
        if (match) {
          match.count += 1;
        } else {
          acc.push({
            kind: ownedEntity.kind,
            type: (_b = (_a = ownedEntity.spec) == null ? void 0 : _a.type) == null ? void 0 : _b.toString(),
            count: 1
          });
        }
        return acc;
      },
      []
    );
    const topN = counts.sort((a, b) => b.count - a.count).slice(0, entityLimit);
    return topN.map((topOwnedEntity) => ({
      counter: topOwnedEntity.count,
      type: topOwnedEntity.type,
      kind: topOwnedEntity.kind,
      queryParams: getQueryParams(owners, topOwnedEntity)
    }));
  }, [catalogApi, entity, relations]);
  return {
    componentsWithCounters,
    loading,
    error
  };
}

const useStyles$1 = makeStyles(
  (theme) => createStyles({
    card: {
      border: `1px solid ${theme.palette.divider}`,
      boxShadow: theme.shadows[2],
      borderRadius: "4px",
      padding: theme.spacing(2),
      transition: `${theme.transitions.duration.standard}ms`,
      "&:hover": {
        boxShadow: theme.shadows[4]
      },
      height: "100%"
    },
    bold: {
      fontWeight: theme.typography.fontWeightBold
    },
    smallFont: {
      fontSize: theme.typography.body2.fontSize
    },
    entityTypeBox: {
      background: (props) => theme.getPageTheme({ themeId: props.type }).backgroundImage,
      color: (props) => theme.getPageTheme({ themeId: props.type }).fontColor
    }
  })
);
const EntityCountTile = ({
  counter,
  type,
  kind,
  url
}) => {
  const classes = useStyles$1({ type: type != null ? type : kind });
  const rawTitle = type != null ? type : kind;
  const isLongText = rawTitle.length > 10;
  return /* @__PURE__ */ React.createElement(Link, { to: url, variant: "body2" }, /* @__PURE__ */ React.createElement(
    Box,
    {
      className: `${classes.card} ${classes.entityTypeBox}`,
      display: "flex",
      flexDirection: "column",
      alignItems: "center"
    },
    /* @__PURE__ */ React.createElement(Typography, { className: classes.bold, variant: "h6" }, counter),
    /* @__PURE__ */ React.createElement(Box, { sx: { width: "100%", textAlign: "center" } }, /* @__PURE__ */ React.createElement(
      Typography,
      {
        className: `${classes.bold} ${isLongText && classes.smallFont}`,
        variant: "h6"
      },
      /* @__PURE__ */ React.createElement(
        OverflowTooltip,
        {
          text: pluralize(rawTitle.toLocaleUpperCase("en-US"), counter)
        }
      )
    )),
    type && /* @__PURE__ */ React.createElement(Typography, { variant: "subtitle1" }, kind)
  ));
};
const ComponentsGrid = ({
  entity,
  relationsType,
  entityFilterKind,
  entityLimit = 6
}) => {
  const catalogLink = useRouteRef(catalogIndexRouteRef);
  const { componentsWithCounters, loading, error } = useGetEntities(
    entity,
    relationsType,
    entityFilterKind,
    entityLimit
  );
  if (loading) {
    return /* @__PURE__ */ React.createElement(Progress, null);
  } else if (error) {
    return /* @__PURE__ */ React.createElement(ResponseErrorPanel, { error });
  }
  return /* @__PURE__ */ React.createElement(Grid, { container: true }, componentsWithCounters == null ? void 0 : componentsWithCounters.map((c) => {
    var _a;
    return /* @__PURE__ */ React.createElement(Grid, { item: true, xs: 6, md: 6, lg: 4, key: (_a = c.type) != null ? _a : c.kind }, /* @__PURE__ */ React.createElement(
      EntityCountTile,
      {
        counter: c.counter,
        kind: c.kind,
        type: c.type,
        url: `${catalogLink()}/?${c.queryParams}`
      }
    ));
  }));
};

const useStyles = makeStyles((theme) => ({
  list: {
    [theme.breakpoints.down("xs")]: {
      padding: `0 0 12px`
    }
  },
  listItemText: {
    [theme.breakpoints.down("xs")]: {
      paddingRight: 0,
      paddingLeft: 0
    }
  },
  listItemSecondaryAction: {
    [theme.breakpoints.down("xs")]: {
      width: "100%",
      top: "auto",
      right: "auto",
      position: "relative",
      transform: "unset"
    }
  }
}));
const OwnershipCard = (props) => {
  const {
    variant,
    entityFilterKind,
    hideRelationsToggle,
    relationsType,
    entityLimit = 6
  } = props;
  const relationsToggle = hideRelationsToggle === void 0 ? false : hideRelationsToggle;
  const classes = useStyles();
  const { entity } = useEntity();
  const defaultRelationsType = entity.kind === "User" ? "aggregated" : "direct";
  const [getRelationsType, setRelationsType] = useState(
    relationsType != null ? relationsType : defaultRelationsType
  );
  useEffect(() => {
    if (!relationsType) {
      setRelationsType(defaultRelationsType);
    }
  }, [setRelationsType, defaultRelationsType, relationsType]);
  return /* @__PURE__ */ React.createElement(InfoCard, { title: "Ownership", variant }, !relationsToggle && /* @__PURE__ */ React.createElement(List, { dense: true }, /* @__PURE__ */ React.createElement(ListItem, { className: classes.list }, /* @__PURE__ */ React.createElement(ListItemText, { className: classes.listItemText }), /* @__PURE__ */ React.createElement(
    ListItemSecondaryAction,
    {
      className: classes.listItemSecondaryAction
    },
    "Direct Relations",
    /* @__PURE__ */ React.createElement(
      Tooltip,
      {
        placement: "top",
        arrow: true,
        title: `${getRelationsType === "direct" ? "Direct" : "Aggregated"} Relations`
      },
      /* @__PURE__ */ React.createElement(
        Switch,
        {
          color: "primary",
          checked: getRelationsType !== "direct",
          onChange: () => {
            const updatedRelationsType = getRelationsType === "direct" ? "aggregated" : "direct";
            setRelationsType(updatedRelationsType);
          },
          name: "pin",
          inputProps: { "aria-label": "Ownership Type Switch" }
        }
      )
    ),
    "Aggregated Relations"
  ))), /* @__PURE__ */ React.createElement(
    ComponentsGrid,
    {
      entity,
      entityLimit,
      relationsType: getRelationsType,
      entityFilterKind
    }
  ));
};

const MyGroupsSidebarItem = (props) => {
  const { singularTitle, pluralTitle, icon, filter } = props;
  const identityApi = useApi(identityApiRef);
  const catalogApi = useApi(catalogApiRef);
  const catalogEntityRoute = useRouteRef(entityRouteRef);
  const { value: groups } = useAsync(async () => {
    const profile = await identityApi.getBackstageIdentity();
    const response = await catalogApi.getEntities({
      filter: [
        {
          kind: "group",
          "relations.hasMember": profile.userEntityRef,
          ...filter != null ? filter : {}
        }
      ],
      fields: ["metadata", "kind"]
    });
    return response.items;
  }, []);
  if (!(groups == null ? void 0 : groups.length)) {
    return null;
  }
  if (groups.length === 1) {
    const group = groups[0];
    return /* @__PURE__ */ React.createElement(
      SidebarItem,
      {
        text: singularTitle,
        to: catalogEntityRoute(getCompoundEntityRef(group)),
        icon
      }
    );
  }
  return /* @__PURE__ */ React.createElement(SidebarItem, { icon, text: pluralTitle }, /* @__PURE__ */ React.createElement(SidebarSubmenu, { title: pluralTitle }, groups == null ? void 0 : groups.map(function groupsMap(group) {
    return /* @__PURE__ */ React.createElement(
      SidebarSubmenuItem,
      {
        title: group.metadata.title || group.metadata.name,
        subtitle: group.metadata.namespace !== DEFAULT_NAMESPACE ? group.metadata.namespace : void 0,
        to: catalogEntityRoute(getCompoundEntityRef(group)),
        icon,
        key: stringifyEntityRef(group)
      }
    );
  })));
};

export { EntityGroupProfileCard, EntityMembersListCard, EntityOwnershipCard, EntityUserProfileCard, GroupProfileCard, MembersListCard, MyGroupsSidebarItem, OwnershipCard, UserProfileCard, orgPlugin, orgPlugin as plugin };
//# sourceMappingURL=index.esm.js.map
