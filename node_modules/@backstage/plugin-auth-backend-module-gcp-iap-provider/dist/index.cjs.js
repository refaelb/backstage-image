'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var errors = require('@backstage/errors');
var pluginAuthNode = require('@backstage/plugin-auth-node');
var googleAuthLibrary = require('google-auth-library');
var backendPluginApi = require('@backstage/backend-plugin-api');

function createTokenValidator(audience, providedClient) {
  const client = providedClient != null ? providedClient : new googleAuthLibrary.OAuth2Client();
  return async function tokenValidator(token) {
    const response = await client.getIapPublicKeys().catch((error) => {
      throw new errors.AuthenticationError(
        `Unable to list Google IAP token verification keys, ${error}`
      );
    });
    const ticket = await client.verifySignedJwtWithCertsAsync(token, response.pubkeys, audience, [
      "https://cloud.google.com/iap"
    ]).catch((error) => {
      throw new errors.AuthenticationError(
        `Google IAP token verification failed, ${error}`
      );
    });
    const payload = ticket.getPayload();
    if (!payload) {
      throw new errors.AuthenticationError(
        "Google IAP token verification failed, token had no payload"
      );
    }
    if (!payload.sub) {
      throw new errors.AuthenticationError(
        "Google IAP token payload is missing subject claim"
      );
    }
    if (!payload.email) {
      throw new errors.AuthenticationError(
        "Google IAP token payload is missing email claim"
      );
    }
    return payload;
  };
}

const DEFAULT_IAP_JWT_HEADER = "x-goog-iap-jwt-assertion";
const gcpIapAuthenticator = pluginAuthNode.createProxyAuthenticator({
  defaultProfileTransform: async (result) => {
    return { profile: { email: result.iapToken.email } };
  },
  initialize({ config }) {
    var _a;
    const audience = config.getString("audience");
    const jwtHeader = (_a = config.getOptionalString("jwtHeader")) != null ? _a : DEFAULT_IAP_JWT_HEADER;
    const tokenValidator = createTokenValidator(audience);
    return { jwtHeader, tokenValidator };
  },
  async authenticate({ req }, { jwtHeader, tokenValidator }) {
    const token = req.header(jwtHeader);
    if (!token || typeof token !== "string") {
      throw new errors.AuthenticationError("Missing Google IAP header");
    }
    const iapToken = await tokenValidator(token);
    return { result: { iapToken } };
  }
});

exports.gcpIapSignInResolvers = void 0;
((gcpIapSignInResolvers2) => {
  gcpIapSignInResolvers2.emailMatchingUserEntityAnnotation = pluginAuthNode.createSignInResolverFactory({
    create() {
      return async (info, ctx) => {
        const email = info.result.iapToken.email;
        if (!email) {
          throw new Error("Google IAP sign-in result is missing email");
        }
        return ctx.signInWithCatalogUser({
          annotations: {
            "google.com/email": email
          }
        });
      };
    }
  });
})(exports.gcpIapSignInResolvers || (exports.gcpIapSignInResolvers = {}));

const authModuleGcpIapProvider = backendPluginApi.createBackendModule({
  pluginId: "auth",
  moduleId: "gcp-iap-provider",
  register(reg) {
    reg.registerInit({
      deps: {
        providers: pluginAuthNode.authProvidersExtensionPoint
      },
      async init({ providers }) {
        providers.registerProvider({
          providerId: "gcpIap",
          factory: pluginAuthNode.createProxyAuthProviderFactory({
            authenticator: gcpIapAuthenticator,
            signInResolverFactories: {
              ...exports.gcpIapSignInResolvers,
              ...pluginAuthNode.commonSignInResolvers
            }
          })
        });
      }
    });
  }
});

exports["default"] = authModuleGcpIapProvider;
exports.gcpIapAuthenticator = gcpIapAuthenticator;
//# sourceMappingURL=index.cjs.js.map
