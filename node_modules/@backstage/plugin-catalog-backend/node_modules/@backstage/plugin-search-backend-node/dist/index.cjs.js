'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var IndexBuilder = require('./cjs/IndexBuilder-5081eb72.cjs.js');
var ndjson = require('ndjson');
var errors = require('@backstage/errors');
var lunr = require('lunr');
var uuid = require('uuid');
var stream = require('stream');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var lunr__default = /*#__PURE__*/_interopDefaultLegacy(lunr);

var __defProp$5 = Object.defineProperty;
var __defNormalProp$5 = (obj, key, value) => key in obj ? __defProp$5(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$5 = (obj, key, value) => {
  __defNormalProp$5(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
class NewlineDelimitedJsonCollatorFactory {
  constructor(type, searchPattern, reader, logger, visibilityPermission) {
    this.searchPattern = searchPattern;
    this.reader = reader;
    this.logger = logger;
    __publicField$5(this, "type");
    __publicField$5(this, "visibilityPermission");
    this.type = type;
    this.visibilityPermission = visibilityPermission;
  }
  /**
   * Returns a NewlineDelimitedJsonCollatorFactory instance from configuration
   * and a set of options.
   */
  static fromConfig(_config, options) {
    return new NewlineDelimitedJsonCollatorFactory(
      options.type,
      options.searchPattern,
      options.reader,
      options.logger.child({ documentType: options.type }),
      options.visibilityPermission
    );
  }
  /**
   * Returns the "latest" URL for the given search pattern (e.g. the one at the
   * end of the list, sorted alphabetically).
   */
  async lastUrl() {
    var _a;
    try {
      this.logger.info(
        `Attempting to find latest .ndjson matching ${this.searchPattern}`
      );
      const { files } = await this.reader.search(this.searchPattern);
      const candidates = files.filter((file) => file.url.endsWith(".ndjson")).sort((a, b) => a.url.localeCompare(b.url)).reverse();
      return (_a = candidates[0]) == null ? void 0 : _a.url;
    } catch (e) {
      this.logger.error(`Could not search for ${this.searchPattern}`, e);
      throw e;
    }
  }
  async getCollator() {
    const lastUrl = await this.lastUrl();
    if (!lastUrl) {
      const noMatchingFile = `Could not find an .ndjson file matching ${this.searchPattern}`;
      this.logger.error(noMatchingFile);
      throw new Error(noMatchingFile);
    } else {
      this.logger.info(`Using latest .ndjson file ${lastUrl}`);
    }
    const readerResponse = await this.reader.readUrl(lastUrl);
    const stream = readerResponse.stream();
    return stream.pipe(ndjson.parse());
  }
}

var __defProp$4 = Object.defineProperty;
var __defNormalProp$4 = (obj, key, value) => key in obj ? __defProp$4(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$4 = (obj, key, value) => {
  __defNormalProp$4(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
class MissingIndexError extends Error {
  constructor(message, cause) {
    var _a;
    super(message);
    /**
     * An inner error that caused this error to be thrown, if any.
     */
    __publicField$4(this, "cause");
    (_a = Error.captureStackTrace) == null ? void 0 : _a.call(Error, this, this.constructor);
    this.name = this.constructor.name;
    this.cause = errors.isError(cause) ? cause : void 0;
  }
}

var __defProp$3 = Object.defineProperty;
var __defNormalProp$3 = (obj, key, value) => key in obj ? __defProp$3(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$3 = (obj, key, value) => {
  __defNormalProp$3(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
class BatchSearchEngineIndexer extends stream.Writable {
  constructor(options) {
    super({ objectMode: true });
    __publicField$3(this, "batchSize");
    __publicField$3(this, "currentBatch", []);
    this.batchSize = options.batchSize;
  }
  /**
   * Encapsulates initialization logic.
   * @internal
   */
  async _construct(done) {
    try {
      await this.initialize();
      done();
    } catch (e) {
      errors.assertError(e);
      done(e);
    }
  }
  /**
   * Encapsulates batch stream write logic.
   * @internal
   */
  async _write(doc, _e, done) {
    this.currentBatch.push(doc);
    if (this.currentBatch.length < this.batchSize) {
      done();
      return;
    }
    try {
      await this.index(this.currentBatch);
      this.currentBatch = [];
      done();
    } catch (e) {
      errors.assertError(e);
      done(e);
    }
  }
  /**
   * Encapsulates finalization and final error handling logic.
   * @internal
   */
  async _final(done) {
    try {
      if (this.currentBatch.length) {
        await this.index(this.currentBatch);
        this.currentBatch = [];
      }
      await this.finalize();
      done();
    } catch (e) {
      errors.assertError(e);
      done(e);
    }
  }
}

class DecoratorBase extends stream.Transform {
  constructor() {
    super({ objectMode: true });
  }
  /**
   * Encapsulates initialization logic.
   * @internal
   */
  async _construct(done) {
    try {
      await this.initialize();
      done();
    } catch (e) {
      errors.assertError(e);
      done(e);
    }
  }
  /**
   * Encapsulates simple transform stream logic.
   * @internal
   */
  async _transform(document, _, done) {
    try {
      const decorated = await this.decorate(document);
      if (decorated === void 0) {
        done();
        return;
      }
      if (Array.isArray(decorated)) {
        decorated.forEach((doc) => {
          this.push(doc);
        });
        done();
        return;
      }
      this.push(decorated);
      done();
    } catch (e) {
      errors.assertError(e);
      done(e);
    }
  }
  /**
   * Encapsulates finalization and final error handling logic.
   * @internal
   */
  async _final(done) {
    try {
      await this.finalize();
      done();
    } catch (e) {
      errors.assertError(e);
      done(e);
    }
  }
}

var __defProp$2 = Object.defineProperty;
var __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$2 = (obj, key, value) => {
  __defNormalProp$2(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
class LunrSearchEngineIndexer extends BatchSearchEngineIndexer {
  constructor() {
    super({ batchSize: 1e3 });
    __publicField$2(this, "schemaInitialized", false);
    __publicField$2(this, "builder");
    __publicField$2(this, "docStore", {});
    this.builder = new lunr__default["default"].Builder();
    this.builder.pipeline.add(lunr__default["default"].trimmer, lunr__default["default"].stopWordFilter, lunr__default["default"].stemmer);
    this.builder.searchPipeline.add(lunr__default["default"].stemmer);
    this.builder.metadataWhitelist = ["position"];
  }
  // No async initialization required.
  async initialize() {
  }
  async finalize() {
  }
  async index(documents) {
    if (!this.schemaInitialized) {
      Object.keys(documents[0]).forEach((field) => {
        this.builder.field(field);
      });
      this.builder.ref("location");
      this.schemaInitialized = true;
    }
    documents.forEach((document) => {
      this.builder.add(document);
      this.docStore[document.location] = document;
    });
  }
  buildIndex() {
    return this.builder.build();
  }
  getDocumentStore() {
    return this.docStore;
  }
}

var __defProp$1 = Object.defineProperty;
var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$1 = (obj, key, value) => {
  __defNormalProp$1(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
class LunrSearchEngine {
  constructor(options) {
    __publicField$1(this, "lunrIndices", {});
    __publicField$1(this, "docStore");
    __publicField$1(this, "logger");
    __publicField$1(this, "highlightPreTag");
    __publicField$1(this, "highlightPostTag");
    __publicField$1(this, "translator", ({
      term,
      filters,
      types,
      pageLimit
    }) => {
      const pageSize = pageLimit || 25;
      return {
        lunrQueryBuilder: (q) => {
          const termToken = lunr__default["default"].tokenizer(term);
          q.term(termToken, {
            usePipeline: true,
            boost: 100
          });
          q.term(termToken, {
            usePipeline: false,
            boost: 10,
            wildcard: lunr__default["default"].Query.wildcard.TRAILING
          });
          q.term(termToken, {
            usePipeline: false,
            editDistance: 2,
            boost: 1
          });
          if (filters) {
            Object.entries(filters).forEach(([field, fieldValue]) => {
              if (!q.allFields.includes(field)) {
                throw new Error(`unrecognised field ${field}`);
              }
              const value = Array.isArray(fieldValue) && fieldValue.length === 1 ? fieldValue[0] : fieldValue;
              if (["string", "number", "boolean"].includes(typeof value)) {
                q.term(
                  lunr__default["default"].tokenizer(value == null ? void 0 : value.toString()).map(lunr__default["default"].stopWordFilter).filter((element) => element !== void 0),
                  {
                    presence: lunr__default["default"].Query.presence.REQUIRED,
                    fields: [field]
                  }
                );
              } else if (Array.isArray(value)) {
                this.logger.warn(
                  `Non-scalar filter value used for field ${field}. Consider using a different Search Engine for better results.`
                );
                q.term(lunr__default["default"].tokenizer(value), {
                  presence: lunr__default["default"].Query.presence.OPTIONAL,
                  fields: [field]
                });
              } else {
                this.logger.warn(`Unknown filter type used on field ${field}`);
              }
            });
          }
        },
        documentTypes: types,
        pageSize
      };
    });
    this.logger = options.logger;
    this.docStore = {};
    const uuidTag = uuid.v4();
    this.highlightPreTag = `<${uuidTag}>`;
    this.highlightPostTag = `</${uuidTag}>`;
  }
  setTranslator(translator) {
    this.translator = translator;
  }
  async getIndexer(type) {
    const indexer = new LunrSearchEngineIndexer();
    const indexerLogger = this.logger.child({ documentType: type });
    let errorThrown;
    indexer.on("error", (err) => {
      errorThrown = err;
    });
    indexer.on("close", () => {
      const newDocuments = indexer.getDocumentStore();
      const docStoreExists = this.lunrIndices[type] !== void 0;
      const documentsIndexed = Object.keys(newDocuments).length;
      if (!errorThrown && documentsIndexed > 0) {
        this.lunrIndices[type] = indexer.buildIndex();
        this.docStore = { ...this.docStore, ...newDocuments };
      } else {
        indexerLogger.warn(
          `Index for ${type} was not ${docStoreExists ? "replaced" : "created"}: ${errorThrown ? "an error was encountered" : "indexer received 0 documents"}`
        );
      }
    });
    return indexer;
  }
  async query(query) {
    const { lunrQueryBuilder, documentTypes, pageSize } = this.translator(
      query
    );
    const results = [];
    const indexKeys = Object.keys(this.lunrIndices).filter(
      (type) => !documentTypes || documentTypes.includes(type)
    );
    if ((documentTypes == null ? void 0 : documentTypes.length) && !indexKeys.length) {
      throw new MissingIndexError(
        `Missing index for ${documentTypes == null ? void 0 : documentTypes.toString()}. This could be because the index hasn't been created yet or there was a problem during index creation.`
      );
    }
    indexKeys.forEach((type) => {
      try {
        results.push(
          ...this.lunrIndices[type].query(lunrQueryBuilder).map((result) => {
            return {
              result,
              type
            };
          })
        );
      } catch (err) {
        if (err instanceof Error && err.message.startsWith("unrecognised field")) {
          return;
        }
        throw err;
      }
    });
    results.sort((doc1, doc2) => {
      return doc2.result.score - doc1.result.score;
    });
    const { page } = decodePageCursor(query.pageCursor);
    const offset = page * pageSize;
    const hasPreviousPage = page > 0;
    const hasNextPage = results.length > offset + pageSize;
    const nextPageCursor = hasNextPage ? encodePageCursor({ page: page + 1 }) : void 0;
    const previousPageCursor = hasPreviousPage ? encodePageCursor({ page: page - 1 }) : void 0;
    const realResultSet = {
      results: results.slice(offset, offset + pageSize).map((d, index) => ({
        type: d.type,
        document: this.docStore[d.result.ref],
        rank: page * pageSize + index + 1,
        highlight: {
          preTag: this.highlightPreTag,
          postTag: this.highlightPostTag,
          fields: parseHighlightFields({
            preTag: this.highlightPreTag,
            postTag: this.highlightPostTag,
            doc: this.docStore[d.result.ref],
            positionMetadata: d.result.matchData.metadata
          })
        }
      })),
      numberOfResults: results.length,
      nextPageCursor,
      previousPageCursor
    };
    return realResultSet;
  }
}
function decodePageCursor(pageCursor) {
  if (!pageCursor) {
    return { page: 0 };
  }
  return {
    page: Number(Buffer.from(pageCursor, "base64").toString("utf-8"))
  };
}
function encodePageCursor({ page }) {
  return Buffer.from(`${page}`, "utf-8").toString("base64");
}
function parseHighlightFields({
  preTag,
  postTag,
  doc,
  positionMetadata
}) {
  const highlightFieldPositions = Object.values(positionMetadata).reduce(
    (fieldPositions, metadata) => {
      Object.keys(metadata).map((fieldKey) => {
        var _a, _b, _c;
        const validFieldMetadataPositions = (_b = (_a = metadata[fieldKey]) == null ? void 0 : _a.position) == null ? void 0 : _b.filter((position) => Array.isArray(position));
        if (validFieldMetadataPositions.length) {
          fieldPositions[fieldKey] = (_c = fieldPositions[fieldKey]) != null ? _c : [];
          fieldPositions[fieldKey].push(...validFieldMetadataPositions);
        }
      });
      return fieldPositions;
    },
    {}
  );
  return Object.fromEntries(
    Object.entries(highlightFieldPositions).map(([field, positions]) => {
      var _a;
      positions.sort((a, b) => b[0] - a[0]);
      const highlightedField = positions.reduce((content, pos) => {
        return `${String(content).substring(0, pos[0])}${preTag}${String(content).substring(pos[0], pos[0] + pos[1])}${postTag}${String(content).substring(pos[0] + pos[1])}`;
      }, (_a = doc[field]) != null ? _a : "");
      return [field, highlightedField];
    })
  );
}

var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
class TestPipeline {
  constructor({
    collator,
    decorator,
    indexer
  }) {
    __publicField(this, "collator");
    __publicField(this, "decorator");
    __publicField(this, "indexer");
    this.collator = collator;
    this.decorator = decorator;
    this.indexer = indexer;
  }
  /**
   * Provide the collator, decorator, or indexer to be tested.
   *
   * @deprecated Use `fromCollator`, `fromDecorator` or `fromIndexer` static
   *   methods to create a test pipeline instead.
   */
  static withSubject(subject) {
    if (subject instanceof stream.Transform) {
      return new TestPipeline({ decorator: subject });
    }
    if (subject instanceof stream.Writable) {
      return new TestPipeline({ indexer: subject });
    }
    if (subject.readable || subject instanceof stream.Readable) {
      return new TestPipeline({ collator: subject });
    }
    throw new Error(
      "Unknown test subject: are you passing a readable, writable, or transform stream?"
    );
  }
  /**
   * Create a test pipeline given a collator you want to test.
   */
  static fromCollator(collator) {
    return new TestPipeline({ collator });
  }
  /**
   * Add a collator to the test pipeline.
   */
  withCollator(collator) {
    this.collator = collator;
    return this;
  }
  /**
   * Create a test pipeline given a decorator you want to test.
   */
  static fromDecorator(decorator) {
    return new TestPipeline({ decorator });
  }
  /**
   * Add a decorator to the test pipeline.
   */
  withDecorator(decorator) {
    this.decorator = decorator;
    return this;
  }
  /**
   * Create a test pipeline given an indexer you want to test.
   */
  static fromIndexer(indexer) {
    return new TestPipeline({ indexer });
  }
  /**
   * Add an indexer to the test pipeline.
   */
  withIndexer(indexer) {
    this.indexer = indexer;
    return this;
  }
  /**
   * Provide documents for testing decorators and indexers.
   */
  withDocuments(documents) {
    if (this.collator) {
      throw new Error("Cannot provide documents when testing a collator.");
    }
    this.collator = new stream.Readable({ objectMode: true });
    this.collator._read = () => {
    };
    process.nextTick(() => {
      documents.forEach((document) => {
        this.collator.push(document);
      });
      this.collator.push(null);
    });
    return this;
  }
  /**
   * Execute the test pipeline so that you can make assertions about the result
   * or behavior of the given test subject.
   */
  async execute() {
    const documents = [];
    if (!this.collator) {
      throw new Error(
        "Cannot execute pipeline without a collator or documents"
      );
    }
    if (!this.indexer) {
      this.indexer = new stream.Writable({ objectMode: true });
      this.indexer._write = (document, _, done) => {
        documents.push(document);
        done();
      };
    }
    return new Promise((done) => {
      const pipes = [this.collator];
      if (this.decorator) {
        pipes.push(this.decorator);
      }
      pipes.push(this.indexer);
      stream.pipeline(pipes, (error) => {
        done({
          error,
          documents
        });
      });
    });
  }
}

exports.IndexBuilder = IndexBuilder.IndexBuilder;
exports.Scheduler = IndexBuilder.Scheduler;
exports.BatchSearchEngineIndexer = BatchSearchEngineIndexer;
exports.DecoratorBase = DecoratorBase;
exports.LunrSearchEngine = LunrSearchEngine;
exports.MissingIndexError = MissingIndexError;
exports.NewlineDelimitedJsonCollatorFactory = NewlineDelimitedJsonCollatorFactory;
exports.TestPipeline = TestPipeline;
//# sourceMappingURL=index.cjs.js.map
