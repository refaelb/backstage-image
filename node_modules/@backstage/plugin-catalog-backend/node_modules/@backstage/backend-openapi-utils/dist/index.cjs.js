'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var PromiseRouter = require('express-promise-router');
var express = require('express');
var errors = require('@backstage/errors');
var expressOpenapiValidator = require('express-openapi-validator');
var openapiMerge = require('openapi-merge');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var PromiseRouter__default = /*#__PURE__*/_interopDefaultLegacy(PromiseRouter);

var index = /*#__PURE__*/Object.freeze({
  __proto__: null
});

const OPENAPI_SPEC_ROUTE = "/openapi.json";

const baseUrlSymbol = Symbol();
const originalUrlSymbol = Symbol();
function validatorErrorTransformer() {
  return (error, _, _2, next) => {
    next(new errors.InputError(error.message));
  };
}
function getDefaultRouterMiddleware() {
  return [express.json()];
}
function getOpenApiSpecRoute(baseUrl) {
  return `${baseUrl}${OPENAPI_SPEC_ROUTE}`;
}
function createValidatedOpenApiRouter(spec, options) {
  const router = PromiseRouter__default["default"]();
  router.use((options == null ? void 0 : options.middleware) || getDefaultRouterMiddleware());
  router.use((req, _, next) => {
    const customRequest = req;
    customRequest[baseUrlSymbol] = customRequest.baseUrl;
    customRequest.baseUrl = "";
    customRequest[originalUrlSymbol] = customRequest.originalUrl;
    customRequest.originalUrl = customRequest.url;
    next();
  });
  router.use(
    expressOpenapiValidator.middleware({
      validateRequests: {
        coerceTypes: false,
        allowUnknownQueryParameters: false
      },
      ignoreUndocumented: true,
      validateResponses: false,
      ...options == null ? void 0 : options.validatorOptions,
      apiSpec: spec
    })
  );
  router.use((req, _, next) => {
    const customRequest = req;
    customRequest.baseUrl = customRequest[baseUrlSymbol];
    customRequest.originalUrl = customRequest[originalUrlSymbol];
    delete customRequest[baseUrlSymbol];
    delete customRequest[originalUrlSymbol];
    next();
  });
  router.use(validatorErrorTransformer());
  router.get(OPENAPI_SPEC_ROUTE, async (req, res) => {
    const mergeOutput = openapiMerge.merge([
      {
        oas: spec,
        pathModification: {
          /**
           * Get the route that this OpenAPI spec is hosted on. The other
           *  approach of using the discovery API increases the router constructor
           *  significantly and since we're just looking for path and not full URL,
           *  this works.
           *
           * If we wanted to add a list of servers, there may be a case for adding
           *  discovery API to get an exhaustive list of upstream servers, but that's
           *  also not currently supported.
           */
          prepend: req.originalUrl.replace(OPENAPI_SPEC_ROUTE, "")
        }
      }
    ]);
    if (openapiMerge.isErrorResult(mergeOutput)) {
      throw new errors.InputError("Invalid spec defined");
    }
    res.json(mergeOutput.output);
  });
  return router;
}

const wrapInOpenApiTestServer = (app) => {
  if (process.env.OPTIC_PROXY) {
    const server = app.listen(+process.env.PORT);
    return {
      ...server,
      address: () => new URL(process.env.OPTIC_PROXY)
    };
  }
  return app;
};

exports.createValidatedOpenApiRouter = createValidatedOpenApiRouter;
exports.getOpenApiSpecRoute = getOpenApiSpecRoute;
exports.internal = index;
exports.wrapInOpenApiTestServer = wrapInOpenApiTestServer;
//# sourceMappingURL=index.cjs.js.map
