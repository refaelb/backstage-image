'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var catalogClient = require('@backstage/catalog-client');
var catalogModel = require('@backstage/catalog-model');
var alpha = require('@backstage/plugin-catalog-common/alpha');
var stream = require('stream');
var config = require('./cjs/config-6c7298b0.cjs.js');
require('@backstage/backend-tasks');
require('@backstage/errors');

const getDocumentText = (entity) => {
  var _a, _b, _c, _d;
  const documentTexts = [];
  documentTexts.push(entity.metadata.description || "");
  if (catalogModel.isUserEntity(entity) || catalogModel.isGroupEntity(entity)) {
    if ((_b = (_a = entity.spec) == null ? void 0 : _a.profile) == null ? void 0 : _b.displayName) {
      documentTexts.push(entity.spec.profile.displayName);
    }
  }
  if (catalogModel.isUserEntity(entity)) {
    if ((_d = (_c = entity.spec) == null ? void 0 : _c.profile) == null ? void 0 : _d.email) {
      documentTexts.push(entity.spec.profile.email);
    }
  }
  return documentTexts.join(" : ");
};
const defaultCatalogCollatorEntityTransformer = (entity) => {
  var _a, _b, _c, _d, _e, _f, _g;
  return {
    title: (_a = entity.metadata.title) != null ? _a : entity.metadata.name,
    text: getDocumentText(entity),
    componentType: ((_c = (_b = entity.spec) == null ? void 0 : _b.type) == null ? void 0 : _c.toString()) || "other",
    type: ((_e = (_d = entity.spec) == null ? void 0 : _d.type) == null ? void 0 : _e.toString()) || "other",
    namespace: entity.metadata.namespace || "default",
    kind: entity.kind,
    lifecycle: ((_f = entity.spec) == null ? void 0 : _f.lifecycle) || "",
    owner: ((_g = entity.spec) == null ? void 0 : _g.owner) || ""
  };
};

var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
class DefaultCatalogCollatorFactory {
  constructor(options) {
    __publicField(this, "type", "software-catalog");
    __publicField(this, "visibilityPermission", alpha.catalogEntityReadPermission);
    __publicField(this, "locationTemplate");
    __publicField(this, "filter");
    __publicField(this, "batchSize");
    __publicField(this, "catalogClient");
    __publicField(this, "tokenManager");
    __publicField(this, "entityTransformer");
    const {
      batchSize,
      discovery,
      locationTemplate,
      filter,
      catalogClient: catalogClient$1,
      tokenManager,
      entityTransformer
    } = options;
    this.locationTemplate = locationTemplate;
    this.filter = filter;
    this.batchSize = batchSize;
    this.catalogClient = catalogClient$1 || new catalogClient.CatalogClient({ discoveryApi: discovery });
    this.tokenManager = tokenManager;
    this.entityTransformer = entityTransformer != null ? entityTransformer : defaultCatalogCollatorEntityTransformer;
  }
  static fromConfig(configRoot, options) {
    var _a, _b, _c;
    const configOptions = config.readCollatorConfigOptions(configRoot);
    return new DefaultCatalogCollatorFactory({
      locationTemplate: (_a = options.locationTemplate) != null ? _a : configOptions.locationTemplate,
      filter: (_b = options.filter) != null ? _b : configOptions.filter,
      batchSize: (_c = options.batchSize) != null ? _c : configOptions.batchSize,
      entityTransformer: options.entityTransformer,
      discovery: options.discovery,
      tokenManager: options.tokenManager,
      catalogClient: options.catalogClient
    });
  }
  async getCollator() {
    return stream.Readable.from(this.execute());
  }
  async *execute() {
    const { token } = await this.tokenManager.getToken();
    let entitiesRetrieved = 0;
    let moreEntitiesToGet = true;
    while (moreEntitiesToGet) {
      const entities = (await this.catalogClient.getEntities(
        {
          filter: this.filter,
          limit: this.batchSize,
          offset: entitiesRetrieved
        },
        { token }
      )).items;
      moreEntitiesToGet = entities.length === this.batchSize;
      entitiesRetrieved += entities.length;
      for (const entity of entities) {
        yield {
          ...this.entityTransformer(entity),
          authorization: {
            resourceRef: catalogModel.stringifyEntityRef(entity)
          },
          location: this.applyArgsToFormat(this.locationTemplate, {
            namespace: entity.metadata.namespace || "default",
            kind: entity.kind,
            name: entity.metadata.name
          })
        };
      }
    }
  }
  applyArgsToFormat(format, args) {
    let formatted = format;
    for (const [key, value] of Object.entries(args)) {
      formatted = formatted.replace(`:${key}`, value);
    }
    return formatted.toLowerCase();
  }
}

exports.DefaultCatalogCollatorFactory = DefaultCatalogCollatorFactory;
exports.defaultCatalogCollatorEntityTransformer = defaultCatalogCollatorEntityTransformer;
//# sourceMappingURL=index.cjs.js.map
