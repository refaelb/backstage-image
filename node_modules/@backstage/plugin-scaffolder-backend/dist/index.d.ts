import * as _backstage_plugin_scaffolder_node from '@backstage/plugin-scaffolder-node';
import { TemplateFilter as TemplateFilter$1, TemplateGlobal as TemplateGlobal$1, TemplateAction as TemplateAction$1, TaskStatus as TaskStatus$1, TaskCompletionState as TaskCompletionState$1, SerializedTask as SerializedTask$1, TaskEventType as TaskEventType$1, SerializedTaskEvent as SerializedTaskEvent$1, TaskBrokerDispatchResult as TaskBrokerDispatchResult$1, TaskBrokerDispatchOptions as TaskBrokerDispatchOptions$1, TaskContext as TaskContext$1, TaskBroker as TaskBroker$1, TaskSecrets as TaskSecrets$1, ActionContext as ActionContext$1, ExecuteShellCommandOptions, executeShellCommand as executeShellCommand$1, fetchContents as fetchContents$1 } from '@backstage/plugin-scaffolder-node';
import * as _backstage_types from '@backstage/types';
import { HumanDuration, JsonObject } from '@backstage/types';
import * as _backstage_integration from '@backstage/integration';
import { ScmIntegrations } from '@backstage/integration';
import { CatalogApi } from '@backstage/catalog-client';
import { UrlReader, PluginDatabaseManager } from '@backstage/backend-common';
import { Config } from '@backstage/config';
import { Duration } from 'luxon';
import * as github from '@backstage/plugin-scaffolder-backend-module-github';
import * as gitlab from '@backstage/plugin-scaffolder-backend-module-gitlab';
import * as azure from '@backstage/plugin-scaffolder-backend-module-azure';
import * as bitbucket from '@backstage/plugin-scaffolder-backend-module-bitbucket';
import * as gerrit from '@backstage/plugin-scaffolder-backend-module-gerrit';
import { Knex } from 'knex';
import * as _backstage_plugin_scaffolder_common from '@backstage/plugin-scaffolder-common';
import { TaskSpec, TemplateEntityStepV1beta3, TemplateParametersV1beta3 } from '@backstage/plugin-scaffolder-common';
import { Logger } from 'winston';
import { PermissionEvaluator, PermissionRuleParams } from '@backstage/plugin-permission-common';
import { PluginTaskScheduler } from '@backstage/backend-tasks';
import { RESOURCE_TYPE_SCAFFOLDER_TEMPLATE, RESOURCE_TYPE_SCAFFOLDER_ACTION } from '@backstage/plugin-scaffolder-common/alpha';
import express from 'express';
import { IdentityApi } from '@backstage/plugin-auth-node';
import { PermissionRule } from '@backstage/plugin-permission-node';
import * as jsonschema from 'jsonschema';
import * as zod from 'zod';
import { ScaffolderEntitiesProcessor as ScaffolderEntitiesProcessor$1 } from '@backstage/plugin-catalog-backend-module-scaffolder-entity-model';

/**
 * Registers entities from a catalog descriptor file in the workspace into the software catalog.
 * @public
 */
declare function createCatalogRegisterAction(options: {
    catalogClient: CatalogApi;
    integrations: ScmIntegrations;
}): _backstage_plugin_scaffolder_node.TemplateAction<{
    catalogInfoUrl: string;
    optional?: boolean | undefined;
} | {
    repoContentsUrl: string;
    catalogInfoPath?: string | undefined;
    optional?: boolean | undefined;
}, _backstage_types.JsonObject>;

/**
 * Writes a catalog descriptor file containing the provided entity to a path in the workspace.
 * @public
 */
declare function createCatalogWriteAction(): _backstage_plugin_scaffolder_node.TemplateAction<{
    entity: Record<string, any>;
    filePath?: string | undefined;
}, _backstage_types.JsonObject>;

/**
 * Returns entity or entities from the catalog by entity reference(s).
 *
 * @public
 */
declare function createFetchCatalogEntityAction(options: {
    catalogClient: CatalogApi;
}): _backstage_plugin_scaffolder_node.TemplateAction<{
    entityRef?: string | undefined;
    entityRefs?: string[] | undefined;
    optional?: boolean | undefined;
    defaultKind?: string | undefined;
    defaultNamespace?: string | undefined;
}, {
    entity?: any;
    entities?: any[] | undefined;
}>;

/**
 * @public
 * @deprecated Import from `@backstage/plugin-scaffolder-node` instead.
 */
type TemplateFilter = TemplateFilter$1;
/**
 * @public
 * @deprecated Import from `@backstage/plugin-scaffolder-node` instead.
 */
type TemplateGlobal = TemplateGlobal$1;

/**
 * The options passed to {@link createBuiltinActions}
 * @public
 */
interface CreateBuiltInActionsOptions {
    /**
     * The {@link @backstage/backend-common#UrlReader} interface that will be used in the default actions.
     */
    reader: UrlReader;
    /**
     * The {@link @backstage/integrations#ScmIntegrations} that will be used in the default actions.
     */
    integrations: ScmIntegrations;
    /**
     * The {@link @backstage/catalog-client#CatalogApi} that will be used in the default actions.
     */
    catalogClient: CatalogApi;
    /**
     * The {@link @backstage/config#Config} that will be used in the default actions.
     */
    config: Config;
    /**
     * Additional custom filters that will be passed to the nunjucks template engine for use in
     * Template Manifests and also template skeleton files when using `fetch:template`.
     */
    additionalTemplateFilters?: Record<string, TemplateFilter>;
    additionalTemplateGlobals?: Record<string, TemplateGlobal>;
}
/**
 * A function to generate create a list of default actions that the scaffolder provides.
 * Is called internally in the default setup, but can be used when adding your own actions or overriding the default ones
 *
 * TODO(blam): version 2 of the scaffolder shouldn't ship with the additional modules. We should ship the basics, and let people install
 * modules for the providers they want to use.
 * @public
 * @returns A list of actions that can be used in the scaffolder
 *
 */
declare const createBuiltinActions: (options: CreateBuiltInActionsOptions) => TemplateAction$1[];

/**
 * Writes a message into the log or lists all files in the workspace
 *
 * @remarks
 *
 * This task is useful for local development and testing of both the scaffolder
 * and scaffolder templates.
 *
 * @public
 */
declare function createDebugLogAction(): _backstage_plugin_scaffolder_node.TemplateAction<{
    message?: string | undefined;
    listWorkspace?: boolean | undefined;
}, _backstage_types.JsonObject>;

/**
 * Waits for a certain period of time.
 *
 * @remarks
 *
 * This task is useful to give some waiting time for manual intervention.
 * Has to be used in a combination with other actions.
 *
 * @public
 */
declare function createWaitAction(options?: {
    maxWaitTime?: Duration | HumanDuration;
}): _backstage_plugin_scaffolder_node.TemplateAction<HumanDuration, _backstage_types.JsonObject>;

/**
 * Downloads content and places it in the workspace, or optionally
 * in a subdirectory specified by the 'targetPath' input option.
 * @public
 */
declare function createFetchPlainAction(options: {
    reader: UrlReader;
    integrations: ScmIntegrations;
}): _backstage_plugin_scaffolder_node.TemplateAction<{
    url: string;
    targetPath?: string | undefined;
}, _backstage_types.JsonObject>;

/**
 * Downloads content and places it in the workspace, or optionally
 * in a subdirectory specified by the 'targetPath' input option.
 * @public
 */
declare function createFetchPlainFileAction(options: {
    reader: UrlReader;
    integrations: ScmIntegrations;
}): _backstage_plugin_scaffolder_node.TemplateAction<{
    url: string;
    targetPath: string;
}, _backstage_types.JsonObject>;

/**
 * Downloads a skeleton, templates variables into file and directory names and content.
 * Then places the result in the workspace, or optionally in a subdirectory
 * specified by the 'targetPath' input option.
 *
 * @public
 */
declare function createFetchTemplateAction(options: {
    reader: UrlReader;
    integrations: ScmIntegrations;
    additionalTemplateFilters?: Record<string, TemplateFilter>;
    additionalTemplateGlobals?: Record<string, TemplateGlobal>;
}): _backstage_plugin_scaffolder_node.TemplateAction<{
    url: string;
    targetPath?: string | undefined;
    values: any;
    templateFileExtension?: string | boolean | undefined;
    /**
     * @deprecated This field is deprecated in favor of copyWithoutTemplating.
     */
    copyWithoutRender?: string[] | undefined;
    copyWithoutTemplating?: string[] | undefined;
    cookiecutterCompat?: boolean | undefined;
    replace?: boolean | undefined;
}, _backstage_types.JsonObject>;

/**
 * Creates new action that enables deletion of files and directories in the workspace.
 * @public
 */
declare const createFilesystemDeleteAction: () => _backstage_plugin_scaffolder_node.TemplateAction<{
    files: string[];
}, _backstage_types.JsonObject>;

/**
 * Creates a new action that allows renames of files and directories in the workspace.
 * @public
 */
declare const createFilesystemRenameAction: () => _backstage_plugin_scaffolder_node.TemplateAction<{
    files: Array<{
        from: string;
        to: string;
        overwrite?: boolean;
    }>;
}, _backstage_types.JsonObject>;

/**
 * @public @deprecated use import from \@backstage/plugin-scaffolder-backend-module-github instead
 */
declare const createGithubActionsDispatchAction: typeof github.createGithubActionsDispatchAction;
/**
 * @public @deprecated use import from \@backstage/plugin-scaffolder-backend-module-github instead
 */
declare const createGithubDeployKeyAction: typeof github.createGithubDeployKeyAction;
/**
 * @public @deprecated use import from \@backstage/plugin-scaffolder-backend-module-github instead
 */
declare const createGithubEnvironmentAction: typeof github.createGithubEnvironmentAction;
/**
 * @public @deprecated use import from \@backstage/plugin-scaffolder-backend-module-github instead
 */
declare const createGithubIssuesLabelAction: typeof github.createGithubIssuesLabelAction;
/**
 * @public @deprecated use import from \@backstage/plugin-scaffolder-backend-module-github instead
 */
type CreateGithubPullRequestActionOptions = github.CreateGithubPullRequestActionOptions;
/**
 * @public @deprecated use import from \@backstage/plugin-scaffolder-backend-module-github instead
 */
declare const createGithubRepoCreateAction: typeof github.createGithubRepoCreateAction;
/**
 * @public @deprecated use import from \@backstage/plugin-scaffolder-backend-module-github instead
 */
declare const createGithubRepoPushAction: typeof github.createGithubRepoPushAction;
/**
 * @public @deprecated use import from \@backstage/plugin-scaffolder-backend-module-github instead
 */
declare const createGithubWebhookAction: typeof github.createGithubWebhookAction;
/**
 * @public @deprecated use import from \@backstage/plugin-scaffolder-backend-module-github instead
 */
declare const createPublishGithubAction: typeof github.createPublishGithubAction;
/**
 * @public @deprecated use import from \@backstage/plugin-scaffolder-backend-module-github instead
 */
declare const createPublishGithubPullRequestAction: (options: github.CreateGithubPullRequestActionOptions) => _backstage_plugin_scaffolder_node.TemplateAction<{
    title: string;
    branchName: string;
    targetBranchName?: string | undefined;
    description: string;
    repoUrl: string;
    draft?: boolean | undefined;
    targetPath?: string | undefined;
    sourcePath?: string | undefined;
    token?: string | undefined;
    reviewers?: string[] | undefined;
    teamReviewers?: string[] | undefined;
    commitMessage?: string | undefined;
    update?: boolean | undefined;
}, _backstage_types.JsonObject>;
/**
 * @public @deprecated use import from \@backstage/plugin-scaffolder-backend-module-bitbucket instead
 */
declare const createPublishBitbucketAction: typeof bitbucket.createPublishBitbucketAction;
/**
 * @public @deprecated use import from \@backstage/plugin-scaffolder-backend-module-bitbucket instead
 */
declare const createPublishBitbucketCloudAction: typeof bitbucket.createPublishBitbucketCloudAction;
/**
 * @public @deprecated use import from \@backstage/plugin-scaffolder-backend-module-bitbucket instead
 */
declare const createPublishBitbucketServerAction: typeof bitbucket.createPublishBitbucketServerAction;
/**
 * @public @deprecated use import from \@backstage/plugin-scaffolder-backend-module-bitbucket instead
 */
declare const createPublishBitbucketServerPullRequestAction: typeof bitbucket.createPublishBitbucketServerPullRequestAction;
/**
 * @public @deprecated use import from \@backstage/plugin-scaffolder-backend-module-azure instead
 */
declare const createPublishAzureAction: typeof azure.createPublishAzureAction;
/**
 * @public @deprecated use import from \@backstage/plugin-scaffolder-backend-module-gerrit instead
 */
declare const createPublishGerritAction: typeof gerrit.createPublishGerritAction;
/**
 * @public @deprecated use import from \@backstage/plugin-scaffolder-backend-module-gerrit instead
 */
declare const createPublishGerritReviewAction: typeof gerrit.createPublishGerritReviewAction;
/**
 * @public @deprecated use import from \@backstage/plugin-scaffolder-backend-module-gitlab instead
 */
declare const createPublishGitlabAction: typeof gitlab.createPublishGitlabAction;
/**
 * @public @deprecated use import from \@backstage/plugin-scaffolder-backend-module-gitlab instead
 */
declare const createPublishGitlabMergeRequestAction: (options: {
    integrations: _backstage_integration.ScmIntegrationRegistry;
}) => _backstage_plugin_scaffolder_node.TemplateAction<{
    repoUrl: string;
    title: string;
    description: string;
    branchName: string;
    targetBranchName?: string | undefined;
    sourcePath?: string | undefined;
    targetPath?: string | undefined;
    token?: string | undefined;
    commitAction?: "update" | "delete" | "create" | undefined;
    projectid?: string | undefined;
    removeSourceBranch?: boolean | undefined;
    assignee?: string | undefined;
}, _backstage_types.JsonObject>;

/**
 * Registry of all registered template actions.
 * @public
 */
declare class TemplateActionRegistry {
    private readonly actions;
    register(action: TemplateAction$1): void;
    get(actionId: string): TemplateAction$1;
    list(): TemplateAction$1[];
}

/**
 * The status of each step of the Task
 *
 * @public
 * @deprecated Import from `@backstage/plugin-scaffolder-node` instead.
 */
type TaskStatus = TaskStatus$1;
/**
 * The state of a completed task.
 *
 * @public
 * @deprecated Import from `@backstage/plugin-scaffolder-node` instead.
 */
type TaskCompletionState = TaskCompletionState$1;
/**
 * SerializedTask
 *
 * @public
 * @deprecated Import from `@backstage/plugin-scaffolder-node` instead.
 */
type SerializedTask = SerializedTask$1;
/**
 * TaskEventType
 *
 * @public
 * @deprecated Import from `@backstage/plugin-scaffolder-node` instead.
 */
type TaskEventType = TaskEventType$1;
/**
 * SerializedTaskEvent
 *
 * @public
 * @deprecated Import from `@backstage/plugin-scaffolder-node` instead.
 */
type SerializedTaskEvent = SerializedTaskEvent$1;
/**
 * The result of `TaskBroker.dispatch`.
 *
 * @public
 * @deprecated Import from `@backstage/plugin-scaffolder-node` instead.
 */
type TaskBrokerDispatchResult = TaskBrokerDispatchResult$1;
/**
 * The options passed to `TaskBroker.dispatch`.
 * Currently a spec and optional secrets
 *
 * @public
 * @deprecated Import from `@backstage/plugin-scaffolder-node` instead.
 */
type TaskBrokerDispatchOptions = TaskBrokerDispatchOptions$1;
/**
 * Task
 *
 * @public
 * @deprecated Import from `@backstage/plugin-scaffolder-node` instead.
 */
type TaskContext = TaskContext$1;
/**
 * TaskBroker
 *
 * @public
 * @deprecated Import from `@backstage/plugin-scaffolder-node` instead.
 */
type TaskBroker = TaskBroker$1;
/**
 * TaskStoreEmitOptions
 *
 * @public
 */
type TaskStoreEmitOptions<TBody = JsonObject> = {
    taskId: string;
    body: TBody;
};
/**
 * TaskStoreListEventsOptions
 *
 * @public
 */
type TaskStoreListEventsOptions = {
    taskId: string;
    after?: number | undefined;
};
/**
 * TaskStoreShutDownTaskOptions
 *
 * @public
 */
type TaskStoreShutDownTaskOptions = {
    taskId: string;
};
/**
 * The options passed to {@link TaskStore.createTask}
 * @public
 */
type TaskStoreCreateTaskOptions = {
    spec: TaskSpec;
    createdBy?: string;
    secrets?: TaskSecrets$1;
};
/**
 * The response from {@link TaskStore.createTask}
 * @public
 */
type TaskStoreCreateTaskResult = {
    taskId: string;
};
/**
 * TaskStore
 *
 * @public
 */
interface TaskStore {
    cancelTask?(options: TaskStoreEmitOptions): Promise<void>;
    createTask(options: TaskStoreCreateTaskOptions): Promise<TaskStoreCreateTaskResult>;
    getTask(taskId: string): Promise<SerializedTask>;
    claimTask(): Promise<SerializedTask | undefined>;
    completeTask(options: {
        taskId: string;
        status: TaskStatus;
        eventBody: JsonObject;
    }): Promise<void>;
    heartbeatTask(taskId: string): Promise<void>;
    listStaleTasks(options: {
        timeoutS: number;
    }): Promise<{
        tasks: {
            taskId: string;
        }[];
    }>;
    list?(options: {
        createdBy?: string;
    }): Promise<{
        tasks: SerializedTask[];
    }>;
    emitLogEvent(options: TaskStoreEmitOptions): Promise<void>;
    listEvents(options: TaskStoreListEventsOptions): Promise<{
        events: SerializedTaskEvent[];
    }>;
    shutdownTask?(options: TaskStoreShutDownTaskOptions): Promise<void>;
}

/**
 * DatabaseTaskStore
 *
 * @public
 */
type DatabaseTaskStoreOptions = {
    database: PluginDatabaseManager | Knex;
};
/**
 * DatabaseTaskStore
 *
 * @public
 */
declare class DatabaseTaskStore implements TaskStore {
    private readonly db;
    static create(options: DatabaseTaskStoreOptions): Promise<DatabaseTaskStore>;
    private static getClient;
    private static runMigrations;
    private constructor();
    list(options: {
        createdBy?: string;
    }): Promise<{
        tasks: SerializedTask$1[];
    }>;
    getTask(taskId: string): Promise<SerializedTask$1>;
    createTask(options: TaskStoreCreateTaskOptions): Promise<TaskStoreCreateTaskResult>;
    claimTask(): Promise<SerializedTask$1 | undefined>;
    heartbeatTask(taskId: string): Promise<void>;
    listStaleTasks(options: {
        timeoutS: number;
    }): Promise<{
        tasks: {
            taskId: string;
        }[];
    }>;
    completeTask(options: {
        taskId: string;
        status: TaskStatus$1;
        eventBody: JsonObject;
    }): Promise<void>;
    emitLogEvent(options: TaskStoreEmitOptions<{
        message: string;
    } & JsonObject>): Promise<void>;
    listEvents(options: TaskStoreListEventsOptions): Promise<{
        events: SerializedTaskEvent$1[];
    }>;
    shutdownTask(options: TaskStoreShutDownTaskOptions): Promise<void>;
    cancelTask(options: TaskStoreEmitOptions<{
        message: string;
    } & JsonObject>): Promise<void>;
}

/**
 * TaskManager
 *
 * @public
 */
declare class TaskManager implements TaskContext {
    private readonly task;
    private readonly storage;
    private readonly signal;
    private readonly logger;
    private isDone;
    private heartbeatTimeoutId?;
    static create(task: CurrentClaimedTask, storage: TaskStore, abortSignal: AbortSignal, logger: Logger): TaskManager;
    private constructor();
    get spec(): _backstage_plugin_scaffolder_common.TaskSpecV1beta3;
    get cancelSignal(): AbortSignal;
    get secrets(): TaskSecrets$1 | undefined;
    get createdBy(): string | undefined;
    getWorkspaceName(): Promise<string>;
    get done(): boolean;
    emitLog(message: string, logMetadata?: JsonObject): Promise<void>;
    complete(result: TaskCompletionState, metadata?: JsonObject): Promise<void>;
    private startTimeout;
}
/**
 * Stores the state of the current claimed task passed to the TaskContext
 *
 * @public
 */
interface CurrentClaimedTask {
    /**
     * The TaskSpec of the current claimed task.
     */
    spec: TaskSpec;
    /**
     * The uuid of the current claimed task.
     */
    taskId: string;
    /**
     * The secrets that are stored with the task.
     */
    secrets?: TaskSecrets$1;
    /**
     * The creator of the task.
     */
    createdBy?: string;
}

/**
 * CreateWorkerOptions
 *
 * @public
 */
type CreateWorkerOptions = {
    taskBroker: TaskBroker;
    actionRegistry: TemplateActionRegistry;
    integrations: ScmIntegrations;
    workingDirectory: string;
    logger: Logger;
    additionalTemplateFilters?: Record<string, TemplateFilter>;
    /**
     * The number of tasks that can be executed at the same time by the worker
     * @defaultValue 10
     * @example
     * ```
     * {
     *   concurrentTasksLimit: 1,
     *   // OR
     *   concurrentTasksLimit: Infinity
     * }
     * ```
     */
    concurrentTasksLimit?: number;
    additionalTemplateGlobals?: Record<string, TemplateGlobal>;
    permissions?: PermissionEvaluator;
};
/**
 * TaskWorker
 *
 * @public
 */
declare class TaskWorker {
    private readonly options;
    private taskQueue;
    private constructor();
    static create(options: CreateWorkerOptions): Promise<TaskWorker>;
    start(): void;
    protected onReadyToClaimTask(): Promise<void>;
    runOneTask(task: TaskContext): Promise<void>;
}

/**
 *
 * @public
 */
type TemplatePermissionRuleInput<TParams extends PermissionRuleParams = PermissionRuleParams> = PermissionRule<TemplateEntityStepV1beta3 | TemplateParametersV1beta3, {}, typeof RESOURCE_TYPE_SCAFFOLDER_TEMPLATE, TParams>;
/**
 *
 * @public
 */
type ActionPermissionRuleInput<TParams extends PermissionRuleParams = PermissionRuleParams> = PermissionRule<TemplateEntityStepV1beta3 | TemplateParametersV1beta3, {}, typeof RESOURCE_TYPE_SCAFFOLDER_ACTION, TParams>;
/**
 * RouterOptions
 *
 * @public
 */
interface RouterOptions {
    logger: Logger;
    config: Config;
    reader: UrlReader;
    database: PluginDatabaseManager;
    catalogClient: CatalogApi;
    scheduler?: PluginTaskScheduler;
    actions?: TemplateAction$1<any, any>[];
    /**
     * @deprecated taskWorkers is deprecated in favor of concurrentTasksLimit option with a single TaskWorker
     * @defaultValue 1
     */
    taskWorkers?: number;
    /**
     * Sets the number of concurrent tasks that can be run at any given time on the TaskWorker
     * @defaultValue 10
     */
    concurrentTasksLimit?: number;
    taskBroker?: TaskBroker$1;
    additionalTemplateFilters?: Record<string, TemplateFilter$1>;
    additionalTemplateGlobals?: Record<string, TemplateGlobal$1>;
    permissions?: PermissionEvaluator;
    permissionRules?: Array<TemplatePermissionRuleInput | ActionPermissionRuleInput>;
    identity?: IdentityApi;
}
/**
 * A method to create a router for the scaffolder backend plugin.
 * @public
 */
declare function createRouter(options: RouterOptions): Promise<express.Router>;

/**
 * @public
 * @deprecated Import from {@link @backstage/plugin-scaffolder-node#ActionContext} instead
 */
type ActionContext<TInput extends JsonObject> = ActionContext$1<TInput>;
/**
 * @public
 * @deprecated Use `createTemplateAction` from `@backstage/plugin-scaffolder-node` instead
 */
declare const createTemplateAction: <TInputParams extends JsonObject = JsonObject, TOutputParams extends JsonObject = JsonObject, TInputSchema extends zod.ZodType<any, zod.ZodTypeDef, any> | jsonschema.Schema = {}, TOutputSchema extends zod.ZodType<any, zod.ZodTypeDef, any> | jsonschema.Schema = {}, TActionInput extends JsonObject = TInputSchema extends zod.ZodType<any, any, infer IReturn> ? IReturn : TInputParams, TActionOutput extends JsonObject = TOutputSchema extends zod.ZodType<any, any, infer IReturn_1> ? IReturn_1 : TOutputParams>(action: _backstage_plugin_scaffolder_node.TemplateActionOptions<TActionInput, TActionOutput, TInputSchema, TOutputSchema>) => TemplateAction$1<TActionInput, TActionOutput>;
/**
 * @public
 * @deprecated Use `TaskSecrets` from `@backstage/plugin-scaffolder-node` instead
 */
type TaskSecrets = TaskSecrets$1;
/**
 * @public
 * @deprecated Use `TemplateAction` from `@backstage/plugin-scaffolder-node` instead
 */
type TemplateAction<TInput extends JsonObject> = TemplateAction$1<TInput>;
/**
 * Options for {@link executeShellCommand}.
 *
 * @public
 * @deprecated Use `ExecuteShellCommandOptions` from `@backstage/plugin-scaffolder-node` instead
 */
type RunCommandOptions = ExecuteShellCommandOptions;
/**
 * Run a command in a sub-process, normally a shell command.
 *
 * @public
 * @deprecated Use `executeShellCommand` from `@backstage/plugin-scaffolder-node` instead
 */
declare const executeShellCommand: typeof executeShellCommand$1;
/**
 * A helper function that reads the contents of a directory from the given URL.
 * Can be used in your own actions, and also used behind fetch:template and fetch:plain
 *
 * @public
 * @deprecated Use `fetchContents` from `@backstage/plugin-scaffolder-node` instead
 */
declare const fetchContents: typeof fetchContents$1;
/**
 * Adds support for scaffolder specific entity kinds to the catalog.
 *
 * @public
 * @deprecated Import from `@backstage/plugin-catalog-backend-module-scaffolder-entity-model` instead
 */
declare const ScaffolderEntitiesProcessor: typeof ScaffolderEntitiesProcessor$1;

export { ActionContext, ActionPermissionRuleInput, CreateBuiltInActionsOptions, CreateGithubPullRequestActionOptions, CreateWorkerOptions, CurrentClaimedTask, DatabaseTaskStore, DatabaseTaskStoreOptions, RouterOptions, RunCommandOptions, ScaffolderEntitiesProcessor, SerializedTask, SerializedTaskEvent, TaskBroker, TaskBrokerDispatchOptions, TaskBrokerDispatchResult, TaskCompletionState, TaskContext, TaskEventType, TaskManager, TaskSecrets, TaskStatus, TaskStore, TaskStoreCreateTaskOptions, TaskStoreCreateTaskResult, TaskStoreEmitOptions, TaskStoreListEventsOptions, TaskStoreShutDownTaskOptions, TaskWorker, TemplateAction, TemplateActionRegistry, TemplateFilter, TemplateGlobal, TemplatePermissionRuleInput, createBuiltinActions, createCatalogRegisterAction, createCatalogWriteAction, createDebugLogAction, createFetchCatalogEntityAction, createFetchPlainAction, createFetchPlainFileAction, createFetchTemplateAction, createFilesystemDeleteAction, createFilesystemRenameAction, createGithubActionsDispatchAction, createGithubDeployKeyAction, createGithubEnvironmentAction, createGithubIssuesLabelAction, createGithubRepoCreateAction, createGithubRepoPushAction, createGithubWebhookAction, createPublishAzureAction, createPublishBitbucketAction, createPublishBitbucketCloudAction, createPublishBitbucketServerAction, createPublishBitbucketServerPullRequestAction, createPublishGerritAction, createPublishGerritReviewAction, createPublishGithubAction, createPublishGithubPullRequestAction, createPublishGitlabAction, createPublishGitlabMergeRequestAction, createRouter, createTemplateAction, createWaitAction, executeShellCommand, fetchContents };
