import React, { useCallback, memo, useState, useEffect, useContext, useMemo } from 'react';
import { useOutlet } from 'react-router-dom';
import { attachComponentData, createReactExtension, useElementFilter, createApiRef, useApi, configApiRef, AnalyticsContext } from '@backstage/core-plugin-api';
import useAsync from 'react-use/lib/useAsync';
import useAsyncRetry from 'react-use/lib/useAsyncRetry';
import { stringifyEntityRef } from '@backstage/catalog-model';
import { createVersionedContext, createVersionedValueMap } from '@backstage/version-bridge';
import { create } from 'jss';
import { jssPreset, StylesProvider } from '@material-ui/styles';
import { Progress } from '@backstage/core-components';
import debounce from 'lodash/debounce';

const TECHDOCS_ADDONS_KEY = "techdocs.addons.addon.v1";
const TECHDOCS_ADDONS_WRAPPER_KEY = "techdocs.addons.wrapper.v1";
const TechDocsAddons = () => null;
attachComponentData(TechDocsAddons, TECHDOCS_ADDONS_WRAPPER_KEY, true);
const getDataKeyByName = (name) => {
  return `${TECHDOCS_ADDONS_KEY}.${name.toLocaleLowerCase("en-US")}`;
};
function createTechDocsAddonExtension(options) {
  const { name, component: TechDocsAddon } = options;
  return createReactExtension({
    name,
    component: {
      sync: (props) => /* @__PURE__ */ React.createElement(TechDocsAddon, { ...props })
    },
    data: {
      [TECHDOCS_ADDONS_KEY]: options,
      [getDataKeyByName(name)]: true
    }
  });
}
const getTechDocsAddonByName = (collection, key) => {
  return collection.selectByComponentData({ key }).getElements()[0];
};
const getAllTechDocsAddons = (collection) => {
  return collection.selectByComponentData({
    key: TECHDOCS_ADDONS_WRAPPER_KEY
  }).selectByComponentData({
    key: TECHDOCS_ADDONS_KEY
  });
};
const getAllTechDocsAddonsData = (collection) => {
  return collection.selectByComponentData({
    key: TECHDOCS_ADDONS_WRAPPER_KEY
  }).findComponentData({
    key: TECHDOCS_ADDONS_KEY
  });
};
const useTechDocsAddons = () => {
  const node = useOutlet();
  const collection = useElementFilter(node, getAllTechDocsAddons);
  const options = useElementFilter(node, getAllTechDocsAddonsData);
  const findAddonByData = useCallback(
    (data) => {
      var _a;
      if (!collection || !data)
        return null;
      const nameKey = getDataKeyByName(data.name);
      return (_a = getTechDocsAddonByName(collection, nameKey)) != null ? _a : null;
    },
    [collection]
  );
  const renderComponentByName = useCallback(
    (name) => {
      const data = options.find((option) => option.name === name);
      return data ? findAddonByData(data) : null;
    },
    [options, findAddonByData]
  );
  const renderComponentsByLocation = useCallback(
    (location) => {
      const data = options.filter((option) => option.location === location);
      return data.length ? data.map(findAddonByData) : null;
    },
    [options, findAddonByData]
  );
  return { renderComponentByName, renderComponentsByLocation };
};

const techdocsApiRef = createApiRef({
  id: "plugin.techdocs.service"
});
const techdocsStorageApiRef = createApiRef({
  id: "plugin.techdocs.storageservice"
});

function toLowercaseEntityRefMaybe(entityRef, config) {
  if (config.getOptionalBoolean("techdocs.legacyUseCaseSensitiveTripletPaths"))
    return entityRef;
  entityRef.kind = entityRef.kind.toLocaleLowerCase();
  entityRef.name = entityRef.name.toLocaleLowerCase();
  entityRef.namespace = entityRef.namespace.toLocaleLowerCase();
  return entityRef;
}

const areEntityRefsEqual = (prevEntityRef, nextEntityRef) => {
  return stringifyEntityRef(prevEntityRef) === stringifyEntityRef(nextEntityRef);
};
const defaultTechDocsReaderPageValue = {
  title: "",
  subtitle: "",
  setTitle: () => {
  },
  setSubtitle: () => {
  },
  setShadowRoot: () => {
  },
  metadata: { loading: true },
  entityMetadata: { loading: true },
  entityRef: { kind: "", name: "", namespace: "" }
};
const TechDocsReaderPageContext = createVersionedContext("techdocs-reader-page-context");
const TechDocsReaderPageProvider = memo(
  (props) => {
    const { entityRef, children } = props;
    const techdocsApi = useApi(techdocsApiRef);
    const config = useApi(configApiRef);
    const entityMetadata = useAsync(async () => {
      return techdocsApi.getEntityMetadata(entityRef);
    }, [entityRef]);
    const metadata = useAsyncRetry(async () => {
      return techdocsApi.getTechDocsMetadata(entityRef);
    }, [entityRef]);
    const [title, setTitle] = useState(defaultTechDocsReaderPageValue.title);
    const [subtitle, setSubtitle] = useState(
      defaultTechDocsReaderPageValue.subtitle
    );
    const [shadowRoot, setShadowRoot] = useState(
      defaultTechDocsReaderPageValue.shadowRoot
    );
    useEffect(() => {
      if (shadowRoot && !metadata.value && !metadata.loading) {
        metadata.retry();
      }
    }, [
      metadata.value,
      metadata.loading,
      shadowRoot,
      metadata.retry,
      metadata
    ]);
    const value = {
      metadata,
      entityRef: toLowercaseEntityRefMaybe(entityRef, config),
      entityMetadata,
      shadowRoot,
      setShadowRoot,
      title,
      setTitle,
      subtitle,
      setSubtitle
    };
    const versionedValue = createVersionedValueMap({ 1: value });
    return /* @__PURE__ */ React.createElement(
      AnalyticsContext,
      {
        attributes: { entityRef: stringifyEntityRef(entityRef) }
      },
      /* @__PURE__ */ React.createElement(TechDocsReaderPageContext.Provider, { value: versionedValue }, children instanceof Function ? children(value) : children)
    );
  },
  (prevProps, nextProps) => {
    return areEntityRefsEqual(prevProps.entityRef, nextProps.entityRef);
  }
);
const useTechDocsReaderPage = () => {
  const versionedContext = useContext(TechDocsReaderPageContext);
  if (versionedContext === void 0) {
    return defaultTechDocsReaderPageValue;
  }
  const context = versionedContext.atVersion(1);
  if (context === void 0) {
    throw new Error("No context found for version 1.");
  }
  return context;
};

const TechDocsAddonLocations = Object.freeze({
  /**
   * These addons fill up the header from the right, on the same line as the
   * title.
   */
  Header: "Header",
  /**
   * These addons appear below the header and above all content; tooling addons
   * can be inserted for convenience.
   */
  Subheader: "Subheader",
  /**
   * These addons are items added to the settings menu list and are designed to make
   * the reader experience customizable, for example accessibility options
   */
  Settings: "Settings",
  /**
   * These addons appear left of the content and above the navigation.
   */
  PrimarySidebar: "PrimarySidebar",
  /**
   * These addons appear right of the content and above the table of contents.
   */
  SecondarySidebar: "SecondarySidebar",
  /**
   * A virtual location which allows mutation of all content within the shadow
   * root by transforming DOM nodes. These addons should return null on render.
   */
  Content: "Content"
  /**
   * todo(backstage/community): This is a proposed virtual location which would
   * help implement a common addon pattern in which many instances of a given
   * element in markdown would be dynamically replaced at render-time based on
   * attributes provided on that element, for example:
   *
   * ```md
   * ## For Fun
   * <TechDocsAddon>CatGif</TechDocsAddon>
   *
   * ## Component Metadata
   * <TechDocsAddon entityRef="default:component/some-component-name">CatalogEntityCard</TechDocsAddon>
   *
   * ## System Metadata
   * <TechDocsAddon entityRef="default:system/some-system-name">CatalogEntityCard</TechDocsAddon>
   * ```
   *
   * Could correspond to a TechDocs addon named `CatalogEntityCard` with
   * location `TechDocsAddonLocations.COMPONENT`, whose `component` would be
   * the react component that would be rendered in place of all instances of
   * the markdown illustrated above.
   *
   * The `@backstage/plugin-techdocs-react` package would need to be updated to, in
   * cases where such addons had been registered, find all instances of the
   * the `<TechDocsAddon>` tag whose `textContent` corresponded with the name of the
   * addon, then replace them with component instances of the addon component,
   * passing any attributes from the tag as props to the component.
   */
  // Component: 'Component',
});

const SHADOW_DOM_STYLE_LOAD_EVENT = "TECH_DOCS_SHADOW_DOM_STYLE_LOAD";
const useShadowDomStylesEvents = (element) => {
  useEffect(() => {
    var _a;
    if (!element) {
      return () => {
      };
    }
    const styles = element.querySelectorAll(
      'head > link[rel="stylesheet"]'
    );
    let count = (_a = styles == null ? void 0 : styles.length) != null ? _a : 0;
    const event = new CustomEvent(SHADOW_DOM_STYLE_LOAD_EVENT);
    if (!count) {
      element.dispatchEvent(event);
      return () => {
      };
    }
    const handleLoad = () => {
      if (--count === 0) {
        element.dispatchEvent(event);
      }
    };
    styles == null ? void 0 : styles.forEach((style) => {
      style.addEventListener("load", handleLoad);
    });
    return () => {
      styles == null ? void 0 : styles.forEach((style) => {
        style.removeEventListener("load", handleLoad);
      });
    };
  }, [element]);
};
const useShadowDomStylesLoading = (element) => {
  const [loading, setLoading] = useState(false);
  useEffect(() => {
    if (!element)
      return () => {
      };
    setLoading(true);
    const style = element.style;
    style.setProperty("opacity", "0");
    const handleLoad = () => {
      setLoading(false);
      style.setProperty("opacity", "1");
    };
    element.addEventListener(SHADOW_DOM_STYLE_LOAD_EVENT, handleLoad);
    return () => {
      element.removeEventListener(SHADOW_DOM_STYLE_LOAD_EVENT, handleLoad);
    };
  }, [element]);
  return loading;
};
const TechDocsShadowDom = (props) => {
  const { element, onAppend, children } = props;
  const [jss, setJss] = useState(
    create({
      ...jssPreset(),
      insertionPoint: void 0
    })
  );
  useShadowDomStylesEvents(element);
  const loading = useShadowDomStylesLoading(element);
  const ref = useCallback(
    (shadowHost) => {
      if (!element || !shadowHost)
        return;
      setJss(
        create({
          ...jssPreset(),
          insertionPoint: element.querySelector("head") || void 0
        })
      );
      let shadowRoot = shadowHost.shadowRoot;
      if (!shadowRoot) {
        shadowRoot = shadowHost.attachShadow({ mode: "open" });
      }
      shadowRoot.replaceChildren(element);
      if (typeof onAppend === "function") {
        onAppend(shadowRoot);
      }
    },
    [element, onAppend]
  );
  return /* @__PURE__ */ React.createElement(React.Fragment, null, loading && /* @__PURE__ */ React.createElement(Progress, null), /* @__PURE__ */ React.createElement(StylesProvider, { jss, sheetsManager: /* @__PURE__ */ new Map() }, /* @__PURE__ */ React.createElement("div", { ref, "data-testid": "techdocs-native-shadowroot" }), children));
};

const useShadowRoot = () => {
  const { shadowRoot } = useTechDocsReaderPage();
  return shadowRoot;
};
const useShadowRootElements = (selectors) => {
  const shadowRoot = useShadowRoot();
  if (!shadowRoot)
    return [];
  return selectors.map((selector) => shadowRoot == null ? void 0 : shadowRoot.querySelectorAll(selector)).filter((nodeList) => nodeList.length).map((nodeList) => Array.from(nodeList)).flat();
};
const isValidSelection = (newSelection) => {
  return newSelection.toString() && newSelection.rangeCount && newSelection.getRangeAt(0).getBoundingClientRect().top;
};
const useShadowRootSelection = (waitMillis = 0) => {
  const shadowRoot = useShadowRoot();
  const [selection, setSelection] = useState(null);
  const handleSelectionChange = useMemo(
    () => debounce(() => {
      const shadowDocument = shadowRoot;
      const newSelection = shadowDocument.getSelection ? shadowDocument.getSelection() : document.getSelection();
      if (newSelection && isValidSelection(newSelection)) {
        setSelection(newSelection);
      } else {
        setSelection(null);
      }
    }, waitMillis),
    [shadowRoot, setSelection, waitMillis]
  );
  useEffect(() => {
    window.document.addEventListener("selectionchange", handleSelectionChange);
    return () => {
      handleSelectionChange.cancel();
      window.document.removeEventListener(
        "selectionchange",
        handleSelectionChange
      );
    };
  }, [handleSelectionChange]);
  return selection;
};

export { SHADOW_DOM_STYLE_LOAD_EVENT, TECHDOCS_ADDONS_KEY, TECHDOCS_ADDONS_WRAPPER_KEY, TechDocsAddonLocations, TechDocsAddons, TechDocsReaderPageProvider, TechDocsShadowDom, createTechDocsAddonExtension, techdocsApiRef, techdocsStorageApiRef, toLowercaseEntityRefMaybe, useShadowDomStylesLoading, useShadowRoot, useShadowRootElements, useShadowRootSelection, useTechDocsAddons, useTechDocsReaderPage };
//# sourceMappingURL=index.esm.js.map
