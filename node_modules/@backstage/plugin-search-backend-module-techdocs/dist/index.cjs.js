'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var catalogClient = require('@backstage/catalog-client');
var catalogModel = require('@backstage/catalog-model');
var alpha = require('@backstage/plugin-catalog-common/alpha');
var unescape = require('lodash/unescape');
var fetch = require('node-fetch');
var pLimit = require('p-limit');
var stream = require('stream');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var unescape__default = /*#__PURE__*/_interopDefaultLegacy(unescape);
var fetch__default = /*#__PURE__*/_interopDefaultLegacy(fetch);
var pLimit__default = /*#__PURE__*/_interopDefaultLegacy(pLimit);

const getDocumentText = (entity) => {
  var _a, _b, _c, _d;
  const documentTexts = [];
  documentTexts.push(entity.metadata.description || "");
  if (catalogModel.isUserEntity(entity) || catalogModel.isGroupEntity(entity)) {
    if ((_b = (_a = entity.spec) == null ? void 0 : _a.profile) == null ? void 0 : _b.displayName) {
      documentTexts.push(entity.spec.profile.displayName);
    }
  }
  if (catalogModel.isUserEntity(entity)) {
    if ((_d = (_c = entity.spec) == null ? void 0 : _c.profile) == null ? void 0 : _d.email) {
      documentTexts.push(entity.spec.profile.email);
    }
  }
  return documentTexts.join(" : ");
};
const defaultTechDocsCollatorEntityTransformer = (entity) => {
  var _a, _b, _c, _d, _e, _f;
  return {
    kind: entity.kind,
    namespace: entity.metadata.namespace || "default",
    annotations: entity.metadata.annotations || "",
    name: entity.metadata.name || "",
    title: entity.metadata.title || "",
    text: getDocumentText(entity),
    componentType: ((_b = (_a = entity.spec) == null ? void 0 : _a.type) == null ? void 0 : _b.toString()) || "other",
    type: ((_d = (_c = entity.spec) == null ? void 0 : _c.type) == null ? void 0 : _d.toString()) || "other",
    lifecycle: ((_e = entity.spec) == null ? void 0 : _e.lifecycle) || "",
    owner: ((_f = entity.spec) == null ? void 0 : _f.owner) || "",
    path: ""
  };
};

var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
class DefaultTechDocsCollatorFactory {
  constructor(options) {
    __publicField(this, "type", "techdocs");
    __publicField(this, "visibilityPermission", alpha.catalogEntityReadPermission);
    __publicField(this, "discovery");
    __publicField(this, "locationTemplate");
    __publicField(this, "logger");
    __publicField(this, "catalogClient");
    __publicField(this, "tokenManager");
    __publicField(this, "parallelismLimit");
    __publicField(this, "legacyPathCasing");
    __publicField(this, "entityTransformer");
    var _a, _b, _c;
    this.discovery = options.discovery;
    this.locationTemplate = options.locationTemplate || "/docs/:namespace/:kind/:name/:path";
    this.logger = options.logger.child({ documentType: this.type });
    this.catalogClient = options.catalogClient || new catalogClient.CatalogClient({ discoveryApi: options.discovery });
    this.parallelismLimit = (_a = options.parallelismLimit) != null ? _a : 10;
    this.legacyPathCasing = (_b = options.legacyPathCasing) != null ? _b : false;
    this.tokenManager = options.tokenManager;
    this.entityTransformer = (_c = options.entityTransformer) != null ? _c : defaultTechDocsCollatorEntityTransformer;
  }
  static fromConfig(config, options) {
    const legacyPathCasing = config.getOptionalBoolean(
      "techdocs.legacyUseCaseSensitiveTripletPaths"
    ) || false;
    const locationTemplate = config.getOptionalString(
      "search.collators.techdocs.locationTemplate"
    );
    const parallelismLimit = config.getOptionalNumber(
      "search.collators.techdocs.parallelismLimit"
    );
    return new DefaultTechDocsCollatorFactory({
      ...options,
      locationTemplate,
      parallelismLimit,
      legacyPathCasing
    });
  }
  async getCollator() {
    return stream.Readable.from(this.execute());
  }
  async *execute() {
    const limit = pLimit__default["default"](this.parallelismLimit);
    const techDocsBaseUrl = await this.discovery.getBaseUrl("techdocs");
    const { token } = await this.tokenManager.getToken();
    let entitiesRetrieved = 0;
    let moreEntitiesToGet = true;
    const batchSize = this.parallelismLimit * 50;
    while (moreEntitiesToGet) {
      const entities = (await this.catalogClient.getEntities(
        {
          filter: {
            "metadata.annotations.backstage.io/techdocs-ref": catalogClient.CATALOG_FILTER_EXISTS
          },
          limit: batchSize,
          offset: entitiesRetrieved
        },
        { token }
      )).items;
      moreEntitiesToGet = entities.length === batchSize;
      entitiesRetrieved += entities.length;
      const docPromises = entities.filter((it) => {
        var _a, _b;
        return (_b = (_a = it.metadata) == null ? void 0 : _a.annotations) == null ? void 0 : _b["backstage.io/techdocs-ref"];
      }).map(
        (entity) => limit(async () => {
          const entityInfo = DefaultTechDocsCollatorFactory.handleEntityInfoCasing(
            this.legacyPathCasing,
            {
              kind: entity.kind,
              namespace: entity.metadata.namespace || "default",
              name: entity.metadata.name
            }
          );
          try {
            const searchIndexResponse = await fetch__default["default"](
              DefaultTechDocsCollatorFactory.constructDocsIndexUrl(
                techDocsBaseUrl,
                entityInfo
              ),
              {
                headers: {
                  Authorization: `Bearer ${token}`
                }
              }
            );
            const searchIndex = await Promise.race([
              searchIndexResponse.json(),
              new Promise((_resolve, reject) => {
                setTimeout(() => {
                  reject("Could not parse JSON in 5 seconds.");
                }, 5e3);
              })
            ]);
            return searchIndex.docs.map((doc) => {
              var _a, _b, _c;
              return {
                ...this.entityTransformer(entity),
                title: unescape__default["default"](doc.title),
                text: unescape__default["default"](doc.text || ""),
                location: this.applyArgsToFormat(
                  this.locationTemplate || "/docs/:namespace/:kind/:name/:path",
                  {
                    ...entityInfo,
                    path: doc.location
                  }
                ),
                path: doc.location,
                ...entityInfo,
                entityTitle: entity.metadata.title,
                componentType: ((_b = (_a = entity.spec) == null ? void 0 : _a.type) == null ? void 0 : _b.toString()) || "other",
                lifecycle: ((_c = entity.spec) == null ? void 0 : _c.lifecycle) || "",
                owner: getSimpleEntityOwnerString(entity),
                authorization: {
                  resourceRef: catalogModel.stringifyEntityRef(entity)
                }
              };
            });
          } catch (e) {
            this.logger.debug(
              `Failed to retrieve tech docs search index for entity ${entityInfo.namespace}/${entityInfo.kind}/${entityInfo.name}`,
              e
            );
            return [];
          }
        })
      );
      yield* (await Promise.all(docPromises)).flat();
    }
  }
  applyArgsToFormat(format, args) {
    let formatted = format;
    for (const [key, value] of Object.entries(args)) {
      formatted = formatted.replace(`:${key}`, value);
    }
    return formatted;
  }
  static constructDocsIndexUrl(techDocsBaseUrl, entityInfo) {
    return `${techDocsBaseUrl}/static/docs/${entityInfo.namespace}/${entityInfo.kind}/${entityInfo.name}/search/search_index.json`;
  }
  static handleEntityInfoCasing(legacyPaths, entityInfo) {
    return legacyPaths ? entityInfo : Object.entries(entityInfo).reduce((acc, [key, value]) => {
      return { ...acc, [key]: value.toLocaleLowerCase("en-US") };
    }, {});
  }
}
function getSimpleEntityOwnerString(entity) {
  if (entity.relations) {
    const owner = entity.relations.find((r) => r.type === catalogModel.RELATION_OWNED_BY);
    if (owner) {
      const { name } = catalogModel.parseEntityRef(owner.targetRef);
      return name;
    }
  }
  return "";
}

exports.DefaultTechDocsCollatorFactory = DefaultTechDocsCollatorFactory;
exports.defaultTechDocsCollatorEntityTransformer = defaultTechDocsCollatorEntityTransformer;
//# sourceMappingURL=index.cjs.js.map
