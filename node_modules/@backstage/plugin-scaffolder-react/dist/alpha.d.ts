/// <reference types="react" />
import { JsonObject, JsonValue } from '@backstage/types';
import * as React from 'react';
import React__default, { ComponentType, ReactNode, PropsWithChildren, ReactElement } from 'react';
import { TemplatePresentationV1beta3, TemplateEntityV1beta3, TaskStep } from '@backstage/plugin-scaffolder-common';
import { UiSchema, FieldValidation } from '@rjsf/utils';
import { TemplateParameterSchema, FieldExtensionOptions, FormProps, ReviewStepProps, LayoutOptions, CustomFieldValidator, TemplateGroupFilter, ScaffolderTaskOutput, ScaffolderRJSFFormProps, ScaffolderStep, CustomFieldExtensionSchema, ScaffolderRJSFFieldProps, FieldExtensionComponent } from '@backstage/plugin-scaffolder-react';
import { ApiHolder, IconComponent, Extension } from '@backstage/core-plugin-api';

/**
 * This is the parsed template schema that is returned from the {@link useTemplateSchema} hook.
 * @alpha
 */
interface ParsedTemplateSchema {
    uiSchema: UiSchema;
    mergedSchema: JsonObject;
    schema: JsonObject;
    title: string;
    description?: string;
}
/**
 * This hook will parse the template schema and return the steps with the
 * parsed schema and uiSchema. Filtering out any steps or properties that
 * are not enabled with feature flags.
 * @alpha
 */
declare const useTemplateSchema: (manifest: TemplateParameterSchema) => {
    steps: ParsedTemplateSchema[];
    presentation?: TemplatePresentationV1beta3 | undefined;
};

/**
 * The props for the {@link ReviewState} component.
 * @alpha
 */
type ReviewStateProps = {
    schemas: ParsedTemplateSchema[];
    formState: JsonObject;
};
/**
 * The component used by the {@link Stepper} to render the review step.
 * @alpha
 */
declare const ReviewState: (props: ReviewStateProps) => React__default.JSX.Element;

/**
 * The Props for {@link Stepper} component
 * @alpha
 */
type StepperProps = {
    manifest: TemplateParameterSchema;
    extensions: FieldExtensionOptions<any, any>[];
    templateName?: string;
    formProps?: FormProps;
    initialState?: Record<string, JsonValue>;
    onCreate: (values: Record<string, JsonValue>) => Promise<void>;
    components?: {
        ReviewStepComponent?: ComponentType<ReviewStepProps>;
        ReviewStateComponent?: (props: ReviewStateProps) => JSX.Element;
        backButtonText?: ReactNode;
        createButtonText?: ReactNode;
        reviewButtonText?: ReactNode;
    };
    layouts?: LayoutOptions[];
};
/**
 * The `Stepper` component is the Wizard that is rendered when a user selects a template
 * @alpha
 */
declare const Stepper: (stepperProps: StepperProps) => React__default.JSX.Element;

/** @alpha */
type FormValidation = {
    [name: string]: FieldValidation | FormValidation;
};
/** @alpha */
declare const createAsyncValidators: (rootSchema: JsonObject, validators: Record<string, undefined | CustomFieldValidator<unknown, unknown>>, context: {
    apiHolder: ApiHolder;
}) => (formData: JsonObject) => Promise<FormValidation>;

/**
 * The Props for the {@link TemplateCard} component
 * @alpha
 */
interface TemplateCardProps {
    template: TemplateEntityV1beta3;
    additionalLinks?: {
        icon: IconComponent;
        text: string;
        url: string;
    }[];
    onSelected?: (template: TemplateEntityV1beta3) => void;
}
/**
 * The `TemplateCard` component that is rendered in a list for each template
 * @alpha
 */
declare const TemplateCard: (props: TemplateCardProps) => React__default.JSX.Element;

/**
 * The props for the {@link TemplateGroup} component.
 * @alpha
 */
interface TemplateGroupProps {
    templates: {
        template: TemplateEntityV1beta3;
        additionalLinks?: {
            icon: IconComponent;
            text: string;
            url: string;
        }[];
    }[];
    onSelected: (template: TemplateEntityV1beta3) => void;
    title: React__default.ReactNode;
    components?: {
        CardComponent?: React__default.ComponentType<TemplateCardProps>;
    };
}
/**
 * The `TemplateGroup` component is used to display a group of templates with a title.
 * @alpha
 */
declare const TemplateGroup: (props: TemplateGroupProps) => React__default.JSX.Element | null;

/**
 * @alpha
 */
interface TemplateGroupsProps {
    groups: TemplateGroupFilter[];
    templateFilter?: (entity: TemplateEntityV1beta3) => boolean;
    TemplateCardComponent?: React__default.ComponentType<{
        template: TemplateEntityV1beta3;
    }>;
    onTemplateSelected?: (template: TemplateEntityV1beta3) => void;
    additionalLinksForEntity?: (template: TemplateEntityV1beta3) => {
        icon: IconComponent;
        text: string;
        url: string;
    }[];
}
/**
 * @alpha
 */
declare const TemplateGroups: (props: TemplateGroupsProps) => React__default.JSX.Element | null;

/**
 * @alpha
 */
type WorkflowProps = {
    title?: string;
    description?: string;
    namespace: string;
    templateName: string;
    components?: {
        ReviewStepComponent?: React__default.ComponentType<ReviewStepProps>;
    };
    onError(error: Error | undefined): JSX.Element | null;
} & Pick<StepperProps, 'extensions' | 'formProps' | 'components' | 'onCreate' | 'initialState' | 'layouts'>;
/**
 * @alpha
 */
declare const Workflow: (workflowProps: WorkflowProps) => JSX.Element | null;
/**
 * @alpha
 */
declare const EmbeddableWorkflow: (props: WorkflowProps) => React__default.JSX.Element;

/**
 * The DefaultOutputs renderer for the scaffolder task output
 *
 * @alpha
 */
declare const DefaultTemplateOutputs: (props: {
    output?: ScaffolderTaskOutput;
}) => React__default.JSX.Element | null;

/**
 * The Form component
 * @alpha
 */
declare const Form: (props: PropsWithChildren<ScaffolderRJSFFormProps>) => React__default.JSX.Element;

/**
 * Props for the TaskSteps component
 *
 * @alpha
 */
interface TaskStepsProps {
    steps: (TaskStep & ScaffolderStep)[];
    activeStep?: number;
    isComplete?: boolean;
    isError?: boolean;
}
/**
 * The visual stepper of the task event stream
 *
 * @alpha
 */
declare const TaskSteps: (props: TaskStepsProps) => React__default.JSX.Element;

/**
 * The text of the event stream
 *
 * @alpha
 */
declare const TaskLogStream: (props: {
    logs: {
        [k: string]: string[];
    };
}) => React__default.JSX.Element;

/**
 * The Category Picker that is rendered on the left side for picking
 * categories and filtering the template list.
 * @alpha
 */
declare const TemplateCategoryPicker: () => React__default.JSX.Element | null;

/**
 * @alpha
 */
type ScaffolderPageContextMenuProps = {
    onEditorClicked?: () => void;
    onActionsClicked?: () => void;
    onTasksClicked?: () => void;
};
/**
 * @alpha
 */
declare function ScaffolderPageContextMenu(props: ScaffolderPageContextMenuProps): React__default.JSX.Element | null;

/**
 * Props for the {@link ScaffolderField} component
 * @alpha
 */
interface ScaffolderFieldProps {
    rawDescription?: string;
    errors?: ReactElement;
    rawErrors?: string[];
    help?: ReactElement;
    rawHelp?: string;
    required?: boolean;
    disabled?: boolean;
    displayLabel?: boolean;
}
/**
 * A component to wrap up a input field which helps with formatting and supporting markdown
 * on the field types
 * @alpha
 */
declare const ScaffolderField: (props: PropsWithChildren<ScaffolderFieldProps>) => React__default.JSX.Element;

/**
 * Takes a step from a Backstage Template Manifest and converts it to a JSON Schema and UI Schema for rjsf
 * @alpha
 */
declare const extractSchemaFromStep: (inputStep: JsonObject) => {
    uiSchema: UiSchema;
    schema: JsonObject;
};
/**
 * Creates a field validation object for use in react jsonschema form
 * @alpha
 */
declare const createFieldValidation: () => FieldValidation;

/**
 * This hook is used to get the formData from the query string.
 * @alpha
 */
declare const useFormDataFromQuery: (initialState?: Record<string, JsonValue>) => [Record<string, any>, React.Dispatch<React.SetStateAction<Record<string, any>>>];

/**
 * @alpha
 */
declare const useTemplateParameterSchema: (templateRef: string) => {
    manifest: TemplateParameterSchema | undefined;
    loading: boolean;
    error: Error | undefined;
};

/**
 * Returns manifest of software templates with steps without a featureFlag tag.
 * @alpha
 */
declare const useFilteredSchemaProperties: (manifest: TemplateParameterSchema | undefined) => TemplateParameterSchema | undefined;

/**
 * Field validation type for Custom Field Extensions.
 *
 * @alpha
 */
type LegacyCustomFieldValidator<TFieldReturnValue> = (data: TFieldReturnValue, field: FieldValidation, context: {
    apiHolder: ApiHolder;
}) => void | Promise<void>;
/**
 * Type for the Custom Field Extension with the
 * name and components and validation function.
 *
 * @alpha
 */
type LegacyFieldExtensionOptions<TFieldReturnValue = unknown, TInputProps = unknown> = {
    name: string;
    component: (props: LegacyFieldExtensionComponentProps<TFieldReturnValue, TInputProps>) => JSX.Element | null;
    validation?: LegacyCustomFieldValidator<TFieldReturnValue>;
    schema?: CustomFieldExtensionSchema;
};
/**
 * Type for field extensions and being able to type
 * incoming props easier.
 *
 * @alpha
 */
interface LegacyFieldExtensionComponentProps<TFieldReturnValue, TUiOptions = unknown> extends ScaffolderRJSFFieldProps<TFieldReturnValue> {
    uiSchema: ScaffolderRJSFFieldProps['uiSchema'] & {
        'ui:options'?: TUiOptions;
    };
}

/**
 * Method for creating field extensions that can be used in the scaffolder
 * frontend form.
 * @alpha
 */
declare function createLegacyScaffolderFieldExtension<TReturnValue = unknown, TInputProps = unknown>(options: LegacyFieldExtensionOptions<TReturnValue, TInputProps>): Extension<FieldExtensionComponent<TReturnValue, TInputProps>>;

export { DefaultTemplateOutputs, EmbeddableWorkflow, Form, FormValidation, LegacyCustomFieldValidator, LegacyFieldExtensionComponentProps, LegacyFieldExtensionOptions, ParsedTemplateSchema, ReviewState, ReviewStateProps, ScaffolderField, ScaffolderFieldProps, ScaffolderPageContextMenu, ScaffolderPageContextMenuProps, Stepper, StepperProps, TaskLogStream, TaskSteps, TaskStepsProps, TemplateCard, TemplateCardProps, TemplateCategoryPicker, TemplateGroup, TemplateGroupProps, TemplateGroups, TemplateGroupsProps, Workflow, WorkflowProps, createAsyncValidators, createFieldValidation, createLegacyScaffolderFieldExtension, extractSchemaFromStep, useFilteredSchemaProperties, useFormDataFromQuery, useTemplateParameterSchema, useTemplateSchema };
