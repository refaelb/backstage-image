import { createVersionedContext, createVersionedValueMap, getOrCreateGlobalSingleton } from '@backstage/version-bridge';
import React, { useState, useContext, useCallback } from 'react';
import { createApiRef } from '@backstage/core-plugin-api';

const FIELD_EXTENSION_WRAPPER_KEY = "scaffolder.extensions.wrapper.v1";
const FIELD_EXTENSION_KEY = "scaffolder.extensions.field.v1";

const SecretsContext = createVersionedContext("secrets-context");
const SecretsContextProvider = (props) => {
  const [secrets, setSecrets] = useState({});
  return /* @__PURE__ */ React.createElement(
    SecretsContext.Provider,
    {
      value: createVersionedValueMap({ 1: { secrets, setSecrets } })
    },
    props.children
  );
};
const useTemplateSecrets = () => {
  var _a;
  const value = (_a = useContext(SecretsContext)) == null ? void 0 : _a.atVersion(1);
  if (!value) {
    throw new Error(
      "useTemplateSecrets must be used within a SecretsContextProvider"
    );
  }
  const { setSecrets: updateSecrets, secrets = {} } = value;
  const setSecrets = useCallback(
    (input) => {
      updateSecrets((currentSecrets) => ({ ...currentSecrets, ...input }));
    },
    [updateSecrets]
  );
  return { setSecrets, secrets };
};

const scaffolderApiRef = getOrCreateGlobalSingleton(
  "scaffolder:scaffolder-api-ref",
  () => createApiRef({
    id: "plugin.scaffolder.service"
  })
);

export { FIELD_EXTENSION_WRAPPER_KEY as F, SecretsContextProvider as S, FIELD_EXTENSION_KEY as a, scaffolderApiRef as s, useTemplateSecrets as u };
//# sourceMappingURL=ref-6fdfc121.esm.js.map
