'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var backendPluginApi = require('@backstage/backend-plugin-api');
var pluginAuthNode = require('@backstage/plugin-auth-node');
var alpha = require('@backstage/plugin-catalog-node/alpha');
var express = require('express');
var Router = require('express-promise-router');
var cookieParser = require('cookie-parser');
var pluginAuthBackendModuleAtlassianProvider = require('@backstage/plugin-auth-backend-module-atlassian-provider');
var Auth0InternalStrategy = require('passport-auth0');
var crypto = require('crypto');
var url = require('url');
var errors = require('@backstage/errors');
var jwtDecoder = require('jwt-decode');
var fetch = require('node-fetch');
var NodeCache = require('node-cache');
var jose = require('jose');
var passportBitbucketOauth2 = require('passport-bitbucket-oauth2');
var pluginAuthBackendModuleGcpIapProvider = require('@backstage/plugin-auth-backend-module-gcp-iap-provider');
var pluginAuthBackendModuleGithubProvider = require('@backstage/plugin-auth-backend-module-github-provider');
var pluginAuthBackendModuleGitlabProvider = require('@backstage/plugin-auth-backend-module-gitlab-provider');
var pluginAuthBackendModuleGoogleProvider = require('@backstage/plugin-auth-backend-module-google-provider');
var passportMicrosoft = require('passport-microsoft');
var pluginAuthBackendModuleOauth2Provider = require('@backstage/plugin-auth-backend-module-oauth2-provider');
var pluginAuthBackendModuleOauth2ProxyProvider = require('@backstage/plugin-auth-backend-module-oauth2-proxy-provider');
var openidClient = require('openid-client');
var pluginAuthBackendModuleOktaProvider = require('@backstage/plugin-auth-backend-module-okta-provider');
var passportOneloginOauth = require('passport-onelogin-oauth');
var passportSaml = require('passport-saml');
var passportOauth2 = require('passport-oauth2');
var catalogClient = require('@backstage/catalog-client');
var catalogModel = require('@backstage/catalog-model');
var luxon = require('luxon');
var uuid = require('uuid');
var firestore = require('@google-cloud/firestore');
var lodash = require('lodash');
var fs = require('fs');
var session = require('express-session');
var connectSessionKnex = require('connect-session-knex');
var passport = require('passport');
var minimatch = require('minimatch');
var backendCommon = require('@backstage/backend-common');
var config = require('@backstage/config');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var express__default = /*#__PURE__*/_interopDefaultLegacy(express);
var Router__default = /*#__PURE__*/_interopDefaultLegacy(Router);
var cookieParser__default = /*#__PURE__*/_interopDefaultLegacy(cookieParser);
var Auth0InternalStrategy__default = /*#__PURE__*/_interopDefaultLegacy(Auth0InternalStrategy);
var crypto__default = /*#__PURE__*/_interopDefaultLegacy(crypto);
var crypto__namespace = /*#__PURE__*/_interopNamespace(crypto);
var jwtDecoder__default = /*#__PURE__*/_interopDefaultLegacy(jwtDecoder);
var fetch__default = /*#__PURE__*/_interopDefaultLegacy(fetch);
var NodeCache__default = /*#__PURE__*/_interopDefaultLegacy(NodeCache);
var session__default = /*#__PURE__*/_interopDefaultLegacy(session);
var connectSessionKnex__default = /*#__PURE__*/_interopDefaultLegacy(connectSessionKnex);
var passport__default = /*#__PURE__*/_interopDefaultLegacy(passport);

function createAuthProviderIntegration(config) {
  var _a;
  return Object.freeze({
    ...config,
    resolvers: Object.freeze((_a = config.resolvers) != null ? _a : {})
  });
}

function adaptLegacyOAuthHandler(authHandler) {
  return authHandler && (async (result, ctx) => authHandler(
    {
      fullProfile: result.fullProfile,
      accessToken: result.session.accessToken,
      params: {
        scope: result.session.scope,
        id_token: result.session.idToken,
        token_type: result.session.tokenType,
        expires_in: result.session.expiresInSeconds
      }
    },
    ctx
  ));
}

function adaptLegacyOAuthSignInResolver(signInResolver) {
  return signInResolver && (async (input, ctx) => signInResolver(
    {
      profile: input.profile,
      result: {
        fullProfile: input.result.fullProfile,
        accessToken: input.result.session.accessToken,
        refreshToken: input.result.session.refreshToken,
        params: {
          scope: input.result.session.scope,
          id_token: input.result.session.idToken,
          token_type: input.result.session.tokenType,
          expires_in: input.result.session.expiresInSeconds
        }
      }
    },
    ctx
  ));
}

function adaptOAuthSignInResolverToLegacy(resolvers) {
  const legacyResolvers = {};
  for (const name of Object.keys(resolvers)) {
    const resolver = resolvers[name];
    legacyResolvers[name] = () => async (input, ctx) => {
      var _a;
      return resolver(
        {
          profile: input.profile,
          result: {
            fullProfile: input.result.fullProfile,
            session: {
              accessToken: input.result.accessToken,
              expiresInSeconds: input.result.params.expires_in,
              scope: input.result.params.scope,
              idToken: input.result.params.id_token,
              tokenType: (_a = input.result.params.token_type) != null ? _a : "bearer",
              refreshToken: input.result.refreshToken
            }
          }
        },
        ctx
      );
    };
  }
  return legacyResolvers;
}

const atlassian = createAuthProviderIntegration({
  create(options) {
    var _a;
    return pluginAuthNode.createOAuthProviderFactory({
      authenticator: pluginAuthBackendModuleAtlassianProvider.atlassianAuthenticator,
      profileTransform: adaptLegacyOAuthHandler(options == null ? void 0 : options.authHandler),
      signInResolver: adaptLegacyOAuthSignInResolver((_a = options == null ? void 0 : options.signIn) == null ? void 0 : _a.resolver)
    });
  }
});

class Auth0Strategy extends Auth0InternalStrategy__default["default"] {
  constructor(options, verify) {
    const optionsWithURLs = {
      ...options,
      authorizationURL: `https://${options.domain}/authorize`,
      tokenURL: `https://${options.domain}/oauth/token`,
      userInfoURL: `https://${options.domain}/userinfo`,
      apiUrl: `https://${options.domain}/api`
    };
    super(optionsWithURLs, verify);
  }
}

const OAuthEnvironmentHandler = pluginAuthNode.OAuthEnvironmentHandler;

const readState = pluginAuthNode.decodeOAuthState;
const encodeState = pluginAuthNode.encodeOAuthState;
const verifyNonce = (req, providerId) => {
  var _a, _b;
  const cookieNonce = req.cookies[`${providerId}-nonce`];
  const state = readState((_b = (_a = req.query.state) == null ? void 0 : _a.toString()) != null ? _b : "");
  const stateNonce = state.nonce;
  if (!cookieNonce) {
    throw new Error("Auth response is missing cookie nonce");
  }
  if (stateNonce.length === 0) {
    throw new Error("Auth response is missing state nonce");
  }
  if (cookieNonce !== stateNonce) {
    throw new Error("Invalid nonce");
  }
};
const defaultCookieConfigurer = ({
  callbackUrl,
  providerId,
  appOrigin
}) => {
  const { hostname: domain, pathname, protocol } = new URL(callbackUrl);
  const secure = protocol === "https:";
  let sameSite = "lax";
  if (new URL(appOrigin).hostname !== domain && secure) {
    sameSite = "none";
  }
  const path = pathname.endsWith(`${providerId}/handler/frame`) ? pathname.slice(0, -"/handler/frame".length) : `${pathname}/${providerId}`;
  return { domain, path, secure, sameSite };
};

const safelyEncodeURIComponent = (value) => {
  return encodeURIComponent(value).replace(/'/g, "%27");
};
const postMessageResponse = (res, appOrigin, response) => {
  const jsonData = JSON.stringify(response);
  const base64Data = safelyEncodeURIComponent(jsonData);
  const base64Origin = safelyEncodeURIComponent(appOrigin);
  const script = `
    var authResponse = decodeURIComponent('${base64Data}');
    var origin = decodeURIComponent('${base64Origin}');
    var originInfo = {'type': 'config_info', 'targetOrigin': origin};
    (window.opener || window.parent).postMessage(originInfo, '*');
    (window.opener || window.parent).postMessage(JSON.parse(authResponse), origin);
    setTimeout(() => {
      window.close();
    }, 100); // same as the interval of the core-app-api lib/loginPopup.ts (to address race conditions)
  `;
  const hash = crypto__default["default"].createHash("sha256").update(script).digest("base64");
  res.setHeader("Content-Type", "text/html");
  res.setHeader("X-Frame-Options", "sameorigin");
  res.setHeader("Content-Security-Policy", `script-src 'sha256-${hash}'`);
  res.end(`<html><body><script>${script}<\/script></body></html>`);
};
const ensuresXRequestedWith = (req) => {
  const requiredHeader = req.header("X-Requested-With");
  if (!requiredHeader || requiredHeader !== "XMLHttpRequest") {
    return false;
  }
  return true;
};

const prepareBackstageIdentityResponse = pluginAuthNode.prepareBackstageIdentityResponse;

var __defProp$f = Object.defineProperty;
var __defNormalProp$f = (obj, key, value) => key in obj ? __defProp$f(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$f = (obj, key, value) => {
  __defNormalProp$f(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
const THOUSAND_DAYS_MS = 1e3 * 24 * 60 * 60 * 1e3;
const TEN_MINUTES_MS = 600 * 1e3;
class OAuthAdapter {
  constructor(handlers, options) {
    this.handlers = handlers;
    this.options = options;
    __publicField$f(this, "baseCookieOptions");
    __publicField$f(this, "setNonceCookie", (res, nonce, cookieConfig) => {
      res.cookie(`${this.options.providerId}-nonce`, nonce, {
        maxAge: TEN_MINUTES_MS,
        ...this.baseCookieOptions,
        ...cookieConfig,
        path: `${cookieConfig.path}/handler`
      });
    });
    __publicField$f(this, "setGrantedScopeCookie", (res, scope, cookieConfig) => {
      res.cookie(`${this.options.providerId}-granted-scope`, scope, {
        maxAge: THOUSAND_DAYS_MS,
        ...this.baseCookieOptions,
        ...cookieConfig
      });
    });
    __publicField$f(this, "getRefreshTokenFromCookie", (req) => {
      return req.cookies[`${this.options.providerId}-refresh-token`];
    });
    __publicField$f(this, "getGrantedScopeFromCookie", (req) => {
      return req.cookies[`${this.options.providerId}-granted-scope`];
    });
    __publicField$f(this, "setRefreshTokenCookie", (res, refreshToken, cookieConfig) => {
      res.cookie(`${this.options.providerId}-refresh-token`, refreshToken, {
        maxAge: THOUSAND_DAYS_MS,
        ...this.baseCookieOptions,
        ...cookieConfig
      });
    });
    __publicField$f(this, "removeRefreshTokenCookie", (res, cookieConfig) => {
      res.cookie(`${this.options.providerId}-refresh-token`, "", {
        maxAge: 0,
        ...this.baseCookieOptions,
        ...cookieConfig
      });
    });
    __publicField$f(this, "getCookieConfig", (origin) => {
      return this.options.cookieConfigurer({
        providerId: this.options.providerId,
        baseUrl: this.options.baseUrl,
        callbackUrl: this.options.callbackUrl,
        appOrigin: origin != null ? origin : this.options.appOrigin
      });
    });
    this.baseCookieOptions = {
      httpOnly: true,
      sameSite: "lax"
    };
  }
  static fromConfig(config, handlers, options) {
    var _a;
    const { appUrl, baseUrl, isOriginAllowed } = config;
    const { origin: appOrigin } = new url.URL(appUrl);
    const cookieConfigurer = (_a = config.cookieConfigurer) != null ? _a : defaultCookieConfigurer;
    return new OAuthAdapter(handlers, {
      ...options,
      appOrigin,
      baseUrl,
      cookieConfigurer,
      isOriginAllowed
    });
  }
  async start(req, res) {
    var _a, _b, _c, _d, _e, _f;
    const scope = (_b = (_a = req.query.scope) == null ? void 0 : _a.toString()) != null ? _b : "";
    const env = (_c = req.query.env) == null ? void 0 : _c.toString();
    const origin = (_d = req.query.origin) == null ? void 0 : _d.toString();
    const redirectUrl = (_e = req.query.redirectUrl) == null ? void 0 : _e.toString();
    const flow = (_f = req.query.flow) == null ? void 0 : _f.toString();
    if (!env) {
      throw new errors.InputError("No env provided in request query parameters");
    }
    const cookieConfig = this.getCookieConfig(origin);
    const nonce = crypto__default["default"].randomBytes(16).toString("base64");
    this.setNonceCookie(res, nonce, cookieConfig);
    const state = { nonce, env, origin, redirectUrl, flow };
    if (this.options.persistScopes) {
      state.scope = scope;
    }
    const forwardReq = Object.assign(req, { scope, state });
    const { url, status } = await this.handlers.start(
      forwardReq
    );
    res.statusCode = status || 302;
    res.setHeader("Location", url);
    res.setHeader("Content-Length", "0");
    res.end();
  }
  async frameHandler(req, res) {
    var _a, _b;
    let appOrigin = this.options.appOrigin;
    try {
      const state = readState((_b = (_a = req.query.state) == null ? void 0 : _a.toString()) != null ? _b : "");
      if (state.origin) {
        try {
          appOrigin = new url.URL(state.origin).origin;
        } catch {
          throw new errors.NotAllowedError("App origin is invalid, failed to parse");
        }
        if (!this.options.isOriginAllowed(appOrigin)) {
          throw new errors.NotAllowedError(`Origin '${appOrigin}' is not allowed`);
        }
      }
      verifyNonce(req, this.options.providerId);
      const { response, refreshToken } = await this.handlers.handler(req);
      const cookieConfig = this.getCookieConfig(appOrigin);
      if (this.options.persistScopes && state.scope) {
        this.setGrantedScopeCookie(res, state.scope, cookieConfig);
        response.providerInfo.scope = state.scope;
      }
      if (refreshToken) {
        this.setRefreshTokenCookie(res, refreshToken, cookieConfig);
      }
      const identity = await this.populateIdentity(response.backstageIdentity);
      const responseObj = {
        type: "authorization_response",
        response: { ...response, backstageIdentity: identity }
      };
      if (state.flow === "redirect") {
        if (!state.redirectUrl) {
          throw new errors.InputError(
            "No redirectUrl provided in request query parameters"
          );
        }
        res.redirect(state.redirectUrl);
        return void 0;
      }
      return postMessageResponse(res, appOrigin, responseObj);
    } catch (error) {
      const { name, message } = errors.isError(error) ? error : new Error("Encountered invalid error");
      return postMessageResponse(res, appOrigin, {
        type: "authorization_response",
        error: { name, message }
      });
    }
  }
  async logout(req, res) {
    if (!ensuresXRequestedWith(req)) {
      throw new errors.AuthenticationError("Invalid X-Requested-With header");
    }
    if (this.handlers.logout) {
      const refreshToken = this.getRefreshTokenFromCookie(req);
      const revokeRequest = Object.assign(req, {
        refreshToken
      });
      await this.handlers.logout(revokeRequest);
    }
    const origin = req.get("origin");
    const cookieConfig = this.getCookieConfig(origin);
    this.removeRefreshTokenCookie(res, cookieConfig);
    res.status(200).end();
  }
  async refresh(req, res) {
    var _a, _b;
    if (!ensuresXRequestedWith(req)) {
      throw new errors.AuthenticationError("Invalid X-Requested-With header");
    }
    if (!this.handlers.refresh) {
      throw new errors.InputError(
        `Refresh token is not supported for provider ${this.options.providerId}`
      );
    }
    try {
      const refreshToken = this.getRefreshTokenFromCookie(req);
      if (!refreshToken) {
        throw new errors.InputError("Missing session cookie");
      }
      let scope = (_b = (_a = req.query.scope) == null ? void 0 : _a.toString()) != null ? _b : "";
      if (this.options.persistScopes) {
        scope = this.getGrantedScopeFromCookie(req);
      }
      const forwardReq = Object.assign(req, { scope, refreshToken });
      const { response, refreshToken: newRefreshToken } = await this.handlers.refresh(forwardReq);
      const backstageIdentity = await this.populateIdentity(
        response.backstageIdentity
      );
      if (newRefreshToken && newRefreshToken !== refreshToken) {
        const origin = req.get("origin");
        const cookieConfig = this.getCookieConfig(origin);
        this.setRefreshTokenCookie(res, newRefreshToken, cookieConfig);
      }
      res.status(200).json({ ...response, backstageIdentity });
    } catch (error) {
      throw new errors.AuthenticationError("Refresh failed", error);
    }
  }
  /**
   * If the response from the OAuth provider includes a Backstage identity, we
   * make sure it's populated with all the information we can derive from the user ID.
   */
  async populateIdentity(identity) {
    if (!identity) {
      return void 0;
    }
    if (!identity.token) {
      throw new errors.InputError(`Identity response must return a token`);
    }
    return prepareBackstageIdentityResponse(identity);
  }
}

const makeProfileInfo = (profile, idToken) => {
  var _a, _b;
  let email = void 0;
  if (profile.emails && profile.emails.length > 0) {
    const [firstEmail] = profile.emails;
    email = firstEmail.value;
  }
  let picture = void 0;
  if (profile.avatarUrl) {
    picture = profile.avatarUrl;
  } else if (profile.photos && profile.photos.length > 0) {
    const [firstPhoto] = profile.photos;
    picture = firstPhoto.value;
  }
  let displayName = (_b = (_a = profile.displayName) != null ? _a : profile.username) != null ? _b : profile.id;
  if ((!email || !picture || !displayName) && idToken) {
    try {
      const decoded = jwtDecoder__default["default"](idToken);
      if (!email && decoded.email) {
        email = decoded.email;
      }
      if (!picture && decoded.picture) {
        picture = decoded.picture;
      }
      if (!displayName && decoded.name) {
        displayName = decoded.name;
      }
    } catch (e) {
      throw new Error(`Failed to parse id token and get profile info, ${e}`);
    }
  }
  return {
    email,
    picture,
    displayName
  };
};
const executeRedirectStrategy = async (req, providerStrategy, options) => {
  return new Promise((resolve) => {
    const strategy = Object.create(providerStrategy);
    strategy.redirect = (url, status) => {
      resolve({ url, status: status != null ? status : void 0 });
    };
    strategy.authenticate(req, { ...options });
  });
};
const executeFrameHandlerStrategy = async (req, providerStrategy, options) => {
  return new Promise(
    (resolve, reject) => {
      const strategy = Object.create(providerStrategy);
      strategy.success = (result, privateInfo) => {
        resolve({ result, privateInfo });
      };
      strategy.fail = (info) => {
        var _a;
        reject(new Error(`Authentication rejected, ${(_a = info.message) != null ? _a : ""}`));
      };
      strategy.error = (error) => {
        var _a;
        let message = `Authentication failed, ${error.message}`;
        if ((_a = error.oauthError) == null ? void 0 : _a.data) {
          try {
            const errorData = JSON.parse(error.oauthError.data);
            if (errorData.message) {
              message += ` - ${errorData.message}`;
            }
          } catch (parseError) {
            message += ` - ${error.oauthError}`;
          }
        }
        reject(new Error(message));
      };
      strategy.redirect = () => {
        reject(new Error("Unexpected redirect"));
      };
      strategy.authenticate(req, { ...options != null ? options : {} });
    }
  );
};
const executeRefreshTokenStrategy = async (providerStrategy, refreshToken, scope) => {
  return new Promise((resolve, reject) => {
    const anyStrategy = providerStrategy;
    const OAuth2 = anyStrategy._oauth2.constructor;
    const oauth2 = new OAuth2(
      anyStrategy._oauth2._clientId,
      anyStrategy._oauth2._clientSecret,
      anyStrategy._oauth2._baseSite,
      anyStrategy._oauth2._authorizeUrl,
      anyStrategy._refreshURL || anyStrategy._oauth2._accessTokenUrl,
      anyStrategy._oauth2._customHeaders
    );
    oauth2.getOAuthAccessToken(
      refreshToken,
      {
        scope,
        grant_type: "refresh_token"
      },
      (err, accessToken, newRefreshToken, params) => {
        if (err) {
          reject(new Error(`Failed to refresh access token ${err.toString()}`));
        }
        if (!accessToken) {
          reject(
            new Error(
              `Failed to refresh access token, no access token received`
            )
          );
        }
        resolve({
          accessToken,
          refreshToken: newRefreshToken,
          params
        });
      }
    );
  });
};
const executeFetchUserProfileStrategy = async (providerStrategy, accessToken) => {
  return new Promise((resolve, reject) => {
    const anyStrategy = providerStrategy;
    anyStrategy.userProfile(
      accessToken,
      (error, rawProfile) => {
        if (error) {
          reject(error);
        } else {
          resolve(rawProfile);
        }
      }
    );
  });
};

var __defProp$e = Object.defineProperty;
var __defNormalProp$e = (obj, key, value) => key in obj ? __defProp$e(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$e = (obj, key, value) => {
  __defNormalProp$e(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
class Auth0AuthProvider {
  constructor(options) {
    __publicField$e(this, "_strategy");
    __publicField$e(this, "signInResolver");
    __publicField$e(this, "authHandler");
    __publicField$e(this, "resolverContext");
    __publicField$e(this, "audience");
    __publicField$e(this, "connection");
    __publicField$e(this, "connectionScope");
    /**
     * Due to passport-auth0 forcing options.state = true,
     * passport-oauth2 requires express-session to be installed
     * so that the 'state' parameter of the oauth2 flow can be stored.
     * This implementation of StateStore matches the NullStore found within
     * passport-oauth2, which is the StateStore implementation used when options.state = false,
     * allowing us to avoid using express-session in order to integrate with auth0.
     */
    __publicField$e(this, "store", {
      store(_req, cb) {
        cb(null, null);
      },
      verify(_req, _state, cb) {
        cb(null, true);
      }
    });
    this.signInResolver = options.signInResolver;
    this.authHandler = options.authHandler;
    this.resolverContext = options.resolverContext;
    this.audience = options.audience;
    this.connection = options.connection;
    this.connectionScope = options.connectionScope;
    this._strategy = new Auth0Strategy(
      {
        clientID: options.clientId,
        clientSecret: options.clientSecret,
        callbackURL: options.callbackUrl,
        domain: options.domain,
        // We need passReqToCallback set to false to get params, but there's
        // no matching type signature for that, so instead behold this beauty
        passReqToCallback: false,
        store: this.store
      },
      (accessToken, refreshToken, params, fullProfile, done) => {
        done(
          void 0,
          {
            fullProfile,
            accessToken,
            refreshToken,
            params
          },
          {
            refreshToken
          }
        );
      }
    );
  }
  async start(req) {
    return await executeRedirectStrategy(req, this._strategy, {
      accessType: "offline",
      prompt: "consent",
      scope: req.scope,
      state: encodeState(req.state),
      ...this.audience ? { audience: this.audience } : {},
      ...this.connection ? { connection: this.connection } : {},
      ...this.connectionScope ? { connection_scope: this.connectionScope } : {}
    });
  }
  async handler(req) {
    const { result, privateInfo } = await executeFrameHandlerStrategy(req, this._strategy, {
      ...this.audience ? { audience: this.audience } : {},
      ...this.connection ? { connection: this.connection } : {},
      ...this.connectionScope ? { connection_scope: this.connectionScope } : {}
    });
    return {
      response: await this.handleResult(result),
      refreshToken: privateInfo.refreshToken
    };
  }
  async refresh(req) {
    const { accessToken, refreshToken, params } = await executeRefreshTokenStrategy(
      this._strategy,
      req.refreshToken,
      req.scope
    );
    const fullProfile = await executeFetchUserProfileStrategy(
      this._strategy,
      accessToken
    );
    return {
      response: await this.handleResult({
        fullProfile,
        params,
        accessToken
      }),
      refreshToken
    };
  }
  async handleResult(result) {
    const { profile } = await this.authHandler(result, this.resolverContext);
    const response = {
      providerInfo: {
        idToken: result.params.id_token,
        accessToken: result.accessToken,
        scope: result.params.scope,
        expiresInSeconds: result.params.expires_in
      },
      profile
    };
    if (this.signInResolver) {
      response.backstageIdentity = await this.signInResolver(
        {
          result,
          profile
        },
        this.resolverContext
      );
    }
    return response;
  }
}
const auth0 = createAuthProviderIntegration({
  create(options) {
    return ({ providerId, globalConfig, config, resolverContext }) => OAuthEnvironmentHandler.mapConfig(config, (envConfig) => {
      var _a;
      const clientId = envConfig.getString("clientId");
      const clientSecret = envConfig.getString("clientSecret");
      const domain = envConfig.getString("domain");
      const customCallbackUrl = envConfig.getOptionalString("callbackUrl");
      const audience = envConfig.getOptionalString("audience");
      const connection = envConfig.getOptionalString("connection");
      const connectionScope = envConfig.getOptionalString("connectionScope");
      const callbackUrl = customCallbackUrl || `${globalConfig.baseUrl}/${providerId}/handler/frame`;
      const authHandler = (options == null ? void 0 : options.authHandler) ? options.authHandler : async ({ fullProfile, params }) => ({
        profile: makeProfileInfo(fullProfile, params.id_token)
      });
      const signInResolver = (_a = options == null ? void 0 : options.signIn) == null ? void 0 : _a.resolver;
      const provider = new Auth0AuthProvider({
        clientId,
        clientSecret,
        callbackUrl,
        domain,
        authHandler,
        signInResolver,
        resolverContext,
        audience,
        connection,
        connectionScope
      });
      return OAuthAdapter.fromConfig(globalConfig, provider, {
        providerId,
        callbackUrl
      });
    });
  }
});

var __defProp$d = Object.defineProperty;
var __defNormalProp$d = (obj, key, value) => key in obj ? __defProp$d(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$d = (obj, key, value) => {
  __defNormalProp$d(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
const ALB_JWT_HEADER = "x-amzn-oidc-data";
const ALB_ACCESS_TOKEN_HEADER = "x-amzn-oidc-accesstoken";
class AwsAlbAuthProvider {
  constructor(options) {
    __publicField$d(this, "region");
    __publicField$d(this, "issuer");
    __publicField$d(this, "resolverContext");
    __publicField$d(this, "keyCache");
    __publicField$d(this, "authHandler");
    __publicField$d(this, "signInResolver");
    __publicField$d(this, "getKey", async (header) => {
      if (!header.kid) {
        throw new errors.AuthenticationError("No key id was specified in header");
      }
      const optionalCacheKey = this.keyCache.get(header.kid);
      if (optionalCacheKey) {
        return crypto__namespace.createPublicKey(optionalCacheKey);
      }
      const keyText = await fetch__default["default"](
        `https://public-keys.auth.elb.${encodeURIComponent(
          this.region
        )}.amazonaws.com/${encodeURIComponent(header.kid)}`
      ).then((response) => response.text());
      const keyValue = crypto__namespace.createPublicKey(keyText);
      this.keyCache.set(
        header.kid,
        keyValue.export({ format: "pem", type: "spki" })
      );
      return keyValue;
    });
    this.region = options.region;
    this.issuer = options.issuer;
    this.authHandler = options.authHandler;
    this.signInResolver = options.signInResolver;
    this.resolverContext = options.resolverContext;
    this.keyCache = new NodeCache__default["default"]({ stdTTL: 3600 });
  }
  frameHandler() {
    return Promise.resolve(void 0);
  }
  async refresh(req, res) {
    try {
      const result = await this.getResult(req);
      const response = await this.handleResult(result);
      res.json(response);
    } catch (e) {
      throw new errors.AuthenticationError(
        "Exception occurred during AWS ALB token refresh",
        e
      );
    }
  }
  start() {
    return Promise.resolve(void 0);
  }
  async getResult(req) {
    const jwt = req.header(ALB_JWT_HEADER);
    const accessToken = req.header(ALB_ACCESS_TOKEN_HEADER);
    if (jwt === void 0) {
      throw new errors.AuthenticationError(
        `Missing ALB OIDC header: ${ALB_JWT_HEADER}`
      );
    }
    if (accessToken === void 0) {
      throw new errors.AuthenticationError(
        `Missing ALB OIDC header: ${ALB_ACCESS_TOKEN_HEADER}`
      );
    }
    try {
      const verifyResult = await jose.jwtVerify(jwt, this.getKey);
      const claims = verifyResult.payload;
      if (this.issuer && claims.iss !== this.issuer) {
        throw new errors.AuthenticationError("Issuer mismatch on JWT token");
      }
      const fullProfile = {
        provider: "unknown",
        id: claims.sub,
        displayName: claims.name,
        username: claims.email.split("@")[0].toLowerCase(),
        name: {
          familyName: claims.family_name,
          givenName: claims.given_name
        },
        emails: [{ value: claims.email.toLowerCase() }],
        photos: [{ value: claims.picture }]
      };
      return {
        fullProfile,
        expiresInSeconds: claims.exp,
        accessToken
      };
    } catch (e) {
      throw new Error(`Exception occurred during JWT processing: ${e}`);
    }
  }
  async handleResult(result) {
    const { profile } = await this.authHandler(result, this.resolverContext);
    const backstageIdentity = await this.signInResolver(
      {
        result,
        profile
      },
      this.resolverContext
    );
    return {
      providerInfo: {
        accessToken: result.accessToken,
        expiresInSeconds: result.expiresInSeconds
      },
      backstageIdentity: prepareBackstageIdentityResponse(backstageIdentity),
      profile
    };
  }
}
const awsAlb = createAuthProviderIntegration({
  create(options) {
    return ({ config, resolverContext }) => {
      const region = config.getString("region");
      const issuer = config.getOptionalString("iss");
      if ((options == null ? void 0 : options.signIn.resolver) === void 0) {
        throw new Error(
          "SignInResolver is required to use this authentication provider"
        );
      }
      const authHandler = (options == null ? void 0 : options.authHandler) ? options.authHandler : async ({ fullProfile }) => ({
        profile: makeProfileInfo(fullProfile)
      });
      return new AwsAlbAuthProvider({
        region,
        issuer,
        signInResolver: options == null ? void 0 : options.signIn.resolver,
        authHandler,
        resolverContext
      });
    };
  }
});

var __defProp$c = Object.defineProperty;
var __defNormalProp$c = (obj, key, value) => key in obj ? __defProp$c(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$c = (obj, key, value) => {
  __defNormalProp$c(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
class BitbucketAuthProvider {
  constructor(options) {
    __publicField$c(this, "_strategy");
    __publicField$c(this, "signInResolver");
    __publicField$c(this, "authHandler");
    __publicField$c(this, "resolverContext");
    this.signInResolver = options.signInResolver;
    this.authHandler = options.authHandler;
    this.resolverContext = options.resolverContext;
    this._strategy = new passportBitbucketOauth2.Strategy(
      {
        clientID: options.clientId,
        clientSecret: options.clientSecret,
        callbackURL: options.callbackUrl,
        passReqToCallback: false
      },
      (accessToken, refreshToken, params, fullProfile, done) => {
        done(
          void 0,
          {
            fullProfile,
            params,
            accessToken,
            refreshToken
          },
          {
            refreshToken
          }
        );
      }
    );
  }
  async start(req) {
    return await executeRedirectStrategy(req, this._strategy, {
      accessType: "offline",
      prompt: "consent",
      scope: req.scope,
      state: encodeState(req.state)
    });
  }
  async handler(req) {
    const { result, privateInfo } = await executeFrameHandlerStrategy(req, this._strategy);
    return {
      response: await this.handleResult(result),
      refreshToken: privateInfo.refreshToken
    };
  }
  async refresh(req) {
    const { accessToken, refreshToken, params } = await executeRefreshTokenStrategy(
      this._strategy,
      req.refreshToken,
      req.scope
    );
    const fullProfile = await executeFetchUserProfileStrategy(
      this._strategy,
      accessToken
    );
    return {
      response: await this.handleResult({
        fullProfile,
        params,
        accessToken
      }),
      refreshToken
    };
  }
  async handleResult(result) {
    result.fullProfile.avatarUrl = result.fullProfile._json.links.avatar.href;
    const { profile } = await this.authHandler(result, this.resolverContext);
    const response = {
      providerInfo: {
        idToken: result.params.id_token,
        accessToken: result.accessToken,
        scope: result.params.scope,
        expiresInSeconds: result.params.expires_in
      },
      profile
    };
    if (this.signInResolver) {
      response.backstageIdentity = await this.signInResolver(
        {
          result,
          profile
        },
        this.resolverContext
      );
    }
    return response;
  }
}
const bitbucket = createAuthProviderIntegration({
  create(options) {
    return ({ providerId, globalConfig, config, resolverContext }) => OAuthEnvironmentHandler.mapConfig(config, (envConfig) => {
      var _a;
      const clientId = envConfig.getString("clientId");
      const clientSecret = envConfig.getString("clientSecret");
      const customCallbackUrl = envConfig.getOptionalString("callbackUrl");
      const callbackUrl = customCallbackUrl || `${globalConfig.baseUrl}/${providerId}/handler/frame`;
      const authHandler = (options == null ? void 0 : options.authHandler) ? options.authHandler : async ({ fullProfile, params }) => ({
        profile: makeProfileInfo(fullProfile, params.id_token)
      });
      const provider = new BitbucketAuthProvider({
        clientId,
        clientSecret,
        callbackUrl,
        signInResolver: (_a = options == null ? void 0 : options.signIn) == null ? void 0 : _a.resolver,
        authHandler,
        resolverContext
      });
      return OAuthAdapter.fromConfig(globalConfig, provider, {
        providerId,
        callbackUrl
      });
    });
  },
  resolvers: {
    /**
     * Looks up the user by matching their username to the `bitbucket.org/username` annotation.
     */
    usernameMatchingUserEntityAnnotation() {
      return async (info, ctx) => {
        const { result } = info;
        if (!result.fullProfile.username) {
          throw new Error("Bitbucket profile contained no Username");
        }
        return ctx.signInWithCatalogUser({
          annotations: {
            "bitbucket.org/username": result.fullProfile.username
          }
        });
      };
    },
    /**
     * Looks up the user by matching their user ID to the `bitbucket.org/user-id` annotation.
     */
    userIdMatchingUserEntityAnnotation() {
      return async (info, ctx) => {
        const { result } = info;
        if (!result.fullProfile.id) {
          throw new Error("Bitbucket profile contained no User ID");
        }
        return ctx.signInWithCatalogUser({
          annotations: {
            "bitbucket.org/user-id": result.fullProfile.id
          }
        });
      };
    }
  }
});

const commonByEmailLocalPartResolver = async (info, ctx) => {
  const { profile } = info;
  if (!profile.email) {
    throw new Error("Login failed, user profile does not contain an email");
  }
  const [localPart] = profile.email.split("@");
  return ctx.signInWithCatalogUser({
    entityRef: { name: localPart }
  });
};
const commonByEmailResolver = async (info, ctx) => {
  const { profile } = info;
  if (!profile.email) {
    throw new Error("Login failed, user profile does not contain an email");
  }
  return ctx.signInWithCatalogUser({
    filter: {
      "spec.profile.email": profile.email
    }
  });
};

var __defProp$b = Object.defineProperty;
var __defNormalProp$b = (obj, key, value) => key in obj ? __defProp$b(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$b = (obj, key, value) => {
  __defNormalProp$b(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
const CF_JWT_HEADER = "cf-access-jwt-assertion";
const COOKIE_AUTH_NAME = "CF_Authorization";
const CACHE_PREFIX = "providers/cloudflare-access/profile-v1";
class CloudflareAccessAuthProvider {
  constructor(options) {
    __publicField$b(this, "teamName");
    __publicField$b(this, "resolverContext");
    __publicField$b(this, "authHandler");
    __publicField$b(this, "signInResolver");
    __publicField$b(this, "jwtKeySet");
    __publicField$b(this, "cache");
    this.teamName = options.teamName;
    this.authHandler = options.authHandler;
    this.signInResolver = options.signInResolver;
    this.resolverContext = options.resolverContext;
    this.jwtKeySet = jose.createRemoteJWKSet(
      new URL(
        `https://${this.teamName}.cloudflareaccess.com/cdn-cgi/access/certs`
      )
    );
    this.cache = options.cache;
  }
  frameHandler() {
    return Promise.resolve();
  }
  async refresh(req, res) {
    const result = await this.getResult(req);
    const response = await this.handleResult(result);
    res.json(response);
  }
  start() {
    return Promise.resolve();
  }
  async getIdentityProfile(jwt) {
    const headers = new fetch.Headers();
    headers.set(CF_JWT_HEADER, jwt);
    headers.set("cookie", `${COOKIE_AUTH_NAME}=${jwt}`);
    try {
      const res = await fetch__default["default"](
        `https://${this.teamName}.cloudflareaccess.com/cdn-cgi/access/get-identity`,
        { headers }
      );
      if (!res.ok) {
        throw await errors.ResponseError.fromResponse(res);
      }
      const cfIdentity = await res.json();
      return cfIdentity;
    } catch (err) {
      throw new errors.ForwardedError("getIdentityProfile failed", err);
    }
  }
  async getResult(req) {
    var _a, _b;
    let jwt = req.header(CF_JWT_HEADER);
    if (!jwt) {
      jwt = req.cookies.CF_Authorization;
    }
    if (!jwt) {
      throw new errors.AuthenticationError(
        `Missing ${CF_JWT_HEADER} from Cloudflare Access`
      );
    }
    const verifyResult = await jose.jwtVerify(jwt, this.jwtKeySet, {
      issuer: `https://${this.teamName}.cloudflareaccess.com`
    });
    const sub = verifyResult.payload.sub;
    const cfAccessResultStr = await ((_a = this.cache) == null ? void 0 : _a.get(`${CACHE_PREFIX}/${sub}`));
    if (typeof cfAccessResultStr === "string") {
      const result = JSON.parse(cfAccessResultStr);
      return {
        ...result,
        token: jwt
      };
    }
    const claims = verifyResult.payload;
    try {
      const cfIdentity = await this.getIdentityProfile(jwt);
      const cfAccessResult = {
        claims,
        cfIdentity,
        expiresInSeconds: claims.exp - claims.iat
      };
      (_b = this.cache) == null ? void 0 : _b.set(`${CACHE_PREFIX}/${sub}`, JSON.stringify(cfAccessResult));
      return {
        ...cfAccessResult,
        token: jwt
      };
    } catch (err) {
      throw new errors.ForwardedError(
        "Failed to populate access identity information",
        err
      );
    }
  }
  async handleResult(result) {
    const { profile } = await this.authHandler(result, this.resolverContext);
    const backstageIdentity = await this.signInResolver(
      {
        result,
        profile
      },
      this.resolverContext
    );
    return {
      providerInfo: {
        expiresInSeconds: result.expiresInSeconds,
        claims: result.claims,
        cfAccessIdentityProfile: result.cfIdentity
      },
      backstageIdentity: prepareBackstageIdentityResponse(backstageIdentity),
      profile
    };
  }
}
const cfAccess = createAuthProviderIntegration({
  create(options) {
    return ({ config, resolverContext }) => {
      const teamName = config.getString("teamName");
      if (!options.signIn.resolver) {
        throw new Error(
          "SignInResolver is required to use this authentication provider"
        );
      }
      const authHandler = (options == null ? void 0 : options.authHandler) ? options.authHandler : async ({ claims, cfIdentity }) => {
        return {
          profile: {
            email: claims.email,
            displayName: cfIdentity.name
          }
        };
      };
      return new CloudflareAccessAuthProvider({
        teamName,
        signInResolver: options == null ? void 0 : options.signIn.resolver,
        authHandler,
        resolverContext,
        ...options.cache && { cache: options.cache }
      });
    };
  },
  resolvers: {
    /**
     * Looks up the user by matching their email to the entity email.
     */
    emailMatchingUserEntityProfileEmail: () => commonByEmailResolver
  }
});

const gcpIap = createAuthProviderIntegration({
  create(options) {
    var _a;
    return pluginAuthNode.createProxyAuthProviderFactory({
      authenticator: pluginAuthBackendModuleGcpIapProvider.gcpIapAuthenticator,
      profileTransform: options == null ? void 0 : options.authHandler,
      signInResolver: (_a = options == null ? void 0 : options.signIn) == null ? void 0 : _a.resolver
    });
  }
});

const github = createAuthProviderIntegration({
  create(options) {
    var _a;
    const authHandler = options == null ? void 0 : options.authHandler;
    const signInResolver = (_a = options == null ? void 0 : options.signIn) == null ? void 0 : _a.resolver;
    return pluginAuthNode.createOAuthProviderFactory({
      authenticator: pluginAuthBackendModuleGithubProvider.githubAuthenticator,
      profileTransform: authHandler && (async (result, ctx) => authHandler(
        {
          fullProfile: result.fullProfile,
          accessToken: result.session.accessToken,
          params: {
            scope: result.session.scope,
            expires_in: result.session.expiresInSeconds ? String(result.session.expiresInSeconds) : "",
            refresh_token_expires_in: result.session.refreshTokenExpiresInSeconds ? String(result.session.refreshTokenExpiresInSeconds) : ""
          }
        },
        ctx
      )),
      signInResolver: signInResolver && (async ({ profile, result }, ctx) => signInResolver(
        {
          profile,
          result: {
            fullProfile: result.fullProfile,
            accessToken: result.session.accessToken,
            refreshToken: result.session.refreshToken,
            params: {
              scope: result.session.scope,
              expires_in: result.session.expiresInSeconds ? String(result.session.expiresInSeconds) : "",
              refresh_token_expires_in: result.session.refreshTokenExpiresInSeconds ? String(result.session.refreshTokenExpiresInSeconds) : ""
            }
          }
        },
        ctx
      ))
    });
  },
  resolvers: {
    /**
     * Looks up the user by matching their GitHub username to the entity name.
     */
    usernameMatchingUserEntityName: () => {
      return async (info, ctx) => {
        const { fullProfile } = info.result;
        const userId = fullProfile.username;
        if (!userId) {
          throw new Error(`GitHub user profile does not contain a username`);
        }
        return ctx.signInWithCatalogUser({ entityRef: { name: userId } });
      };
    }
  }
});

const gitlab = createAuthProviderIntegration({
  create(options) {
    var _a;
    return pluginAuthNode.createOAuthProviderFactory({
      authenticator: pluginAuthBackendModuleGitlabProvider.gitlabAuthenticator,
      profileTransform: adaptLegacyOAuthHandler(options == null ? void 0 : options.authHandler),
      signInResolver: adaptLegacyOAuthSignInResolver((_a = options == null ? void 0 : options.signIn) == null ? void 0 : _a.resolver)
    });
  }
});

const google = createAuthProviderIntegration({
  create(options) {
    var _a;
    return pluginAuthNode.createOAuthProviderFactory({
      authenticator: pluginAuthBackendModuleGoogleProvider.googleAuthenticator,
      profileTransform: adaptLegacyOAuthHandler(options == null ? void 0 : options.authHandler),
      signInResolver: adaptLegacyOAuthSignInResolver((_a = options == null ? void 0 : options.signIn) == null ? void 0 : _a.resolver)
    });
  },
  resolvers: adaptOAuthSignInResolverToLegacy({
    emailLocalPartMatchingUserEntityName: pluginAuthNode.commonSignInResolvers.emailLocalPartMatchingUserEntityName(),
    emailMatchingUserEntityProfileEmail: pluginAuthNode.commonSignInResolvers.emailMatchingUserEntityProfileEmail(),
    emailMatchingUserEntityAnnotation: pluginAuthBackendModuleGoogleProvider.googleSignInResolvers.emailMatchingUserEntityAnnotation()
  })
});

const BACKSTAGE_SESSION_EXPIRATION = 3600;

var __defProp$a = Object.defineProperty;
var __defNormalProp$a = (obj, key, value) => key in obj ? __defProp$a(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$a = (obj, key, value) => {
  __defNormalProp$a(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
class MicrosoftAuthProvider {
  constructor(options) {
    __publicField$a(this, "_strategy");
    __publicField$a(this, "signInResolver");
    __publicField$a(this, "authHandler");
    __publicField$a(this, "logger");
    __publicField$a(this, "resolverContext");
    __publicField$a(this, "skipUserProfile", (accessToken) => {
      const { aud, scp } = jose.decodeJwt(accessToken);
      const hasGraphReadScope = aud === "00000003-0000-0000-c000-000000000000" && scp.split(" ").map((s) => s.toLowerCase()).includes("user.read");
      return !hasGraphReadScope;
    });
    this.signInResolver = options.signInResolver;
    this.authHandler = options.authHandler;
    this.logger = options.logger;
    this.resolverContext = options.resolverContext;
    this._strategy = new passportMicrosoft.Strategy(
      {
        clientID: options.clientId,
        clientSecret: options.clientSecret,
        callbackURL: options.callbackUrl,
        authorizationURL: options.authorizationUrl,
        tokenURL: options.tokenUrl,
        passReqToCallback: false,
        skipUserProfile: (accessToken, done) => {
          done(null, this.skipUserProfile(accessToken));
        }
      },
      (accessToken, refreshToken, params, fullProfile, done) => {
        done(void 0, { fullProfile, accessToken, params }, { refreshToken });
      }
    );
  }
  async start(req) {
    return await executeRedirectStrategy(req, this._strategy, {
      scope: req.scope,
      state: encodeState(req.state)
    });
  }
  async handler(req) {
    const { result, privateInfo } = await executeFrameHandlerStrategy(req, this._strategy);
    return {
      response: await this.handleResult(result),
      refreshToken: privateInfo.refreshToken
    };
  }
  async refresh(req) {
    const { accessToken, refreshToken, params } = await executeRefreshTokenStrategy(
      this._strategy,
      req.refreshToken,
      req.scope
    );
    return {
      response: await this.handleResult({
        params,
        accessToken,
        ...!this.skipUserProfile(accessToken) && {
          fullProfile: await executeFetchUserProfileStrategy(
            this._strategy,
            accessToken
          )
        }
      }),
      refreshToken
    };
  }
  async handleResult(result) {
    let profile = {};
    if (result.fullProfile) {
      const photo = await this.getUserPhoto(result.accessToken);
      result.fullProfile.photos = photo ? [{ value: photo }] : void 0;
      ({ profile } = await this.authHandler(
        result,
        this.resolverContext
      ));
    }
    const expiresInSeconds = result.params.expires_in === void 0 ? BACKSTAGE_SESSION_EXPIRATION : Math.min(result.params.expires_in, BACKSTAGE_SESSION_EXPIRATION);
    return {
      providerInfo: {
        accessToken: result.accessToken,
        scope: result.params.scope,
        expiresInSeconds,
        ...{ idToken: result.params.id_token }
      },
      profile,
      ...result.fullProfile && this.signInResolver && {
        backstageIdentity: await this.signInResolver(
          { result, profile },
          this.resolverContext
        )
      }
    };
  }
  async getUserPhoto(accessToken) {
    try {
      const res = await fetch__default["default"](
        "https://graph.microsoft.com/v1.0/me/photos/48x48/$value",
        {
          headers: {
            Authorization: `Bearer ${accessToken}`
          }
        }
      );
      const data = await res.buffer();
      return `data:image/jpeg;base64,${data.toString("base64")}`;
    } catch (error) {
      this.logger.warn(
        `Could not retrieve user profile photo from Microsoft Graph API: ${error}`
      );
      return void 0;
    }
  }
}
const microsoft = createAuthProviderIntegration({
  create(options) {
    return ({ providerId, globalConfig, config, logger, resolverContext }) => OAuthEnvironmentHandler.mapConfig(config, (envConfig) => {
      var _a;
      const clientId = envConfig.getString("clientId");
      const clientSecret = envConfig.getString("clientSecret");
      const tenantId = envConfig.getString("tenantId");
      const customCallbackUrl = envConfig.getOptionalString("callbackUrl");
      const callbackUrl = customCallbackUrl || `${globalConfig.baseUrl}/${providerId}/handler/frame`;
      const authorizationUrl = `https://login.microsoftonline.com/${tenantId}/oauth2/v2.0/authorize`;
      const tokenUrl = `https://login.microsoftonline.com/${tenantId}/oauth2/v2.0/token`;
      const authHandler = (options == null ? void 0 : options.authHandler) ? options.authHandler : async ({ fullProfile, params }) => ({
        profile: makeProfileInfo(fullProfile != null ? fullProfile : {}, params.id_token)
      });
      const provider = new MicrosoftAuthProvider({
        clientId,
        clientSecret,
        callbackUrl,
        authorizationUrl,
        tokenUrl,
        authHandler,
        signInResolver: (_a = options == null ? void 0 : options.signIn) == null ? void 0 : _a.resolver,
        logger,
        resolverContext
      });
      return OAuthAdapter.fromConfig(globalConfig, provider, {
        providerId,
        callbackUrl
      });
    });
  },
  resolvers: {
    /**
     * Looks up the user by matching their email local part to the entity name.
     */
    emailLocalPartMatchingUserEntityName: () => commonByEmailLocalPartResolver,
    /**
     * Looks up the user by matching their email to the entity email.
     */
    emailMatchingUserEntityProfileEmail: () => commonByEmailResolver,
    /**
     * Looks up the user by matching their email to the `microsoft.com/email` annotation.
     */
    emailMatchingUserEntityAnnotation() {
      return async (info, ctx) => {
        const { profile } = info;
        if (!profile.email) {
          throw new Error("Microsoft profile contained no email");
        }
        return ctx.signInWithCatalogUser({
          annotations: {
            "microsoft.com/email": profile.email
          }
        });
      };
    }
  }
});

const oauth2 = createAuthProviderIntegration({
  create(options) {
    var _a;
    return pluginAuthNode.createOAuthProviderFactory({
      authenticator: pluginAuthBackendModuleOauth2Provider.oauth2Authenticator,
      profileTransform: adaptLegacyOAuthHandler(options == null ? void 0 : options.authHandler),
      signInResolver: adaptLegacyOAuthSignInResolver((_a = options == null ? void 0 : options.signIn) == null ? void 0 : _a.resolver)
    });
  }
});

const oauth2Proxy = createAuthProviderIntegration({
  create(options) {
    var _a;
    return pluginAuthNode.createProxyAuthProviderFactory({
      authenticator: pluginAuthBackendModuleOauth2ProxyProvider.oauth2ProxyAuthenticator,
      profileTransform: options == null ? void 0 : options.authHandler,
      signInResolver: (_a = options == null ? void 0 : options.signIn) == null ? void 0 : _a.resolver
    });
  }
});

var __defProp$9 = Object.defineProperty;
var __defNormalProp$9 = (obj, key, value) => key in obj ? __defProp$9(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$9 = (obj, key, value) => {
  __defNormalProp$9(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
class OidcAuthProvider {
  constructor(options) {
    __publicField$9(this, "implementation");
    __publicField$9(this, "scope");
    __publicField$9(this, "prompt");
    __publicField$9(this, "signInResolver");
    __publicField$9(this, "authHandler");
    __publicField$9(this, "resolverContext");
    this.implementation = this.setupStrategy(options);
    this.scope = options.scope;
    this.prompt = options.prompt;
    this.signInResolver = options.signInResolver;
    this.authHandler = options.authHandler;
    this.resolverContext = options.resolverContext;
  }
  async start(req) {
    const { strategy } = await this.implementation;
    const options = {
      scope: req.scope || this.scope || "openid profile email",
      state: encodeState(req.state)
    };
    const prompt = this.prompt || "none";
    if (prompt !== "auto") {
      options.prompt = prompt;
    }
    return await executeRedirectStrategy(req, strategy, options);
  }
  async handler(req) {
    const { strategy } = await this.implementation;
    const { result, privateInfo } = await executeFrameHandlerStrategy(req, strategy);
    return {
      response: await this.handleResult(result),
      refreshToken: privateInfo.refreshToken
    };
  }
  async refresh(req) {
    const { client } = await this.implementation;
    const tokenset = await client.refresh(req.refreshToken);
    if (!tokenset.access_token) {
      throw new Error("Refresh failed");
    }
    if (!tokenset.scope) {
      tokenset.scope = req.scope;
    }
    const userinfo = await client.userinfo(tokenset.access_token);
    return {
      response: await this.handleResult({ tokenset, userinfo }),
      refreshToken: tokenset.refresh_token
    };
  }
  async setupStrategy(options) {
    const issuer = await openidClient.Issuer.discover(options.metadataUrl);
    const client = new issuer.Client({
      access_type: "offline",
      // this option must be passed to provider to receive a refresh token
      client_id: options.clientId,
      client_secret: options.clientSecret,
      redirect_uris: [options.callbackUrl],
      response_types: ["code"],
      token_endpoint_auth_method: options.tokenEndpointAuthMethod || "client_secret_basic",
      id_token_signed_response_alg: options.tokenSignedResponseAlg || "RS256",
      scope: options.scope || ""
    });
    const strategy = new openidClient.Strategy(
      {
        client,
        passReqToCallback: false
      },
      (tokenset, userinfo, done) => {
        if (typeof done !== "function") {
          throw new Error(
            "OIDC IdP must provide a userinfo_endpoint in the metadata response"
          );
        }
        done(
          void 0,
          { tokenset, userinfo },
          {
            refreshToken: tokenset.refresh_token
          }
        );
      }
    );
    strategy.error = console.error;
    return { strategy, client };
  }
  // Use this function to grab the user profile info from the token
  // Then populate the profile with it
  async handleResult(result) {
    const { profile } = await this.authHandler(result, this.resolverContext);
    const expiresInSeconds = result.tokenset.expires_in === void 0 ? BACKSTAGE_SESSION_EXPIRATION : Math.min(result.tokenset.expires_in, BACKSTAGE_SESSION_EXPIRATION);
    let backstageIdentity = void 0;
    if (this.signInResolver) {
      backstageIdentity = await this.signInResolver(
        {
          result,
          profile
        },
        this.resolverContext
      );
    }
    return {
      backstageIdentity,
      providerInfo: {
        idToken: result.tokenset.id_token,
        accessToken: result.tokenset.access_token,
        scope: result.tokenset.scope,
        expiresInSeconds
      },
      profile
    };
  }
}
const oidc = createAuthProviderIntegration({
  create(options) {
    return ({ providerId, globalConfig, config, resolverContext }) => OAuthEnvironmentHandler.mapConfig(config, (envConfig) => {
      var _a;
      const clientId = envConfig.getString("clientId");
      const clientSecret = envConfig.getString("clientSecret");
      const customCallbackUrl = envConfig.getOptionalString("callbackUrl");
      const callbackUrl = customCallbackUrl || `${globalConfig.baseUrl}/${providerId}/handler/frame`;
      const metadataUrl = envConfig.getString("metadataUrl");
      const tokenEndpointAuthMethod = envConfig.getOptionalString(
        "tokenEndpointAuthMethod"
      );
      const tokenSignedResponseAlg = envConfig.getOptionalString(
        "tokenSignedResponseAlg"
      );
      const scope = envConfig.getOptionalString("scope");
      const prompt = envConfig.getOptionalString("prompt");
      const authHandler = (options == null ? void 0 : options.authHandler) ? options.authHandler : async ({ userinfo }) => ({
        profile: {
          displayName: userinfo.name,
          email: userinfo.email,
          picture: userinfo.picture
        }
      });
      const provider = new OidcAuthProvider({
        clientId,
        clientSecret,
        callbackUrl,
        tokenEndpointAuthMethod,
        tokenSignedResponseAlg,
        metadataUrl,
        scope,
        prompt,
        signInResolver: (_a = options == null ? void 0 : options.signIn) == null ? void 0 : _a.resolver,
        authHandler,
        resolverContext
      });
      return OAuthAdapter.fromConfig(globalConfig, provider, {
        providerId,
        callbackUrl
      });
    });
  },
  resolvers: {
    /**
     * Looks up the user by matching their email local part to the entity name.
     */
    emailLocalPartMatchingUserEntityName: () => commonByEmailLocalPartResolver,
    /**
     * Looks up the user by matching their email to the entity email.
     */
    emailMatchingUserEntityProfileEmail: () => commonByEmailResolver
  }
});

const okta = createAuthProviderIntegration({
  create(options) {
    var _a;
    return pluginAuthNode.createOAuthProviderFactory({
      authenticator: pluginAuthBackendModuleOktaProvider.oktaAuthenticator,
      profileTransform: adaptLegacyOAuthHandler(options == null ? void 0 : options.authHandler),
      signInResolver: adaptLegacyOAuthSignInResolver((_a = options == null ? void 0 : options.signIn) == null ? void 0 : _a.resolver)
    });
  },
  resolvers: {
    /**
     * Looks up the user by matching their email local part to the entity name.
     */
    emailLocalPartMatchingUserEntityName: () => commonByEmailLocalPartResolver,
    /**
     * Looks up the user by matching their email to the entity email.
     */
    emailMatchingUserEntityProfileEmail: () => commonByEmailResolver,
    /**
     * Looks up the user by matching their email to the `okta.com/email` annotation.
     */
    emailMatchingUserEntityAnnotation() {
      return async (info, ctx) => {
        const { profile } = info;
        if (!profile.email) {
          throw new Error("Okta profile contained no email");
        }
        return ctx.signInWithCatalogUser({
          annotations: {
            "okta.com/email": profile.email
          }
        });
      };
    }
  }
});

var __defProp$8 = Object.defineProperty;
var __defNormalProp$8 = (obj, key, value) => key in obj ? __defProp$8(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$8 = (obj, key, value) => {
  __defNormalProp$8(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
class OneLoginProvider {
  constructor(options) {
    __publicField$8(this, "_strategy");
    __publicField$8(this, "signInResolver");
    __publicField$8(this, "authHandler");
    __publicField$8(this, "resolverContext");
    this.signInResolver = options.signInResolver;
    this.authHandler = options.authHandler;
    this.resolverContext = options.resolverContext;
    this._strategy = new passportOneloginOauth.Strategy(
      {
        issuer: options.issuer,
        clientID: options.clientId,
        clientSecret: options.clientSecret,
        callbackURL: options.callbackUrl,
        passReqToCallback: false
      },
      (accessToken, refreshToken, params, fullProfile, done) => {
        done(
          void 0,
          {
            accessToken,
            refreshToken,
            params,
            fullProfile
          },
          {
            refreshToken
          }
        );
      }
    );
  }
  async start(req) {
    return await executeRedirectStrategy(req, this._strategy, {
      accessType: "offline",
      prompt: "consent",
      scope: "openid",
      state: encodeState(req.state)
    });
  }
  async handler(req) {
    const { result, privateInfo } = await executeFrameHandlerStrategy(req, this._strategy);
    return {
      response: await this.handleResult(result),
      refreshToken: privateInfo.refreshToken
    };
  }
  async refresh(req) {
    const { accessToken, refreshToken, params } = await executeRefreshTokenStrategy(
      this._strategy,
      req.refreshToken,
      req.scope
    );
    const fullProfile = await executeFetchUserProfileStrategy(
      this._strategy,
      accessToken
    );
    return {
      response: await this.handleResult({
        fullProfile,
        params,
        accessToken
      }),
      refreshToken
    };
  }
  async handleResult(result) {
    const { profile } = await this.authHandler(result, this.resolverContext);
    const response = {
      providerInfo: {
        idToken: result.params.id_token,
        accessToken: result.accessToken,
        scope: result.params.scope,
        expiresInSeconds: result.params.expires_in
      },
      profile
    };
    if (this.signInResolver) {
      response.backstageIdentity = await this.signInResolver(
        {
          result,
          profile
        },
        this.resolverContext
      );
    }
    return response;
  }
}
const onelogin = createAuthProviderIntegration({
  create(options) {
    return ({ providerId, globalConfig, config, resolverContext }) => OAuthEnvironmentHandler.mapConfig(config, (envConfig) => {
      var _a;
      const clientId = envConfig.getString("clientId");
      const clientSecret = envConfig.getString("clientSecret");
      const issuer = envConfig.getString("issuer");
      const customCallbackUrl = envConfig.getOptionalString("callbackUrl");
      const callbackUrl = customCallbackUrl || `${globalConfig.baseUrl}/${providerId}/handler/frame`;
      const authHandler = (options == null ? void 0 : options.authHandler) ? options.authHandler : async ({ fullProfile, params }) => ({
        profile: makeProfileInfo(fullProfile, params.id_token)
      });
      const provider = new OneLoginProvider({
        clientId,
        clientSecret,
        callbackUrl,
        issuer,
        authHandler,
        signInResolver: (_a = options == null ? void 0 : options.signIn) == null ? void 0 : _a.resolver,
        resolverContext
      });
      return OAuthAdapter.fromConfig(globalConfig, provider, {
        providerId,
        callbackUrl
      });
    });
  }
});

var __defProp$7 = Object.defineProperty;
var __defNormalProp$7 = (obj, key, value) => key in obj ? __defProp$7(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$7 = (obj, key, value) => {
  __defNormalProp$7(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
class SamlAuthProvider {
  constructor(options) {
    __publicField$7(this, "strategy");
    __publicField$7(this, "signInResolver");
    __publicField$7(this, "authHandler");
    __publicField$7(this, "resolverContext");
    __publicField$7(this, "appUrl");
    this.appUrl = options.appUrl;
    this.signInResolver = options.signInResolver;
    this.authHandler = options.authHandler;
    this.resolverContext = options.resolverContext;
    this.strategy = new passportSaml.Strategy({ ...options }, (fullProfile, done) => {
      done(void 0, { fullProfile });
    });
  }
  async start(req, res) {
    const { url } = await executeRedirectStrategy(req, this.strategy, {});
    res.redirect(url);
  }
  async frameHandler(req, res) {
    try {
      const { result } = await executeFrameHandlerStrategy(
        req,
        this.strategy
      );
      const { profile } = await this.authHandler(result, this.resolverContext);
      const response = {
        profile,
        providerInfo: {}
      };
      if (this.signInResolver) {
        const signInResponse = await this.signInResolver(
          {
            result,
            profile
          },
          this.resolverContext
        );
        response.backstageIdentity = prepareBackstageIdentityResponse(signInResponse);
      }
      return postMessageResponse(res, this.appUrl, {
        type: "authorization_response",
        response
      });
    } catch (error) {
      const { name, message } = errors.isError(error) ? error : new Error("Encountered invalid error");
      return postMessageResponse(res, this.appUrl, {
        type: "authorization_response",
        error: { name, message }
      });
    }
  }
  async logout(_req, res) {
    res.end();
  }
}
const saml = createAuthProviderIntegration({
  create(options) {
    return ({ providerId, globalConfig, config, resolverContext }) => {
      var _a;
      const authHandler = (options == null ? void 0 : options.authHandler) ? options.authHandler : async ({ fullProfile }) => ({
        profile: {
          email: fullProfile.email,
          displayName: fullProfile.displayName
        }
      });
      return new SamlAuthProvider({
        callbackUrl: `${globalConfig.baseUrl}/${providerId}/handler/frame`,
        entryPoint: config.getString("entryPoint"),
        logoutUrl: config.getOptionalString("logoutUrl"),
        audience: config.getOptionalString("audience"),
        issuer: config.getString("issuer"),
        cert: config.getString("cert"),
        privateKey: config.getOptionalString("privateKey"),
        authnContext: config.getOptionalStringArray("authnContext"),
        identifierFormat: config.getOptionalString("identifierFormat"),
        decryptionPvk: config.getOptionalString("decryptionPvk"),
        signatureAlgorithm: config.getOptionalString("signatureAlgorithm"),
        digestAlgorithm: config.getOptionalString("digestAlgorithm"),
        acceptedClockSkewMs: config.getOptionalNumber("acceptedClockSkewMs"),
        appUrl: globalConfig.appUrl,
        authHandler,
        signInResolver: (_a = options == null ? void 0 : options.signIn) == null ? void 0 : _a.resolver,
        resolverContext
      });
    };
  },
  resolvers: {
    /**
     * Looks up the user by matching their nameID to the entity name.
     */
    nameIdMatchingUserEntityName() {
      return async (info, ctx) => {
        const id = info.result.fullProfile.nameID;
        if (!id) {
          throw new errors.AuthenticationError("No nameID found in SAML response");
        }
        return ctx.signInWithCatalogUser({
          entityRef: { name: id }
        });
      };
    }
  }
});

var __defProp$6 = Object.defineProperty;
var __defNormalProp$6 = (obj, key, value) => key in obj ? __defProp$6(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$6 = (obj, key, value) => {
  __defNormalProp$6(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
class BitbucketServerAuthProvider {
  constructor(options) {
    __publicField$6(this, "signInResolver");
    __publicField$6(this, "authHandler");
    __publicField$6(this, "resolverContext");
    __publicField$6(this, "strategy");
    __publicField$6(this, "host");
    this.signInResolver = options.signInResolver;
    this.authHandler = options.authHandler;
    this.resolverContext = options.resolverContext;
    this.strategy = new passportOauth2.Strategy(
      {
        authorizationURL: options.authorizationUrl,
        tokenURL: options.tokenUrl,
        clientID: options.clientId,
        clientSecret: options.clientSecret,
        callbackURL: options.callbackUrl
      },
      (accessToken, refreshToken, params, fullProfile, done) => {
        done(void 0, { fullProfile, params, accessToken }, { refreshToken });
      }
    );
    this.host = options.host;
  }
  async start(req) {
    return await executeRedirectStrategy(req, this.strategy, {
      accessType: "offline",
      prompt: "consent",
      scope: req.scope,
      state: encodeState(req.state)
    });
  }
  async handler(req) {
    const { result, privateInfo } = await executeFrameHandlerStrategy(req, this.strategy);
    return {
      response: await this.handleResult(result),
      refreshToken: privateInfo.refreshToken
    };
  }
  async refresh(req) {
    const { accessToken, refreshToken, params } = await executeRefreshTokenStrategy(
      this.strategy,
      req.refreshToken,
      req.scope
    );
    const fullProfile = await executeFetchUserProfileStrategy(
      this.strategy,
      accessToken
    );
    return {
      response: await this.handleResult({
        fullProfile,
        params,
        accessToken
      }),
      refreshToken
    };
  }
  async handleResult(result) {
    result.fullProfile = await this.fetchProfile(result);
    const { profile } = await this.authHandler(result, this.resolverContext);
    let backstageIdentity = void 0;
    if (this.signInResolver) {
      backstageIdentity = await this.signInResolver(
        { result, profile },
        this.resolverContext
      );
    }
    return {
      providerInfo: {
        accessToken: result.accessToken,
        scope: result.params.scope,
        expiresInSeconds: result.params.expires_in
      },
      profile,
      backstageIdentity
    };
  }
  async fetchProfile(result) {
    let whoAmIResponse;
    try {
      whoAmIResponse = await fetch__default["default"](
        `https://${this.host}/plugins/servlet/applinks/whoami`,
        {
          headers: {
            Authorization: `Bearer ${result.accessToken}`
          }
        }
      );
    } catch (e) {
      throw new Error(`Failed to retrieve the username of the logged in user`);
    }
    const username = whoAmIResponse.headers.get("X-Ausername");
    if (!username) {
      throw new Error(`Failed to retrieve the username of the logged in user`);
    }
    let userResponse;
    try {
      userResponse = await fetch__default["default"](
        `https://${this.host}/rest/api/latest/users/${username}?avatarSize=256`,
        {
          headers: {
            Authorization: `Bearer ${result.accessToken}`
          }
        }
      );
    } catch (e) {
      throw new Error(`Failed to retrieve the user '${username}'`);
    }
    if (!userResponse.ok) {
      throw new Error(`Failed to retrieve the user '${username}'`);
    }
    const user = await userResponse.json();
    const passportProfile = {
      provider: "bitbucketServer",
      id: user.id.toString(),
      displayName: user.displayName,
      username: user.name,
      emails: [
        {
          value: user.emailAddress
        }
      ]
    };
    if (user.avatarUrl) {
      passportProfile.photos = [
        { value: `https://${this.host}${user.avatarUrl}` }
      ];
    }
    return passportProfile;
  }
}
const bitbucketServer = createAuthProviderIntegration({
  create(options) {
    return ({ providerId, globalConfig, config, resolverContext }) => OAuthEnvironmentHandler.mapConfig(config, (envConfig) => {
      var _a;
      const clientId = envConfig.getString("clientId");
      const clientSecret = envConfig.getString("clientSecret");
      const host = envConfig.getString("host");
      const customCallbackUrl = envConfig.getOptionalString("callbackUrl");
      const callbackUrl = customCallbackUrl || `${globalConfig.baseUrl}/${providerId}/handler/frame`;
      const authorizationUrl = `https://${host}/rest/oauth2/latest/authorize`;
      const tokenUrl = `https://${host}/rest/oauth2/latest/token`;
      const authHandler = (options == null ? void 0 : options.authHandler) ? options.authHandler : async ({ fullProfile }) => ({
        profile: makeProfileInfo(fullProfile)
      });
      const provider = new BitbucketServerAuthProvider({
        callbackUrl,
        clientId,
        clientSecret,
        host,
        authorizationUrl,
        tokenUrl,
        authHandler,
        signInResolver: (_a = options == null ? void 0 : options.signIn) == null ? void 0 : _a.resolver,
        resolverContext
      });
      return OAuthAdapter.fromConfig(globalConfig, provider, {
        providerId,
        callbackUrl
      });
    });
  },
  resolvers: {
    /**
     * Looks up the user by matching their email to the entity email.
     */
    emailMatchingUserEntityProfileEmail: () => commonByEmailResolver
  }
});

var __defProp$5 = Object.defineProperty;
var __defNormalProp$5 = (obj, key, value) => key in obj ? __defProp$5(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$5 = (obj, key, value) => {
  __defNormalProp$5(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
const ID_TOKEN_HEADER = "x-ms-token-aad-id-token";
const ACCESS_TOKEN_HEADER = "x-ms-token-aad-access-token";
class EasyAuthAuthProvider {
  constructor(options) {
    __publicField$5(this, "resolverContext");
    __publicField$5(this, "authHandler");
    __publicField$5(this, "signInResolver");
    this.authHandler = options.authHandler;
    this.signInResolver = options.signInResolver;
    this.resolverContext = options.resolverContext;
  }
  frameHandler() {
    return Promise.resolve(void 0);
  }
  async refresh(req, res) {
    const result = await this.getResult(req);
    const response = await this.handleResult(result);
    res.json(response);
  }
  start() {
    return Promise.resolve(void 0);
  }
  async getResult(req) {
    const idToken = req.header(ID_TOKEN_HEADER);
    const accessToken = req.header(ACCESS_TOKEN_HEADER);
    if (idToken === void 0) {
      throw new errors.AuthenticationError(`Missing ${ID_TOKEN_HEADER} header`);
    }
    return {
      fullProfile: this.idTokenToProfile(idToken),
      accessToken
    };
  }
  idTokenToProfile(idToken) {
    const claims = jose.decodeJwt(idToken);
    if (claims.ver !== "2.0") {
      throw new Error("id_token is not version 2.0 ");
    }
    return {
      id: claims.oid,
      displayName: claims.name,
      provider: "easyauth",
      emails: [{ value: claims.email }],
      username: claims.preferred_username
    };
  }
  async handleResult(result) {
    const { profile } = await this.authHandler(result, this.resolverContext);
    const backstageIdentity = await this.signInResolver(
      {
        result,
        profile
      },
      this.resolverContext
    );
    return {
      providerInfo: {
        accessToken: result.accessToken
      },
      backstageIdentity: prepareBackstageIdentityResponse(backstageIdentity),
      profile
    };
  }
}
const easyAuth = createAuthProviderIntegration({
  create(options) {
    return ({ resolverContext }) => {
      var _a;
      validateAppServiceConfiguration(process.env);
      if ((options == null ? void 0 : options.signIn.resolver) === void 0) {
        throw new Error(
          "SignInResolver is required to use this authentication provider"
        );
      }
      const authHandler = (_a = options.authHandler) != null ? _a : async ({ fullProfile }) => ({
        profile: makeProfileInfo(fullProfile)
      });
      return new EasyAuthAuthProvider({
        signInResolver: options.signIn.resolver,
        authHandler,
        resolverContext
      });
    };
  }
});
function validateAppServiceConfiguration(env) {
  var _a, _b, _c;
  if (env.WEBSITE_SKU === void 0) {
    throw new Error("Backstage is not running on Azure App Services");
  }
  if (((_a = env.WEBSITE_AUTH_ENABLED) == null ? void 0 : _a.toLowerCase()) !== "true") {
    throw new Error("Azure App Services does not have authentication enabled");
  }
  if (((_b = env.WEBSITE_AUTH_DEFAULT_PROVIDER) == null ? void 0 : _b.toLowerCase()) !== "azureactivedirectory") {
    throw new Error("Authentication provider is not Entra ID");
  }
  if (((_c = process.env.WEBSITE_AUTH_TOKEN_STORE) == null ? void 0 : _c.toLowerCase()) !== "true") {
    throw new Error("Token Store is not enabled");
  }
}

const providers = Object.freeze({
  atlassian,
  auth0,
  awsAlb,
  bitbucket,
  bitbucketServer,
  cfAccess,
  gcpIap,
  github,
  gitlab,
  google,
  microsoft,
  oauth2,
  oauth2Proxy,
  oidc,
  okta,
  onelogin,
  saml,
  easyAuth
});
const defaultAuthProviderFactories = {
  google: google.create(),
  github: github.create(),
  gitlab: gitlab.create(),
  saml: saml.create(),
  okta: okta.create(),
  auth0: auth0.create(),
  microsoft: microsoft.create(),
  easyAuth: easyAuth.create(),
  oauth2: oauth2.create(),
  oidc: oidc.create(),
  onelogin: onelogin.create(),
  awsalb: awsAlb.create(),
  bitbucket: bitbucket.create(),
  bitbucketServer: bitbucketServer.create(),
  atlassian: atlassian.create()
};

function createOidcRouter(options) {
  const { baseUrl, tokenIssuer } = options;
  const router = Router__default["default"]();
  const config = {
    issuer: baseUrl,
    token_endpoint: `${baseUrl}/v1/token`,
    userinfo_endpoint: `${baseUrl}/v1/userinfo`,
    jwks_uri: `${baseUrl}/.well-known/jwks.json`,
    response_types_supported: ["id_token"],
    subject_types_supported: ["public"],
    id_token_signing_alg_values_supported: ["RS256"],
    scopes_supported: ["openid"],
    token_endpoint_auth_methods_supported: [],
    claims_supported: ["sub"],
    grant_types_supported: []
  };
  router.get("/.well-known/openid-configuration", (_req, res) => {
    res.json(config);
  });
  router.get("/.well-known/jwks.json", async (_req, res) => {
    const { keys } = await tokenIssuer.listPublicKeys();
    res.json({ keys });
  });
  router.get("/v1/token", (_req, res) => {
    res.status(501).send("Not Implemented");
  });
  router.get("/v1/userinfo", (_req, res) => {
    res.status(501).send("Not Implemented");
  });
  return router;
}

var __defProp$4 = Object.defineProperty;
var __defNormalProp$4 = (obj, key, value) => key in obj ? __defProp$4(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$4 = (obj, key, value) => {
  __defNormalProp$4(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
const MS_IN_S$1 = 1e3;
class TokenFactory {
  constructor(options) {
    __publicField$4(this, "issuer");
    __publicField$4(this, "logger");
    __publicField$4(this, "keyStore");
    __publicField$4(this, "keyDurationSeconds");
    __publicField$4(this, "algorithm");
    __publicField$4(this, "keyExpiry");
    __publicField$4(this, "privateKeyPromise");
    var _a;
    this.issuer = options.issuer;
    this.logger = options.logger;
    this.keyStore = options.keyStore;
    this.keyDurationSeconds = options.keyDurationSeconds;
    this.algorithm = (_a = options.algorithm) != null ? _a : "ES256";
  }
  async issueToken(params) {
    const key = await this.getKey();
    const iss = this.issuer;
    const { sub, ent, ...additionalClaims } = params.claims;
    const aud = "backstage";
    const iat = Math.floor(Date.now() / MS_IN_S$1);
    const exp = iat + this.keyDurationSeconds;
    try {
      catalogModel.parseEntityRef(sub);
    } catch (error) {
      throw new Error(
        '"sub" claim provided by the auth resolver is not a valid EntityRef.'
      );
    }
    this.logger.info(`Issuing token for ${sub}, with entities ${ent != null ? ent : []}`);
    if (!key.alg) {
      throw new errors.AuthenticationError("No algorithm was provided in the key");
    }
    return new jose.SignJWT({ ...additionalClaims, iss, sub, ent, aud, iat, exp }).setProtectedHeader({ alg: key.alg, kid: key.kid }).setIssuer(iss).setAudience(aud).setSubject(sub).setIssuedAt(iat).setExpirationTime(exp).sign(await jose.importJWK(key));
  }
  // This will be called by other services that want to verify ID tokens.
  // It is important that it returns a list of all public keys that could
  // have been used to sign tokens that have not yet expired.
  async listPublicKeys() {
    const { items: keys } = await this.keyStore.listKeys();
    const validKeys = [];
    const expiredKeys = [];
    for (const key of keys) {
      const expireAt = luxon.DateTime.fromJSDate(key.createdAt).plus({
        seconds: 3 * this.keyDurationSeconds
      });
      if (expireAt < luxon.DateTime.local()) {
        expiredKeys.push(key);
      } else {
        validKeys.push(key);
      }
    }
    if (expiredKeys.length > 0) {
      const kids = expiredKeys.map(({ key }) => key.kid);
      this.logger.info(`Removing expired signing keys, '${kids.join("', '")}'`);
      this.keyStore.removeKeys(kids).catch((error) => {
        this.logger.error(`Failed to remove expired keys, ${error}`);
      });
    }
    return { keys: validKeys.map(({ key }) => key) };
  }
  async getKey() {
    if (this.privateKeyPromise) {
      if (this.keyExpiry && luxon.DateTime.fromJSDate(this.keyExpiry) > luxon.DateTime.local()) {
        return this.privateKeyPromise;
      }
      this.logger.info(`Signing key has expired, generating new key`);
      delete this.privateKeyPromise;
    }
    this.keyExpiry = luxon.DateTime.utc().plus({
      seconds: this.keyDurationSeconds
    }).toJSDate();
    const promise = (async () => {
      const key = await jose.generateKeyPair(this.algorithm);
      const publicKey = await jose.exportJWK(key.publicKey);
      const privateKey = await jose.exportJWK(key.privateKey);
      publicKey.kid = privateKey.kid = uuid.v4();
      publicKey.alg = privateKey.alg = this.algorithm;
      this.logger.info(`Created new signing key ${publicKey.kid}`);
      await this.keyStore.addKey(publicKey);
      return privateKey;
    })();
    this.privateKeyPromise = promise;
    try {
      await promise;
    } catch (error) {
      this.logger.error(`Failed to generate new signing key, ${error}`);
      delete this.keyExpiry;
      delete this.privateKeyPromise;
    }
    return promise;
  }
}

const TABLE = "signing_keys";
const parseDate = (date) => {
  const parsedDate = typeof date === "string" ? luxon.DateTime.fromSQL(date, { zone: "UTC" }) : luxon.DateTime.fromJSDate(date);
  if (!parsedDate.isValid) {
    throw new Error(
      `Failed to parse date, reason: ${parsedDate.invalidReason}, explanation: ${parsedDate.invalidExplanation}`
    );
  }
  return parsedDate.toJSDate();
};
class DatabaseKeyStore {
  constructor(client) {
    this.client = client;
  }
  async addKey(key) {
    await this.client(TABLE).insert({
      kid: key.kid,
      key: JSON.stringify(key)
    });
  }
  async listKeys() {
    const rows = await this.client(TABLE).select();
    return {
      items: rows.map((row) => ({
        key: JSON.parse(row.key),
        createdAt: parseDate(row.created_at)
      }))
    };
  }
  async removeKeys(kids) {
    await this.client(TABLE).delete().whereIn("kid", kids);
  }
}

var __defProp$3 = Object.defineProperty;
var __defNormalProp$3 = (obj, key, value) => key in obj ? __defProp$3(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$3 = (obj, key, value) => {
  __defNormalProp$3(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
class MemoryKeyStore {
  constructor() {
    __publicField$3(this, "keys", /* @__PURE__ */ new Map());
  }
  async addKey(key) {
    this.keys.set(key.kid, {
      createdAt: luxon.DateTime.utc().toJSDate(),
      key: JSON.stringify(key)
    });
  }
  async removeKeys(kids) {
    for (const kid of kids) {
      this.keys.delete(kid);
    }
  }
  async listKeys() {
    return {
      items: Array.from(this.keys).map(([, { createdAt, key: keyStr }]) => ({
        createdAt,
        key: JSON.parse(keyStr)
      }))
    };
  }
}

const DEFAULT_TIMEOUT_MS = 1e4;
const DEFAULT_DOCUMENT_PATH = "sessions";
class FirestoreKeyStore {
  constructor(database, path, timeout) {
    this.database = database;
    this.path = path;
    this.timeout = timeout;
  }
  static async create(settings) {
    const { path, timeout, ...firestoreSettings } = settings != null ? settings : {};
    const database = new firestore.Firestore(firestoreSettings);
    return new FirestoreKeyStore(
      database,
      path != null ? path : DEFAULT_DOCUMENT_PATH,
      timeout != null ? timeout : DEFAULT_TIMEOUT_MS
    );
  }
  static async verifyConnection(keyStore, logger) {
    try {
      await keyStore.verify();
    } catch (error) {
      if (process.env.NODE_ENV !== "development") {
        throw new Error(
          `Failed to connect to database: ${error.message}`
        );
      }
      logger == null ? void 0 : logger.warn(
        `Failed to connect to database: ${error.message}`
      );
    }
  }
  async addKey(key) {
    await this.withTimeout(
      this.database.collection(this.path).doc(key.kid).set({
        kid: key.kid,
        key: JSON.stringify(key)
      })
    );
  }
  async listKeys() {
    const keys = await this.withTimeout(
      this.database.collection(this.path).get()
    );
    return {
      items: keys.docs.map((key) => ({
        key: key.data(),
        createdAt: key.createTime.toDate()
      }))
    };
  }
  async removeKeys(kids) {
    for (const kid of kids) {
      await this.withTimeout(
        this.database.collection(this.path).doc(kid).delete()
      );
    }
  }
  /**
   * Helper function to allow us to modify the timeout used when
   * performing Firestore database operations.
   *
   * The reason for this is that it seems that there's no other
   * practical solution to change the default timeout of 10mins
   * that Firestore has.
   *
   */
  async withTimeout(operation) {
    const timer = new Promise(
      (_, reject) => setTimeout(() => {
        reject(new Error(`Operation timed out after ${this.timeout}ms`));
      }, this.timeout)
    );
    return Promise.race([operation, timer]);
  }
  /**
   * Used to verify that the database is reachable.
   */
  async verify() {
    await this.withTimeout(this.database.collection(this.path).limit(1).get());
  }
}

var __defProp$2 = Object.defineProperty;
var __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$2 = (obj, key, value) => {
  __defNormalProp$2(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
const DEFAULT_ALGORITHM = "ES256";
class StaticKeyStore {
  constructor(keyPairs) {
    __publicField$2(this, "keyPairs");
    __publicField$2(this, "createdAt");
    if (keyPairs.length === 0) {
      throw new Error("Should provide at least one key pair");
    }
    this.keyPairs = keyPairs;
    this.createdAt = /* @__PURE__ */ new Date();
  }
  static async fromConfig(config) {
    const keyConfigs = config.getConfigArray("auth.keyStore.static.keys").map((c) => {
      var _a;
      const staticKeyConfig = {
        publicKeyFile: c.getString("publicKeyFile"),
        privateKeyFile: c.getString("privateKeyFile"),
        keyId: c.getString("keyId"),
        algorithm: (_a = c.getOptionalString("algorithm")) != null ? _a : DEFAULT_ALGORITHM
      };
      return staticKeyConfig;
    });
    const keyPairs = await Promise.all(
      keyConfigs.map(async (k) => await this.loadKeyPair(k))
    );
    return new StaticKeyStore(keyPairs);
  }
  addKey(_key) {
    throw new Error("Cannot add keys to the static key store");
  }
  listKeys() {
    const keys = this.keyPairs.map((k) => this.keyPairToStoredKey(k));
    return Promise.resolve({ items: keys });
  }
  getPrivateKey(keyId) {
    const keyPair = this.keyPairs.find((k) => k.publicKey.kid === keyId);
    if (keyPair === void 0) {
      throw new Error(`Could not find key with keyId: ${keyId}`);
    }
    return keyPair.privateKey;
  }
  removeKeys(_kids) {
    throw new Error("Cannot remove keys from the static key store");
  }
  keyPairToStoredKey(keyPair) {
    const publicKey = {
      ...keyPair.publicKey,
      use: "sig"
    };
    return {
      key: publicKey,
      createdAt: this.createdAt
    };
  }
  static async loadKeyPair(options) {
    const algorithm = options.algorithm;
    const keyId = options.keyId;
    const publicKey = await this.loadPublicKeyFromFile(
      options.publicKeyFile,
      keyId,
      algorithm
    );
    const privateKey = await this.loadPrivateKeyFromFile(
      options.privateKeyFile,
      keyId,
      algorithm
    );
    return { publicKey, privateKey };
  }
  static async loadPublicKeyFromFile(path, keyId, algorithm) {
    return this.loadKeyFromFile(path, keyId, algorithm, jose.importSPKI);
  }
  static async loadPrivateKeyFromFile(path, keyId, algorithm) {
    return this.loadKeyFromFile(path, keyId, algorithm, jose.importPKCS8);
  }
  static async loadKeyFromFile(path, keyId, algorithm, importer) {
    const content = await fs.promises.readFile(path, { encoding: "utf8", flag: "r" });
    const key = await importer(content, algorithm);
    const jwk = await jose.exportJWK(key);
    jwk.kid = keyId;
    jwk.alg = algorithm;
    return jwk;
  }
}

class KeyStores {
  /**
   * Looks at the `auth.keyStore` section in the application configuration
   * and returns a KeyStore store. Defaults to `database`
   *
   * @returns a KeyStore store
   */
  static async fromConfig(config, options) {
    var _a;
    const { logger, database } = options;
    const ks = config.getOptionalConfig("auth.keyStore");
    const provider = (_a = ks == null ? void 0 : ks.getOptionalString("provider")) != null ? _a : "database";
    logger.info(`Configuring "${provider}" as KeyStore provider`);
    if (provider === "database") {
      return new DatabaseKeyStore(await database.get());
    }
    if (provider === "memory") {
      return new MemoryKeyStore();
    }
    if (provider === "firestore") {
      const settings = ks == null ? void 0 : ks.getConfig(provider);
      const keyStore = await FirestoreKeyStore.create(
        lodash.pickBy(
          {
            projectId: settings == null ? void 0 : settings.getOptionalString("projectId"),
            keyFilename: settings == null ? void 0 : settings.getOptionalString("keyFilename"),
            host: settings == null ? void 0 : settings.getOptionalString("host"),
            port: settings == null ? void 0 : settings.getOptionalNumber("port"),
            ssl: settings == null ? void 0 : settings.getOptionalBoolean("ssl"),
            path: settings == null ? void 0 : settings.getOptionalString("path"),
            timeout: settings == null ? void 0 : settings.getOptionalNumber("timeout")
          },
          (value) => value !== void 0
        )
      );
      await FirestoreKeyStore.verifyConnection(keyStore, logger);
      return keyStore;
    }
    if (provider === "static") {
      return await StaticKeyStore.fromConfig(config);
    }
    throw new Error(`Unknown KeyStore provider: ${provider}`);
  }
}

var __defProp$1 = Object.defineProperty;
var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$1 = (obj, key, value) => {
  __defNormalProp$1(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
class CatalogIdentityClient {
  constructor(options) {
    __publicField$1(this, "catalogApi");
    __publicField$1(this, "tokenManager");
    this.catalogApi = options.catalogApi;
    this.tokenManager = options.tokenManager;
  }
  /**
   * Looks up a single user using a query.
   *
   * Throws a NotFoundError or ConflictError if 0 or multiple users are found.
   */
  async findUser(query) {
    const filter = {
      kind: "user"
    };
    for (const [key, value] of Object.entries(query.annotations)) {
      filter[`metadata.annotations.${key}`] = value;
    }
    const { token } = await this.tokenManager.getToken();
    const { items } = await this.catalogApi.getEntities({ filter }, { token });
    if (items.length !== 1) {
      if (items.length > 1) {
        throw new errors.ConflictError("User lookup resulted in multiple matches");
      } else {
        throw new errors.NotFoundError("User not found");
      }
    }
    return items[0];
  }
  /**
   * Resolve additional entity claims from the catalog, using the passed-in entity names. Designed
   * to be used within a `signInResolver` where additional entity claims might be provided, but
   * group membership and transient group membership lean on imported catalog relations.
   *
   * Returns a superset of the entity names that can be passed directly to `issueToken` as `ent`.
   */
  async resolveCatalogMembership(query) {
    const { entityRefs, logger } = query;
    const resolvedEntityRefs = entityRefs.map((ref) => {
      try {
        const parsedRef = catalogModel.parseEntityRef(ref.toLocaleLowerCase("en-US"), {
          defaultKind: "user",
          defaultNamespace: "default"
        });
        return parsedRef;
      } catch {
        logger == null ? void 0 : logger.warn(`Failed to parse entityRef from ${ref}, ignoring`);
        return null;
      }
    }).filter((ref) => ref !== null);
    const filter = resolvedEntityRefs.map((ref) => ({
      kind: ref.kind,
      "metadata.namespace": ref.namespace,
      "metadata.name": ref.name
    }));
    const { token } = await this.tokenManager.getToken();
    const entities = await this.catalogApi.getEntities({ filter }, { token }).then((r) => r.items);
    if (entityRefs.length !== entities.length) {
      const foundEntityNames = entities.map(catalogModel.stringifyEntityRef);
      const missingEntityNames = resolvedEntityRefs.map(catalogModel.stringifyEntityRef).filter((s) => !foundEntityNames.includes(s));
      logger == null ? void 0 : logger.debug(`Entities not found for refs ${missingEntityNames.join()}`);
    }
    const memberOf = entities.flatMap(
      (e) => {
        var _a, _b;
        return (_b = (_a = e.relations) == null ? void 0 : _a.filter((r) => r.type === catalogModel.RELATION_MEMBER_OF).map((r) => r.targetRef)) != null ? _b : [];
      }
    );
    const newEntityRefs = [
      ...new Set(resolvedEntityRefs.map(catalogModel.stringifyEntityRef).concat(memberOf))
    ];
    logger == null ? void 0 : logger.debug(`Found catalog membership: ${newEntityRefs.join()}`);
    return newEntityRefs;
  }
}

function getDefaultOwnershipEntityRefs(entity) {
  var _a, _b;
  const membershipRefs = (_b = (_a = entity.relations) == null ? void 0 : _a.filter(
    (r) => r.type === catalogModel.RELATION_MEMBER_OF && r.targetRef.startsWith("group:")
  ).map((r) => r.targetRef)) != null ? _b : [];
  return Array.from(/* @__PURE__ */ new Set([catalogModel.stringifyEntityRef(entity), ...membershipRefs]));
}
class CatalogAuthResolverContext {
  constructor(logger, tokenIssuer, catalogIdentityClient, catalogApi, tokenManager) {
    this.logger = logger;
    this.tokenIssuer = tokenIssuer;
    this.catalogIdentityClient = catalogIdentityClient;
    this.catalogApi = catalogApi;
    this.tokenManager = tokenManager;
  }
  static create(options) {
    const catalogIdentityClient = new CatalogIdentityClient({
      catalogApi: options.catalogApi,
      tokenManager: options.tokenManager
    });
    return new CatalogAuthResolverContext(
      options.logger,
      options.tokenIssuer,
      catalogIdentityClient,
      options.catalogApi,
      options.tokenManager
    );
  }
  async issueToken(params) {
    const token = await this.tokenIssuer.issueToken(params);
    return { token };
  }
  async findCatalogUser(query) {
    let result = void 0;
    const { token } = await this.tokenManager.getToken();
    if ("entityRef" in query) {
      const entityRef = catalogModel.parseEntityRef(query.entityRef, {
        defaultKind: "User",
        defaultNamespace: catalogModel.DEFAULT_NAMESPACE
      });
      result = await this.catalogApi.getEntityByRef(entityRef, { token });
    } else if ("annotations" in query) {
      const filter = {
        kind: "user"
      };
      for (const [key, value] of Object.entries(query.annotations)) {
        filter[`metadata.annotations.${key}`] = value;
      }
      const res = await this.catalogApi.getEntities({ filter }, { token });
      result = res.items;
    } else if ("filter" in query) {
      const res = await this.catalogApi.getEntities(
        { filter: query.filter },
        { token }
      );
      result = res.items;
    } else {
      throw new errors.InputError("Invalid user lookup query");
    }
    if (Array.isArray(result)) {
      if (result.length > 1) {
        throw new errors.ConflictError("User lookup resulted in multiple matches");
      }
      result = result[0];
    }
    if (!result) {
      throw new errors.NotFoundError("User not found");
    }
    return { entity: result };
  }
  async signInWithCatalogUser(query) {
    const { entity } = await this.findCatalogUser(query);
    const ownershipRefs = getDefaultOwnershipEntityRefs(entity);
    const token = await this.tokenIssuer.issueToken({
      claims: {
        sub: catalogModel.stringifyEntityRef(entity),
        ent: ownershipRefs
      }
    });
    return { token };
  }
}

var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var _database, _promise;
const migrationsDir = backendCommon.resolvePackagePath(
  "@backstage/plugin-auth-backend",
  "migrations"
);
const _AuthDatabase = class _AuthDatabase {
  constructor(database) {
    __privateAdd(this, _database, void 0);
    __privateAdd(this, _promise, void 0);
    __privateSet(this, _database, database);
  }
  static create(database) {
    return new _AuthDatabase(database);
  }
  /** @internal */
  static forTesting() {
    const config$1 = new config.ConfigReader({
      backend: {
        database: {
          client: "better-sqlite3",
          connection: ":memory:",
          useNullAsDefault: true
        }
      }
    });
    const database = backendCommon.DatabaseManager.fromConfig(config$1).forPlugin("auth");
    return new _AuthDatabase(database);
  }
  static async runMigrations(knex) {
    await knex.migrate.latest({
      directory: migrationsDir
    });
  }
  get() {
    var _a;
    (_a = __privateGet(this, _promise)) != null ? _a : __privateSet(this, _promise, __privateGet(this, _database).getClient().then(async (client) => {
      var _a2;
      if (!((_a2 = __privateGet(this, _database).migrations) == null ? void 0 : _a2.skip)) {
        await _AuthDatabase.runMigrations(client);
      }
      return client;
    }));
    return __privateGet(this, _promise);
  }
};
_database = new WeakMap();
_promise = new WeakMap();
let AuthDatabase = _AuthDatabase;

var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
const MS_IN_S = 1e3;
class StaticTokenIssuer {
  constructor(options, keyStore) {
    __publicField(this, "issuer");
    __publicField(this, "logger");
    __publicField(this, "keyStore");
    __publicField(this, "sessionExpirationSeconds");
    this.issuer = options.issuer;
    this.logger = options.logger;
    this.sessionExpirationSeconds = options.sessionExpirationSeconds;
    this.keyStore = keyStore;
  }
  async issueToken(params) {
    const key = await this.getSigningKey();
    const iss = this.issuer;
    const { sub, ent, ...additionalClaims } = params.claims;
    const aud = "backstage";
    const iat = Math.floor(Date.now() / MS_IN_S);
    const exp = iat + this.sessionExpirationSeconds;
    try {
      catalogModel.parseEntityRef(sub);
    } catch (error) {
      throw new Error(
        '"sub" claim provided by the auth resolver is not a valid EntityRef.'
      );
    }
    this.logger.info(`Issuing token for ${sub}, with entities ${ent != null ? ent : []}`);
    if (!key.alg) {
      throw new errors.AuthenticationError("No algorithm was provided in the key");
    }
    return new jose.SignJWT({ ...additionalClaims, iss, sub, ent, aud, iat, exp }).setProtectedHeader({ alg: key.alg, kid: key.kid }).setIssuer(iss).setAudience(aud).setSubject(sub).setIssuedAt(iat).setExpirationTime(exp).sign(await jose.importJWK(key));
  }
  async getSigningKey() {
    const { items: keys } = await this.keyStore.listKeys();
    if (keys.length >= 1) {
      return this.keyStore.getPrivateKey(keys[0].key.kid);
    }
    throw new Error("Keystore should hold at least 1 key");
  }
  async listPublicKeys() {
    const { items: keys } = await this.keyStore.listKeys();
    return { keys: keys.map(({ key }) => key) };
  }
}

async function createRouter(options) {
  const {
    logger,
    config,
    discovery,
    database,
    tokenManager,
    tokenFactoryAlgorithm,
    providerFactories = {},
    catalogApi
  } = options;
  const router = Router__default["default"]();
  const appUrl = config.getString("app.baseUrl");
  const authUrl = await discovery.getExternalBaseUrl("auth");
  const authDb = AuthDatabase.create(database);
  const sessionExpirationSeconds = BACKSTAGE_SESSION_EXPIRATION;
  const keyStore = await KeyStores.fromConfig(config, {
    logger,
    database: authDb
  });
  let tokenIssuer;
  if (keyStore instanceof StaticKeyStore) {
    tokenIssuer = new StaticTokenIssuer(
      {
        logger: logger.child({ component: "token-factory" }),
        issuer: authUrl,
        sessionExpirationSeconds
      },
      keyStore
    );
  } else {
    tokenIssuer = new TokenFactory({
      issuer: authUrl,
      keyStore,
      keyDurationSeconds: sessionExpirationSeconds,
      logger: logger.child({ component: "token-factory" }),
      algorithm: tokenFactoryAlgorithm != null ? tokenFactoryAlgorithm : config.getOptionalString("auth.identityTokenAlgorithm")
    });
  }
  const secret = config.getOptionalString("auth.session.secret");
  if (secret) {
    router.use(cookieParser__default["default"](secret));
    const enforceCookieSSL = authUrl.startsWith("https");
    const KnexSessionStore = connectSessionKnex__default["default"](session__default["default"]);
    router.use(
      session__default["default"]({
        secret,
        saveUninitialized: false,
        resave: false,
        cookie: { secure: enforceCookieSSL ? "auto" : false },
        store: new KnexSessionStore({
          createtable: false,
          knex: await authDb.get()
        })
      })
    );
    router.use(passport__default["default"].initialize());
    router.use(passport__default["default"].session());
  } else {
    router.use(cookieParser__default["default"]());
  }
  router.use(express__default["default"].urlencoded({ extended: false }));
  router.use(express__default["default"].json());
  const allProviderFactories = options.disableDefaultProviderFactories ? providerFactories : {
    ...defaultAuthProviderFactories,
    ...providerFactories
  };
  const providersConfig = config.getOptionalConfig("auth.providers");
  const isOriginAllowed = createOriginFilter(config);
  for (const [providerId, providerFactory] of Object.entries(
    allProviderFactories
  )) {
    if (providersConfig == null ? void 0 : providersConfig.has(providerId)) {
      logger.info(`Configuring auth provider: ${providerId}`);
      try {
        const provider = providerFactory({
          providerId,
          appUrl,
          baseUrl: authUrl,
          isOriginAllowed,
          globalConfig: {
            baseUrl: authUrl,
            appUrl,
            isOriginAllowed
          },
          config: providersConfig.getConfig(providerId),
          logger,
          resolverContext: CatalogAuthResolverContext.create({
            logger,
            catalogApi: catalogApi != null ? catalogApi : new catalogClient.CatalogClient({ discoveryApi: discovery }),
            tokenIssuer,
            tokenManager
          })
        });
        const r = Router__default["default"]();
        r.get("/start", provider.start.bind(provider));
        r.get("/handler/frame", provider.frameHandler.bind(provider));
        r.post("/handler/frame", provider.frameHandler.bind(provider));
        if (provider.logout) {
          r.post("/logout", provider.logout.bind(provider));
        }
        if (provider.refresh) {
          r.get("/refresh", provider.refresh.bind(provider));
          r.post("/refresh", provider.refresh.bind(provider));
        }
        router.use(`/${providerId}`, r);
      } catch (e) {
        errors.assertError(e);
        if (process.env.NODE_ENV !== "development") {
          throw new Error(
            `Failed to initialize ${providerId} auth provider, ${e.message}`
          );
        }
        logger.warn(`Skipping ${providerId} auth provider, ${e.message}`);
        router.use(`/${providerId}`, () => {
          throw new errors.NotFoundError(
            `Auth provider registered for '${providerId}' is misconfigured. This could mean the configs under auth.providers.${providerId} are missing or the environment variables used are not defined. Check the auth backend plugin logs when the backend starts to see more details.`
          );
        });
      }
    } else {
      router.use(`/${providerId}`, () => {
        throw new errors.NotFoundError(
          `No auth provider registered for '${providerId}'`
        );
      });
    }
  }
  router.use(
    createOidcRouter({
      tokenIssuer,
      baseUrl: authUrl
    })
  );
  router.use("/:provider/", (req) => {
    const { provider } = req.params;
    throw new errors.NotFoundError(`Unknown auth provider '${provider}'`);
  });
  return router;
}
function createOriginFilter(config) {
  var _a;
  const appUrl = config.getString("app.baseUrl");
  const { origin: appOrigin } = new URL(appUrl);
  const allowedOrigins = config.getOptionalStringArray(
    "auth.experimentalExtraAllowedOrigins"
  );
  const allowedOriginPatterns = (_a = allowedOrigins == null ? void 0 : allowedOrigins.map(
    (pattern) => new minimatch.Minimatch(pattern, { nocase: true, noglobstar: true })
  )) != null ? _a : [];
  return (origin) => {
    if (origin === appOrigin) {
      return true;
    }
    return allowedOriginPatterns.some((pattern) => pattern.match(origin));
  };
}

const authPlugin = backendPluginApi.createBackendPlugin({
  pluginId: "auth",
  register(reg) {
    const providers = /* @__PURE__ */ new Map();
    reg.registerExtensionPoint(pluginAuthNode.authProvidersExtensionPoint, {
      registerProvider({ providerId, factory }) {
        if (providers.has(providerId)) {
          throw new Error(
            `Auth provider '${providerId}' was already registered`
          );
        }
        providers.set(providerId, factory);
      }
    });
    reg.registerInit({
      deps: {
        httpRouter: backendPluginApi.coreServices.httpRouter,
        logger: backendPluginApi.coreServices.logger,
        config: backendPluginApi.coreServices.rootConfig,
        database: backendPluginApi.coreServices.database,
        discovery: backendPluginApi.coreServices.discovery,
        tokenManager: backendPluginApi.coreServices.tokenManager,
        catalogApi: alpha.catalogServiceRef
      },
      async init({
        httpRouter,
        logger,
        config,
        database,
        discovery,
        tokenManager,
        catalogApi
      }) {
        const router = await createRouter({
          logger,
          config,
          database,
          discovery,
          tokenManager,
          catalogApi,
          providerFactories: Object.fromEntries(providers),
          disableDefaultProviderFactories: true
        });
        httpRouter.use(router);
      }
    });
  }
});

exports.CatalogIdentityClient = CatalogIdentityClient;
exports.OAuthAdapter = OAuthAdapter;
exports.OAuthEnvironmentHandler = OAuthEnvironmentHandler;
exports.createAuthProviderIntegration = createAuthProviderIntegration;
exports.createOriginFilter = createOriginFilter;
exports.createRouter = createRouter;
exports["default"] = authPlugin;
exports.defaultAuthProviderFactories = defaultAuthProviderFactories;
exports.encodeState = encodeState;
exports.ensuresXRequestedWith = ensuresXRequestedWith;
exports.getDefaultOwnershipEntityRefs = getDefaultOwnershipEntityRefs;
exports.postMessageResponse = postMessageResponse;
exports.prepareBackstageIdentityResponse = prepareBackstageIdentityResponse;
exports.providers = providers;
exports.readState = readState;
exports.verifyNonce = verifyNonce;
//# sourceMappingURL=index.cjs.js.map
