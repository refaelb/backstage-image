import * as _backstage_backend_plugin_api from '@backstage/backend-plugin-api';
import { LoggerService } from '@backstage/backend-plugin-api';
import express from 'express';
import * as _backstage_plugin_auth_node from '@backstage/plugin-auth-node';
import { BackstageSignInResult, OAuthState as OAuthState$1, AuthResolverCatalogUserQuery as AuthResolverCatalogUserQuery$1, AuthResolverContext as AuthResolverContext$1, CookieConfigurer as CookieConfigurer$1, AuthProviderConfig as AuthProviderConfig$1, AuthProviderRouteHandlers as AuthProviderRouteHandlers$1, AuthProviderFactory as AuthProviderFactory$1, ClientAuthResponse, ProfileInfo as ProfileInfo$1, SignInInfo as SignInInfo$1, SignInResolver as SignInResolver$1, OAuthEnvironmentHandler as OAuthEnvironmentHandler$1, decodeOAuthState, encodeOAuthState, prepareBackstageIdentityResponse as prepareBackstageIdentityResponse$1, TokenParams as TokenParams$1, WebMessageResponse as WebMessageResponse$1 } from '@backstage/plugin-auth-node';
import { Profile } from 'passport';
import { PluginDatabaseManager, PluginEndpointDiscovery, TokenManager } from '@backstage/backend-common';
import { CatalogApi } from '@backstage/catalog-client';
import { Config } from '@backstage/config';
import * as _backstage_plugin_auth_backend_module_oauth2_proxy_provider from '@backstage/plugin-auth-backend-module-oauth2-proxy-provider';
import { OAuth2ProxyResult as OAuth2ProxyResult$1 } from '@backstage/plugin-auth-backend-module-oauth2-proxy-provider';
import { TokenSet, UserinfoResponse } from 'openid-client';
import * as _backstage_plugin_auth_backend_module_gcp_iap_provider from '@backstage/plugin-auth-backend-module-gcp-iap-provider';
import { GcpIapTokenInfo as GcpIapTokenInfo$1, GcpIapResult as GcpIapResult$1 } from '@backstage/plugin-auth-backend-module-gcp-iap-provider';
import { UserEntity, Entity } from '@backstage/catalog-model';

/**
 * Auth plugin
 *
 * @public
 */
declare const authPlugin: () => _backstage_backend_plugin_api.BackendFeature;

/**
 * Common options for passport.js-based OAuth providers
 *
 * @public
 * @deprecated No longer in use
 */
type OAuthProviderOptions = {
    /**
     * Client ID of the auth provider.
     */
    clientId: string;
    /**
     * Client Secret of the auth provider.
     */
    clientSecret: string;
    /**
     * Callback URL to be passed to the auth provider to redirect to after the user signs in.
     */
    callbackUrl: string;
};
/**
 * @public
 * @deprecated Use `OAuthAuthenticatorResult<PassportProfile>` from `@backstage/plugin-auth-node` instead
 */
type OAuthResult = {
    fullProfile: Profile;
    params: {
        id_token?: string;
        scope: string;
        token_type?: string;
        expires_in: number;
    };
    accessToken: string;
    refreshToken?: string;
};
/**
 * @public
 * @deprecated Use `ClientAuthResponse` from `@backstage/plugin-auth-node` instead
 */
type OAuthResponse = {
    profile: ProfileInfo;
    providerInfo: OAuthProviderInfo;
    backstageIdentity?: BackstageSignInResult;
};
/**
 * @public
 * @deprecated Use `createOAuthRouteHandlers` from `@backstage/plugin-auth-node` instead
 */
type OAuthProviderInfo = {
    /**
     * An access token issued for the signed in user.
     */
    accessToken: string;
    /**
     * (Optional) Id token issued for the signed in user.
     */
    idToken?: string;
    /**
     * Expiry of the access token in seconds.
     */
    expiresInSeconds?: number;
    /**
     * Scopes granted for the access token.
     */
    scope: string;
};
/**
 * @public
 * @deprecated import from `@backstage/plugin-auth-node` instead
 */
type OAuthState = OAuthState$1;
/**
 * @public
 * @deprecated Use `createOAuthRouteHandlers` from `@backstage/plugin-auth-node` instead
 */
type OAuthStartRequest = express.Request<{}> & {
    scope: string;
    state: OAuthState;
};
/**
 * @public
 * @deprecated Use `createOAuthRouteHandlers` from `@backstage/plugin-auth-node` instead
 */
type OAuthRefreshRequest = express.Request<{}> & {
    scope: string;
    refreshToken: string;
};
/**
 * @public
 * @deprecated Use `createOAuthRouteHandlers` from `@backstage/plugin-auth-node` instead
 */
type OAuthLogoutRequest = express.Request<{}> & {
    refreshToken: string;
};
/**
 * @public
 * @deprecated Use `createOAuthRouteHandlers` from `@backstage/plugin-auth-node` instead
 */
interface OAuthHandlers {
    /**
     * Initiate a sign in request with an auth provider.
     */
    start(req: OAuthStartRequest): Promise<OAuthStartResponse>;
    /**
     * Handle the redirect from the auth provider when the user has signed in.
     */
    handler(req: express.Request): Promise<{
        response: OAuthResponse;
        refreshToken?: string;
    }>;
    /**
     * (Optional) Given a refresh token and scope fetches a new access token from the auth provider.
     */
    refresh?(req: OAuthRefreshRequest): Promise<{
        response: OAuthResponse;
        refreshToken?: string;
    }>;
    /**
     * (Optional) Sign out of the auth provider.
     */
    logout?(req: OAuthLogoutRequest): Promise<void>;
}

/**
 * @public
 * @deprecated import from `@backstage/plugin-auth-node` instead
 */
type AuthResolverCatalogUserQuery = AuthResolverCatalogUserQuery$1;
/**
 * @public
 * @deprecated import from `@backstage/plugin-auth-node` instead
 */
type AuthResolverContext = AuthResolverContext$1;
/**
 * @public
 * @deprecated import from `@backstage/plugin-auth-node` instead
 */
type CookieConfigurer = CookieConfigurer$1;
/**
 * @public
 * @deprecated Use `createOAuthAuthenticator` from `@backstage/plugin-auth-node` instead
 */
type OAuthStartResponse = {
    /**
     * URL to redirect to
     */
    url: string;
    /**
     * Status code to use for the redirect
     */
    status?: number;
};
/**
 * @public
 * @deprecated import from `@backstage/plugin-auth-node` instead
 */
type AuthProviderConfig = AuthProviderConfig$1;
/**
 * @public
 * @deprecated import from `@backstage/plugin-auth-node` instead
 */
type AuthProviderRouteHandlers = AuthProviderRouteHandlers$1;
/**
 * @public
 * @deprecated import from `@backstage/plugin-auth-node` instead
 */
type AuthProviderFactory = AuthProviderFactory$1;
/**
 * @public
 * @deprecated import `ClientAuthResponse` from `@backstage/plugin-auth-node` instead
 */
type AuthResponse<TProviderInfo> = ClientAuthResponse<TProviderInfo>;
/**
 * @public
 * @deprecated import from `@backstage/plugin-auth-node` instead
 */
type ProfileInfo = ProfileInfo$1;
/**
 * @public
 * @deprecated import from `@backstage/plugin-auth-node` instead
 */
type SignInInfo<TAuthResult> = SignInInfo$1<TAuthResult>;
/**
 * @public
 * @deprecated import from `@backstage/plugin-auth-node` instead
 */
type SignInResolver<TAuthResult> = SignInResolver$1<TAuthResult>;
/**
 * The return type of an authentication handler. Must contain valid profile
 * information.
 *
 * @public
 * @deprecated Use `createOAuthRouteHandlers` from `@backstage/plugin-auth-node` instead
 */
type AuthHandlerResult = {
    profile: ProfileInfo;
};
/**
 * The AuthHandler function is called every time the user authenticates using
 * the provider.
 *
 * The handler should return a profile that represents the session for the user
 * in the frontend.
 *
 * Throwing an error in the function will cause the authentication to fail,
 * making it possible to use this function as a way to limit access to a certain
 * group of users.
 *
 * @public
 * @deprecated Use `createOAuthRouteHandlers` from `@backstage/plugin-auth-node` instead
 */
type AuthHandler<TAuthResult> = (input: TAuthResult, context: AuthResolverContext) => Promise<AuthHandlerResult>;
/**
 * @public
 * @deprecated Use `createOAuthRouteHandlers` from `@backstage/plugin-auth-node` instead
 */
type StateEncoder = (req: OAuthStartRequest) => Promise<{
    encodedState: string;
}>;

/** @public */
type AwsAlbResult = {
    fullProfile: Profile;
    expiresInSeconds?: number;
    accessToken: string;
};

/** @public */
type EasyAuthResult = {
    fullProfile: Profile;
    accessToken?: string;
};

/**
 * @public
 * @deprecated import from `@backstage/plugin-auth-node` instead
 */
declare const OAuthEnvironmentHandler: typeof OAuthEnvironmentHandler$1;

/**
 * @public
 * @deprecated Use `createOAuthRouteHandlers` from `@backstage/plugin-auth-node` instead
 */
type OAuthAdapterOptions = {
    providerId: string;
    persistScopes?: boolean;
    appOrigin: string;
    baseUrl: string;
    cookieConfigurer: CookieConfigurer;
    isOriginAllowed: (origin: string) => boolean;
    callbackUrl: string;
};
/**
 * @public
 * @deprecated Use `createOAuthRouteHandlers` from `@backstage/plugin-auth-node` instead
 */
declare class OAuthAdapter implements AuthProviderRouteHandlers {
    private readonly handlers;
    private readonly options;
    static fromConfig(config: AuthProviderConfig, handlers: OAuthHandlers, options: Pick<OAuthAdapterOptions, 'providerId' | 'persistScopes' | 'callbackUrl'>): OAuthAdapter;
    private readonly baseCookieOptions;
    constructor(handlers: OAuthHandlers, options: OAuthAdapterOptions);
    start(req: express.Request, res: express.Response): Promise<void>;
    frameHandler(req: express.Request, res: express.Response): Promise<void>;
    logout(req: express.Request, res: express.Response): Promise<void>;
    refresh(req: express.Request, res: express.Response): Promise<void>;
    /**
     * If the response from the OAuth provider includes a Backstage identity, we
     * make sure it's populated with all the information we can derive from the user ID.
     */
    private populateIdentity;
    private setNonceCookie;
    private setGrantedScopeCookie;
    private getRefreshTokenFromCookie;
    private getGrantedScopeFromCookie;
    private setRefreshTokenCookie;
    private removeRefreshTokenCookie;
    private getCookieConfig;
}

/**
 * @public
 * @deprecated Use `decodeOAuthState` from `@backstage/plugin-auth-node` instead
 */
declare const readState: typeof decodeOAuthState;
/**
 * @public
 * @deprecated Use `encodeOAuthState` from `@backstage/plugin-auth-node` instead
 */
declare const encodeState: typeof encodeOAuthState;
/**
 * @public
 * @deprecated Use inline logic to make sure the session and state nonce matches instead.
 */
declare const verifyNonce: (req: express.Request, providerId: string) => void;

/** @public */
type BitbucketOAuthResult = {
    fullProfile: BitbucketPassportProfile;
    params: {
        id_token?: string;
        scope: string;
        expires_in: number;
    };
    accessToken: string;
    refreshToken?: string;
};
/** @public */
type BitbucketPassportProfile = Profile & {
    id?: string;
    displayName?: string;
    username?: string;
    avatarUrl?: string;
    _json?: {
        links?: {
            avatar?: {
                href?: string;
            };
        };
    };
};

/** @public */
type BitbucketServerOAuthResult = {
    fullProfile: Profile;
    params: {
        scope: string;
        access_token?: string;
        token_type?: string;
        expires_in?: number;
    };
    accessToken: string;
    refreshToken?: string;
};

/**
 * CloudflareAccessClaims
 *
 * Can be used in externally provided auth handler or sign in resolver to
 * enrich user profile for sign-in user entity
 *
 * @public
 */
type CloudflareAccessClaims = {
    /**
     * `aud` identifies the application to which the JWT is issued.
     */
    aud: string[];
    /**
     * `email` contains the email address of the authenticated user.
     */
    email: string;
    /**
     * iat and exp are the issuance and expiration timestamps.
     */
    exp: number;
    iat: number;
    /**
     * `nonce` is the session identifier.
     */
    nonce: string;
    /**
     * `identity_nonce` is available in the Application Token and can be used to
     * query all group membership for a given user.
     */
    identity_nonce: string;
    /**
     * `sub` contains the identifier of the authenticated user.
     */
    sub: string;
    /**
     * `iss` the issuer is the application’s Cloudflare Access Domain URL.
     */
    iss: string;
    /**
     * `custom` contains SAML attributes in the Application Token specified by an
     * administrator in the identity provider configuration.
     */
    custom: string;
};
/**
 * CloudflareAccessGroup
 *
 * @public
 */
type CloudflareAccessGroup = {
    /**
     * Group id
     */
    id: string;
    /**
     * Name of group as defined in Cloudflare zero trust dashboard
     */
    name: string;
    /**
     * Access group email address
     */
    email: string;
};
/**
 * CloudflareAccessIdentityProfile
 *
 * Can be used in externally provided auth handler or sign in resolver to
 * enrich user profile for sign-in user entity
 *
 * @public
 */
type CloudflareAccessIdentityProfile = {
    id: string;
    name: string;
    email: string;
    groups: CloudflareAccessGroup[];
};
/**
 * @public
 */
type CloudflareAccessResult = {
    claims: CloudflareAccessClaims;
    cfIdentity: CloudflareAccessIdentityProfile;
    expiresInSeconds?: number;
    token: string;
};

/** @public */
type GithubOAuthResult = {
    fullProfile: Profile;
    params: {
        scope: string;
        expires_in?: string;
        refresh_token_expires_in?: string;
    };
    accessToken: string;
    refreshToken?: string;
};

/**
 * @public
 * @deprecated import from `@backstage/plugin-auth-backend-module-oauth2-proxy-provider` instead
 */
type OAuth2ProxyResult = OAuth2ProxyResult$1;

/**
 * authentication result for the OIDC which includes the token set and user information (a profile response sent by OIDC server)
 * @public
 */
type OidcAuthResult = {
    tokenset: TokenSet;
    userinfo: UserinfoResponse;
};

/** @public */
type SamlAuthResult = {
    fullProfile: any;
};

/**
 * The data extracted from an IAP token.
 *
 * @public
 * @deprecated import from `@backstage/plugin-auth-backend-module-gcp-iap-provider` instead
 */
type GcpIapTokenInfo = GcpIapTokenInfo$1;
/**
 * The result of the initial auth challenge. This is the input to the auth
 * callbacks.
 *
 * @public
 * @deprecated import from `@backstage/plugin-auth-backend-module-gcp-iap-provider` instead
 */
type GcpIapResult = GcpIapResult$1;

/**
 * All built-in auth provider integrations.
 *
 * @public
 */
declare const providers: Readonly<{
    atlassian: Readonly<{
        create: (options?: {
            authHandler?: AuthHandler<OAuthResult> | undefined;
            signIn?: {
                resolver: SignInResolver<OAuthResult>;
            } | undefined;
        } | undefined) => _backstage_plugin_auth_node.AuthProviderFactory;
        resolvers: never;
    }>;
    auth0: Readonly<{
        create: (options?: {
            authHandler?: AuthHandler<OAuthResult> | undefined;
            signIn?: {
                resolver: SignInResolver<OAuthResult>;
            } | undefined;
        } | undefined) => _backstage_plugin_auth_node.AuthProviderFactory;
        resolvers: never;
    }>;
    awsAlb: Readonly<{
        create: (options?: {
            authHandler?: AuthHandler<AwsAlbResult> | undefined;
            signIn: {
                resolver: SignInResolver<AwsAlbResult>;
            };
        } | undefined) => _backstage_plugin_auth_node.AuthProviderFactory;
        resolvers: never;
    }>;
    bitbucket: Readonly<{
        create: (options?: {
            authHandler?: AuthHandler<OAuthResult> | undefined;
            signIn?: {
                resolver: SignInResolver<OAuthResult>;
            } | undefined;
        } | undefined) => _backstage_plugin_auth_node.AuthProviderFactory;
        resolvers: Readonly<{
            usernameMatchingUserEntityAnnotation(): SignInResolver<OAuthResult>;
            userIdMatchingUserEntityAnnotation(): SignInResolver<OAuthResult>;
        }>;
    }>;
    bitbucketServer: Readonly<{
        create: (options?: {
            authHandler?: AuthHandler<BitbucketServerOAuthResult> | undefined;
            signIn?: {
                resolver: SignInResolver<BitbucketServerOAuthResult>;
            } | undefined;
        } | undefined) => _backstage_plugin_auth_node.AuthProviderFactory;
        resolvers: Readonly<{
            emailMatchingUserEntityProfileEmail: () => SignInResolver<BitbucketServerOAuthResult>;
        }>;
    }>;
    cfAccess: Readonly<{
        create: (options: {
            authHandler?: AuthHandler<CloudflareAccessResult> | undefined;
            signIn: {
                resolver: SignInResolver<CloudflareAccessResult>;
            };
            cache?: _backstage_backend_plugin_api.CacheService | undefined;
        }) => _backstage_plugin_auth_node.AuthProviderFactory;
        resolvers: Readonly<{
            emailMatchingUserEntityProfileEmail: () => SignInResolver<unknown>;
        }>;
    }>;
    gcpIap: Readonly<{
        create: (options: {
            authHandler?: AuthHandler<_backstage_plugin_auth_backend_module_gcp_iap_provider.GcpIapResult> | undefined;
            signIn: {
                resolver: SignInResolver<_backstage_plugin_auth_backend_module_gcp_iap_provider.GcpIapResult>;
            };
        }) => _backstage_plugin_auth_node.AuthProviderFactory;
        resolvers: never;
    }>;
    github: Readonly<{
        create: (options?: {
            authHandler?: AuthHandler<GithubOAuthResult> | undefined;
            signIn?: {
                resolver: _backstage_plugin_auth_node.SignInResolver<GithubOAuthResult>;
            } | undefined;
            stateEncoder?: StateEncoder | undefined;
        } | undefined) => _backstage_plugin_auth_node.AuthProviderFactory;
        resolvers: Readonly<{
            usernameMatchingUserEntityName: () => _backstage_plugin_auth_node.SignInResolver<GithubOAuthResult>;
        }>;
    }>;
    gitlab: Readonly<{
        create: (options?: {
            authHandler?: AuthHandler<OAuthResult> | undefined;
            signIn?: {
                resolver: SignInResolver<OAuthResult>;
            } | undefined;
        } | undefined) => _backstage_plugin_auth_node.AuthProviderFactory;
        resolvers: never;
    }>;
    google: Readonly<{
        create: (options?: {
            authHandler?: AuthHandler<OAuthResult> | undefined;
            signIn?: {
                resolver: SignInResolver<OAuthResult>;
            } | undefined;
        } | undefined) => _backstage_plugin_auth_node.AuthProviderFactory;
        resolvers: Readonly<{
            emailMatchingUserEntityProfileEmail: () => _backstage_plugin_auth_node.SignInResolver<OAuthResult>;
            emailLocalPartMatchingUserEntityName: () => _backstage_plugin_auth_node.SignInResolver<OAuthResult>;
            emailMatchingUserEntityAnnotation: () => _backstage_plugin_auth_node.SignInResolver<OAuthResult>;
        }>;
    }>;
    microsoft: Readonly<{
        create: (options?: {
            authHandler?: AuthHandler<OAuthResult> | undefined;
            signIn?: {
                resolver: SignInResolver<OAuthResult>;
            } | undefined;
        } | undefined) => _backstage_plugin_auth_node.AuthProviderFactory;
        resolvers: Readonly<{
            emailLocalPartMatchingUserEntityName: () => SignInResolver<unknown>;
            emailMatchingUserEntityProfileEmail: () => SignInResolver<unknown>;
            emailMatchingUserEntityAnnotation(): SignInResolver<OAuthResult>;
        }>;
    }>;
    oauth2: Readonly<{
        create: (options?: {
            authHandler?: AuthHandler<OAuthResult> | undefined;
            signIn?: {
                resolver: SignInResolver<OAuthResult>;
            } | undefined;
        } | undefined) => _backstage_plugin_auth_node.AuthProviderFactory;
        resolvers: never;
    }>;
    oauth2Proxy: Readonly<{
        create: (options: {
            authHandler?: AuthHandler<_backstage_plugin_auth_backend_module_oauth2_proxy_provider.OAuth2ProxyResult> | undefined;
            signIn: {
                resolver: SignInResolver<_backstage_plugin_auth_backend_module_oauth2_proxy_provider.OAuth2ProxyResult>;
            };
        }) => _backstage_plugin_auth_node.AuthProviderFactory;
        resolvers: never;
    }>;
    oidc: Readonly<{
        create: (options?: {
            authHandler?: AuthHandler<OidcAuthResult> | undefined;
            signIn?: {
                resolver: SignInResolver<OidcAuthResult>;
            } | undefined;
        } | undefined) => _backstage_plugin_auth_node.AuthProviderFactory;
        resolvers: Readonly<{
            emailLocalPartMatchingUserEntityName: () => SignInResolver<unknown>;
            emailMatchingUserEntityProfileEmail: () => SignInResolver<unknown>;
        }>;
    }>;
    okta: Readonly<{
        create: (options?: {
            authHandler?: AuthHandler<OAuthResult> | undefined;
            signIn?: {
                resolver: SignInResolver<OAuthResult>;
            } | undefined;
        } | undefined) => _backstage_plugin_auth_node.AuthProviderFactory;
        resolvers: Readonly<{
            emailLocalPartMatchingUserEntityName: () => SignInResolver<unknown>;
            emailMatchingUserEntityProfileEmail: () => SignInResolver<unknown>;
            emailMatchingUserEntityAnnotation(): SignInResolver<OAuthResult>;
        }>;
    }>;
    onelogin: Readonly<{
        create: (options?: {
            authHandler?: AuthHandler<OAuthResult> | undefined;
            signIn?: {
                resolver: SignInResolver<OAuthResult>;
            } | undefined;
        } | undefined) => _backstage_plugin_auth_node.AuthProviderFactory;
        resolvers: never;
    }>;
    saml: Readonly<{
        create: (options?: {
            authHandler?: AuthHandler<SamlAuthResult> | undefined;
            signIn?: {
                resolver: SignInResolver<SamlAuthResult>;
            } | undefined;
        } | undefined) => _backstage_plugin_auth_node.AuthProviderFactory;
        resolvers: Readonly<{
            nameIdMatchingUserEntityName(): SignInResolver<SamlAuthResult>;
        }>;
    }>;
    easyAuth: Readonly<{
        create: (options?: {
            authHandler?: AuthHandler<EasyAuthResult> | undefined;
            signIn: {
                resolver: SignInResolver<EasyAuthResult>;
            };
        } | undefined) => _backstage_plugin_auth_node.AuthProviderFactory;
        resolvers: never;
    }>;
}>;
/**
 * All auth provider factories that are installed by default.
 *
 * @public
 */
declare const defaultAuthProviderFactories: {
    [providerId: string]: AuthProviderFactory;
};

/**
 * Creates a standardized representation of an integration with a third-party
 * auth provider.
 *
 * The returned object facilitates the creation of provider instances, and
 * supplies built-in sign-in resolvers for the specific provider.
 *
 * @public
 */
declare function createAuthProviderIntegration<TCreateOptions extends unknown[], TResolvers extends {
    [name in string]: (...args: any[]) => SignInResolver<any>;
}>(config: {
    create: (...args: TCreateOptions) => AuthProviderFactory;
    resolvers?: TResolvers;
}): Readonly<{
    create: (...args: TCreateOptions) => AuthProviderFactory;
    resolvers: Readonly<string extends keyof TResolvers ? never : TResolvers>;
}>;

/**
 * @public
 * @deprecated import from `@backstage/plugin-auth-node` instead
 */
declare const prepareBackstageIdentityResponse: typeof prepareBackstageIdentityResponse$1;

/** @public */
type ProviderFactories = {
    [s: string]: AuthProviderFactory;
};
/** @public */
interface RouterOptions {
    logger: LoggerService;
    database: PluginDatabaseManager;
    config: Config;
    discovery: PluginEndpointDiscovery;
    tokenManager: TokenManager;
    tokenFactoryAlgorithm?: string;
    providerFactories?: ProviderFactories;
    disableDefaultProviderFactories?: boolean;
    catalogApi?: CatalogApi;
}
/** @public */
declare function createRouter(options: RouterOptions): Promise<express.Router>;
/** @public */
declare function createOriginFilter(config: Config): (origin: string) => boolean;

/**
 * @public
 * @deprecated import from `@backstage/plugin-auth-node` instead
 */
type TokenParams = TokenParams$1;

/**
 * @public
 * @deprecated import from `@backstage/plugin-auth-node` instead
 */
type WebMessageResponse = WebMessageResponse$1;

/**
 * @public
 * @deprecated Use `sendWebMessageResponse` from `@backstage/plugin-auth-node` instead
 */
declare const postMessageResponse: (res: express.Response, appOrigin: string, response: WebMessageResponse) => void;
/**
 * @public
 * @deprecated Use inline logic to check that the `X-Requested-With` header is set to `'XMLHttpRequest'` instead.
 */
declare const ensuresXRequestedWith: (req: express.Request) => boolean;

/**
 * A catalog client tailored for reading out identity data from the catalog.
 *
 * @public
 */
declare class CatalogIdentityClient {
    private readonly catalogApi;
    private readonly tokenManager;
    constructor(options: {
        catalogApi: CatalogApi;
        tokenManager: TokenManager;
    });
    /**
     * Looks up a single user using a query.
     *
     * Throws a NotFoundError or ConflictError if 0 or multiple users are found.
     */
    findUser(query: {
        annotations: Record<string, string>;
    }): Promise<UserEntity>;
    /**
     * Resolve additional entity claims from the catalog, using the passed-in entity names. Designed
     * to be used within a `signInResolver` where additional entity claims might be provided, but
     * group membership and transient group membership lean on imported catalog relations.
     *
     * Returns a superset of the entity names that can be passed directly to `issueToken` as `ent`.
     */
    resolveCatalogMembership(query: {
        entityRefs: string[];
        logger?: LoggerService;
    }): Promise<string[]>;
}

/**
 * Uses the default ownership resolution logic to return an array
 * of entity refs that the provided entity claims ownership through.
 *
 * A reference to the entity itself will also be included in the returned array.
 *
 * @public
 */
declare function getDefaultOwnershipEntityRefs(entity: Entity): string[];

export { AuthHandler, AuthHandlerResult, AuthProviderConfig, AuthProviderFactory, AuthProviderRouteHandlers, AuthResolverCatalogUserQuery, AuthResolverContext, AuthResponse, AwsAlbResult, BitbucketOAuthResult, BitbucketPassportProfile, BitbucketServerOAuthResult, CatalogIdentityClient, CloudflareAccessClaims, CloudflareAccessGroup, CloudflareAccessIdentityProfile, CloudflareAccessResult, CookieConfigurer, EasyAuthResult, GcpIapResult, GcpIapTokenInfo, GithubOAuthResult, OAuth2ProxyResult, OAuthAdapter, OAuthAdapterOptions, OAuthEnvironmentHandler, OAuthHandlers, OAuthLogoutRequest, OAuthProviderInfo, OAuthProviderOptions, OAuthRefreshRequest, OAuthResponse, OAuthResult, OAuthStartRequest, OAuthStartResponse, OAuthState, OidcAuthResult, ProfileInfo, ProviderFactories, RouterOptions, SamlAuthResult, SignInInfo, SignInResolver, StateEncoder, TokenParams, WebMessageResponse, createAuthProviderIntegration, createOriginFilter, createRouter, authPlugin as default, defaultAuthProviderFactories, encodeState, ensuresXRequestedWith, getDefaultOwnershipEntityRefs, postMessageResponse, prepareBackstageIdentityResponse, providers, readState, verifyNonce };
