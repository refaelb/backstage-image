import { r as rootRouteRef, D as DefaultStarredEntitiesApi, a as DefaultEntityPresentationApi, c as createComponentRouteRef, v as viewTechDocRouteRef, b as createFromTemplateRouteRef, u as unregisterRedirectRouteRef } from './esm/routes-86c34994.esm.js';
export { a as DefaultEntityPresentationApi, D as DefaultStarredEntitiesApi } from './esm/routes-86c34994.esm.js';
export { A as AboutContent, a as AboutField } from './esm/AboutCard-ed377723.esm.js';
import React, { useMemo, useState, useEffect } from 'react';
import { makeStyles, createStyles, Select, InputBase, MenuItem, Dialog, DialogTitle, DialogActions, Button, Box } from '@material-ui/core';
import { catalogApiRef, useEntityList, EntityKindFilter, useEntity, EntityRefLink, useAsyncEntity, CatalogFilterLayout, starredEntitiesApiRef, entityPresentationApiRef, entityRouteRef } from '@backstage/plugin-catalog-react';
import pluralize from 'pluralize';
import { useApi, alertApiRef, useRouteRef, attachComponentData, useApiHolder, useElementFilter, createPlugin, createApiFactory, discoveryApiRef, fetchApiRef, storageApiRef, createRoutableExtension, createComponentExtension } from '@backstage/core-plugin-api';
import useAsync from 'react-use/lib/useAsync';
export { C as CatalogTable } from './esm/CatalogTable-2194265c.esm.js';
export { E as EntityLayout } from './esm/EntityLayout-7a74c718.esm.js';
import { Alert } from '@material-ui/lab';
import { useNavigate } from 'react-router-dom';
import { assertError } from '@backstage/errors';
import { ResponseErrorPanel } from '@backstage/core-components';
import { stringifyEntityRef } from '@backstage/catalog-model';
import { ENTITY_STATUS_CATALOG_PROCESSING_TYPE, CatalogClient } from '@backstage/catalog-client';
export { h as hasLabels } from './esm/conditions-7e166d27.esm.js';
import { createSearchResultListItemExtension } from '@backstage/plugin-search-react';
import '@backstage/types';
import 'dataloader';
import 'expiry-map';
import 'zen-observable';
import '@material-ui/icons/Apartment';
import '@material-ui/icons/Business';
import '@material-ui/icons/Extension';
import '@material-ui/icons/Help';
import '@material-ui/icons/LibraryAdd';
import '@material-ui/icons/LocationOn';
import '@material-ui/icons/Memory';
import '@material-ui/icons/People';
import '@material-ui/icons/Person';
import '@material-ui/icons/Work';
import 'lodash';
import '@backstage/integration-react';
import './esm/LinksGridList-c9dd074c.esm.js';
import '@material-ui/icons/Language';
import '@material-ui/icons/Cached';
import '@material-ui/icons/AddCircleOutline';
import '@material-ui/icons/Description';
import '@material-ui/icons/Edit';
import '@backstage/plugin-scaffolder-common';
import '@backstage/plugin-catalog-react/alpha';
import '@backstage/plugin-catalog-common/alpha';
import '@material-ui/core/Typography';
import '@material-ui/core/styles';
import '@mui/utils';
import '@material-ui/icons/OpenInNew';
import '@material-ui/icons/Star';
import '@material-ui/icons/StarBorder';
import '@material-ui/icons/BugReport';
import '@material-ui/icons/MoreVert';
import '@material-ui/icons/FileCopyTwoTone';
import '@material-ui/icons/Cancel';
import 'react-use/lib/useCopyToClipboard';

function useAllKinds() {
  const catalogApi = useApi(catalogApiRef);
  const {
    error,
    loading,
    value: allKinds
  } = useAsync(async () => {
    const items = await catalogApi.getEntityFacets({ facets: ["kind"] }).then((response) => {
      var _a;
      return ((_a = response.facets.kind) == null ? void 0 : _a.map((f) => f.value).sort()) || [];
    });
    return items;
  }, [catalogApi]);
  return { loading, error, allKinds: allKinds != null ? allKinds : [] };
}
function filterKinds(allKinds, allowedKinds, forcedKinds) {
  let availableKinds = allKinds;
  if (allowedKinds) {
    availableKinds = availableKinds.filter(
      (k) => allowedKinds.some(
        (a) => a.toLocaleLowerCase("en-US") === k.toLocaleLowerCase("en-US")
      )
    );
  }
  if (forcedKinds && !allKinds.some(
    (a) => a.toLocaleLowerCase("en-US") === forcedKinds.toLocaleLowerCase("en-US")
  )) {
    availableKinds = availableKinds.concat([forcedKinds]);
  }
  const kindsMap = availableKinds.sort().reduce((acc, kind) => {
    acc[kind.toLocaleLowerCase("en-US")] = kind;
    return acc;
  }, {});
  return kindsMap;
}

const useStyles = makeStyles(
  (theme) => createStyles({
    root: {
      ...theme.typography.h4
    }
  })
);
function CatalogKindHeader(props) {
  var _a, _b;
  const { initialFilter = "component", allowedKinds } = props;
  const classes = useStyles();
  const { allKinds } = useAllKinds();
  const {
    filters,
    updateFilters,
    queryParameters: { kind: kindParameter }
  } = useEntityList();
  const queryParamKind = useMemo(
    () => [kindParameter].flat()[0],
    [kindParameter]
  );
  const [selectedKind, setSelectedKind] = useState(
    (_b = queryParamKind != null ? queryParamKind : (_a = filters.kind) == null ? void 0 : _a.value) != null ? _b : initialFilter
  );
  useEffect(() => {
    if (queryParamKind) {
      setSelectedKind(queryParamKind);
    }
  }, [queryParamKind]);
  useEffect(() => {
    var _a2, _b2;
    if ((_a2 = filters.kind) == null ? void 0 : _a2.value) {
      setSelectedKind((_b2 = filters.kind) == null ? void 0 : _b2.value);
    }
  }, [filters.kind]);
  useEffect(() => {
    updateFilters({
      kind: selectedKind ? new EntityKindFilter(selectedKind) : void 0
    });
  }, [selectedKind, updateFilters]);
  const options = filterKinds(allKinds, allowedKinds, selectedKind);
  return /* @__PURE__ */ React.createElement(
    Select,
    {
      input: /* @__PURE__ */ React.createElement(InputBase, null),
      value: selectedKind.toLocaleLowerCase("en-US"),
      onChange: (e) => setSelectedKind(e.target.value),
      classes
    },
    Object.keys(options).map((kind) => /* @__PURE__ */ React.createElement(MenuItem, { value: kind, key: kind }, `${pluralize(options[kind])}`))
  );
}

function DeleteEntityDialog(props) {
  const { open, onClose, onConfirm, entity } = props;
  const [busy, setBusy] = useState(false);
  const catalogApi = useApi(catalogApiRef);
  const alertApi = useApi(alertApiRef);
  const onDelete = async () => {
    setBusy(true);
    try {
      const uid = entity.metadata.uid;
      await catalogApi.removeEntityByUid(uid);
      onConfirm();
    } catch (err) {
      assertError(err);
      alertApi.post({ message: err.message });
    } finally {
      setBusy(false);
    }
  };
  return /* @__PURE__ */ React.createElement(Dialog, { open, onClose }, /* @__PURE__ */ React.createElement(DialogTitle, { id: "responsive-dialog-title" }, "Are you sure you want to delete this entity?"), /* @__PURE__ */ React.createElement(DialogActions, null, /* @__PURE__ */ React.createElement(
    Button,
    {
      variant: "contained",
      color: "secondary",
      disabled: busy,
      onClick: onDelete
    },
    "Delete"
  ), /* @__PURE__ */ React.createElement(Button, { onClick: onClose, color: "primary" }, "Cancel")));
}

function isOrphan(entity) {
  var _a, _b;
  return ((_b = (_a = entity == null ? void 0 : entity.metadata) == null ? void 0 : _a.annotations) == null ? void 0 : _b["backstage.io/orphan"]) === "true";
}
function EntityOrphanWarning() {
  const navigate = useNavigate();
  const catalogLink = useRouteRef(rootRouteRef);
  const [confirmationDialogOpen, setConfirmationDialogOpen] = useState(false);
  const { entity } = useEntity();
  const cleanUpAfterRemoval = async () => {
    setConfirmationDialogOpen(false);
    navigate(catalogLink());
  };
  return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(Alert, { severity: "warning", onClick: () => setConfirmationDialogOpen(true) }, "This entity is not referenced by any location and is therefore not receiving updates. Click here to delete."), /* @__PURE__ */ React.createElement(
    DeleteEntityDialog,
    {
      open: confirmationDialogOpen,
      entity,
      onConfirm: cleanUpAfterRemoval,
      onClose: () => setConfirmationDialogOpen(false)
    }
  ));
}

async function getRelationWarnings(entity, catalogApi) {
  var _a;
  const entityRefRelations = (_a = entity.relations) == null ? void 0 : _a.map(
    (relation) => relation.targetRef
  );
  if (!entityRefRelations || (entityRefRelations == null ? void 0 : entityRefRelations.length) < 1 || entityRefRelations.length > 1e3) {
    return [];
  }
  const relatedEntities = await catalogApi.getEntitiesByRefs({
    entityRefs: entityRefRelations,
    fields: ["kind", "metadata.name", "metadata.namespace"]
  });
  return entityRefRelations.filter(
    (_, index) => relatedEntities.items[index] === void 0
  );
}
async function hasRelationWarnings(entity, context) {
  const catalogApi = context.apis.get(catalogApiRef);
  if (!catalogApi) {
    throw new Error(`No implementation available for ${catalogApiRef}`);
  }
  const relatedEntitiesMissing = await getRelationWarnings(entity, catalogApi);
  return relatedEntitiesMissing.length > 0;
}
function EntityRelationWarning() {
  const { entity } = useEntity();
  const catalogApi = useApi(catalogApiRef);
  const { loading, error, value } = useAsync(async () => {
    return getRelationWarnings(entity, catalogApi);
  }, [entity, catalogApi]);
  if (error) {
    return /* @__PURE__ */ React.createElement(Box, { mb: 1 }, /* @__PURE__ */ React.createElement(ResponseErrorPanel, { error }));
  }
  if (loading || !value || value.length === 0) {
    return null;
  }
  return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(Alert, { severity: "warning" }, "This entity has relations to other entities, which can't be found in the catalog. ", /* @__PURE__ */ React.createElement("br", null), "Entities not found are: ", value.join(", ")));
}

const errorFilter = (i) => i.error && i.level === "error" && i.type === ENTITY_STATUS_CATALOG_PROCESSING_TYPE;
async function getOwnAndAncestorsErrors(entityRef, catalogApi) {
  const ancestors = await catalogApi.getEntityAncestors({ entityRef });
  const items = ancestors.items.map((item) => {
    var _a, _b;
    const statuses = (_b = (_a = item.entity.status) == null ? void 0 : _a.items) != null ? _b : [];
    const errors = statuses.filter(errorFilter).map((e) => e.error).filter((e) => Boolean(e));
    return { errors, entity: item.entity };
  }).filter((item) => item.errors.length > 0);
  return { items };
}
async function hasCatalogProcessingErrors(entity, context) {
  const catalogApi = context.apis.get(catalogApiRef);
  if (!catalogApi) {
    throw new Error(`No implementation available for ${catalogApiRef}`);
  }
  const errors = await getOwnAndAncestorsErrors(
    stringifyEntityRef(entity),
    catalogApi
  );
  return errors.items.length > 0;
}
function EntityProcessingErrorsPanel() {
  const { entity } = useEntity();
  const entityRef = stringifyEntityRef(entity);
  const catalogApi = useApi(catalogApiRef);
  const { loading, error, value } = useAsync(async () => {
    return getOwnAndAncestorsErrors(entityRef, catalogApi);
  }, [entityRef, catalogApi]);
  if (error) {
    return /* @__PURE__ */ React.createElement(Box, { mb: 1 }, /* @__PURE__ */ React.createElement(ResponseErrorPanel, { error }));
  }
  if (loading || !value) {
    return null;
  }
  return /* @__PURE__ */ React.createElement(React.Fragment, null, value.items.map((ancestorError, index) => /* @__PURE__ */ React.createElement(Box, { key: index, mb: 1 }, stringifyEntityRef(entity) !== stringifyEntityRef(ancestorError.entity) && /* @__PURE__ */ React.createElement(Box, { p: 1 }, "The error below originates from", " ", /* @__PURE__ */ React.createElement(EntityRefLink, { entityRef: ancestorError.entity })), ancestorError.errors.map((e, i) => /* @__PURE__ */ React.createElement(ResponseErrorPanel, { key: i, error: e })))));
}

const ENTITY_SWITCH_KEY = "core.backstage.entitySwitch";
const EntitySwitchCaseComponent = (_props) => null;
attachComponentData(EntitySwitchCaseComponent, ENTITY_SWITCH_KEY, true);
const EntitySwitch = (props) => {
  var _a, _b;
  const { entity, loading } = useAsyncEntity();
  const apis = useApiHolder();
  const results = useElementFilter(
    props.children,
    (collection) => collection.selectByComponentData({
      key: ENTITY_SWITCH_KEY,
      withStrictError: "Child of EntitySwitch is not an EntitySwitch.Case"
    }).getElements().flatMap((element) => {
      if (loading && !entity) {
        return [];
      }
      const { if: condition, children: elementsChildren } = element.props;
      if (!entity) {
        return [
          {
            if: condition === void 0,
            children: elementsChildren
          }
        ];
      }
      return [
        {
          if: condition == null ? void 0 : condition(entity, { apis }),
          children: elementsChildren
        }
      ];
    }),
    [apis, entity, loading]
  );
  const hasAsyncCases = results.some(
    (r) => typeof r.if === "object" && "then" in r.if
  );
  if (hasAsyncCases) {
    return /* @__PURE__ */ React.createElement(
      AsyncEntitySwitch,
      {
        results,
        renderMultipleMatches: props.renderMultipleMatches
      }
    );
  }
  if (props.renderMultipleMatches === "all") {
    const children = results.filter((r) => r.if).map((r) => r.children);
    if (children.length === 0) {
      return getDefaultChildren(results);
    }
    return /* @__PURE__ */ React.createElement(React.Fragment, null, children);
  }
  return (_b = (_a = results.find((r) => r.if)) == null ? void 0 : _a.children) != null ? _b : getDefaultChildren(results);
};
function AsyncEntitySwitch({
  results,
  renderMultipleMatches
}) {
  const { loading, value } = useAsync(async () => {
    var _a;
    const promises = results.map(
      async ({ if: condition, children: output }) => {
        try {
          if (await condition) {
            return output;
          }
        } catch {
        }
        return null;
      }
    );
    if (renderMultipleMatches === "all") {
      const children = (await Promise.all(promises)).filter(Boolean);
      if (children.length === 0) {
        return getDefaultChildren(results);
      }
      return /* @__PURE__ */ React.createElement(React.Fragment, null, children);
    }
    return (_a = (await Promise.all(promises)).find(Boolean)) != null ? _a : getDefaultChildren(results);
  }, [results]);
  if (loading || !value) {
    return null;
  }
  return value;
}
function getDefaultChildren(results) {
  var _a, _b;
  return (_b = (_a = results.filter((r) => r.if === void 0)[0]) == null ? void 0 : _a.children) != null ? _b : null;
}
EntitySwitch.Case = EntitySwitchCaseComponent;

function strCmp(a, b) {
  return Boolean(
    a && typeof a === "string" && (a == null ? void 0 : a.toLocaleLowerCase("en-US")) === (b == null ? void 0 : b.toLocaleLowerCase("en-US"))
  );
}
function strCmpAll(value, cmpValues) {
  return typeof cmpValues === "string" ? strCmp(value, cmpValues) : cmpValues.length === 0 || cmpValues.some((cmpVal) => strCmp(value, cmpVal));
}
function isKind(kinds) {
  return isEntityWith({ kind: kinds });
}
function isComponentType(types) {
  return isEntityWith({ kind: "component", type: types });
}
function isResourceType(types) {
  return isEntityWith({ kind: "resource", type: types });
}
function isEntityWith(predicate) {
  return (entity) => {
    var _a;
    if (predicate.kind && !strCmpAll(entity.kind, predicate.kind)) {
      return false;
    }
    if (predicate.type && !strCmpAll((_a = entity.spec) == null ? void 0 : _a.type, predicate.type)) {
      return false;
    }
    return true;
  };
}
function isNamespace(namespaces) {
  return (entity) => {
    var _a;
    return strCmpAll((_a = entity.metadata) == null ? void 0 : _a.namespace, namespaces);
  };
}

const FilteredEntityLayout = CatalogFilterLayout;
const FilterContainer = CatalogFilterLayout.Filters;
const EntityListContainer = CatalogFilterLayout.Content;

const catalogPlugin = createPlugin({
  id: "catalog",
  apis: [
    createApiFactory({
      api: catalogApiRef,
      deps: {
        discoveryApi: discoveryApiRef,
        fetchApi: fetchApiRef
      },
      factory: ({ discoveryApi, fetchApi }) => new CatalogClient({ discoveryApi, fetchApi })
    }),
    createApiFactory({
      api: starredEntitiesApiRef,
      deps: { storageApi: storageApiRef },
      factory: ({ storageApi }) => new DefaultStarredEntitiesApi({ storageApi })
    }),
    createApiFactory({
      api: entityPresentationApiRef,
      deps: { catalogApi: catalogApiRef },
      factory: ({ catalogApi }) => DefaultEntityPresentationApi.create({ catalogApi })
    })
  ],
  routes: {
    catalogIndex: rootRouteRef,
    catalogEntity: entityRouteRef
  },
  externalRoutes: {
    createComponent: createComponentRouteRef,
    viewTechDoc: viewTechDocRouteRef,
    createFromTemplate: createFromTemplateRouteRef,
    unregisterRedirect: unregisterRedirectRouteRef
  }
});
const CatalogIndexPage = catalogPlugin.provide(
  createRoutableExtension({
    name: "CatalogIndexPage",
    component: () => import('./esm/index-3544ccde.esm.js').then((m) => m.CatalogPage),
    mountPoint: rootRouteRef
  })
);
const CatalogEntityPage = catalogPlugin.provide(
  createRoutableExtension({
    name: "CatalogEntityPage",
    component: () => import('./esm/index-1fe355f9.esm.js').then((m) => m.CatalogEntityPage),
    mountPoint: entityRouteRef
  })
);
const EntityAboutCard = catalogPlugin.provide(
  createComponentExtension({
    name: "EntityAboutCard",
    component: {
      lazy: () => import('./esm/index-6ed25e48.esm.js').then((m) => m.AboutCard)
    }
  })
);
const EntityLinksCard = catalogPlugin.provide(
  createComponentExtension({
    name: "EntityLinksCard",
    component: {
      lazy: () => import('./esm/index-a2f43c63.esm.js').then((m) => m.EntityLinksCard)
    }
  })
);
const EntityLabelsCard = catalogPlugin.provide(
  createComponentExtension({
    name: "EntityLabelsCard",
    component: {
      lazy: () => import('./esm/index-1819df86.esm.js').then((m) => m.EntityLabelsCard)
    }
  })
);
const EntityHasSystemsCard = catalogPlugin.provide(
  createComponentExtension({
    name: "EntityHasSystemsCard",
    component: {
      lazy: () => import('./esm/index-b87e664e.esm.js').then((m) => m.HasSystemsCard)
    }
  })
);
const EntityHasComponentsCard = catalogPlugin.provide(
  createComponentExtension({
    name: "EntityHasComponentsCard",
    component: {
      lazy: () => import('./esm/index-151a7b53.esm.js').then((m) => m.HasComponentsCard)
    }
  })
);
const EntityHasSubcomponentsCard = catalogPlugin.provide(
  createComponentExtension({
    name: "EntityHasSubcomponentsCard",
    component: {
      lazy: () => import('./esm/index-df2397a2.esm.js').then(
        (m) => m.HasSubcomponentsCard
      )
    }
  })
);
const EntityHasResourcesCard = catalogPlugin.provide(
  createComponentExtension({
    name: "EntityHasResourcesCard",
    component: {
      lazy: () => import('./esm/index-457f1bef.esm.js').then((m) => m.HasResourcesCard)
    }
  })
);
const EntityDependsOnComponentsCard = catalogPlugin.provide(
  createComponentExtension({
    name: "EntityDependsOnComponentsCard",
    component: {
      lazy: () => import('./esm/index-5d579387.esm.js').then(
        (m) => m.DependsOnComponentsCard
      )
    }
  })
);
const EntityDependencyOfComponentsCard = catalogPlugin.provide(
  createComponentExtension({
    name: "EntityDependencyOfComponentsCard",
    component: {
      lazy: () => import('./esm/index-226f1855.esm.js').then(
        (m) => m.DependencyOfComponentsCard
      )
    }
  })
);
const EntityDependsOnResourcesCard = catalogPlugin.provide(
  createComponentExtension({
    name: "EntityDependsOnResourcesCard",
    component: {
      lazy: () => import('./esm/index-2ae6a112.esm.js').then(
        (m) => m.DependsOnResourcesCard
      )
    }
  })
);
const RelatedEntitiesCard = catalogPlugin.provide(
  createComponentExtension({
    name: "RelatedEntitiesCard",
    component: {
      lazy: () => import('./esm/index-87a68cf7.esm.js').then(
        (m) => m.RelatedEntitiesCard
      )
    }
  })
);
const CatalogSearchResultListItem = catalogPlugin.provide(
  createSearchResultListItemExtension({
    name: "CatalogSearchResultListItem",
    component: () => import('./esm/index-391ccf9c.esm.js').then(
      (m) => m.CatalogSearchResultListItem
    ),
    predicate: (result) => result.type === "software-catalog"
  })
);

export { CatalogEntityPage, CatalogIndexPage, CatalogKindHeader, CatalogSearchResultListItem, EntityAboutCard, EntityDependencyOfComponentsCard, EntityDependsOnComponentsCard, EntityDependsOnResourcesCard, EntityHasComponentsCard, EntityHasResourcesCard, EntityHasSubcomponentsCard, EntityHasSystemsCard, EntityLabelsCard, EntityLinksCard, EntityListContainer, EntityOrphanWarning, EntityProcessingErrorsPanel, EntityRelationWarning, EntitySwitch, FilterContainer, FilteredEntityLayout, RelatedEntitiesCard, catalogPlugin, hasCatalogProcessingErrors, hasRelationWarnings, isComponentType, isEntityWith, isKind, isNamespace, isOrphan, isResourceType };
//# sourceMappingURL=index.esm.js.map
