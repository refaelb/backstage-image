import { useEntity } from '@backstage/plugin-catalog-react';
import Grid from '@material-ui/core/Grid';
import React, { useMemo } from 'react';
import { InputError } from '@backstage/errors';

function createKindMatcher(parameters, _onParseError) {
  const items = parameters.map((p) => p.toLocaleLowerCase("en-US"));
  return (entity) => items.includes(entity.kind.toLocaleLowerCase("en-US"));
}

function createTypeMatcher(parameters, _onParseError) {
  const items = parameters.map((p) => p.toLocaleLowerCase("en-US"));
  return (entity) => {
    var _a;
    const value = (_a = entity.spec) == null ? void 0 : _a.type;
    return typeof value === "string" && items.includes(value.toLocaleLowerCase("en-US"));
  };
}

const allowedMatchers$1 = {
  orphan: (entity) => {
    var _a;
    return Boolean((_a = entity.metadata.annotations) == null ? void 0 : _a["backstage.io/orphan"]);
  }
};
function createIsMatcher(parameters, onParseError) {
  const matchers = parameters.flatMap((parameter) => {
    const matcher = allowedMatchers$1[parameter.toLocaleLowerCase("en-US")];
    if (!matcher) {
      const known = Object.keys(allowedMatchers$1).map((m) => `'${m}'`);
      onParseError(
        new InputError(
          `'${parameter}' is not a valid parameter for 'is' filter expressions, expected one of ${known}`
        )
      );
      return [];
    }
    return [matcher];
  });
  return (entity) => matchers.length ? matchers.some((matcher) => matcher(entity)) : true;
}

const allowedMatchers = {
  labels: (entity) => {
    var _a;
    return Object.keys((_a = entity.metadata.labels) != null ? _a : {}).length > 0;
  },
  links: (entity) => {
    var _a;
    return ((_a = entity.metadata.links) != null ? _a : []).length > 0;
  }
};
function createHasMatcher(parameters, onParseError) {
  const matchers = parameters.flatMap((parameter) => {
    const matcher = allowedMatchers[parameter.toLocaleLowerCase("en-US")];
    if (!matcher) {
      const known = Object.keys(allowedMatchers).map((m) => `'${m}'`);
      onParseError(
        new InputError(
          `'${parameter}' is not a valid parameter for 'has' filter expressions, expected one of ${known}`
        )
      );
      return [];
    }
    return [matcher];
  });
  return (entity) => matchers.length ? matchers.some((matcher) => matcher(entity)) : true;
}

const rootMatcherFactories = {
  kind: createKindMatcher,
  type: createTypeMatcher,
  is: createIsMatcher,
  has: createHasMatcher
};
function parseFilterExpression(expression) {
  const expressionParseErrors = [];
  const parts = splitFilterExpression(
    expression,
    (e) => expressionParseErrors.push(e)
  );
  const matchers = parts.flatMap((part) => {
    const factory = rootMatcherFactories[part.key];
    if (!factory) {
      const known = Object.keys(rootMatcherFactories).map((m) => `'${m}'`);
      expressionParseErrors.push(
        new InputError(
          `'${part.key}' is not a valid filter expression key, expected one of ${known}`
        )
      );
      return [];
    }
    const matcher = factory(
      part.parameters,
      (e) => expressionParseErrors.push(e)
    );
    return [matcher];
  });
  const filterFn = (entity) => matchers.every((matcher) => {
    try {
      return matcher(entity);
    } catch {
      return false;
    }
  });
  return {
    filterFn,
    expressionParseErrors
  };
}
function splitFilterExpression(expression, onParseError) {
  const words = expression.split(" ").map((w) => w.trim()).filter(Boolean);
  const result = new Array();
  for (const word of words) {
    const match = word.match(/^([^:]+):(.+)$/);
    if (!match) {
      onParseError(
        new InputError(
          `'${word}' is not a valid filter expression, expected 'key:parameter' form`
        )
      );
      continue;
    }
    const key = match[1];
    const parameters = match[2].split(",").filter(Boolean);
    result.push({ key, parameters });
  }
  return result;
}

const seenParseErrorExpressionStrings = /* @__PURE__ */ new Set();
const seenDuplicateExpressionStrings = /* @__PURE__ */ new Set();
function buildFilterFn(filterFunction, filterExpression) {
  if (filterFunction && filterExpression && !seenDuplicateExpressionStrings.has(filterExpression)) {
    console.warn(
      `Duplicate entity filter methods found, both '${filterExpression}' as well as a callback function, which is not permitted - using the callback`
    );
    seenDuplicateExpressionStrings.add(filterExpression);
  }
  const filter = filterFunction || filterExpression;
  if (!filter) {
    return () => true;
  } else if (typeof filter === "function") {
    return (subject) => filter(subject);
  }
  const result = parseFilterExpression(filter);
  if (result.expressionParseErrors.length && !seenParseErrorExpressionStrings.has(filter)) {
    console.warn(
      `Error(s) in entity filter expression '${filter}'`,
      result.expressionParseErrors
    );
    seenParseErrorExpressionStrings.add(filter);
  }
  return result.filterFn;
}
function CardWrapper(props) {
  const { entity, element, filterFunction, filterExpression } = props;
  const filterFn = useMemo(
    () => buildFilterFn(filterFunction, filterExpression),
    [filterFunction, filterExpression]
  );
  return filterFn(entity) ? /* @__PURE__ */ React.createElement(Grid, { item: true, md: 6, xs: 12 }, element) : null;
}
function EntityOverviewPage(props) {
  const { entity } = useEntity();
  return /* @__PURE__ */ React.createElement(Grid, { container: true, spacing: 3, alignItems: "stretch" }, props.cards.map((card, index) => /* @__PURE__ */ React.createElement(CardWrapper, { key: index, entity, ...card })));
}

export { EntityOverviewPage };
//# sourceMappingURL=EntityOverviewPage-f61e50bf.esm.js.map
