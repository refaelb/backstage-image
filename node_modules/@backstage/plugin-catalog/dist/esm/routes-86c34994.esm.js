import { stringifyEntityRef, parseEntityRef } from '@backstage/catalog-model';
import { durationToMilliseconds } from '@backstage/types';
import DataLoader from 'dataloader';
import ExpiryMap from 'expiry-map';
import ObservableImpl from 'zen-observable';
import { defaultEntityPresentation } from '@backstage/plugin-catalog-react';
import ApartmentIcon from '@material-ui/icons/Apartment';
import BusinessIcon from '@material-ui/icons/Business';
import ExtensionIcon from '@material-ui/icons/Extension';
import HelpIcon from '@material-ui/icons/Help';
import LibraryAddIcon from '@material-ui/icons/LibraryAdd';
import LocationOnIcon from '@material-ui/icons/LocationOn';
import MemoryIcon from '@material-ui/icons/Memory';
import PeopleIcon from '@material-ui/icons/People';
import PersonIcon from '@material-ui/icons/Person';
import WorkIcon from '@material-ui/icons/Work';
import { isArray, isString } from 'lodash';
import { createExternalRouteRef, createRouteRef } from '@backstage/core-plugin-api';

const DEFAULT_CACHE_TTL = { seconds: 10 };
const DEFAULT_BATCH_DELAY = { milliseconds: 50 };
const UNKNOWN_KIND_ICON = HelpIcon;
const DEFAULT_ICONS = {
  api: ExtensionIcon,
  component: MemoryIcon,
  system: BusinessIcon,
  resource: WorkIcon,
  domain: ApartmentIcon,
  location: LocationOnIcon,
  user: PersonIcon,
  group: PeopleIcon,
  template: LibraryAddIcon
};
function createDefaultRenderer(options) {
  return {
    async: options.async,
    render: ({ entityRef, entity, context }) => {
      const presentation = defaultEntityPresentation(
        entity || entityRef,
        context
      );
      return {
        snapshot: presentation,
        loadEntity: options.async
      };
    }
  };
}

var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var __privateMethod = (obj, member, method) => {
  __accessCheck(obj, member, "access private method");
  return method;
};
var _cache, _cacheTtlMs, _loader, _kindIcons, _renderer, _getEntityForInitialRender, getEntityForInitialRender_fn, _createLoader, createLoader_fn, _maybeFallbackIcon, maybeFallbackIcon_fn;
const _DefaultEntityPresentationApi = class _DefaultEntityPresentationApi {
  constructor(options) {
    __privateAdd(this, _getEntityForInitialRender);
    __privateAdd(this, _createLoader);
    __privateAdd(this, _maybeFallbackIcon);
    // This cache holds on to all entity data ever loaded, no matter how old. Each
    // entry is tagged with a timestamp of when it was inserted. We use this map
    // to be able to always render SOME data even though the information is old.
    // Entities change very rarely, so it's likely that the rendered information
    // was perfectly fine in the first place.
    __privateAdd(this, _cache, void 0);
    __privateAdd(this, _cacheTtlMs, void 0);
    __privateAdd(this, _loader, void 0);
    __privateAdd(this, _kindIcons, void 0);
    // lowercased kinds
    __privateAdd(this, _renderer, void 0);
    var _a, _b, _c, _d;
    const cacheTtl = (_a = options.cacheTtl) != null ? _a : DEFAULT_CACHE_TTL;
    const batchDelay = (_b = options.batchDelay) != null ? _b : DEFAULT_BATCH_DELAY;
    const renderer = (_c = options.renderer) != null ? _c : createDefaultRenderer({ async: true });
    const kindIcons = {};
    Object.entries(DEFAULT_ICONS).forEach(([kind, icon]) => {
      kindIcons[kind.toLocaleLowerCase("en-US")] = icon;
    });
    Object.entries((_d = options.kindIcons) != null ? _d : {}).forEach(([kind, icon]) => {
      kindIcons[kind.toLocaleLowerCase("en-US")] = icon;
    });
    if (renderer.async) {
      if (!options.catalogApi) {
        throw new TypeError(`Asynchronous rendering requires a catalog API`);
      }
      __privateSet(this, _loader, __privateMethod(this, _createLoader, createLoader_fn).call(this, {
        cacheTtl,
        batchDelay,
        renderer,
        catalogApi: options.catalogApi
      }));
    }
    __privateSet(this, _cacheTtlMs, durationToMilliseconds(cacheTtl));
    __privateSet(this, _cache, /* @__PURE__ */ new Map());
    __privateSet(this, _kindIcons, kindIcons);
    __privateSet(this, _renderer, renderer);
  }
  /**
   * Creates a new presentation API that does not reach out to the catalog.
   */
  static createLocal() {
    return new _DefaultEntityPresentationApi({
      renderer: createDefaultRenderer({ async: false })
    });
  }
  /**
   * Creates a new presentation API that calls out to the catalog as needed to
   * get additional information about entities.
   */
  static create(options) {
    return new _DefaultEntityPresentationApi(options);
  }
  /** {@inheritdoc @backstage/plugin-catalog-react#EntityPresentationApi.forEntity} */
  forEntity(entityOrRef, context) {
    const { entityRef, kind, entity, needsLoad } = __privateMethod(this, _getEntityForInitialRender, getEntityForInitialRender_fn).call(this, entityOrRef);
    const render = (options) => {
      const { snapshot } = __privateGet(this, _renderer).render({
        entityRef,
        loading: options.loading,
        entity: options.entity,
        context: context || {}
      });
      return {
        ...snapshot,
        entityRef,
        Icon: __privateMethod(this, _maybeFallbackIcon, maybeFallbackIcon_fn).call(this, snapshot.Icon, kind)
      };
    };
    let initialSnapshot;
    try {
      initialSnapshot = render({
        loading: needsLoad,
        entity
      });
    } catch {
      initialSnapshot = {
        primaryTitle: entityRef,
        entityRef
      };
    }
    const observable = !needsLoad ? void 0 : new ObservableImpl((subscriber) => {
      let aborted = false;
      Promise.resolve().then(() => {
        var _a;
        return (_a = __privateGet(this, _loader)) == null ? void 0 : _a.load(entityRef);
      }).then((newEntity) => {
        if (!aborted && newEntity && newEntity.metadata.etag !== (entity == null ? void 0 : entity.metadata.etag)) {
          const updatedSnapshot = render({
            loading: false,
            entity: newEntity
          });
          subscriber.next(updatedSnapshot);
        }
      }).catch(() => {
      }).finally(() => {
        if (!aborted) {
          subscriber.complete();
        }
      });
      return () => {
        aborted = true;
      };
    });
    return {
      snapshot: initialSnapshot,
      update$: observable
    };
  }
};
_cache = new WeakMap();
_cacheTtlMs = new WeakMap();
_loader = new WeakMap();
_kindIcons = new WeakMap();
_renderer = new WeakMap();
_getEntityForInitialRender = new WeakSet();
getEntityForInitialRender_fn = function(entityOrRef) {
  if (typeof entityOrRef !== "string") {
    return {
      entity: entityOrRef,
      kind: entityOrRef.kind,
      entityRef: stringifyEntityRef(entityOrRef),
      needsLoad: false
    };
  }
  const cached = __privateGet(this, _cache).get(entityOrRef);
  const cachedEntity = cached == null ? void 0 : cached.entity;
  const cacheNeedsUpdate = !cached || Date.now() - cached.updatedAt > __privateGet(this, _cacheTtlMs);
  const needsLoad = cacheNeedsUpdate && __privateGet(this, _renderer).async !== false && __privateGet(this, _loader) !== void 0;
  return {
    entity: cachedEntity,
    kind: parseEntityRef(entityOrRef).kind,
    entityRef: entityOrRef,
    needsLoad
  };
};
_createLoader = new WeakSet();
createLoader_fn = function(options) {
  const cacheTtlMs = durationToMilliseconds(options.cacheTtl);
  const batchDelayMs = durationToMilliseconds(options.batchDelay);
  return new DataLoader(
    async (entityRefs) => {
      const { items } = await options.catalogApi.getEntitiesByRefs({
        entityRefs
      });
      const now = Date.now();
      entityRefs.forEach((entityRef, index) => {
        __privateGet(this, _cache).set(entityRef, {
          updatedAt: now,
          entity: items[index]
        });
      });
      return items;
    },
    {
      name: "DefaultEntityPresentationApi",
      // This cache is the one that the data loader uses internally for
      // memoizing requests; essentially what it achieves is that multiple
      // requests for the same entity ref will be batched up into a single
      // request and then the resulting promises are held on to. We put an
      // expiring map here, which makes it so that it re-fetches data with the
      // expiry cadence of that map. Otherwise it would only fetch a given ref
      // once and then never try again. This cache does therefore not fulfill
      // the same purpose as the one that is in the root of the class.
      cacheMap: new ExpiryMap(cacheTtlMs),
      maxBatchSize: 100,
      batchScheduleFn: batchDelayMs ? (cb) => setTimeout(cb, batchDelayMs) : void 0
    }
  );
};
_maybeFallbackIcon = new WeakSet();
maybeFallbackIcon_fn = function(renderedIcon, kind) {
  var _a;
  if (renderedIcon) {
    return renderedIcon;
  } else if (renderedIcon === false) {
    return false;
  }
  return (_a = __privateGet(this, _kindIcons)[kind.toLocaleLowerCase("en-US")]) != null ? _a : UNKNOWN_KIND_ICON;
};
let DefaultEntityPresentationApi = _DefaultEntityPresentationApi;

async function performMigrationToTheNewBucket({
  storageApi
}) {
  var _a;
  const source = storageApi.forBucket("settings");
  const target = storageApi.forBucket("starredEntities");
  const oldStarredEntities = source.snapshot("starredEntities").value;
  if (!isArray(oldStarredEntities)) {
    return;
  }
  const targetEntities = new Set(
    (_a = target.snapshot("entityRefs").value) != null ? _a : []
  );
  oldStarredEntities.filter(isString).map((old) => old.split(":")).filter((split) => split.length === 4 && split[0] === "entity").map(
    ([_, kind, namespace, name]) => stringifyEntityRef({ kind, namespace, name })
  ).forEach((e) => targetEntities.add(e));
  await target.set("entityRefs", Array.from(targetEntities));
  await source.remove("starredEntities");
}

var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
class DefaultStarredEntitiesApi {
  constructor(opts) {
    __publicField(this, "settingsStore");
    __publicField(this, "starredEntities");
    __publicField(this, "subscribers", /* @__PURE__ */ new Set());
    __publicField(this, "observable", new ObservableImpl((subscriber) => {
      subscriber.next(new Set(this.starredEntities));
      this.subscribers.add(subscriber);
      return () => {
        this.subscribers.delete(subscriber);
      };
    }));
    var _a;
    performMigrationToTheNewBucket(opts).then();
    this.settingsStore = opts.storageApi.forBucket("starredEntities");
    this.starredEntities = new Set(
      (_a = this.settingsStore.snapshot("entityRefs").value) != null ? _a : []
    );
    this.settingsStore.observe$("entityRefs").subscribe({
      next: (next) => {
        var _a2;
        this.starredEntities = new Set((_a2 = next.value) != null ? _a2 : []);
        this.notifyChanges();
      }
    });
  }
  async toggleStarred(entityRef) {
    if (this.starredEntities.has(entityRef)) {
      this.starredEntities.delete(entityRef);
    } else {
      this.starredEntities.add(entityRef);
    }
    await this.settingsStore.set(
      "entityRefs",
      Array.from(this.starredEntities)
    );
  }
  starredEntitie$() {
    return this.observable;
  }
  notifyChanges() {
    for (const subscription of this.subscribers) {
      subscription.next(new Set(this.starredEntities));
    }
  }
}

const createComponentRouteRef = createExternalRouteRef({
  id: "create-component",
  optional: true
});
const viewTechDocRouteRef = createExternalRouteRef({
  id: "view-techdoc",
  optional: true,
  params: ["namespace", "kind", "name"]
});
const createFromTemplateRouteRef = createExternalRouteRef({
  id: "create-from-template",
  optional: true,
  params: ["namespace", "templateName"]
});
const unregisterRedirectRouteRef = createExternalRouteRef({
  id: "catalog:unregister-redirect",
  optional: true
});
const rootRouteRef = createRouteRef({
  id: "catalog"
});

export { DefaultStarredEntitiesApi as D, DefaultEntityPresentationApi as a, createFromTemplateRouteRef as b, createComponentRouteRef as c, rootRouteRef as r, unregisterRedirectRouteRef as u, viewTechDocRouteRef as v };
//# sourceMappingURL=routes-86c34994.esm.js.map
