{"version":3,"file":"EntityOverviewPage-f61e50bf.esm.js","sources":["../../src/alpha/filter/matrchers/createKindMatcher.ts","../../src/alpha/filter/matrchers/createTypeMatcher.ts","../../src/alpha/filter/matrchers/createIsMatcher.ts","../../src/alpha/filter/matrchers/createHasMatcher.ts","../../src/alpha/filter/parseFilterExpression.ts","../../src/alpha/EntityOverviewPage.tsx"],"sourcesContent":["/*\n * Copyright 2023 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { EntityMatcherFn } from './types';\n\n/**\n * Matches on kind\n */\nexport function createKindMatcher(\n  parameters: string[],\n  _onParseError: (error: Error) => void,\n): EntityMatcherFn {\n  const items = parameters.map(p => p.toLocaleLowerCase('en-US'));\n  return entity => items.includes(entity.kind.toLocaleLowerCase('en-US'));\n}\n","/*\n * Copyright 2023 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { EntityMatcherFn } from './types';\n\n/**\n * Matches on spec.type\n */\nexport function createTypeMatcher(\n  parameters: string[],\n  _onParseError: (error: Error) => void,\n): EntityMatcherFn {\n  const items = parameters.map(p => p.toLocaleLowerCase('en-US'));\n  return entity => {\n    const value = entity.spec?.type;\n    return (\n      typeof value === 'string' &&\n      items.includes(value.toLocaleLowerCase('en-US'))\n    );\n  };\n}\n","/*\n * Copyright 2023 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { InputError } from '@backstage/errors';\nimport { EntityMatcherFn } from './types';\n\nconst allowedMatchers: Record<string, EntityMatcherFn> = {\n  orphan: entity =>\n    Boolean(entity.metadata.annotations?.['backstage.io/orphan']),\n};\n\n/**\n * Matches on different semantic properties of the entity\n */\nexport function createIsMatcher(\n  parameters: string[],\n  onParseError: (error: Error) => void,\n): EntityMatcherFn {\n  const matchers = parameters.flatMap(parameter => {\n    const matcher = allowedMatchers[parameter.toLocaleLowerCase('en-US')];\n    if (!matcher) {\n      const known = Object.keys(allowedMatchers).map(m => `'${m}'`);\n      onParseError(\n        new InputError(\n          `'${parameter}' is not a valid parameter for 'is' filter expressions, expected one of ${known}`,\n        ),\n      );\n      return [];\n    }\n    return [matcher];\n  });\n\n  return entity =>\n    matchers.length ? matchers.some(matcher => matcher(entity)) : true;\n}\n","/*\n * Copyright 2023 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { InputError } from '@backstage/errors';\nimport { EntityMatcherFn } from './types';\n\nconst allowedMatchers: Record<string, EntityMatcherFn> = {\n  labels: entity => {\n    return Object.keys(entity.metadata.labels ?? {}).length > 0;\n  },\n  links: entity => {\n    return (entity.metadata.links ?? []).length > 0;\n  },\n};\n\n/**\n * Matches on the non-empty presence of different parts of the entity\n */\nexport function createHasMatcher(\n  parameters: string[],\n  onParseError: (error: Error) => void,\n): EntityMatcherFn {\n  const matchers = parameters.flatMap(parameter => {\n    const matcher = allowedMatchers[parameter.toLocaleLowerCase('en-US')];\n    if (!matcher) {\n      const known = Object.keys(allowedMatchers).map(m => `'${m}'`);\n      onParseError(\n        new InputError(\n          `'${parameter}' is not a valid parameter for 'has' filter expressions, expected one of ${known}`,\n        ),\n      );\n      return [];\n    }\n    return [matcher];\n  });\n\n  return entity =>\n    matchers.length ? matchers.some(matcher => matcher(entity)) : true;\n}\n","/*\n * Copyright 2023 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Entity } from '@backstage/catalog-model';\nimport { InputError } from '@backstage/errors';\nimport { EntityMatcherFn } from './matrchers/types';\nimport { createKindMatcher } from './matrchers/createKindMatcher';\nimport { createTypeMatcher } from './matrchers/createTypeMatcher';\nimport { createIsMatcher } from './matrchers/createIsMatcher';\nimport { createHasMatcher } from './matrchers/createHasMatcher';\n\nconst rootMatcherFactories: Record<\n  string,\n  (\n    parameters: string[],\n    onParseError: (error: Error) => void,\n  ) => EntityMatcherFn\n> = {\n  kind: createKindMatcher,\n  type: createTypeMatcher,\n  is: createIsMatcher,\n  has: createHasMatcher,\n};\n\n/**\n * Parses a filter expression that decides whether to render an entity component\n * or not. Returns a function that matches entities based on that expression.\n *\n * @remarks\n *\n * Filter strings are on the form `kind:user,group is:orphan`. There's\n * effectively an AND between the space separated parts, and an OR between comma\n * separated parameters. So the example filter string semantically means\n * \"entities that are of either User or Group kind, and also are orphans\".\n *\n * The `expressionParseErrors` array contains any errors that were encountered\n * during initial parsing of the expression. Note that the parts of the input\n * expression that had errors are ignored entirely and parsing continues as if\n * they didn't exist.\n */\nexport function parseFilterExpression(expression: string): {\n  filterFn: (entity: Entity) => boolean;\n  expressionParseErrors: Error[];\n} {\n  const expressionParseErrors: Error[] = [];\n\n  const parts = splitFilterExpression(expression, e =>\n    expressionParseErrors.push(e),\n  );\n\n  const matchers = parts.flatMap(part => {\n    const factory = rootMatcherFactories[part.key];\n    if (!factory) {\n      const known = Object.keys(rootMatcherFactories).map(m => `'${m}'`);\n      expressionParseErrors.push(\n        new InputError(\n          `'${part.key}' is not a valid filter expression key, expected one of ${known}`,\n        ),\n      );\n      return [];\n    }\n\n    const matcher = factory(part.parameters, e =>\n      expressionParseErrors.push(e),\n    );\n    return [matcher];\n  });\n\n  const filterFn = (entity: Entity) =>\n    matchers.every(matcher => {\n      try {\n        return matcher(entity);\n      } catch {\n        return false;\n      }\n    });\n\n  return {\n    filterFn,\n    expressionParseErrors,\n  };\n}\n\nexport function splitFilterExpression(\n  expression: string,\n  onParseError: (error: Error) => void,\n): Array<{ key: string; parameters: string[] }> {\n  const words = expression\n    .split(' ')\n    .map(w => w.trim())\n    .filter(Boolean);\n\n  const result = new Array<{ key: string; parameters: string[] }>();\n\n  for (const word of words) {\n    const match = word.match(/^([^:]+):(.+)$/);\n    if (!match) {\n      onParseError(\n        new InputError(\n          `'${word}' is not a valid filter expression, expected 'key:parameter' form`,\n        ),\n      );\n      continue;\n    }\n\n    const key = match[1];\n    const parameters = match[2].split(',').filter(Boolean); // silently ignore double commas\n\n    result.push({ key, parameters });\n  }\n\n  return result;\n}\n","/*\n * Copyright 2023 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Entity } from '@backstage/catalog-model';\nimport { useEntity } from '@backstage/plugin-catalog-react';\nimport Grid from '@material-ui/core/Grid';\nimport React, { useMemo } from 'react';\nimport { parseFilterExpression } from './filter/parseFilterExpression';\n\ninterface EntityOverviewPageProps {\n  cards: Array<{\n    element: React.JSX.Element;\n    filterFunction?: (entity: Entity) => boolean;\n    filterExpression?: string;\n  }>;\n}\n\n// Keeps track of what filter expression strings that we've seen duplicates of\n// with functions, or which emitted parsing errors for so far\nconst seenParseErrorExpressionStrings = new Set<string>();\nconst seenDuplicateExpressionStrings = new Set<string>();\n\n// Given an optional filter function and an optional filter expression, make\n// sure that at most one of them was given, and return a filter function that\n// does the right thing.\nfunction buildFilterFn(\n  filterFunction?: (entity: Entity) => boolean,\n  filterExpression?: string,\n): (entity: Entity) => boolean {\n  if (\n    filterFunction &&\n    filterExpression &&\n    !seenDuplicateExpressionStrings.has(filterExpression)\n  ) {\n    // eslint-disable-next-line no-console\n    console.warn(\n      `Duplicate entity filter methods found, both '${filterExpression}' as well as a callback function, which is not permitted - using the callback`,\n    );\n    seenDuplicateExpressionStrings.add(filterExpression);\n  }\n\n  const filter = filterFunction || filterExpression;\n  if (!filter) {\n    return () => true;\n  } else if (typeof filter === 'function') {\n    return subject => filter(subject);\n  }\n\n  const result = parseFilterExpression(filter);\n  if (\n    result.expressionParseErrors.length &&\n    !seenParseErrorExpressionStrings.has(filter)\n  ) {\n    // eslint-disable-next-line no-console\n    console.warn(\n      `Error(s) in entity filter expression '${filter}'`,\n      result.expressionParseErrors,\n    );\n    seenParseErrorExpressionStrings.add(filter);\n  }\n\n  return result.filterFn;\n}\n\n// Handles the memoized parsing of filter expressions for each card\nfunction CardWrapper(props: {\n  entity: Entity;\n  element: React.JSX.Element;\n  filterFunction?: (entity: Entity) => boolean;\n  filterExpression?: string;\n}) {\n  const { entity, element, filterFunction, filterExpression } = props;\n\n  const filterFn = useMemo(\n    () => buildFilterFn(filterFunction, filterExpression),\n    [filterFunction, filterExpression],\n  );\n\n  return filterFn(entity) ? (\n    <Grid item md={6} xs={12}>\n      {element}\n    </Grid>\n  ) : null;\n}\n\nexport function EntityOverviewPage(props: EntityOverviewPageProps) {\n  const { entity } = useEntity();\n  return (\n    <Grid container spacing={3} alignItems=\"stretch\">\n      {props.cards.map((card, index) => (\n        <CardWrapper key={index} entity={entity} {...card} />\n      ))}\n    </Grid>\n  );\n}\n"],"names":["allowedMatchers"],"mappings":"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"}