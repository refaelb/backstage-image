/// <reference types="react" />
import { Entity, CompoundEntityRef, ComponentEntity, ResourceEntity } from '@backstage/catalog-model';
import * as _backstage_core_plugin_api from '@backstage/core-plugin-api';
import { IconComponent, StorageApi, ApiHolder } from '@backstage/core-plugin-api';
import { EntityRefPresentationSnapshot, CatalogApi, EntityPresentationApi, EntityRefPresentation, StarredEntitiesApi, EntityListContextProps, UserListFilterKind, EntityOwnerPickerProps } from '@backstage/plugin-catalog-react';
import { HumanDuration, Observable } from '@backstage/types';
import { InfoCardVariants, TableColumn, TableProps, TableOptions } from '@backstage/core-components';
import * as React$1 from 'react';
import React__default, { ReactNode } from 'react';
import { TabProps } from '@material-ui/core';
import { Overrides } from '@material-ui/core/styles/overrides';
import { StyleRules } from '@material-ui/core/styles/withStyles';
import { SearchResultListItemExtensionProps } from '@backstage/plugin-search-react';
import { IndexableDocument, ResultHighlight } from '@backstage/plugin-search-common';

/**
 * A custom renderer for the {@link DefaultEntityPresentationApi}.
 *
 * @public
 */
interface DefaultEntityPresentationApiRenderer {
    /**
     * Whether to request the entity from the catalog API asynchronously.
     *
     * @remarks
     *
     * If this is set to true, entity data will be streamed in from the catalog
     * whenever needed, and the render function may be called more than once:
     * first when no entity data existed (or with old cached data), and then again
     * at a later point when data is loaded from the catalog that proved to be
     * different from the old one.
     *
     * @defaultValue true
     */
    async?: boolean;
    /**
     * The actual render function.
     *
     * @remarks
     *
     * This function may be called multiple times.
     *
     * The loading flag signals that the framework MAY be trying to load more
     * entity data from the catalog and call the render function again, if it
     * succeeds. In some cases you may want to render a loading state in that
     * case.
     *
     * The entity may or may not be given. If the caller of the presentation API
     * did present an entity upfront, then that's what will be passed in here.
     * Otherwise, it may be a server-side entity that either comes from a local
     * cache or directly from the server.
     *
     * In either case, the renderer should return a presentation that is the most
     * useful possible for the end user, given the data that is available.
     */
    render: (options: {
        entityRef: string;
        loading: boolean;
        entity: Entity | undefined;
        context: {
            defaultKind?: string;
            defaultNamespace?: string;
        };
    }) => {
        snapshot: Omit<EntityRefPresentationSnapshot, 'entityRef'>;
    };
}
/**
 * Options for the {@link DefaultEntityPresentationApi}.
 *
 * @public
 */
interface DefaultEntityPresentationApiOptions {
    /**
     * The catalog API to use. If you want to use any asynchronous features, you
     * must supply one.
     */
    catalogApi?: CatalogApi;
    /**
     * When to expire entities that have been loaded from the catalog API and
     * cached for a while.
     *
     * @defaultValue 10 seconds
     * @remarks
     *
     * The higher this value, the lower the load on the catalog API, but also the
     * higher the risk of users seeing stale data.
     */
    cacheTtl?: HumanDuration;
    /**
     * For how long to wait before sending a batch of entity references to the
     * catalog API.
     *
     * @defaultValue 50 milliseconds
     * @remarks
     *
     * The higher this value, the greater the chance of batching up requests from
     * across a page, but also the longer the lag time before displaying accurate
     * information.
     */
    batchDelay?: HumanDuration;
    /**
     * A mapping from kinds to icons.
     *
     * @remarks
     *
     * The keys are kinds (case insensitive) that map to icon values to represent
     * kinds by. These are merged with the default set of icons.
     */
    kindIcons?: Record<string, IconComponent>;
    /**
     * A custom renderer, if any.
     */
    renderer?: DefaultEntityPresentationApiRenderer;
}
/**
 * Default implementation of the {@link @backstage/plugin-catalog-react#EntityPresentationApi}.
 *
 * @public
 */
declare class DefaultEntityPresentationApi implements EntityPresentationApi {
    #private;
    /**
     * Creates a new presentation API that does not reach out to the catalog.
     */
    static createLocal(): EntityPresentationApi;
    /**
     * Creates a new presentation API that calls out to the catalog as needed to
     * get additional information about entities.
     */
    static create(options: DefaultEntityPresentationApiOptions): EntityPresentationApi;
    private constructor();
    /** {@inheritdoc @backstage/plugin-catalog-react#EntityPresentationApi.forEntity} */
    forEntity(entityOrRef: Entity | string, context?: {
        defaultKind?: string;
        defaultNamespace?: string;
    }): EntityRefPresentation;
}

/**
 * Default implementation of the StarredEntitiesApi that is backed by the StorageApi.
 *
 * @public
 */
declare class DefaultStarredEntitiesApi implements StarredEntitiesApi {
    private readonly settingsStore;
    private starredEntities;
    constructor(opts: {
        storageApi: StorageApi;
    });
    toggleStarred(entityRef: string): Promise<void>;
    starredEntitie$(): Observable<Set<string>>;
    private readonly subscribers;
    private readonly observable;
    private notifyChanges;
}

/**
 * Props for {@link EntityAboutCard}.
 *
 * @public
 */
interface AboutCardProps {
    variant?: InfoCardVariants;
}

/**
 * Props for {@link AboutContent}.
 *
 * @public
 */
interface AboutContentProps {
    entity: Entity;
}
/** @public */
declare function AboutContent(props: AboutContentProps): React__default.JSX.Element;

/**
 * Props for {@link AboutField}.
 *
 * @public
 */
interface AboutFieldProps {
    label: string;
    value?: string;
    gridSizes?: Record<string, number>;
    children?: React__default.ReactNode;
}
/** @public */
declare function AboutField(props: AboutFieldProps): React__default.JSX.Element;

/**
 * Props for {@link CatalogKindHeader}.
 *
 * @public
 */
interface CatalogKindHeaderProps {
    /**
     * Entity kinds to show in the dropdown; by default all kinds are fetched from the catalog and
     * displayed.
     */
    allowedKinds?: string[];
    /**
     * The initial kind to select; defaults to 'component'. A kind filter entered directly in the
     * query parameter will override this value.
     */
    initialFilter?: string;
}
/**
 * @public
 * @deprecated This component has been deprecated in favour of the EntityKindPicker in the list of filters. If you wish to keep this component long term make sure to raise an issue at github.com/backstage/backstage
 */
declare function CatalogKindHeader(props: CatalogKindHeaderProps): React__default.JSX.Element;

/** @public */
interface CatalogTableRow {
    entity: Entity;
    resolved: {
        name: string;
        entityRef: string;
        partOfSystemRelationTitle?: string;
        partOfSystemRelations: CompoundEntityRef[];
        ownedByRelationsTitle?: string;
        ownedByRelations: CompoundEntityRef[];
    };
}
/**
 * Typed columns function to dynamically render columns based on entity list context.
 *
 * @public
 */
type CatalogTableColumnsFunc = (entityListContext: EntityListContextProps) => TableColumn<CatalogTableRow>[];

/**
 * Props for {@link CatalogTable}.
 *
 * @public
 */
interface CatalogTableProps {
    columns?: TableColumn<CatalogTableRow>[] | CatalogTableColumnsFunc;
    actions?: TableProps<CatalogTableRow>['actions'];
    tableOptions?: TableProps<CatalogTableRow>['options'];
    emptyContent?: ReactNode;
    subtitle?: string;
}
/** @public */
declare const CatalogTable: {
    (props: CatalogTableProps): React__default.JSX.Element;
    columns: Readonly<{
        createNameColumn(options?: {
            defaultKind?: string | undefined;
        } | undefined): TableColumn<CatalogTableRow>;
        createSystemColumn(): TableColumn<CatalogTableRow>;
        createOwnerColumn(): TableColumn<CatalogTableRow>;
        createSpecTargetsColumn(): TableColumn<CatalogTableRow>;
        createSpecTypeColumn(options?: {
            hidden: boolean;
        }): TableColumn<CatalogTableRow>;
        createSpecLifecycleColumn(): TableColumn<CatalogTableRow>;
        createMetadataDescriptionColumn(): TableColumn<CatalogTableRow>;
        createTagsColumn(): TableColumn<CatalogTableRow>;
        createTitleColumn(options?: {
            hidden?: boolean | undefined;
        } | undefined): TableColumn<CatalogTableRow>;
        createLabelColumn(key: string, options?: {
            title?: string | undefined;
            defaultValue?: string | undefined;
        } | undefined): TableColumn<CatalogTableRow>;
        createNamespaceColumn(): TableColumn<CatalogTableRow>;
    }>;
};

/** @public */
type EntityLayoutRouteProps = {
    path: string;
    title: string;
    children: JSX.Element;
    if?: (entity: Entity) => boolean;
    tabProps?: TabProps<React__default.ElementType, {
        component?: React__default.ElementType;
    }>;
};
interface ExtraContextMenuItem {
    title: string;
    Icon: IconComponent;
    onClick: () => void;
}
type VisibleType = 'visible' | 'hidden' | 'disable';
interface EntityContextMenuOptions {
    disableUnregister: boolean | VisibleType;
}
/** @public */
interface EntityLayoutProps {
    UNSTABLE_extraContextMenuItems?: ExtraContextMenuItem[];
    UNSTABLE_contextMenuOptions?: EntityContextMenuOptions;
    children?: React__default.ReactNode;
    NotFoundComponent?: React__default.ReactNode;
}
/**
 * EntityLayout is a compound component, which allows you to define a layout for
 * entities using a sub-navigation mechanism.
 *
 * Consists of two parts: EntityLayout and EntityLayout.Route
 *
 * @example
 * ```jsx
 * <EntityLayout>
 *   <EntityLayout.Route path="/example" title="Example tab">
 *     <div>This is rendered under /example/anything-here route</div>
 *   </EntityLayout.Route>
 * </EntityLayout>
 * ```
 *
 * @public
 */
declare const EntityLayout: {
    (props: EntityLayoutProps): React__default.JSX.Element;
    Route: (props: EntityLayoutRouteProps) => null;
};

/**
 * Returns true if the given entity has the orphan annotation given by the
 * catalog.
 *
 * @public
 */
declare function isOrphan(entity: Entity): boolean;
/**
 * Displays a warning alert if the entity is marked as orphan with the ability
 * to delete said entity.
 *
 * @public
 */
declare function EntityOrphanWarning(): React__default.JSX.Element;

/**
 * Returns true if the given entity has relations to other entities, which
 * don't exist in the catalog
 *
 * @public
 */
declare function hasRelationWarnings(entity: Entity, context: {
    apis: ApiHolder;
}): Promise<boolean>;
/**
 * Displays a warning alert if the entity has relations to other entities, which
 * don't exist in the catalog
 *
 * @public
 */
declare function EntityRelationWarning(): React__default.JSX.Element | null;

/**
 * Returns true if the given entity has any processing errors on it.
 *
 * @public
 */
declare function hasCatalogProcessingErrors(entity: Entity, context: {
    apis: ApiHolder;
}): Promise<boolean>;
/**
 * Displays a list of errors from the ancestors of the current entity.
 *
 * @public
 */
declare function EntityProcessingErrorsPanel(): React__default.JSX.Element | null;

/** @public */
interface EntitySwitchCaseProps {
    if?: (entity: Entity, context: {
        apis: ApiHolder;
    }) => boolean | Promise<boolean>;
    children: ReactNode;
}
/**
 * Props for the {@link EntitySwitch} component.
 * @public
 */
interface EntitySwitchProps {
    children: ReactNode;
    renderMultipleMatches?: 'first' | 'all';
}
/** @public */
declare const EntitySwitch: {
    (props: EntitySwitchProps): React__default.JSX.Element;
    Case: (_props: EntitySwitchCaseProps) => null;
};

/** @public */
interface EntityPredicates {
    kind?: string | string[];
    type?: string | string[];
}
/**
 * For use in EntitySwitch.Case. Matches if the entity is of a given kind.
 * @public
 */
declare function isKind(kinds: string | string[]): (entity: Entity) => boolean;
/**
 * For use in EntitySwitch.Case. Matches if the entity is a Component of a given spec.type.
 * @public
 */
declare function isComponentType(types: string | string[]): (entity: Entity) => boolean;
/**
 * For use in EntitySwitch.Case. Matches if the entity is a Resource of a given spec.type.
 * @public
 */
declare function isResourceType(types: string | string[]): (entity: Entity) => boolean;
/**
 * For use in EntitySwitch.Case. Matches if the entity is the specified kind and type (if present).
 * @public
 */
declare function isEntityWith(predicate: EntityPredicates): (entity: Entity) => boolean;
/**
 * For use in EntitySwitch.Case. Matches if the entity is in a given namespace.
 * @public
 */
declare function isNamespace(namespaces: string | string[]): (entity: Entity) => boolean;

/**
 * @public
 * @deprecated Use `CatalogFilterLayout` from `@backstage/plugin-catalog-react` instead.
 */
declare const FilteredEntityLayout: (props: {
    children: React.ReactNode;
}) => JSX.Element;
/**
 * @public
 * @deprecated Use `CatalogFilterLayout.Filters` from `@backstage/plugin-catalog-react` instead.
 */
declare const FilterContainer: (props: {
    children: React$1.ReactNode;
    options?: {
        drawerBreakpoint?: number | "xs" | "sm" | "md" | "lg" | "xl" | undefined;
        drawerAnchor?: "left" | "top" | "bottom" | "right" | undefined;
    } | undefined;
}) => React$1.JSX.Element;
/**
 * @public
 * @deprecated Use `CatalogFilterLayout.Content` from `@backstage/plugin-catalog-react` instead.
 */
declare const EntityListContainer: (props: {
    children: React$1.ReactNode;
}) => React$1.JSX.Element;

/** @public */
type Breakpoint = 'xs' | 'sm' | 'md' | 'lg' | 'xl';
/** @public */
type ColumnBreakpoints = Record<Breakpoint, number>;

/** @public */
interface EntityLinksCardProps {
    cols?: ColumnBreakpoints | number;
    variant?: InfoCardVariants;
}

/** @public */
type EntityLinksEmptyStateClassKey = 'code';

/** @public */
type SystemDiagramCardClassKey = 'domainNode' | 'systemNode' | 'componentNode' | 'apiNode' | 'resourceNode';

/** @public */
type EntityContextMenuClassKey = 'button';

/** @public */
type PluginCatalogComponentsNameToClassKey = {
    PluginCatalogEntityLinksEmptyState: EntityLinksEmptyStateClassKey;
    PluginCatalogSystemDiagramCard: SystemDiagramCardClassKey;
    PluginCatalogEntityContextMenu: EntityContextMenuClassKey;
};
/** @public */
type BackstageOverrides = Overrides & {
    [Name in keyof PluginCatalogComponentsNameToClassKey]?: Partial<StyleRules<PluginCatalogComponentsNameToClassKey[Name]>>;
};
declare module '@backstage/theme' {
    interface OverrideComponentNameToClassKeys extends PluginCatalogComponentsNameToClassKey {
    }
}

/** @public */
interface EntityLabelsCardProps {
    variant?: InfoCardVariants;
    title?: string;
}

/**
 * Returns true if the given entity has labels annotation given by the
 * catalog. For use by EntitySwitch
 *
 * @public
 */
declare function hasLabels(entity: Entity): boolean;

/**
 * Props for root catalog pages.
 *
 * @public
 */
interface DefaultCatalogPageProps {
    initiallySelectedFilter?: UserListFilterKind;
    columns?: TableColumn<CatalogTableRow>[] | CatalogTableColumnsFunc;
    actions?: TableProps<CatalogTableRow>['actions'];
    initialKind?: string;
    tableOptions?: TableProps<CatalogTableRow>['options'];
    emptyContent?: ReactNode;
    ownerPickerMode?: EntityOwnerPickerProps['mode'];
    pagination?: boolean | {
        limit?: number;
    };
}

/** @public */
interface DependencyOfComponentsCardProps {
    variant?: InfoCardVariants;
    title?: string;
}

/** @public */
interface DependsOnComponentsCardProps {
    variant?: InfoCardVariants;
    title?: string;
    columns?: TableColumn<ComponentEntity>[];
    tableOptions?: TableOptions;
}

/** @public */
interface DependsOnResourcesCardProps {
    variant?: InfoCardVariants;
    title?: string;
    columns?: TableColumn<ResourceEntity>[];
    tableOptions?: TableOptions;
}

/** @public */
interface HasComponentsCardProps {
    variant?: InfoCardVariants;
    title?: string;
}

/** @public */
interface HasResourcesCardProps {
    variant?: InfoCardVariants;
    title?: string;
}

/** @public */
interface HasSubcomponentsCardProps {
    variant?: InfoCardVariants;
    tableOptions?: TableOptions;
    title?: string;
}

/** @public */
interface HasSystemsCardProps {
    variant?: InfoCardVariants;
    title?: string;
}

/** @public */
type RelatedEntitiesCardProps<T extends Entity> = {
    variant?: InfoCardVariants;
    title: string;
    columns: TableColumn<T>[];
    entityKind?: string;
    relationType: string;
    emptyMessage: string;
    emptyHelpLink: string;
    asRenderableEntities: (entities: Entity[]) => T[];
    tableOptions?: TableOptions;
};

/**
 * Props for {@link CatalogSearchResultListItem}.
 *
 * @public
 */
interface CatalogSearchResultListItemProps {
    icon?: ReactNode | ((result: IndexableDocument) => ReactNode);
    result?: IndexableDocument;
    highlight?: ResultHighlight;
    rank?: number;
}

/** @public */
declare const catalogPlugin: _backstage_core_plugin_api.BackstagePlugin<{
    catalogIndex: _backstage_core_plugin_api.RouteRef<undefined>;
    catalogEntity: _backstage_core_plugin_api.RouteRef<{
        name: string;
        kind: string;
        namespace: string;
    }>;
}, {
    createComponent: _backstage_core_plugin_api.ExternalRouteRef<undefined, true>;
    viewTechDoc: _backstage_core_plugin_api.ExternalRouteRef<{
        name: string;
        kind: string;
        namespace: string;
    }, true>;
    createFromTemplate: _backstage_core_plugin_api.ExternalRouteRef<{
        namespace: string;
        templateName: string;
    }, true>;
    unregisterRedirect: _backstage_core_plugin_api.ExternalRouteRef<undefined, true>;
}>;
/** @public */
declare const CatalogIndexPage: (props: DefaultCatalogPageProps) => JSX.Element;
/** @public */
declare const CatalogEntityPage: () => JSX.Element;
/** @public */
declare const EntityAboutCard: (props: AboutCardProps) => JSX.Element;
/** @public */
declare const EntityLinksCard: (props: EntityLinksCardProps) => React$1.JSX.Element;
/** @public */
declare const EntityLabelsCard: (props: EntityLabelsCardProps) => React$1.JSX.Element;
/** @public */
declare const EntityHasSystemsCard: (props: HasSystemsCardProps) => JSX.Element;
/** @public */
declare const EntityHasComponentsCard: (props: HasComponentsCardProps) => JSX.Element;
/** @public */
declare const EntityHasSubcomponentsCard: (props: HasSubcomponentsCardProps) => JSX.Element;
/** @public */
declare const EntityHasResourcesCard: (props: HasResourcesCardProps) => JSX.Element;
/** @public */
declare const EntityDependsOnComponentsCard: (props: DependsOnComponentsCardProps) => JSX.Element;
/** @public */
declare const EntityDependencyOfComponentsCard: (props: DependencyOfComponentsCardProps) => JSX.Element;
/** @public */
declare const EntityDependsOnResourcesCard: (props: DependsOnResourcesCardProps) => JSX.Element;
/** @public */
declare const RelatedEntitiesCard: <T extends Entity>(props: RelatedEntitiesCardProps<T>) => JSX.Element;
/** @public */
declare const CatalogSearchResultListItem: (props: SearchResultListItemExtensionProps<CatalogSearchResultListItemProps>) => JSX.Element | null;

export { AboutCardProps, AboutContent, AboutContentProps, AboutField, AboutFieldProps, BackstageOverrides, Breakpoint, CatalogEntityPage, CatalogIndexPage, CatalogKindHeader, CatalogKindHeaderProps, CatalogSearchResultListItem, CatalogSearchResultListItemProps, CatalogTable, CatalogTableColumnsFunc, CatalogTableProps, CatalogTableRow, ColumnBreakpoints, DefaultCatalogPageProps, DefaultEntityPresentationApi, DefaultEntityPresentationApiOptions, DefaultEntityPresentationApiRenderer, DefaultStarredEntitiesApi, DependencyOfComponentsCardProps, DependsOnComponentsCardProps, DependsOnResourcesCardProps, EntityAboutCard, EntityContextMenuClassKey, EntityDependencyOfComponentsCard, EntityDependsOnComponentsCard, EntityDependsOnResourcesCard, EntityHasComponentsCard, EntityHasResourcesCard, EntityHasSubcomponentsCard, EntityHasSystemsCard, EntityLabelsCard, EntityLabelsCardProps, EntityLayout, EntityLayoutProps, EntityLayoutRouteProps, EntityLinksCard, EntityLinksCardProps, EntityLinksEmptyStateClassKey, EntityListContainer, EntityOrphanWarning, EntityPredicates, EntityProcessingErrorsPanel, EntityRelationWarning, EntitySwitch, EntitySwitchCaseProps, EntitySwitchProps, FilterContainer, FilteredEntityLayout, HasComponentsCardProps, HasResourcesCardProps, HasSubcomponentsCardProps, HasSystemsCardProps, PluginCatalogComponentsNameToClassKey, RelatedEntitiesCard, RelatedEntitiesCardProps, SystemDiagramCardClassKey, catalogPlugin, hasCatalogProcessingErrors, hasLabels, hasRelationWarnings, isComponentType, isEntityWith, isKind, isNamespace, isOrphan, isResourceType };
