/**
 * @public
 */
interface EventParams<TPayload = unknown> {
    /**
     * Topic for which this event should be published.
     */
    topic: string;
    /**
     * Event payload.
     */
    eventPayload: TPayload;
    /**
     * Metadata (e.g., HTTP headers and similar for events received from external).
     */
    metadata?: Record<string, string | string[] | undefined>;
}

/**
 * Handles received events.
 * This may include triggering refreshes of catalog entities
 * or other actions to react on events.
 *
 * @public
 */
interface EventSubscriber {
    /**
     * Supported event topics like "github", "bitbucketCloud", etc.
     */
    supportsEventTopics(): string[];
    /**
     * React on a received event.
     *
     * @param params - parameters for the to be received event.
     */
    onEvent(params: EventParams): Promise<void>;
}

/**
 * Allows a decoupled and asynchronous communication between components.
 * Components can publish events for a given topic and
 * others can subscribe for future events for topics they are interested in.
 *
 * @public
 */
interface EventBroker {
    /**
     * Publishes an event for the topic.
     *
     * @param params - parameters for the to be published event.
     */
    publish(params: EventParams): Promise<void>;
    /**
     * Adds new subscribers for {@link EventSubscriber#supportsEventTopics | interested topics}.
     *
     * @param subscribers - interested in events of specified topics.
     */
    subscribe(...subscribers: Array<EventSubscriber | Array<EventSubscriber>>): void;
}

/**
 * Publishes events to be consumed by subscribers for their topic.
 * The events can come from different (external) sources
 * like emitted themselves, received via HTTP endpoint (i.e. webhook)
 * or from event brokers, queues, etc.
 *
 * @public
 */
interface EventPublisher {
    setEventBroker(eventBroker: EventBroker): Promise<void>;
}

/**
 * Subscribes to a topic and - depending on a set of conditions -
 * republishes the event to another topic.
 *
 * @see {@link https://www.enterpriseintegrationpatterns.com/MessageRouter.html | Message Router pattern}.
 * @public
 */
declare abstract class EventRouter implements EventPublisher, EventSubscriber {
    private eventBroker?;
    protected abstract determineDestinationTopic(params: EventParams): string | undefined;
    onEvent(params: EventParams): Promise<void>;
    setEventBroker(eventBroker: EventBroker): Promise<void>;
    abstract supportsEventTopics(): string[];
}

/**
 * @public
 */
interface RequestDetails {
    /**
     * Request body. JSON payloads have been parsed already.
     */
    body: unknown;
    /**
     * Key-value pairs of header names and values. Header names are lower-cased.
     */
    headers: Record<string, string | string[] | undefined>;
}

/**
 * Details for how to respond to the rejection
 * of the received HTTP request transmitting an event payload.
 *
 * @public
 */
interface RequestRejectionDetails {
    status: number;
    payload: unknown;
}

/**
 * Passed context for the validation
 * at which rejections can be expressed.
 *
 * @public
 */
interface RequestValidationContext {
    /**
     * Rejects the validated request
     *
     * @param details - Optional details about the rejection which will be provided to the sender.
     */
    reject(details?: Partial<RequestRejectionDetails>): void;
}

/**
 * Validator used to check the received HTTP request
 * transmitting an event payload.
 *
 * E.g., it can be used for signature verification like
 * for GitHub webhook events
 * (https://docs.github.com/en/developers/webhooks-and-events/webhooks/creating-webhooks#secret)
 * or other kinds of checks.
 *
 * @public
 */
type RequestValidator = (request: RequestDetails, context: RequestValidationContext) => Promise<void>;

/**
 * @public
 */
interface HttpPostIngressOptions {
    topic: string;
    validator?: RequestValidator;
}

/**
 * Subscribes to the provided (generic) topic
 * and publishes the events under the more concrete sub-topic
 * depending on the implemented logic for determining it.
 * Implementing classes might use information from `metadata`
 * and/or properties within the payload.
 *
 * @public
 */
declare abstract class SubTopicEventRouter extends EventRouter {
    private readonly topic;
    protected constructor(topic: string);
    protected abstract determineSubTopic(params: EventParams): string | undefined;
    protected determineDestinationTopic(params: EventParams): string | undefined;
    supportsEventTopics(): string[];
}

export { EventBroker, EventParams, EventPublisher, EventRouter, EventSubscriber, HttpPostIngressOptions, RequestDetails, RequestRejectionDetails, RequestValidationContext, RequestValidator, SubTopicEventRouter };
