{"version":3,"file":"paths-cfcd05fc.cjs.js","sources":["../../src/paths.ts"],"sourcesContent":["/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { isChildPath } from '@backstage/cli-common';\nimport { NotAllowedError } from '@backstage/errors';\nimport { resolve as resolvePath } from 'path';\n\n/** @internal */\nexport const packagePathMocks = new Map<\n  string,\n  (paths: string[]) => string | undefined\n>();\n\n/**\n * Resolve a path relative to the root of a package directory.\n * Additional path arguments are resolved relative to the package dir.\n *\n * This is particularly useful when you want to access assets shipped with\n * your backend plugin package. When doing so, do not forget to include the assets\n * in your published package by adding them to `files` in your `package.json`.\n *\n * @public\n */\nexport function resolvePackagePath(name: string, ...paths: string[]) {\n  const mockedResolve = packagePathMocks.get(name);\n  if (mockedResolve) {\n    const resolved = mockedResolve(paths);\n    if (resolved) {\n      return resolved;\n    }\n  }\n\n  const req =\n    typeof __non_webpack_require__ === 'undefined'\n      ? require\n      : __non_webpack_require__;\n\n  return resolvePath(req.resolve(`${name}/package.json`), '..', ...paths);\n}\n\n/**\n * Resolves a target path from a base path while guaranteeing that the result is\n * a path that point to or within the base path. This is useful for resolving\n * paths from user input, as it otherwise opens up for vulnerabilities.\n *\n * @public\n * @param base - The base directory to resolve the path from.\n * @param path - The target path, relative or absolute\n * @returns A path that is guaranteed to point to or within the base path.\n */\nexport function resolveSafeChildPath(base: string, path: string): string {\n  const targetPath = resolvePath(base, path);\n\n  if (!isChildPath(base, targetPath)) {\n    throw new NotAllowedError(\n      'Relative path is not allowed to refer to a directory outside its parent',\n    );\n  }\n\n  return targetPath;\n}\n\n// Re-export isChildPath so that backend packages don't need to depend on cli-common\nexport { isChildPath };\n"],"names":["resolvePath","isChildPath","NotAllowedError"],"mappings":";;;;;;AAqBa,MAAA,gBAAA,uBAAuB,GAGlC,GAAA;AAYc,SAAA,kBAAA,CAAmB,SAAiB,KAAiB,EAAA;AACnE,EAAM,MAAA,aAAA,GAAgB,gBAAiB,CAAA,GAAA,CAAI,IAAI,CAAA,CAAA;AAC/C,EAAA,IAAI,aAAe,EAAA;AACjB,IAAM,MAAA,QAAA,GAAW,cAAc,KAAK,CAAA,CAAA;AACpC,IAAA,IAAI,QAAU,EAAA;AACZ,MAAO,OAAA,QAAA,CAAA;AAAA,KACT;AAAA,GACF;AAEA,EAAA,MAAM,GACJ,GAAA,OAAO,uBAA4B,KAAA,WAAA,GAC/B,OACA,GAAA,uBAAA,CAAA;AAEN,EAAO,OAAAA,oBAAA,CAAY,IAAI,OAAQ,CAAA,CAAA,EAAG,IAAI,CAAe,aAAA,CAAA,CAAA,EAAG,IAAM,EAAA,GAAG,KAAK,CAAA,CAAA;AACxE,CAAA;AAYgB,SAAA,oBAAA,CAAqB,MAAc,IAAsB,EAAA;AACvE,EAAM,MAAA,UAAA,GAAaA,oBAAY,CAAA,IAAA,EAAM,IAAI,CAAA,CAAA;AAEzC,EAAA,IAAI,CAACC,qBAAA,CAAY,IAAM,EAAA,UAAU,CAAG,EAAA;AAClC,IAAA,MAAM,IAAIC,sBAAA;AAAA,MACR,yEAAA;AAAA,KACF,CAAA;AAAA,GACF;AAEA,EAAO,OAAA,UAAA,CAAA;AACT;;;;;;"}