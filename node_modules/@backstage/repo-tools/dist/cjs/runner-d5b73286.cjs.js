'use strict';

var paths = require('./paths-9ab9b8a8.cjs.js');
var pLimit = require('p-limit');
var path = require('path');
var portFinder = require('portfinder');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var pLimit__default = /*#__PURE__*/_interopDefaultLegacy(pLimit);
var portFinder__default = /*#__PURE__*/_interopDefaultLegacy(portFinder);

async function runner(paths$1, command, options) {
  var _a;
  const packages = await paths.resolvePackagePaths({ paths: paths$1 });
  const limit = pLimit__default["default"]((_a = options == null ? void 0 : options.concurrencyLimit) != null ? _a : 5);
  let port = (options == null ? void 0 : options.startingPort) && await portFinder__default["default"].getPortPromise({
    // Prevent collisions with optic which runs 8000->8999
    port: options.startingPort,
    stopPort: options.startingPort + 1e3
  });
  const resultsList = await Promise.all(
    packages.map(
      (pkg) => limit(async () => {
        let resultText = "";
        try {
          if (port)
            port = (options == null ? void 0 : options.startingPort) && await portFinder__default["default"].getPortPromise({
              // Prevent collisions with optic which runs 8000->8999
              port: port + 1,
              stopPort: options.startingPort + 1e3
            });
          console.log(`## Processing ${pkg}`);
          await command(pkg, port ? { port } : void 0);
        } catch (err) {
          resultText = err.message;
        }
        return {
          relativeDir: path.relative(paths.paths.targetRoot, pkg),
          resultText
        };
      })
    )
  );
  return resultsList;
}

exports.runner = runner;
//# sourceMappingURL=runner-d5b73286.cjs.js.map
