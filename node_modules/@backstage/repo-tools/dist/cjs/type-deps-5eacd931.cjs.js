'use strict';

var fs = require('fs');
var path = require('path');
var chalk = require('chalk');
var getPackages = require('@manypkg/get-packages');
var entryPoints = require('./entryPoints-c9b88245.cjs.js');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var fs__default = /*#__PURE__*/_interopDefaultLegacy(fs);
var chalk__default = /*#__PURE__*/_interopDefaultLegacy(chalk);

var typeDeps = async () => {
  const { packages } = await getPackages.getPackages(path.resolve("."));
  let hadErrors = false;
  for (const pkg of packages) {
    if (!shouldCheckTypes(pkg)) {
      continue;
    }
    const { errors } = await checkTypes(pkg);
    if (errors.length) {
      hadErrors = true;
      console.error(
        `Incorrect type dependencies in ${chalk__default["default"].yellow(pkg.packageJson.name)}:`
      );
      for (const error of errors) {
        if (error.name === "WrongDepError") {
          console.error(
            `  Move from ${chalk__default["default"].red(error.from)} to ${chalk__default["default"].green(
              error.to
            )}: ${chalk__default["default"].cyan(error.dep)}`
          );
        } else if (error.name === "MissingDepError") {
          console.error(
            `  Missing a type dependency: ${chalk__default["default"].cyan(error.dep)}`
          );
        } else {
          console.error(`  Unknown error, ${chalk__default["default"].red(error)}`);
        }
      }
    }
  }
  if (hadErrors) {
    console.error();
    console.error(
      chalk__default["default"].red("At least one package had incorrect type dependencies")
    );
    process.exit(2);
  }
};
function shouldCheckTypes(pkg) {
  return !pkg.packageJson.private && pkg.packageJson.types && fs__default["default"].existsSync(path.resolve(pkg.dir, "dist/index.d.ts"));
}
function findAllDeps(declSrc) {
  const importedDeps = (declSrc.match(/^import .* from '.*';$/gm) || []).map((match) => {
    var _a, _b;
    return (_b = (_a = match.match(/from '(.*)'/)) == null ? void 0 : _a[1]) != null ? _b : "";
  }).filter((n) => !n.startsWith("."));
  const referencedDeps = (declSrc.match(/^\/\/\/ <reference types=".*" \/>$/gm) || []).map((match) => {
    var _a, _b;
    return (_b = (_a = match.match(/types="(.*)"/)) == null ? void 0 : _a[1]) != null ? _b : "";
  }).filter((n) => !n.startsWith(".")).filter((n) => !["node", "react"].includes(n));
  return Array.from(/* @__PURE__ */ new Set([...importedDeps, ...referencedDeps]));
}
function checkTypes(pkg) {
  var _a;
  const entryPointNames = (_a = entryPoints.getPackageExportNames(pkg.packageJson)) != null ? _a : ["index"];
  const allDeps = entryPointNames.flatMap((name) => {
    const typeDecl = fs__default["default"].readFileSync(
      path.resolve(pkg.dir, `dist/${name}.d.ts`),
      "utf8"
    );
    return findAllDeps(typeDecl);
  });
  const deps = Array.from(new Set(allDeps));
  const errors = [];
  const typeDeps = [];
  for (let dep of deps) {
    if (dep.endsWith("/*")) {
      dep = dep.slice(0, -2);
    }
    try {
      const typeDep = findTypesPackage(dep, pkg);
      if (typeDep) {
        typeDeps.push(typeDep);
      }
    } catch (error) {
      errors.push(error);
    }
  }
  errors.push(...findTypeDepErrors(typeDeps, pkg));
  return { errors };
}
function findTypesPackage(dep, pkg) {
  try {
    require.resolve(`@types/${dep}/package.json`, { paths: [pkg.dir] });
    return `@types/${dep}`;
  } catch {
    try {
      require.resolve(dep, { paths: [pkg.dir] });
      return void 0;
    } catch {
      try {
        require.resolve(`${dep}/package.json`, { paths: [pkg.dir] });
        return void 0;
      } catch {
        try {
          require.resolve(`${dep}.d.ts`, { paths: [pkg.dir] });
          return void 0;
        } catch {
          if (fs__default["default"].existsSync(path.resolve(pkg.dir, `node_modules/${dep}.d.ts`))) {
            return void 0;
          }
          if (fs__default["default"].existsSync(
            path.resolve(pkg.dir, `../../node_modules/${dep}.d.ts`)
          )) {
            return void 0;
          }
          throw mkErr("MissingDepError", `No types for ${dep}`, { dep });
        }
      }
    }
  }
}
function findTypeDepErrors(typeDeps, pkg) {
  const devDeps = mkTypeDepSet(pkg.packageJson.devDependencies);
  const deps = mkTypeDepSet({
    ...pkg.packageJson.dependencies,
    ...pkg.packageJson.peerDependencies
  });
  const errors = [];
  for (const typeDep of typeDeps) {
    if (!deps.has(typeDep)) {
      if (devDeps.has(typeDep)) {
        errors.push(
          mkErr("WrongDepError", `Should be dep ${typeDep}`, {
            dep: typeDep,
            from: "devDependencies",
            to: "dependencies"
          })
        );
      } else {
        errors.push(
          mkErr("MissingDepError", `No types for ${typeDep}`, {
            dep: typeDep
          })
        );
      }
    } else {
      deps.delete(typeDep);
    }
  }
  for (const dep of deps) {
    errors.push(
      mkErr("WrongDepError", `Should be dev dep ${dep}`, {
        dep,
        from: "dependencies",
        to: "devDependencies"
      })
    );
  }
  return errors;
}
function mkTypeDepSet(deps) {
  const typeDeps = Object.keys(deps || {}).filter((n) => n.startsWith("@types/"));
  return new Set(typeDeps);
}
function mkErr(name, msg, extra) {
  const error = new Error(msg);
  error.name = name;
  Object.assign(error, extra);
  return error;
}

exports["default"] = typeDeps;
//# sourceMappingURL=type-deps-5eacd931.cjs.js.map
