'use strict';

var YAML = require('js-yaml');
var pLimit = require('p-limit');
var path = require('path');
var yamlDiffPatch = require('yaml-diff-patch');
var chalk = require('chalk');
var cliNode = require('@backstage/cli-node');
var codeownersUtils = require('codeowners-utils');
var fs = require('fs');
var util = require('util');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var YAML__default = /*#__PURE__*/_interopDefaultLegacy(YAML);
var pLimit__default = /*#__PURE__*/_interopDefaultLegacy(pLimit);
var chalk__default = /*#__PURE__*/_interopDefaultLegacy(chalk);
var fs__default = /*#__PURE__*/_interopDefaultLegacy(fs);

const readFile = util.promisify(fs__default["default"].readFile);
const writeFile = util.promisify(fs__default["default"].writeFile);
function isBackstagePackage(packageJson) {
  var _a;
  return packageJson && packageJson.hasOwnProperty("backstage") && ((_a = packageJson == null ? void 0 : packageJson.backstage) == null ? void 0 : _a.role) !== "undefined";
}
const isRejected = (input) => input.status === "rejected";
const isFulfilled = (input) => input.status === "fulfilled";
const safeEntityName = (packageName) => {
  return packageName.replace(/^[^\w\s]|[^a-z0-9]$/g, "").replace(/[^A-Za-z0-9_\-.]+/g, "-").replace(
    /([a-z])([A-Z])/g,
    (_, a, b) => `${a}-${b.toLocaleLowerCase("en-US")}`
  ).replace(/^(.)/, (_, a) => a.toLocaleLowerCase("en-US"));
};

async function loadCodeowners() {
  const maybeFiles = await Promise.allSettled(
    codeownersUtils.CODEOWNERS_PATHS.map(
      async (path$1) => readFile(path.resolve(".", path$1), { encoding: "utf-8" })
    )
  );
  const file = maybeFiles.find(
    (maybeFile) => maybeFile.status === "fulfilled"
  );
  if (!file) {
    throw new Error(
      "This utility expects a CODEOWNERS file, but no such file was found."
    );
  }
  return codeownersUtils.parse(file.value);
}
function getPossibleCodeowners(codeowners, relPath) {
  const codeownerMaybe = codeownersUtils.matchFile(relPath, codeowners);
  return codeownerMaybe ? codeownerMaybe.owners.map(
    (owner) => (owner.match(/(?:\@[^\/]+\/)?([^\@\/]*)$/) || [])[1]
  ) : [];
}
function getOwnerFromCodeowners(codeowners, absPath) {
  const relPath = path.relative(".", absPath);
  const possibleOwners = getPossibleCodeowners(codeowners, relPath);
  const owner = possibleOwners[0];
  if (!owner) {
    throw new Error(`${relPath} isn't owned by anyone in CODEOWNERS`);
  }
  return owner;
}

var generateCatalogInfo = async (opts) => {
  const { dryRun = false, ci = false } = opts;
  const packages = await cliNode.PackageGraph.listTargetPackages();
  const codeowners = await loadCodeowners();
  const limit = pLimit__default["default"](10);
  const isDryRun = ci ? true : dryRun;
  const checkForChanges = ci;
  const results = await Promise.allSettled(
    packages.map(
      ({ packageJson, dir }) => limit(async () => {
        if (!isBackstagePackage(packageJson)) {
          return "";
        }
        const infoYamlPath = path.resolve(dir, "catalog-info.yaml");
        let yamlString = "";
        try {
          yamlString = await readFile(infoYamlPath, { encoding: "utf-8" });
        } catch (e) {
          if (e.code === "ENOENT") {
            return await createCatalogInfoYaml({
              yamlPath: infoYamlPath,
              packageJson,
              codeowners,
              dryRun: isDryRun
            });
          }
          throw e;
        }
        return await fixCatalogInfoYaml({
          yamlPath: infoYamlPath,
          packageJson,
          codeowners,
          yamlString,
          dryRun: isDryRun,
          ci
        });
      })
    )
  );
  const rejects = results.filter(isRejected);
  if (rejects.length > 0) {
    console.error(
      chalk__default["default"].red("Unable to create or fix catalog-info.yaml files\n")
    );
    rejects.forEach((reject) => console.error(`  ${reject.reason}`));
    console.error();
    process.exit(1);
  }
  if (checkForChanges) {
    const instructions = results.filter(isFulfilled).map((r) => r.value).filter((r) => r !== "");
    if (instructions.length > 0) {
      console.error(
        "\ncatalog-info.yaml file(s) out of sync with CODEOWNERS and/or package.json (see instructions above)\n"
      );
      process.exit(1);
    } else {
      console.error(
        "catalog-info.yaml file(s) in sync with CODEOWNERS and package.json"
      );
    }
  }
};
async function createCatalogInfoYaml(options) {
  const { codeowners, dryRun, packageJson, yamlPath } = options;
  const instruction = `Create ${path.relative(".", yamlPath)}`;
  const owner = getOwnerFromCodeowners(codeowners, yamlPath);
  const entity = createOrMergeEntity(packageJson, owner);
  if (dryRun) {
    console.error(instruction);
  } else {
    await writeFile(yamlPath, YAML__default["default"].dump(entity));
  }
  return instruction;
}
async function fixCatalogInfoYaml(options) {
  var _a, _b, _c;
  const { ci, codeowners, dryRun, packageJson, yamlPath, yamlString } = options;
  const possibleOwners = getPossibleCodeowners(
    codeowners,
    path.relative(".", yamlPath)
  );
  const safeName = safeEntityName(packageJson.name);
  let yamlJson;
  try {
    yamlJson = YAML__default["default"].load(yamlString);
  } catch (e) {
    throw new Error(`Unable to parse ${path.relative(".", yamlPath)}: ${e}`);
  }
  const badOwner = !possibleOwners.includes((_a = yamlJson.spec) == null ? void 0 : _a.owner);
  const badTitle = yamlJson.metadata.title !== packageJson.name;
  const badName = yamlJson.metadata.name !== safeName;
  const badType = ((_b = yamlJson.spec) == null ? void 0 : _b.type) !== `backstage-${packageJson.backstage.role}`;
  if (badOwner || badTitle || badName || badType) {
    const owner = badOwner ? getOwnerFromCodeowners(codeowners, yamlPath) : (_c = yamlJson.spec) == null ? void 0 : _c.owner;
    const newJson = createOrMergeEntity(packageJson, owner, yamlJson);
    const instructions = [`Update ${path.relative(".", yamlPath)}`];
    if (ci) {
      if (badOwner) {
        instructions.push(
          `  spec.owner cannot be "${yamlJson.spec.owner}" because it must be one of (${possibleOwners.join(
            ", "
          )}) as listed in CODEOWNERS`
        );
      }
      if (badTitle) {
        instructions.push(
          `  metadata.title cannot be "${yamlJson.metadata.title}" because it must be exactly "${packageJson.name}", the package.json name`
        );
      }
      if (badName) {
        instructions.push(
          `  metadata.name cannot be "${yamlJson.metadata.name}" because it must be exactly "${safeName}", as derived from package.json name`
        );
      }
      if (badType) {
        instructions.push(
          `  spec.type cannot be "${yamlJson.spec.type}" because it must be exactly "backstage-${packageJson.backstage.role}", as derived from package.json backstage.role`
        );
      }
    }
    if (dryRun) {
      console.error(instructions.join("\n"));
    } else {
      await writeFile(yamlPath, yamlDiffPatch.yamlOverwrite(yamlString, newJson));
    }
    return instructions.join("\n");
  }
  return "";
}
function createOrMergeEntity(packageJson, owner, existingEntity = {}) {
  var _a;
  const entityName = safeEntityName(packageJson.name);
  return {
    ...existingEntity,
    apiVersion: "backstage.io/v1alpha1",
    kind: "Component",
    metadata: {
      ...existingEntity.metadata,
      // Provide default name/title/description values.
      name: entityName,
      title: packageJson.name,
      ...packageJson.description && !((_a = existingEntity.metadata) == null ? void 0 : _a.description) ? { description: packageJson.description } : void 0
    },
    spec: {
      lifecycle: "experimental",
      ...existingEntity.spec,
      type: `backstage-${packageJson.backstage.role}`,
      owner
    }
  };
}

exports["default"] = generateCatalogInfo;
//# sourceMappingURL=generate-catalog-info-e7071c1c.cjs.js.map
