'use strict';

var lodash = require('lodash');
var path = require('path');
var fs = require('fs-extra');
var apiExtractor = require('@microsoft/api-extractor');
var tsdoc = require('@microsoft/tsdoc');
var tsdocConfig = require('@microsoft/tsdoc-config');
var apiExtractorModel = require('@microsoft/api-extractor-model');
var MarkdownDocumenter = require('@microsoft/api-documenter/lib/documenters/MarkdownDocumenter');
var DocTable = require('@microsoft/api-documenter/lib/nodes/DocTable');
var DocTableRow = require('@microsoft/api-documenter/lib/nodes/DocTableRow');
var DocHeading = require('@microsoft/api-documenter/lib/nodes/DocHeading');
var CustomMarkdownEmitter = require('@microsoft/api-documenter/lib/markdown/CustomMarkdownEmitter');
var paths = require('./paths-9ab9b8a8.cjs.js');
var minimatch = require('minimatch');
var entryPoints = require('./entryPoints-c9b88245.cjs.js');
var util = require('./util-bfc74a41.cjs.js');
var child_process = require('child_process');
require('@backstage/cli-common');
require('@backstage/cli-node');
require('os');
require('p-limit');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var fs__default = /*#__PURE__*/_interopDefaultLegacy(fs);
var minimatch__default = /*#__PURE__*/_interopDefaultLegacy(minimatch);

var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var _tokens;
const tmpDir = paths.paths.resolveTargetRoot(
  "./node_modules/.cache/api-extractor"
);
const {
  ApiReportGenerator
} = require("@microsoft/api-extractor/lib/generators/ApiReportGenerator");
function patchFileMessageFetcher(router, transform) {
  const {
    fetchAssociatedMessagesForReviewFile,
    fetchUnassociatedMessagesForReviewFile
  } = router;
  router.fetchAssociatedMessagesForReviewFile = function patchedFetchAssociatedMessagesForReviewFile(ast) {
    const messages = fetchAssociatedMessagesForReviewFile.call(this, ast);
    return transform(messages, ast);
  };
  router.fetchUnassociatedMessagesForReviewFile = function patchedFetchUnassociatedMessagesForReviewFile() {
    const messages = fetchUnassociatedMessagesForReviewFile.call(this);
    return transform(messages);
  };
}
const originalGenerateReviewFileContent = ApiReportGenerator.generateReviewFileContent;
ApiReportGenerator.generateReviewFileContent = function decoratedGenerateReviewFileContent(collector, ...moreArgs) {
  var _a;
  const program = collector.program;
  patchFileMessageFetcher(
    collector.messageRouter,
    (messages) => {
      return messages.filter((message) => {
        var _a2, _b, _c, _d;
        if (message.messageId !== "ae-forgotten-export") {
          return true;
        }
        const symbolMatch = message.text.match(/The symbol "([^"]+)"/);
        if (!symbolMatch) {
          throw new Error(
            `Failed to extract symbol name from message "${message.text}"`
          );
        }
        const [, symbolName] = symbolMatch;
        const sourceFile = message.sourceFilePath && program.getSourceFile(message.sourceFilePath);
        if (!sourceFile) {
          throw new Error(
            `Failed to find source file in program at path "${message.sourceFilePath}"`
          );
        }
        let localName = (_a2 = sourceFile.identifiers) == null ? void 0 : _a2.get(symbolName);
        if (!localName) {
          const [, trimmedSymbolName] = symbolName.match(/(.*)_\d+/) || [];
          localName = (_b = sourceFile.identifiers) == null ? void 0 : _b.get(trimmedSymbolName);
        }
        if (!localName) {
          throw new Error(
            `Unable to find local name of "${symbolName}" in ${sourceFile.fileName}`
          );
        }
        const local = (_c = sourceFile.locals) == null ? void 0 : _c.get(localName);
        if (!local) {
          return true;
        }
        const type = program.getTypeChecker().getDeclaredTypeOfSymbol(local);
        if (!type) {
          throw new Error(
            `Unable to find type declaration of "${symbolName}" in ${sourceFile.fileName}`
          );
        }
        const declarations = (_d = type.aliasSymbol) == null ? void 0 : _d.declarations;
        if (!declarations || declarations.length === 0) {
          return true;
        }
        const isIgnored = declarations.some((declaration) => {
          const tags = [declaration.jsDoc].flat().filter(Boolean).flatMap((tagNode) => tagNode.tags);
          return tags.some((tag) => (tag == null ? void 0 : tag.tagName.text) === "ignore");
        });
        return !isIgnored;
      });
    }
  );
  const content = originalGenerateReviewFileContent.call(
    this,
    collector,
    ...moreArgs
  );
  try {
    const prettier = require("prettier");
    const config = (_a = prettier.resolveConfig.sync(paths.paths.targetRoot)) != null ? _a : {};
    return prettier.format(content, {
      ...config,
      parser: "markdown"
    });
  } catch (e) {
    return content;
  }
};
async function createTemporaryTsConfig(includedPackageDirs) {
  const path$1 = paths.paths.resolveTargetRoot("tsconfig.tmp.json");
  process.once("exit", () => {
    fs__default["default"].removeSync(path$1);
  });
  let assetTypeFile = [];
  try {
    assetTypeFile = [
      require.resolve("@backstage/cli/asset-types/asset-types.d.ts")
    ];
  } catch {
  }
  await fs__default["default"].writeJson(path$1, {
    extends: "./tsconfig.json",
    include: [
      // These two contain global definitions that are needed for stable API report generation
      ...assetTypeFile,
      ...includedPackageDirs.map((dir) => path.join(dir, "src"))
    ],
    // we don't exclude node_modules so that we can use the asset-types.d.ts file
    exclude: []
  });
  return path$1;
}
async function countApiReportWarnings(reportPath) {
  try {
    const content = await fs__default["default"].readFile(reportPath, "utf8");
    const lines = content.split("\n");
    const lineWarnings = lines.filter(
      (line) => line.includes("// Warning:")
    ).length;
    const trailerStart = lines.findIndex(
      (line) => line === "// Warnings were encountered during analysis:"
    );
    const trailerWarnings = trailerStart === -1 ? 0 : lines.length - trailerStart - 4;
    return lineWarnings + trailerWarnings;
  } catch (error) {
    if (error.code === "ENOENT") {
      return 0;
    }
    throw error;
  }
}
async function getTsDocConfig() {
  const tsdocConfigFile = await tsdocConfig.TSDocConfigFile.loadFile(
    require.resolve("@microsoft/api-extractor/extends/tsdoc-base.json")
  );
  tsdocConfigFile.addTagDefinition({
    tagName: "@ignore",
    syntaxKind: tsdoc.TSDocTagSyntaxKind.ModifierTag
  });
  tsdocConfigFile.addTagDefinition({
    tagName: "@config",
    syntaxKind: tsdoc.TSDocTagSyntaxKind.BlockTag
  });
  tsdocConfigFile.setSupportForTag("@ignore", true);
  tsdocConfigFile.setSupportForTag("@config", true);
  return tsdocConfigFile;
}
function logApiReportInstructions() {
  console.log("");
  console.log(
    "*************************************************************************************"
  );
  console.log(
    "* You have uncommitted changes to the public API or reports of a package.           *"
  );
  console.log(
    "* To solve this, run `yarn build:api-reports` and commit all md file changes.       *"
  );
  console.log(
    "*************************************************************************************"
  );
  console.log("");
}
async function findPackageEntryPoints(packageDirs) {
  return Promise.all(
    packageDirs.map(async (packageDir) => {
      var _a, _b;
      const pkg = await fs__default["default"].readJson(
        paths.paths.resolveTargetRoot(packageDir, "package.json")
      );
      return (_b = (_a = entryPoints.getPackageExportNames(pkg)) == null ? void 0 : _a.map((name) => ({ packageDir, name }))) != null ? _b : {
        packageDir,
        name: "index"
      };
    })
  ).then((results) => results.flat());
}
async function runApiExtraction({
  packageDirs,
  outputDir,
  isLocalBuild,
  tsconfigFilePath,
  allowWarnings = false,
  omitMessages = [],
  validateReleaseTags = false
}) {
  await fs__default["default"].remove(outputDir);
  const packageEntryPoints = await findPackageEntryPoints(packageDirs);
  const entryPoints = packageEntryPoints.map(({ packageDir, name }) => {
    return paths.paths.resolveTargetRoot(
      `./dist-types/${packageDir}/src/${name}.d.ts`
    );
  });
  let compilerState = void 0;
  const allowWarningPkg = Array.isArray(allowWarnings) ? allowWarnings : [];
  const messagesConf = {};
  for (const messageCode of omitMessages) {
    messagesConf[messageCode] = {
      logLevel: "none"
    };
  }
  const warnings = new Array();
  for (const [packageDir, group] of Object.entries(
    lodash.groupBy(packageEntryPoints, (ep) => ep.packageDir)
  )) {
    console.log(`## Processing ${packageDir}`);
    const noBail = Array.isArray(allowWarnings) ? allowWarnings.some((aw) => aw === packageDir || minimatch__default["default"](packageDir, aw)) : allowWarnings;
    const projectFolder = paths.paths.resolveTargetRoot(packageDir);
    const packageFolder = paths.paths.resolveTargetRoot(
      "./dist-types",
      packageDir
    );
    const names = group.map((ep) => ep.name);
    const remainingReportFiles = new Set(
      fs__default["default"].readdirSync(projectFolder).filter(
        (filename) => filename.match(/^(.+)-api-report\.md$/) || filename.match(/^api-report(-.+)?\.md$/)
      )
    );
    for (const name of names) {
      const suffix = name === "index" ? "" : `-${name}`;
      const reportFileName = `api-report${suffix}.md`;
      const reportPath = path.resolve(projectFolder, reportFileName);
      remainingReportFiles.delete(reportFileName);
      const warningCountBefore = await countApiReportWarnings(reportPath);
      const extractorConfig = apiExtractor.ExtractorConfig.prepare({
        configObject: {
          mainEntryPointFilePath: path.resolve(
            packageFolder,
            `src/${name}.d.ts`
          ),
          bundledPackages: [],
          compiler: {
            tsconfigFilePath
          },
          apiReport: {
            enabled: true,
            reportFileName,
            reportFolder: projectFolder,
            reportTempFolder: path.resolve(
              outputDir,
              `<unscopedPackageName>${suffix}`
            )
          },
          docModel: {
            // TODO(Rugvip): This skips docs for non-index entry points. We can try to work around it, but
            //               most likely it makes sense to wait for API Extractor to natively support exports.
            enabled: name === "index",
            apiJsonFilePath: path.resolve(
              outputDir,
              `<unscopedPackageName>${suffix}.api.json`
            )
          },
          dtsRollup: {
            enabled: false
          },
          tsdocMetadata: {
            enabled: false
          },
          messages: {
            // Silence compiler warnings, as these will prevent the CI build to work
            compilerMessageReporting: {
              default: {
                logLevel: "none"
                // These contain absolute file paths, so can't be included in the report
                // addToApiReportFile: true,
              }
            },
            extractorMessageReporting: {
              default: {
                logLevel: "warning",
                addToApiReportFile: true
              },
              ...messagesConf
            },
            tsdocMessageReporting: {
              default: {
                logLevel: "warning",
                addToApiReportFile: true
              }
            }
          },
          newlineKind: "lf",
          projectFolder
        },
        configObjectFullPath: projectFolder,
        packageJsonFullPath: path.resolve(projectFolder, "package.json"),
        tsdocConfigFile: await getTsDocConfig(),
        ignoreMissingEntryPoint: true
      });
      extractorConfig.packageFolder = packageFolder;
      if (!compilerState) {
        compilerState = apiExtractor.CompilerState.create(extractorConfig, {
          additionalEntryPoints: entryPoints
        });
      }
      apiExtractor.Extractor._checkCompilerCompatibility = () => {
      };
      let shouldLogInstructions = false;
      let conflictingFile = void 0;
      const extractorResult = apiExtractor.Extractor.invoke(extractorConfig, {
        localBuild: isLocalBuild,
        showVerboseMessages: false,
        showDiagnostics: false,
        messageCallback(message) {
          if (message.text.includes("The API report file is missing")) {
            shouldLogInstructions = true;
          }
          if (message.text.includes(
            "You have changed the public API signature for this project."
          )) {
            shouldLogInstructions = true;
            const match = message.text.match(
              /Please copy the file "(.*)" to "api-report\.md"/
            );
            if (match) {
              conflictingFile = match[1];
            }
          }
        },
        compilerState
      });
      if (validateReleaseTags && fs__default["default"].pathExistsSync(extractorConfig.reportFilePath)) {
        if (["index", "alpha", "beta"].includes(name)) {
          const report = await fs__default["default"].readFile(
            extractorConfig.reportFilePath,
            "utf8"
          );
          const lines = report.split(/\r?\n/);
          const expectedTag = name === "index" ? "public" : name;
          for (let i = 0; i < lines.length; i += 1) {
            const line = lines[i];
            const match = line.match(/^\/\/ @(alpha|beta|public)/);
            if (match && match[1] !== expectedTag) {
              if (expectedTag !== "public" && match[1] === "public") {
                continue;
              }
              throw new Error(
                `Unexpected release tag ${match[1]} in ${extractorConfig.reportFilePath} at line ${i + 1}`
              );
            }
          }
        }
      }
      if (!extractorResult.succeeded) {
        if (shouldLogInstructions) {
          logApiReportInstructions();
          if (conflictingFile) {
            console.log("");
            console.log(
              `The conflicting file is ${path.relative(
                tmpDir,
                conflictingFile
              )}, with the following content:`
            );
            console.log("");
            const content = await fs__default["default"].readFile(conflictingFile, "utf8");
            console.log(content);
            logApiReportInstructions();
          }
        }
        throw new Error(
          `API Extractor completed with ${extractorResult.errorCount} errors and ${extractorResult.warningCount} warnings`
        );
      }
      const warningCountAfter = await countApiReportWarnings(reportPath);
      if (noBail) {
        console.log(`Skipping warnings check for ${packageDir}`);
      }
      if (warningCountAfter > 0 && !noBail) {
        throw new Error(
          `The API Report for ${packageDir} is not allowed to have warnings`
        );
      }
      if (warningCountAfter === 0 && allowWarningPkg.includes(packageDir)) {
        console.log(
          `No need to allow warnings for ${packageDir}, it does not have any`
        );
      }
      if (warningCountAfter > warningCountBefore) {
        warnings.push(
          `The API Report for ${packageDir} introduces new warnings. Please fix these warnings in order to keep the API Reports tidy.`
        );
      }
    }
    if (remainingReportFiles.size > 0) {
      if (isLocalBuild) {
        for (const f of remainingReportFiles) {
          fs__default["default"].rmSync(path.resolve(projectFolder, f));
          console.log(`Deleted deprecated API report ${f}`);
        }
      } else {
        const staleList = [...remainingReportFiles].map((f) => path.join(packageDir, f)).join(", ");
        throw new Error(
          `The API Report(s) ${staleList} are no longer relevant and should be deleted`
        );
      }
    }
  }
  if (warnings.length > 0) {
    console.warn();
    for (const warning of warnings) {
      console.warn(warning);
    }
    console.warn();
  }
}
class ExcerptTokenMatcher {
  constructor(tokens) {
    __privateAdd(this, _tokens, void 0);
    __privateSet(this, _tokens, tokens.slice());
  }
  nextContent() {
    const token = __privateGet(this, _tokens).shift();
    if ((token == null ? void 0 : token.kind) === "Content") {
      return token.text;
    }
    return void 0;
  }
  matchContent(expectedText) {
    const text = this.nextContent();
    return text !== expectedText;
  }
  getTokensUntilArrow() {
    const tokens = [];
    for (; ; ) {
      const token = __privateGet(this, _tokens).shift();
      if (token === void 0) {
        return void 0;
      }
      if (token.kind === "Content" && token.text === ") => ") {
        return tokens;
      }
      tokens.push(token);
    }
  }
  getComponentReturnTokens() {
    const first = __privateGet(this, _tokens).shift();
    if (!first) {
      return void 0;
    }
    const second = __privateGet(this, _tokens).shift();
    if (__privateGet(this, _tokens).length !== 0) {
      return void 0;
    }
    if (first.kind !== "Reference" || first.text !== "JSX.Element") {
      return void 0;
    }
    if (!second) {
      return [first];
    } else if (second.kind === "Content" && second.text === " | null") {
      return [first, second];
    }
    return void 0;
  }
}
_tokens = new WeakMap();
const _ApiModelTransforms = class _ApiModelTransforms {
  static deserializeWithTransforms(serialized, transforms) {
    if (serialized.kind !== "Package") {
      throw new Error(
        `Unexpected root kind in serialized ApiPackage, ${serialized.kind}`
      );
    }
    if (serialized.members.length !== 1) {
      throw new Error(
        `Unexpected members in serialized ApiPackage, [${serialized.members.map((m) => m.kind).join(" ")}]`
      );
    }
    const [entryPoint] = serialized.members;
    if (entryPoint.kind !== "EntryPoint") {
      throw new Error(
        `Unexpected kind in serialized ApiPackage member, ${entryPoint.kind}`
      );
    }
    const transformed = {
      ...serialized,
      members: [
        {
          ...entryPoint,
          members: entryPoint.members.map(
            (member) => transforms.reduce((m, t) => t(m), member)
          )
        }
      ]
    };
    return apiExtractorModel.ApiPackage.deserialize(
      transformed,
      transformed.metadata
    );
  }
  static makeComponentMember(member, ret, props) {
    var _a;
    const declTokens = props ? [
      {
        kind: "Content",
        text: `export declare function ${member.name}(props: `
      },
      ...props,
      {
        kind: "Content",
        text: "): "
      }
    ] : [
      {
        kind: "Content",
        text: `export declare function ${member.name}(): `
      }
    ];
    return {
      kind: "Function",
      name: member.name,
      releaseTag: member.releaseTag,
      docComment: (_a = member.docComment) != null ? _a : "",
      canonicalReference: member.canonicalReference,
      excerptTokens: [...declTokens, ...ret],
      returnTypeTokenRange: {
        startIndex: declTokens.length,
        endIndex: declTokens.length + ret.length
      },
      parameters: props ? [
        {
          parameterName: "props",
          parameterTypeTokenRange: {
            startIndex: 1,
            endIndex: 1 + props.length
          }
        }
      ] : [],
      overloadIndex: 1
    };
  }
};
__publicField(_ApiModelTransforms, "transformArrowComponents", (member) => {
  if (member.kind !== "Variable") {
    return member;
  }
  const { name, excerptTokens } = member;
  const [firstChar] = name;
  if (firstChar.toLocaleUpperCase("en-US") !== firstChar) {
    return member;
  }
  const tokens = new ExcerptTokenMatcher(excerptTokens);
  if (tokens.nextContent() !== `${name}: `) {
    return member;
  }
  const declStart = tokens.nextContent();
  if (declStart === "(props: " || declStart === "(_props: ") {
    const props = tokens.getTokensUntilArrow();
    const ret = tokens.getComponentReturnTokens();
    if (props && ret) {
      return _ApiModelTransforms.makeComponentMember(member, ret, props);
    }
  } else if (declStart === "() => ") {
    const ret = tokens.getComponentReturnTokens();
    if (ret) {
      return _ApiModelTransforms.makeComponentMember(member, ret);
    }
  }
  return member;
});
__publicField(_ApiModelTransforms, "transformTrimDeclare", (member) => {
  const { excerptTokens } = member;
  const firstContent = new ExcerptTokenMatcher(excerptTokens).nextContent();
  if (firstContent && firstContent.startsWith("export declare ")) {
    return {
      ...member,
      excerptTokens: [
        {
          kind: "Content",
          text: firstContent.slice("export declare ".length)
        },
        ...excerptTokens.slice(1)
      ]
    };
  }
  return member;
});
let ApiModelTransforms = _ApiModelTransforms;
async function buildDocs({
  inputDir,
  outputDir
}) {
  const parseFile = async (filename) => {
    console.log(`Reading ${filename}`);
    return fs__default["default"].readJson(path.resolve(inputDir, filename));
  };
  const filenames = await fs__default["default"].readdir(inputDir);
  const serializedPackages = await Promise.all(
    filenames.filter((filename) => filename.match(/\.api\.json$/i)).map(parseFile)
  );
  const newModel = new apiExtractorModel.ApiModel();
  for (const serialized of serializedPackages) {
    newModel.addMember(
      ApiModelTransforms.deserializeWithTransforms(serialized, [
        ApiModelTransforms.transformArrowComponents,
        ApiModelTransforms.transformTrimDeclare
      ])
    );
  }
  const _DocFrontMatter = class _DocFrontMatter extends tsdoc.DocNode {
    constructor(parameters) {
      super(parameters);
      __publicField(this, "values");
      this.values = parameters.values;
    }
    /** @override */
    get kind() {
      return _DocFrontMatter.kind;
    }
  };
  __publicField(_DocFrontMatter, "kind", "DocFrontMatter");
  let DocFrontMatter = _DocFrontMatter;
  const _DocCodeSpanLink = class _DocCodeSpanLink extends tsdoc.DocLinkTag {
    /** @override */
    get kind() {
      return _DocCodeSpanLink.kind;
    }
  };
  __publicField(_DocCodeSpanLink, "kind", "DocCodeSpanLink");
  let DocCodeSpanLink = _DocCodeSpanLink;
  class CustomCustomMarkdownEmitter extends CustomMarkdownEmitter.CustomMarkdownEmitter {
    // Until https://github.com/microsoft/rushstack/issues/2914 gets fixed or we change markdown renderer we need a fix
    // to render pipe | character correctly.
    getEscapedText(text) {
      return text.replace(/\\/g, "\\\\").replace(/[*#[\]_`~]/g, (x) => `\\${x}`).replace(/---/g, "\\-\\-\\-").replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\|/g, "&#124;");
    }
    /** @override */
    writeNode(docNode, context, docNodeSiblings) {
      switch (docNode.kind) {
        case DocFrontMatter.kind: {
          const node = docNode;
          context.writer.writeLine("---");
          for (const [name, value] of Object.entries(node.values)) {
            if (value) {
              context.writer.writeLine(
                `${name}: "${String(value).replace(/\"/g, "")}"`
              );
            }
          }
          context.writer.writeLine("---");
          context.writer.writeLine();
          break;
        }
        case "BlockTag": {
          const node = docNode;
          if (node.tagName === "@config") {
            context.writer.writeLine("## Related config ");
          }
          break;
        }
        case DocCodeSpanLink.kind: {
          const node = docNode;
          if (node.codeDestination) {
            super.writeLinkTagWithCodeDestination(node, context);
          } else if (node.urlDestination) {
            const linkText = node.linkText !== void 0 ? node.linkText : node.urlDestination;
            const encodedLinkText = this.getEscapedText(
              linkText.replace(/\s+/g, " ")
            );
            context.writer.write("[");
            context.writer.write(`\`${encodedLinkText}\``);
            context.writer.write(`](${node.urlDestination})`);
          } else if (node.linkText) {
            this.writePlainText(node.linkText, context);
          }
          break;
        }
        default:
          super.writeNode(docNode, context, docNodeSiblings);
      }
    }
    /** @override */
    emit(stringBuilder, docNode, options) {
      stringBuilder._chunks.length = 0;
      return super.emit(stringBuilder, docNode, options);
    }
  }
  class CustomMarkdownDocumenter extends MarkdownDocumenter.MarkdownDocumenter {
    constructor(options) {
      super(options);
      this._tsdocConfiguration.docNodeManager.registerDocNodes("@backstage/docs", [
        { docNodeKind: DocFrontMatter.kind, constructor: DocFrontMatter }
      ]);
      this._tsdocConfiguration.docNodeManager.registerDocNodes("@backstage/docs", [
        { docNodeKind: DocCodeSpanLink.kind, constructor: DocCodeSpanLink }
      ]);
      this._tsdocConfiguration.docNodeManager.registerAllowableChildren("Paragraph", [
        DocFrontMatter.kind,
        DocCodeSpanLink.kind
      ]);
      const def = {
        tagName: "@config",
        syntaxKind: tsdoc.TSDocTagSyntaxKind.BlockTag,
        tagNameWithUpperCase: "@CONFIG",
        standardization: tsdoc.Standardization.Extended,
        allowMultiple: false
      };
      this._tsdocConfiguration.addTagDefinition(def);
      this._tsdocConfiguration.setSupportForTag(
        def,
        true
      );
      this._markdownEmitter = new CustomCustomMarkdownEmitter(newModel);
    }
    _getFilenameForApiItem(apiItem) {
      const filename = super._getFilenameForApiItem(apiItem);
      if (filename.includes(".html.")) {
        return filename.replace(/\.html\./g, "._html.");
      }
      return filename;
    }
    // We don't really get many chances to modify the generated AST
    // so we hook in wherever we can. In this case we add the front matter
    // just before writing the breadcrumbs at the top.
    /** @override */
    _writeBreadcrumb(output, apiItem) {
      let title;
      let description;
      const name = apiItem.getScopedNameWithinPackage();
      if (name) {
        title = name;
        description = `API reference for ${apiItem.getScopedNameWithinPackage()}`;
      } else if (apiItem.kind === "Model") {
        title = "Package Index";
        description = "Index of all Backstage Packages";
      } else if (apiItem.name) {
        title = apiItem.name;
        description = `API Reference for ${apiItem.name}`;
      } else {
        title = apiItem.displayName;
        description = `API Reference for ${apiItem.displayName}`;
      }
      output.appendNodeInParagraph(
        new DocFrontMatter({
          configuration: this._tsdocConfiguration,
          values: {
            id: this._getFilenameForApiItem(apiItem).slice(0, -3),
            title,
            description
          }
        })
      );
      const configuration = this._tsdocConfiguration;
      output.appendNodeInParagraph(
        new tsdoc.DocLinkTag({
          configuration,
          tagName: "@link",
          linkText: "Home",
          urlDestination: this._getLinkFilenameForApiItem(this._apiModel)
        })
      );
      for (const hierarchyItem of apiItem.getHierarchy()) {
        switch (hierarchyItem.kind) {
          case apiExtractorModel.ApiItemKind.Model:
          case apiExtractorModel.ApiItemKind.EntryPoint:
            break;
          default:
            output.appendNodesInParagraph([
              new tsdoc.DocPlainText({
                configuration,
                text: " > "
              }),
              new DocCodeSpanLink({
                configuration,
                tagName: "@link",
                linkText: hierarchyItem.displayName,
                urlDestination: this._getLinkFilenameForApiItem(hierarchyItem)
              })
            ]);
        }
      }
      const oldAppendNode = output.appendNode;
      output.appendNode = () => {
        output.appendNode = oldAppendNode;
      };
    }
    _writeModelTable(output, apiModel) {
      const configuration = this._tsdocConfiguration;
      const packagesTable = new DocTable.DocTable({
        configuration,
        headerTitles: ["Package", "Description"]
      });
      const pluginsTable = new DocTable.DocTable({
        configuration,
        headerTitles: ["Package", "Description"]
      });
      for (const apiMember of apiModel.members) {
        const row = new DocTableRow.DocTableRow({ configuration }, [
          this._createTitleCell(apiMember),
          this._createDescriptionCell(apiMember)
        ]);
        if (apiMember.kind === "Package") {
          this._writeApiItemPage(apiMember);
          if (apiMember.name.startsWith("@backstage/plugin-")) {
            pluginsTable.addRow(row);
          } else {
            packagesTable.addRow(row);
          }
        }
      }
      if (packagesTable.rows.length > 0) {
        output.appendNode(
          new DocHeading.DocHeading({
            configuration: this._tsdocConfiguration,
            title: "Packages"
          })
        );
        output.appendNode(packagesTable);
      }
      if (pluginsTable.rows.length > 0) {
        output.appendNode(
          new DocHeading.DocHeading({
            configuration: this._tsdocConfiguration,
            title: "Plugins"
          })
        );
        output.appendNode(pluginsTable);
      }
    }
  }
  const documenter = new CustomMarkdownDocumenter({
    apiModel: newModel,
    documenterConfig: {
      outputTarget: "markdown",
      newlineKind: "\n",
      // De ba dålig kod
      configFilePath: "",
      configFile: {}
    },
    outputFolder: outputDir
  });
  await fs__default["default"].remove(outputDir);
  await fs__default["default"].ensureDir(outputDir);
  documenter.generateFiles();
}
async function categorizePackageDirs(packageDirs) {
  const dirs = packageDirs.slice();
  const tsPackageDirs = new Array();
  const cliPackageDirs = new Array();
  await Promise.all(
    Array(10).fill(0).map(async () => {
      var _a;
      for (; ; ) {
        const dir = dirs.pop();
        if (!dir) {
          return;
        }
        const pkgJson = await fs__default["default"].readJson(paths.paths.resolveTargetRoot(dir, "package.json")).catch((error) => {
          if (error.code === "ENOENT") {
            return void 0;
          }
          throw error;
        });
        const role = (_a = pkgJson == null ? void 0 : pkgJson.backstage) == null ? void 0 : _a.role;
        if (!role) {
          return;
        }
        if (role === "cli") {
          cliPackageDirs.push(dir);
        } else if (role !== "frontend" && role !== "backend") {
          tsPackageDirs.push(dir);
        }
      }
    })
  );
  return { tsPackageDirs, cliPackageDirs };
}
function parseHelpPage(helpPageContent) {
  var _a;
  const [, usage] = (_a = helpPageContent.match(/^\s*Usage: (.*)$/im)) != null ? _a : [];
  const lines = helpPageContent.split(/\r?\n/);
  let options = new Array();
  let commands = new Array();
  let commandArguments = new Array();
  while (lines.length > 0) {
    while (lines.length > 0 && !lines[0].endsWith(":")) {
      lines.shift();
    }
    if (lines.length > 0) {
      const sectionName = lines.shift();
      const sectionEndIndex = lines.findIndex(
        (line) => line && !line.match(/^\s/)
      );
      const sectionLines = lines.slice(0, sectionEndIndex);
      lines.splice(0, sectionLines.length);
      const sectionItems = sectionLines.map((line) => {
        var _a2;
        return (_a2 = line.match(/^\s{1,8}(.*?)\s\s+/)) == null ? void 0 : _a2[1];
      }).filter(Boolean);
      if ((sectionName == null ? void 0 : sectionName.toLocaleLowerCase("en-US")) === "options:") {
        options = sectionItems;
      } else if ((sectionName == null ? void 0 : sectionName.toLocaleLowerCase("en-US")) === "commands:") {
        commands = sectionItems;
      } else if ((sectionName == null ? void 0 : sectionName.toLocaleLowerCase("en-US")) === "arguments:") {
        commandArguments = sectionItems;
      } else {
        throw new Error(`Unknown CLI section: ${sectionName}`);
      }
    }
  }
  return {
    usage,
    options,
    commands,
    commandArguments
  };
}
async function exploreCliHelpPages(run) {
  const helpPages = new Array();
  async function exploreHelpPage(...path) {
    const content = await run(...path, "--help");
    const parsed = parseHelpPage(content);
    helpPages.push({ path, ...parsed });
    await Promise.all(
      parsed.commands.map(async (fullCommand) => {
        const command = fullCommand.split(/[|\s]/)[0];
        if (command !== "help") {
          await exploreHelpPage(...path, command);
        }
      })
    );
  }
  await exploreHelpPage();
  helpPages.sort((a, b) => a.path.join(" ").localeCompare(b.path.join(" ")));
  return helpPages;
}
function generateCliReport(name, models) {
  var _a;
  const content = [
    `## CLI Report file for "${name}"`,
    "",
    "> Do not edit this file. It is a report generated by `yarn build:api-reports`",
    ""
  ];
  for (const model of models) {
    for (const helpPage of model.helpPages) {
      content.push(
        `### \`${[model.name, ...helpPage.path].join(" ")}\``,
        "",
        "```",
        `Usage: ${(_a = helpPage.usage) != null ? _a : "<none>"}`
      );
      if (helpPage.options.length > 0) {
        content.push("", "Options:", ...helpPage.options.map((l) => `  ${l}`));
      }
      if (helpPage.commands.length > 0) {
        content.push("", "Commands:", ...helpPage.commands.map((l) => `  ${l}`));
      }
      content.push("```", "");
    }
  }
  return content.join("\n");
}
async function runCliExtraction({
  packageDirs,
  isLocalBuild
}) {
  for (const packageDir of packageDirs) {
    console.log(`## Processing ${packageDir}`);
    const fullDir = paths.paths.resolveTargetRoot(packageDir);
    const pkgJson = await fs__default["default"].readJson(path.resolve(fullDir, "package.json"));
    if (!pkgJson.bin) {
      throw new Error(`CLI Package in ${packageDir} has no bin field`);
    }
    const models = new Array();
    if (typeof pkgJson.bin === "string") {
      const run = util.createBinRunner(fullDir, pkgJson.bin);
      const helpPages = await exploreCliHelpPages(run);
      models.push({ name: path.basename(pkgJson.bin), helpPages });
    } else {
      for (const [name, path] of Object.entries(pkgJson.bin)) {
        const run = util.createBinRunner(fullDir, path);
        const helpPages = await exploreCliHelpPages(run);
        models.push({ name, helpPages });
      }
    }
    const report = generateCliReport(pkgJson.name, models);
    const reportPath = path.resolve(fullDir, "cli-report.md");
    const existingReport = await fs__default["default"].readFile(reportPath, "utf8").catch((error) => {
      if (error.code === "ENOENT") {
        return void 0;
      }
      throw error;
    });
    if (existingReport !== report) {
      if (isLocalBuild) {
        console.warn(`CLI report changed for ${packageDir}`);
        await fs__default["default"].writeFile(reportPath, report);
      } else {
        logApiReportInstructions();
        if (existingReport) {
          console.log("");
          console.log(
            `The conflicting file is ${path.relative(
              paths.paths.targetRoot,
              reportPath
            )}, expecting the following content:`
          );
          console.log("");
          console.log(report);
          logApiReportInstructions();
        }
        throw new Error(`CLI report changed for ${packageDir}, `);
      }
    }
  }
}

async function generateTypeDeclarations(tsconfigFilePath) {
  await fs__default["default"].remove(paths.paths.resolveTargetRoot("dist-types"));
  const { status } = child_process.spawnSync(
    "yarn",
    [
      "tsc",
      ["--project", tsconfigFilePath],
      ["--skipLibCheck", "false"],
      ["--incremental", "false"]
    ].flat(),
    {
      stdio: "inherit",
      shell: true,
      cwd: paths.paths.targetRoot
    }
  );
  if (status !== 0) {
    process.exit(status || void 0);
  }
}

const buildApiReports = async (paths$1 = [], opts) => {
  const tmpDir = paths.paths.resolveTargetRoot(
    "./node_modules/.cache/api-extractor"
  );
  const isCiBuild = opts.ci;
  const isDocsBuild = opts.docs;
  const runTsc = opts.tsc;
  const allowWarnings = parseArrayOption(opts.allowWarnings);
  const allowAllWarnings = opts.allowAllWarnings;
  const omitMessages = parseArrayOption(opts.omitMessages);
  const isAllPackages = !(paths$1 == null ? void 0 : paths$1.length);
  const selectedPackageDirs = await paths.resolvePackagePaths({
    paths: paths$1,
    include: opts.include,
    exclude: opts.exclude
  });
  if (isAllPackages && !isCiBuild && !isDocsBuild) {
    console.log("");
    console.log(
      "TIP: You can generate api-reports for select packages by passing package paths:"
    );
    console.log("");
    console.log(
      "       yarn build:api-reports packages/config packages/core-plugin-api plugins/*"
    );
    console.log("");
  }
  let temporaryTsConfigPath;
  if (!isAllPackages) {
    temporaryTsConfigPath = await createTemporaryTsConfig(selectedPackageDirs);
  }
  const tsconfigFilePath = temporaryTsConfigPath != null ? temporaryTsConfigPath : paths.paths.resolveTargetRoot("tsconfig.json");
  if (runTsc) {
    console.log("# Compiling TypeScript");
    await generateTypeDeclarations(tsconfigFilePath);
  }
  const { tsPackageDirs, cliPackageDirs } = await categorizePackageDirs(
    selectedPackageDirs
  );
  if (tsPackageDirs.length > 0) {
    console.log("# Generating package API reports");
    await runApiExtraction({
      packageDirs: tsPackageDirs,
      outputDir: tmpDir,
      isLocalBuild: !isCiBuild,
      tsconfigFilePath,
      allowWarnings: allowAllWarnings || allowWarnings,
      omitMessages: Array.isArray(omitMessages) ? omitMessages : [],
      validateReleaseTags: opts.validateReleaseTags
    });
  }
  if (cliPackageDirs.length > 0) {
    console.log("# Generating package CLI reports");
    await runCliExtraction({
      packageDirs: cliPackageDirs,
      isLocalBuild: !isCiBuild
    });
  }
  if (isDocsBuild) {
    console.log("# Generating package documentation");
    await buildDocs({
      inputDir: tmpDir,
      outputDir: paths.paths.resolveTargetRoot("docs/reference")
    });
  }
};
function parseArrayOption(value) {
  return value ? value.split(",").map((s) => s.trim()) : [];
}

exports.buildApiReports = buildApiReports;
//# sourceMappingURL=api-reports-4f93d814.cjs.js.map
