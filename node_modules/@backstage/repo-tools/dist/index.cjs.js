'use strict';

var commander = require('commander');
var chalk = require('chalk');
var errors = require('@backstage/errors');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var chalk__default = /*#__PURE__*/_interopDefaultLegacy(chalk);

var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
class CustomError extends Error {
  get name() {
    return this.constructor.name;
  }
}
class ExitCodeError extends CustomError {
  constructor(code, command) {
    super(
      command ? `Command '${command}' exited with code ${code}` : `Child exited with code ${code}`
    );
    __publicField(this, "code");
    this.code = code;
  }
}
function exitWithError(error) {
  if (error instanceof ExitCodeError) {
    process.stderr.write(`
${chalk__default["default"].red(error.message)}

`);
    process.exit(error.code);
  } else {
    process.stderr.write(`
${chalk__default["default"].red(`${error}`)}

`);
    process.exit(1);
  }
}

function registerPackageCommand(program) {
  const command = program.command("package [command]").description("Various tools for working with specific packages.");
  const schemaCommand = command.command("schema [command]").description(
    "Various tools for working with specific packages' API schema"
  );
  const openApiCommand = schemaCommand.command("openapi [command]").description("Tooling for OpenAPI schema");
  openApiCommand.command("init").description(
    "Initialize any required files to use the OpenAPI tooling for this package."
  ).action(
    lazy(
      () => Promise.resolve().then(function () { return require('./cjs/init-3d29e55d.cjs.js'); }).then((m) => m.singleCommand)
    )
  );
  openApiCommand.command("generate").option(
    "--client-package [package]",
    "Top-level path to where the client should be generated, ie packages/catalog-client."
  ).option("--server").description(
    "Command to generate a client and/or a server stub from an OpenAPI spec."
  ).action(
    lazy(
      () => Promise.resolve().then(function () { return require('./cjs/index-c6ffc4f4.cjs.js'); }).then((m) => m.command)
    )
  );
}
function registerRepoCommand(program) {
  const command = program.command("repo [command]").description("Tools for working across your entire repository.");
  const schemaCommand = command.command("schema [command]").description("Various tools for working with API schema");
  const openApiCommand = schemaCommand.command("openapi [command]").description("Tooling for OpenApi schema");
  openApiCommand.command("verify [paths...]").description(
    "Verify that all OpenAPI schemas are valid and have a matching `schemas/openapi.generated.ts` file."
  ).action(
    lazy(
      () => Promise.resolve().then(function () { return require('./cjs/verify-dad6101f.cjs.js'); }).then((m) => m.bulkCommand)
    )
  );
  openApiCommand.command("lint [paths...]").description("Lint OpenAPI schemas.").option(
    "--strict",
    "Fail on any linting severity messages, not just errors."
  ).action(
    lazy(() => Promise.resolve().then(function () { return require('./cjs/lint-5433166f.cjs.js'); }).then((m) => m.bulkCommand))
  );
  openApiCommand.command("test [paths...]").description("Test OpenAPI schemas against written tests").option("--update", "Update the spec on failure.").action(
    lazy(() => Promise.resolve().then(function () { return require('./cjs/test-df73bb76.cjs.js'); }).then((m) => m.bulkCommand))
  );
}
function registerCommands(program) {
  program.command("api-reports [paths...]").option("--ci", "CI run checks that there is no changes on API reports").option("--tsc", "executes the tsc compilation before extracting the APIs").option("--docs", "generates the api documentation").option(
    "--include <pattern>",
    "Only include packages matching the provided patterns",
    (opt, opts = []) => [...opts, ...opt.split(",")]
  ).option(
    "--exclude <pattern>",
    "Exclude package matching the provided patterns",
    (opt, opts = []) => [...opts, ...opt.split(",")]
  ).option(
    "-a, --allow-warnings <allowWarningsPaths>",
    "continue processing packages after getting errors on selected packages Allows glob patterns and comma separated values (i.e. packages/core,plugins/core-*)"
  ).option(
    "--allow-all-warnings",
    "continue processing packages after getting errors on all packages",
    false
  ).option(
    "-o, --omit-messages <messageCodes>",
    "select some message code to be omited on the API Extractor (comma separated values i.e ae-cyclic-inherit-doc,ae-missing-getter )"
  ).option(
    "--validate-release-tags",
    "Turn on release tag validation for the public, beta, and alpha APIs"
  ).description("Generate an API report for selected packages").action(
    lazy(
      () => Promise.resolve().then(function () { return require('./cjs/api-reports-4f93d814.cjs.js'); }).then((m) => m.buildApiReports)
    )
  );
  program.command("type-deps").description("Find inconsistencies in types of all packages and plugins").action(lazy(() => Promise.resolve().then(function () { return require('./cjs/type-deps-5eacd931.cjs.js'); }).then((m) => m.default)));
  program.command("generate-catalog-info").option(
    "--dry-run",
    "Shows what would happen without actually writing any yaml."
  ).option(
    "--ci",
    "CI run checks that there are no changes to catalog-info.yaml files"
  ).description("Create or fix info yaml files for all backstage packages").action(
    lazy(
      () => Promise.resolve().then(function () { return require('./cjs/generate-catalog-info-e7071c1c.cjs.js'); }).then(
        (m) => m.default
      )
    )
  );
  program.command("knip-reports [paths...]").option("--ci", "CI run checks that there is no changes on knip reports").description("Generate a knip report for selected packages").action(
    lazy(
      () => Promise.resolve().then(function () { return require('./cjs/knip-reports-7309d5ae.cjs.js'); }).then((m) => m.buildKnipReports)
    )
  );
  registerPackageCommand(program);
  registerRepoCommand(program);
}
function lazy(getActionFunc) {
  return async (...args) => {
    try {
      const actionFunc = await getActionFunc();
      await actionFunc(...args);
      process.exit(0);
    } catch (error) {
      errors.assertError(error);
      exitWithError(error);
    }
  };
}

var version = "0.6.3";

const main = (argv) => {
  commander.program.name("backstage-repo-tools").version(version);
  registerCommands(commander.program);
  commander.program.on("command:*", () => {
    console.log();
    console.log(chalk__default["default"].red(`Invalid command: ${commander.program.args.join(" ")}`));
    console.log();
    commander.program.outputHelp();
    process.exit(1);
  });
  commander.program.parse(argv);
};
process.on("unhandledRejection", (rejection) => {
  if (rejection instanceof Error) {
    exitWithError(rejection);
  } else {
    exitWithError(new Error(`Unknown rejection: '${rejection}'`));
  }
});
main(process.argv);
//# sourceMappingURL=index.cjs.js.map
