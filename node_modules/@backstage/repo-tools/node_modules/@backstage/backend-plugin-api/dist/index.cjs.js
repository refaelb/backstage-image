'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function createServiceRef(config) {
  const { id, scope = "plugin", defaultFactory } = config;
  return {
    id,
    scope,
    get T() {
      throw new Error(`tried to read ServiceRef.T of ${this}`);
    },
    toString() {
      return `serviceRef{${config.id}}`;
    },
    $$type: "@backstage/ServiceRef",
    __defaultFactory: defaultFactory
  };
}
function createServiceFactory(config) {
  const configCallback = typeof config === "function" ? config : () => config;
  const factory = (options) => {
    const anyConf = configCallback(options);
    if (anyConf.service.scope === "root") {
      const c2 = anyConf;
      return {
        $$type: "@backstage/BackendFeature",
        version: "v1",
        service: c2.service,
        deps: c2.deps,
        factory: async (deps) => c2.factory(deps)
      };
    }
    const c = anyConf;
    return {
      $$type: "@backstage/BackendFeature",
      version: "v1",
      service: c.service,
      ..."createRootContext" in c ? {
        createRootContext: async (deps) => {
          var _a;
          return (_a = c == null ? void 0 : c.createRootContext) == null ? void 0 : _a.call(c, deps);
        }
      } : {},
      deps: c.deps,
      factory: async (deps, ctx) => c.factory(deps, ctx)
    };
  };
  factory.$$type = "@backstage/BackendFeatureFactory";
  return factory;
}

exports.coreServices = void 0;
((coreServices2) => {
  coreServices2.cache = createServiceRef({
    id: "core.cache"
  });
  coreServices2.rootConfig = createServiceRef({ id: "core.rootConfig", scope: "root" });
  coreServices2.database = createServiceRef({ id: "core.database" });
  coreServices2.discovery = createServiceRef({ id: "core.discovery" });
  coreServices2.httpRouter = createServiceRef({ id: "core.httpRouter" });
  coreServices2.lifecycle = createServiceRef({ id: "core.lifecycle" });
  coreServices2.logger = createServiceRef({ id: "core.logger" });
  coreServices2.permissions = createServiceRef({ id: "core.permissions" });
  coreServices2.pluginMetadata = createServiceRef({ id: "core.pluginMetadata" });
  coreServices2.rootHttpRouter = createServiceRef({ id: "core.rootHttpRouter", scope: "root" });
  coreServices2.rootLifecycle = createServiceRef({ id: "core.rootLifecycle", scope: "root" });
  coreServices2.rootLogger = createServiceRef({ id: "core.rootLogger", scope: "root" });
  coreServices2.scheduler = createServiceRef({ id: "core.scheduler" });
  coreServices2.tokenManager = createServiceRef({ id: "core.tokenManager" });
  coreServices2.urlReader = createServiceRef({ id: "core.urlReader" });
  coreServices2.identity = createServiceRef({ id: "core.identity" });
})(exports.coreServices || (exports.coreServices = {}));

function createExtensionPoint(config) {
  return {
    id: config.id,
    get T() {
      throw new Error(`tried to read ExtensionPoint.T of ${this}`);
    },
    toString() {
      return `extensionPoint{${config.id}}`;
    },
    $$type: "@backstage/ExtensionPoint"
  };
}
function createBackendPlugin(config) {
  const factory = () => {
    let registrations;
    return {
      $$type: "@backstage/BackendFeature",
      version: "v1",
      getRegistrations() {
        if (registrations) {
          return registrations;
        }
        const extensionPoints = [];
        let init = void 0;
        config.register({
          registerExtensionPoint(ext, impl) {
            if (init) {
              throw new Error(
                "registerExtensionPoint called after registerInit"
              );
            }
            extensionPoints.push([ext, impl]);
          },
          registerInit(regInit) {
            if (init) {
              throw new Error("registerInit must only be called once");
            }
            init = {
              deps: regInit.deps,
              func: regInit.init
            };
          }
        });
        if (!init) {
          throw new Error(
            `registerInit was not called by register in ${config.pluginId}`
          );
        }
        registrations = [
          {
            type: "plugin",
            pluginId: config.pluginId,
            extensionPoints,
            init
          }
        ];
        return registrations;
      }
    };
  };
  factory.$$type = "@backstage/BackendFeatureFactory";
  return factory;
}
function createBackendModule(config) {
  const factory = () => {
    let registrations;
    return {
      $$type: "@backstage/BackendFeature",
      version: "v1",
      getRegistrations() {
        if (registrations) {
          return registrations;
        }
        const extensionPoints = [];
        let init = void 0;
        config.register({
          registerExtensionPoint(ext, impl) {
            if (init) {
              throw new Error(
                "registerExtensionPoint called after registerInit"
              );
            }
            extensionPoints.push([ext, impl]);
          },
          registerInit(regInit) {
            if (init) {
              throw new Error("registerInit must only be called once");
            }
            init = {
              deps: regInit.deps,
              func: regInit.init
            };
          }
        });
        if (!init) {
          throw new Error(
            `registerInit was not called by register in ${config.moduleId} module for ${config.pluginId}`
          );
        }
        registrations = [
          {
            type: "module",
            pluginId: config.pluginId,
            moduleId: config.moduleId,
            extensionPoints,
            init
          }
        ];
        return registrations;
      }
    };
  };
  factory.$$type = "@backstage/BackendFeatureFactory";
  return factory;
}

exports.createBackendModule = createBackendModule;
exports.createBackendPlugin = createBackendPlugin;
exports.createExtensionPoint = createExtensionPoint;
exports.createServiceFactory = createServiceFactory;
exports.createServiceRef = createServiceRef;
//# sourceMappingURL=index.cjs.js.map
