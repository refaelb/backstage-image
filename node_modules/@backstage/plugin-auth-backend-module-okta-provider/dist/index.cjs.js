'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var passportOktaOauth = require('@davidzemon/passport-okta-oauth');
var pluginAuthNode = require('@backstage/plugin-auth-node');
var backendPluginApi = require('@backstage/backend-plugin-api');

const oktaAuthenticator = pluginAuthNode.createOAuthAuthenticator({
  defaultProfileTransform: pluginAuthNode.PassportOAuthAuthenticatorHelper.defaultProfileTransform,
  initialize({ callbackUrl, config }) {
    const clientId = config.getString("clientId");
    const clientSecret = config.getString("clientSecret");
    const audience = config.getOptionalString("audience") || "https://okta.com";
    const authServerId = config.getOptionalString("authServerId");
    const idp = config.getOptionalString("idp");
    const defaultScopes = "openid profile email";
    const additionalScopes = config.getOptionalString("additionalScopes") || "";
    const combineScopeStrings = (scopesA, scopesB) => {
      const scopesAArray = scopesA.split(" ");
      const scopesBArray = scopesB.split(" ");
      const combinedScopes = /* @__PURE__ */ new Set([...scopesAArray, ...scopesBArray]);
      return Array.from(combinedScopes).join(" ");
    };
    const scope = combineScopeStrings(defaultScopes, additionalScopes);
    return pluginAuthNode.PassportOAuthAuthenticatorHelper.from(
      new passportOktaOauth.Strategy(
        {
          clientID: clientId,
          clientSecret,
          callbackURL: callbackUrl,
          audience,
          authServerID: authServerId,
          idp,
          passReqToCallback: false,
          response_type: "code",
          scope
        },
        (accessToken, refreshToken, params, fullProfile, done) => {
          done(
            void 0,
            { fullProfile, params, accessToken },
            { refreshToken }
          );
        }
      )
    );
  },
  async start(input, helper) {
    return helper.start(input, {
      accessType: "offline",
      prompt: "consent"
    });
  },
  async authenticate(input, helper) {
    return helper.authenticate(input);
  },
  async refresh(input, helper) {
    return helper.refresh(input);
  }
});

exports.oktaSignInResolvers = void 0;
((oktaSignInResolvers2) => {
  oktaSignInResolvers2.emailMatchingUserEntityAnnotation = pluginAuthNode.createSignInResolverFactory({
    create() {
      return async (info, ctx) => {
        const { profile } = info;
        if (!profile.email) {
          throw new Error("Okta profile contained no email");
        }
        return ctx.signInWithCatalogUser({
          annotations: {
            "okta.com/email": profile.email
          }
        });
      };
    }
  });
})(exports.oktaSignInResolvers || (exports.oktaSignInResolvers = {}));

const authModuleOktaProvider = backendPluginApi.createBackendModule({
  pluginId: "auth",
  moduleId: "okta-provider",
  register(reg) {
    reg.registerInit({
      deps: {
        providers: pluginAuthNode.authProvidersExtensionPoint
      },
      async init({ providers }) {
        providers.registerProvider({
          providerId: "okta",
          factory: pluginAuthNode.createOAuthProviderFactory({
            authenticator: oktaAuthenticator,
            signInResolverFactories: {
              ...exports.oktaSignInResolvers,
              ...pluginAuthNode.commonSignInResolvers
            }
          })
        });
      }
    });
  }
});

exports["default"] = authModuleOktaProvider;
exports.oktaAuthenticator = oktaAuthenticator;
//# sourceMappingURL=index.cjs.js.map
