export { CATALOG_FILTER_EXISTS } from '@backstage/catalog-client';
import { createApiRef, useApiHolder, useApi, identityApiRef, alertApiRef, createRouteRef, useRouteRef, useApp, configApiRef } from '@backstage/core-plugin-api';
import { stringifyEntityRef, DEFAULT_NAMESPACE, ANNOTATION_SOURCE_LOCATION, parseLocationRef, parseEntityRef, RELATION_OWNED_BY, getCompoundEntityRef, isUserEntity, isGroupEntity, RELATION_PART_OF, ANNOTATION_LOCATION, ANNOTATION_ORIGIN_LOCATION } from '@backstage/catalog-model';
import get from 'lodash/get';
import React, { useState, useEffect, useMemo, createContext, useCallback, useContext, useRef, memo, forwardRef, useLayoutEffect, Fragment } from 'react';
import ObservableImpl from 'zen-observable';
import { Grid, useMediaQuery, useTheme, Button, Drawer, Box, Typography, FormControlLabel, Checkbox, makeStyles, TextField, Tooltip, IconButton, Card, CardContent, Chip, CardActions, Toolbar, FormControl, Input, InputAdornment, withStyles, DialogContentText, ListItemText as ListItemText$1, ListSubheader as ListSubheader$1, ListItem, ListItemIcon, List, ListItemSecondaryAction, Dialog, DialogTitle, DialogContent, Tabs, Tab, DialogActions, Divider, MenuItem } from '@material-ui/core';
import FilterListIcon from '@material-ui/icons/FilterList';
import { Select, Link, ResponseErrorPanel, Progress, OverflowTooltip, Table, DependencyGraph, DependencyGraphTypes, CodeSnippet, CopyTextButton, EmptyState } from '@backstage/core-components';
import { g as getEntityRelations, u as useEntity } from './esm/useEntity-de64059a.esm.js';
export { A as AsyncEntityProvider, E as EntityProvider, g as getEntityRelations, a as useAsyncEntity, u as useEntity } from './esm/useEntity-de64059a.esm.js';
import { compact, isEqual, debounce, intersection } from 'lodash';
import qs from 'qs';
import { useLocation, useNavigate } from 'react-router-dom';
import useAsyncFn from 'react-use/lib/useAsyncFn';
import useDebounce from 'react-use/lib/useDebounce';
import useMountedState from 'react-use/lib/useMountedState';
import useAsync from 'react-use/lib/useAsync';
import isEqual$1 from 'lodash/isEqual';
import sortBy from 'lodash/sortBy';
import useObservable from 'react-use/lib/useObservable';
import ExpandMoreIcon from '@material-ui/icons/ExpandMore';
import { Autocomplete, Alert } from '@material-ui/lab';
import CheckBoxIcon from '@material-ui/icons/CheckBox';
import CheckBoxOutlineBlankIcon from '@material-ui/icons/CheckBoxOutlineBlank';
import classNames from 'classnames';
import { useMountEffect, useDebouncedEffect } from '@react-hookz/web';
import PersonIcon from '@material-ui/icons/Person';
import GroupIcon from '@material-ui/icons/Group';
import { getOrCreateGlobalSingleton } from '@backstage/version-bridge';
import HoverPopover from 'material-ui-popup-state/HoverPopover';
import { usePopupState, bindHover, bindPopover } from 'material-ui-popup-state/hooks';
import InfoIcon from '@material-ui/icons/Info';
import EmailIcon from '@material-ui/icons/Email';
import Clear from '@material-ui/icons/Clear';
import Search from '@material-ui/icons/Search';
import Star from '@material-ui/icons/Star';
import StarBorder from '@material-ui/icons/StarBorder';
import WorkIcon from '@material-ui/icons/Work';
import HelpOutlineIcon from '@material-ui/icons/HelpOutline';
import groupBy from 'lodash/groupBy';
import DialogContentText$1 from '@material-ui/core/DialogContentText';
import YAML from 'yaml';
import Alert$1 from '@material-ui/lab/Alert';
import { assertError } from '@backstage/errors';
import SettingsIcon from '@material-ui/icons/Settings';
import useDeepCompareEffect from 'react-use/lib/useDeepCompareEffect';
import Box$1 from '@material-ui/core/Box';
import Button$1 from '@material-ui/core/Button';
import { makeStyles as makeStyles$1 } from '@material-ui/core/styles';
import Typography$1 from '@material-ui/core/Typography';

const catalogApiRef = createApiRef({
  id: "plugin.catalog.service"
});

const entityPresentationApiRef = createApiRef({
  id: "plugin.catalog.entity-presentation"
});

function defaultEntityPresentation(entityOrRef, context) {
  const { kind, namespace, name, title, description, displayName, type } = getParts(entityOrRef);
  const entityRef = stringifyEntityRef({
    kind: kind || "unknown",
    namespace: namespace || DEFAULT_NAMESPACE,
    name: name || "unknown"
  });
  const shortRef = getShortRef({ kind, namespace, name, context });
  const primary = [displayName, title, shortRef].find(
    (candidate) => candidate && typeof candidate === "string"
  );
  const secondary = [
    primary !== entityRef ? entityRef : void 0,
    type,
    description
  ].filter((candidate) => candidate && typeof candidate === "string").join(" | ");
  return {
    entityRef,
    primaryTitle: primary,
    secondaryTitle: secondary || void 0,
    Icon: void 0
    // leave it up to the presentation API to handle
  };
}
function getParts(entityOrRef) {
  if (typeof entityOrRef === "string") {
    let colonI = entityOrRef.indexOf(":");
    const slashI = entityOrRef.indexOf("/");
    if (slashI !== -1 && slashI < colonI) {
      colonI = -1;
    }
    const kind = colonI === -1 ? void 0 : entityOrRef.slice(0, colonI);
    const namespace = slashI === -1 ? void 0 : entityOrRef.slice(colonI + 1, slashI);
    const name = entityOrRef.slice(Math.max(colonI + 1, slashI + 1));
    return { kind, namespace, name };
  }
  if (typeof entityOrRef === "object" && entityOrRef !== null) {
    const kind = [get(entityOrRef, "kind")].find(
      (candidate) => candidate && typeof candidate === "string"
    );
    const namespace = [
      get(entityOrRef, "metadata.namespace"),
      get(entityOrRef, "namespace")
    ].find((candidate) => candidate && typeof candidate === "string");
    const name = [
      get(entityOrRef, "metadata.name"),
      get(entityOrRef, "name")
    ].find((candidate) => candidate && typeof candidate === "string");
    const title = [get(entityOrRef, "metadata.title")].find(
      (candidate) => candidate && typeof candidate === "string"
    );
    const description = [get(entityOrRef, "metadata.description")].find(
      (candidate) => candidate && typeof candidate === "string"
    );
    const displayName = [get(entityOrRef, "spec.profile.displayName")].find(
      (candidate) => candidate && typeof candidate === "string"
    );
    const type = [get(entityOrRef, "spec.type")].find(
      (candidate) => candidate && typeof candidate === "string"
    );
    return { kind, namespace, name, title, description, displayName, type };
  }
  return {};
}
function getShortRef(options) {
  var _a, _b, _c, _d, _e;
  const kind = ((_a = options.kind) == null ? void 0 : _a.toLocaleLowerCase("en-US")) || "unknown";
  const namespace = options.namespace || DEFAULT_NAMESPACE;
  const name = options.name || "unknown";
  const defaultKindLower = (_c = (_b = options.context) == null ? void 0 : _b.defaultKind) == null ? void 0 : _c.toLocaleLowerCase("en-US");
  const defaultNamespaceLower = (_e = (_d = options.context) == null ? void 0 : _d.defaultNamespace) == null ? void 0 : _e.toLocaleLowerCase("en-US");
  let result = name;
  if (defaultNamespaceLower && namespace.toLocaleLowerCase("en-US") !== defaultNamespaceLower || namespace !== DEFAULT_NAMESPACE) {
    result = `${namespace}/${result}`;
  }
  if (defaultKindLower && kind.toLocaleLowerCase("en-US") !== defaultKindLower) {
    result = `${kind}:${result}`;
  }
  return result;
}

function useUpdatingObservable(value, observable, deps) {
  const [snapshot, setSnapshot] = useState(value);
  useEffect(() => {
    setSnapshot(value);
    const subscription = observable == null ? void 0 : observable.subscribe({
      next: (updatedValue) => {
        setSnapshot(updatedValue);
      },
      complete: () => {
        subscription == null ? void 0 : subscription.unsubscribe();
      }
    });
    return () => {
      subscription == null ? void 0 : subscription.unsubscribe();
    };
  }, deps);
  return snapshot;
}

function useEntityPresentation(entityOrRef, context) {
  const apis = useApiHolder();
  const entityPresentationApi = apis.get(entityPresentationApiRef);
  const deps = [
    entityPresentationApi,
    JSON.stringify(entityOrRef),
    JSON.stringify(context || null)
  ];
  const presentation = useMemo(
    () => {
      if (!entityPresentationApi) {
        return { snapshot: defaultEntityPresentation(entityOrRef, context) };
      }
      return entityPresentationApi.forEntity(
        typeof entityOrRef === "string" || "metadata" in entityOrRef ? entityOrRef : stringifyEntityRef(entityOrRef),
        context
      );
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    deps
  );
  return useUpdatingObservable(presentation.snapshot, presentation.update$, [
    presentation
  ]);
}

const starredEntitiesApiRef = createApiRef({
  id: "catalog-react.starred-entities"
});

var __defProp$1 = Object.defineProperty;
var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$1 = (obj, key, value) => {
  __defNormalProp$1(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
class MockStarredEntitiesApi {
  constructor() {
    __publicField$1(this, "starredEntities", /* @__PURE__ */ new Set());
    __publicField$1(this, "subscribers", /* @__PURE__ */ new Set());
    __publicField$1(this, "observable", new ObservableImpl((subscriber) => {
      subscriber.next(new Set(this.starredEntities));
      this.subscribers.add(subscriber);
      return () => {
        this.subscribers.delete(subscriber);
      };
    }));
  }
  async toggleStarred(entityRef) {
    if (!this.starredEntities.delete(entityRef)) {
      this.starredEntities.add(entityRef);
    }
    for (const subscription of this.subscribers) {
      subscription.next(new Set(this.starredEntities));
    }
  }
  starredEntitie$() {
    return this.observable;
  }
}

const Filters = (props) => {
  var _a, _b;
  const isScreenSmallerThanBreakpoint = useMediaQuery(
    (theme2) => {
      var _a2, _b2;
      return theme2.breakpoints.down((_b2 = (_a2 = props.options) == null ? void 0 : _a2.drawerBreakpoint) != null ? _b2 : "md");
    }
  );
  const theme = useTheme();
  const [filterDrawerOpen, setFilterDrawerOpen] = useState(false);
  return isScreenSmallerThanBreakpoint ? /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(
    Button,
    {
      style: { marginTop: theme.spacing(1), marginLeft: theme.spacing(1) },
      onClick: () => setFilterDrawerOpen(true),
      startIcon: /* @__PURE__ */ React.createElement(FilterListIcon, null)
    },
    "Filters"
  ), /* @__PURE__ */ React.createElement(
    Drawer,
    {
      open: filterDrawerOpen,
      onClose: () => setFilterDrawerOpen(false),
      anchor: (_b = (_a = props.options) == null ? void 0 : _a.drawerAnchor) != null ? _b : "left",
      disableAutoFocus: true,
      keepMounted: true,
      variant: "temporary"
    },
    /* @__PURE__ */ React.createElement(Box, { m: 2 }, /* @__PURE__ */ React.createElement(
      Typography,
      {
        variant: "h6",
        component: "h2",
        style: { marginBottom: theme.spacing(1) }
      },
      "Filters"
    ), props.children)
  )) : /* @__PURE__ */ React.createElement(Grid, { item: true, lg: 2 }, props.children);
};
const Content = (props) => {
  return /* @__PURE__ */ React.createElement(Grid, { item: true, xs: 12, lg: 10 }, props.children);
};
const CatalogFilterLayout = (props) => {
  return /* @__PURE__ */ React.createElement(Grid, { container: true, style: { position: "relative" } }, props.children);
};
CatalogFilterLayout.Filters = Filters;
CatalogFilterLayout.Content = Content;

function reduceCatalogFilters(filters) {
  return filters.reduce((compoundFilter, filter) => {
    return {
      ...compoundFilter,
      ...filter.getCatalogFilters ? filter.getCatalogFilters() : {}
    };
  }, {});
}
function reduceBackendCatalogFilters(filters) {
  const backendCatalogFilters = {};
  filters.forEach((filter) => {
    var _a;
    if (filter instanceof EntityTagFilter || filter instanceof EntityOwnerFilter || filter instanceof EntityLifecycleFilter || filter instanceof EntityNamespaceFilter || filter instanceof EntityUserFilter || filter instanceof EntityOrphanFilter || filter instanceof EntityTextFilter || filter instanceof UserListFilter) {
      return;
    }
    Object.assign(backendCatalogFilters, ((_a = filter.getCatalogFilters) == null ? void 0 : _a.call(filter)) || {});
  });
  return backendCatalogFilters;
}
function reduceEntityFilters(filters) {
  return (entity) => filters.every(
    (filter) => !filter.filterEntity || filter.filterEntity(entity)
  );
}

function getEntitySourceLocation(entity, scmIntegrationsApi) {
  var _a;
  const sourceLocation = (_a = entity.metadata.annotations) == null ? void 0 : _a[ANNOTATION_SOURCE_LOCATION];
  if (!sourceLocation) {
    return void 0;
  }
  try {
    const sourceLocationRef = parseLocationRef(sourceLocation);
    const integration = scmIntegrationsApi.byUrl(sourceLocationRef.target);
    return {
      locationTargetUrl: sourceLocationRef.target,
      integrationType: integration == null ? void 0 : integration.type
    };
  } catch {
    return void 0;
  }
}

var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
class EntityKindFilter {
  constructor(value) {
    this.value = value;
  }
  getCatalogFilters() {
    return { kind: this.value };
  }
  toQueryValue() {
    return this.value;
  }
}
class EntityTypeFilter {
  constructor(value) {
    this.value = value;
  }
  // Simplify `string | string[]` for consumers, always returns an array
  getTypes() {
    return Array.isArray(this.value) ? this.value : [this.value];
  }
  getCatalogFilters() {
    return { "spec.type": this.getTypes() };
  }
  toQueryValue() {
    return this.getTypes();
  }
}
class EntityTagFilter {
  constructor(values) {
    this.values = values;
  }
  filterEntity(entity) {
    return this.values.every((v) => {
      var _a;
      return ((_a = entity.metadata.tags) != null ? _a : []).includes(v);
    });
  }
  getCatalogFilters() {
    return { "metadata.tags": this.values };
  }
  toQueryValue() {
    return this.values;
  }
}
class EntityTextFilter {
  constructor(value) {
    this.value = value;
  }
  filterEntity(entity) {
    const words = this.toUpperArray(this.value.split(/\s/));
    const exactMatch = this.toUpperArray([entity.metadata.tags]);
    const partialMatch = this.toUpperArray([
      entity.metadata.name,
      entity.metadata.title
    ]);
    for (const word of words) {
      if (exactMatch.every((m) => m !== word) && partialMatch.every((m) => !m.includes(word))) {
        return false;
      }
    }
    return true;
  }
  toUpperArray(value) {
    return value.flat().filter((m) => Boolean(m)).map((m) => m.toLocaleUpperCase("en-US"));
  }
}
class EntityOwnerFilter {
  constructor(values) {
    __publicField(this, "values");
    this.values = values.reduce((fullRefs, ref) => {
      try {
        fullRefs.push(
          stringifyEntityRef(parseEntityRef(ref, { defaultKind: "Group" }))
        );
        return fullRefs;
      } catch (err) {
        return fullRefs;
      }
    }, []);
  }
  getCatalogFilters() {
    return { "relations.ownedBy": this.values };
  }
  filterEntity(entity) {
    return this.values.some(
      (v) => getEntityRelations(entity, RELATION_OWNED_BY).some(
        (o) => stringifyEntityRef(o) === v
      )
    );
  }
  /**
   * Get the URL query parameter value. May be a mix of full and humanized entity refs.
   * @returns list of entity refs.
   */
  toQueryValue() {
    return this.values;
  }
}
class EntityLifecycleFilter {
  constructor(values) {
    this.values = values;
  }
  getCatalogFilters() {
    return { "spec.lifecycle": this.values };
  }
  filterEntity(entity) {
    return this.values.some((v) => {
      var _a;
      return ((_a = entity.spec) == null ? void 0 : _a.lifecycle) === v;
    });
  }
  toQueryValue() {
    return this.values;
  }
}
class EntityNamespaceFilter {
  constructor(values) {
    this.values = values;
  }
  getCatalogFilters() {
    return { "metadata.namespace": this.values };
  }
  filterEntity(entity) {
    return this.values.some((v) => entity.metadata.namespace === v);
  }
  toQueryValue() {
    return this.values;
  }
}
class EntityUserFilter {
  constructor(value, refs) {
    this.value = value;
    this.refs = refs;
  }
  static owned(ownershipEntityRefs) {
    return new EntityUserFilter("owned", ownershipEntityRefs);
  }
  static all() {
    return new EntityUserFilter("all");
  }
  static starred(starredEntityRefs) {
    return new EntityUserFilter("starred", starredEntityRefs);
  }
  getCatalogFilters() {
    var _a, _b, _c;
    if (this.value === "owned") {
      return { "relations.ownedBy": (_a = this.refs) != null ? _a : [] };
    }
    if (this.value === "starred") {
      return {
        "metadata.name": (_c = (_b = this.refs) == null ? void 0 : _b.map((e) => parseEntityRef(e).name)) != null ? _c : []
      };
    }
    return {};
  }
  filterEntity(entity) {
    var _a, _b, _c, _d;
    if (this.value === "starred") {
      return (_b = (_a = this.refs) == null ? void 0 : _a.includes(stringifyEntityRef(entity))) != null ? _b : true;
    }
    if (this.value === "owned") {
      const relations = getEntityRelations(entity, RELATION_OWNED_BY);
      return (_d = (_c = this.refs) == null ? void 0 : _c.some(
        (v) => relations.some((o) => stringifyEntityRef(o) === v)
      )) != null ? _d : false;
    }
    return true;
  }
  toQueryValue() {
    return this.value;
  }
}
class UserListFilter {
  constructor(value, isOwnedEntity, isStarredEntity) {
    this.value = value;
    this.isOwnedEntity = isOwnedEntity;
    this.isStarredEntity = isStarredEntity;
  }
  filterEntity(entity) {
    switch (this.value) {
      case "owned":
        return this.isOwnedEntity(entity);
      case "starred":
        return this.isStarredEntity(entity);
      default:
        return true;
    }
  }
  toQueryValue() {
    return this.value;
  }
}
class EntityOrphanFilter {
  constructor(value) {
    this.value = value;
  }
  getCatalogFilters() {
    if (this.value) {
      return { "metadata.annotations.backstage.io/orphan": String(this.value) };
    }
    return {};
  }
  filterEntity(entity) {
    var _a;
    const orphan = (_a = entity.metadata.annotations) == null ? void 0 : _a["backstage.io/orphan"];
    return orphan !== void 0 && this.value.toString() === orphan;
  }
}
class EntityErrorFilter {
  constructor(value) {
    this.value = value;
  }
  filterEntity(entity) {
    var _a, _b;
    const error = ((_b = (_a = entity == null ? void 0 : entity.status) == null ? void 0 : _a.items) == null ? void 0 : _b.length) > 0;
    return error !== void 0 && this.value === error;
  }
}

const EntityListContext = createContext(void 0);
const EntityListProvider = (props) => {
  const isMounted = useMountedState();
  const catalogApi = useApi(catalogApiRef);
  const [requestedFilters, setRequestedFilters] = useState(
    {}
  );
  const location = useLocation();
  const enablePagination = props.pagination === true || typeof props.pagination === "object";
  const limit = props.pagination && typeof props.pagination === "object" && typeof props.pagination.limit === "number" ? props.pagination.limit : 20;
  const { queryParameters, cursor: initialCursor } = useMemo(() => {
    var _a;
    const parsed = qs.parse(location.search, {
      ignoreQueryPrefix: true
    });
    return {
      queryParameters: (_a = parsed.filters) != null ? _a : {},
      cursor: typeof parsed.cursor === "string" ? parsed.cursor : void 0
    };
  }, [location]);
  const [cursor, setCursor] = useState(initialCursor);
  const [outputState, setOutputState] = useState(
    () => {
      return {
        appliedFilters: {},
        entities: [],
        backendEntities: [],
        pageInfo: enablePagination ? {} : void 0
      };
    }
  );
  const [{ loading, error }, refresh] = useAsyncFn(
    async () => {
      var _a;
      const compacted = compact(Object.values(requestedFilters));
      const queryParams = Object.keys(requestedFilters).reduce(
        (params, key) => {
          const filter = requestedFilters[key];
          if (filter == null ? void 0 : filter.toQueryValue) {
            params[key] = filter.toQueryValue();
          }
          return params;
        },
        {}
      );
      if (enablePagination) {
        if (cursor) {
          if (cursor !== outputState.appliedCursor) {
            const entityFilter = reduceEntityFilters(compacted);
            const response = await catalogApi.queryEntities({
              cursor,
              limit
            });
            setOutputState({
              appliedFilters: requestedFilters,
              appliedCursor: cursor,
              backendEntities: response.items,
              entities: response.items.filter(entityFilter),
              pageInfo: response.pageInfo
            });
          }
        } else {
          const entityFilter = reduceEntityFilters(compacted);
          const backendFilter = reduceCatalogFilters(compacted);
          const previousBackendFilter = reduceCatalogFilters(
            compact(Object.values(outputState.appliedFilters))
          );
          if (!isEqual(previousBackendFilter, backendFilter)) {
            const response = await catalogApi.queryEntities({
              filter: backendFilter,
              limit,
              orderFields: [{ field: "metadata.name", order: "asc" }]
            });
            setOutputState({
              appliedFilters: requestedFilters,
              backendEntities: response.items,
              entities: response.items.filter(entityFilter),
              pageInfo: response.pageInfo
            });
          }
        }
      } else {
        const entityFilter = reduceEntityFilters(compacted);
        const backendFilter = reduceBackendCatalogFilters(compacted);
        const previousBackendFilter = reduceBackendCatalogFilters(
          compact(Object.values(outputState.appliedFilters))
        );
        if (!isEqual(previousBackendFilter, backendFilter)) {
          const response = await catalogApi.getEntities({
            filter: backendFilter
          });
          setOutputState({
            appliedFilters: requestedFilters,
            backendEntities: response.items,
            entities: response.items.filter(entityFilter)
          });
        } else {
          setOutputState({
            appliedFilters: requestedFilters,
            backendEntities: outputState.backendEntities,
            entities: outputState.backendEntities.filter(entityFilter)
          });
        }
      }
      if (isMounted()) {
        const oldParams = qs.parse(location.search, {
          ignoreQueryPrefix: true
        });
        const newParams = qs.stringify(
          { ...oldParams, filters: queryParams, cursor },
          { addQueryPrefix: true, arrayFormat: "repeat" }
        );
        const newUrl = `${window.location.pathname}${newParams}`;
        (_a = window.history) == null ? void 0 : _a.replaceState(null, document.title, newUrl);
      }
    },
    [
      catalogApi,
      queryParameters,
      requestedFilters,
      outputState,
      cursor,
      enablePagination
    ],
    { loading: true }
  );
  useDebounce(refresh, 10, [requestedFilters, cursor]);
  const updateFilters = useCallback(
    (update) => {
      setCursor(void 0);
      setRequestedFilters((prevFilters) => {
        const newFilters = typeof update === "function" ? update(prevFilters) : update;
        return { ...prevFilters, ...newFilters };
      });
    },
    []
  );
  const pageInfo = useMemo(() => {
    var _a, _b;
    if (!enablePagination) {
      return void 0;
    }
    const prevCursor = (_a = outputState.pageInfo) == null ? void 0 : _a.prevCursor;
    const nextCursor = (_b = outputState.pageInfo) == null ? void 0 : _b.nextCursor;
    return {
      prev: prevCursor ? () => setCursor(prevCursor) : void 0,
      next: nextCursor ? () => setCursor(nextCursor) : void 0
    };
  }, [enablePagination, outputState.pageInfo]);
  const value = useMemo(
    () => ({
      filters: outputState.appliedFilters,
      entities: outputState.entities,
      backendEntities: outputState.backendEntities,
      updateFilters,
      queryParameters,
      loading,
      error,
      pageInfo
    }),
    [outputState, updateFilters, queryParameters, loading, error, pageInfo]
  );
  return /* @__PURE__ */ React.createElement(EntityListContext.Provider, { value }, props.children);
};
function useEntityList() {
  const context = useContext(EntityListContext);
  if (!context)
    throw new Error("useEntityList must be used within EntityListProvider");
  return context;
}

function useEntityTypeFilter() {
  var _a;
  const catalogApi = useApi(catalogApiRef);
  const {
    filters: { kind: kindFilter, type: typeFilter },
    queryParameters: { type: typeParameter },
    updateFilters
  } = useEntityList();
  const flattenedQueryTypes = useMemo(
    () => [typeParameter].flat().filter(Boolean),
    [typeParameter]
  );
  const [selectedTypes, setSelectedTypes] = useState(
    flattenedQueryTypes.length ? flattenedQueryTypes : (_a = typeFilter == null ? void 0 : typeFilter.getTypes()) != null ? _a : []
  );
  useEffect(() => {
    if (flattenedQueryTypes.length) {
      setSelectedTypes(flattenedQueryTypes);
    }
  }, [flattenedQueryTypes]);
  const [availableTypes, setAvailableTypes] = useState([]);
  const kind = useMemo(() => kindFilter == null ? void 0 : kindFilter.value, [kindFilter]);
  const {
    error,
    loading,
    value: facets
  } = useAsync(async () => {
    if (kind) {
      const items = await catalogApi.getEntityFacets({
        filter: { kind },
        facets: ["spec.type"]
      }).then((response) => response.facets["spec.type"] || []);
      return items;
    }
    return [];
  }, [kind, catalogApi]);
  const facetsRef = useRef(facets);
  useEffect(() => {
    const oldFacets = facetsRef.current;
    facetsRef.current = facets;
    if (loading || !kind || oldFacets === facets || !facets) {
      return;
    }
    const newTypes = [
      ...new Set(
        sortBy(facets, (f) => -f.count).map(
          (f) => f.value.toLocaleLowerCase("en-US")
        )
      )
    ];
    setAvailableTypes(newTypes);
    const stillValidTypes = selectedTypes.filter(
      (value) => newTypes.includes(value)
    );
    if (!isEqual$1(selectedTypes, stillValidTypes)) {
      setSelectedTypes(stillValidTypes);
    }
  }, [loading, kind, selectedTypes, setSelectedTypes, facets]);
  useEffect(() => {
    updateFilters({
      type: selectedTypes.length ? new EntityTypeFilter(selectedTypes) : void 0
    });
  }, [selectedTypes, updateFilters]);
  return {
    loading,
    error,
    availableTypes,
    selectedTypes,
    setSelectedTypes
  };
}

function useRelatedEntities(entity, relationFilter) {
  var _a, _b;
  const filterByTypeLower = (_a = relationFilter == null ? void 0 : relationFilter.type) == null ? void 0 : _a.toLocaleLowerCase("en-US");
  const filterByKindLower = (_b = relationFilter == null ? void 0 : relationFilter.kind) == null ? void 0 : _b.toLocaleLowerCase("en-US");
  const catalogApi = useApi(catalogApiRef);
  const {
    loading,
    value: entities,
    error
  } = useAsync(async () => {
    var _a2;
    const relations = (_a2 = entity.relations) == null ? void 0 : _a2.filter(
      (r) => (!filterByTypeLower || r.type.toLocaleLowerCase("en-US") === filterByTypeLower) && (!filterByKindLower || parseEntityRef(r.targetRef).kind === filterByKindLower)
    );
    if (!(relations == null ? void 0 : relations.length)) {
      return [];
    }
    const { items } = await catalogApi.getEntitiesByRefs({
      entityRefs: relations.map((r) => r.targetRef)
    });
    return items.filter((x) => Boolean(x));
  }, [entity, filterByTypeLower, filterByKindLower]);
  return {
    entities,
    loading,
    error
  };
}

function getEntityRef$1(entityOrRef) {
  return typeof entityOrRef === "string" ? entityOrRef : stringifyEntityRef(entityOrRef);
}
function useStarredEntities() {
  const starredEntitiesApi = useApi(starredEntitiesApiRef);
  const starredEntities = useObservable(
    useMemo(() => starredEntitiesApi.starredEntitie$(), [starredEntitiesApi]),
    /* @__PURE__ */ new Set()
  );
  const isStarredEntity = useCallback(
    (entityOrRef) => starredEntities.has(getEntityRef$1(entityOrRef)),
    [starredEntities]
  );
  const toggleStarredEntity = useCallback(
    (entityOrRef) => starredEntitiesApi.toggleStarred(getEntityRef$1(entityOrRef)).then(),
    [starredEntitiesApi]
  );
  return {
    starredEntities,
    toggleStarredEntity,
    isStarredEntity
  };
}

function getEntityRef(entityOrRef) {
  return typeof entityOrRef === "string" ? entityOrRef : stringifyEntityRef(entityOrRef);
}
function useStarredEntity(entityOrRef) {
  const starredEntitiesApi = useApi(starredEntitiesApiRef);
  const [isStarredEntity, setIsStarredEntity] = useState(false);
  useEffect(() => {
    const subscription = starredEntitiesApi.starredEntitie$().subscribe({
      next(starredEntities) {
        setIsStarredEntity(starredEntities.has(getEntityRef(entityOrRef)));
      }
    });
    return () => {
      subscription.unsubscribe();
    };
  }, [entityOrRef, starredEntitiesApi]);
  const toggleStarredEntity = useCallback(
    () => starredEntitiesApi.toggleStarred(getEntityRef(entityOrRef)).then(),
    [entityOrRef, starredEntitiesApi]
  );
  return {
    toggleStarredEntity,
    isStarredEntity
  };
}

function useEntityOwnership() {
  const identityApi = useApi(identityApiRef);
  const { loading, value: refs } = useAsync(
    async () => {
      const { ownershipEntityRefs } = await identityApi.getBackstageIdentity();
      return ownershipEntityRefs;
    },
    // load only on mount
    []
  );
  const isOwnedEntity = useMemo(() => {
    const myOwnerRefs = new Set(refs != null ? refs : []);
    return (entity) => {
      const entityOwnerRefs = getEntityRelations(entity, RELATION_OWNED_BY).map(
        stringifyEntityRef
      );
      for (const ref of entityOwnerRefs) {
        if (myOwnerRefs.has(ref)) {
          return true;
        }
      }
      return false;
    };
  }, [refs]);
  return { loading, isOwnedEntity };
}

function useAllKinds() {
  const catalogApi = useApi(catalogApiRef);
  const {
    error,
    loading,
    value: allKinds
  } = useAsync(async () => {
    const items = await catalogApi.getEntityFacets({ facets: ["kind"] }).then((response) => {
      var _a;
      return ((_a = response.facets.kind) == null ? void 0 : _a.map((f) => f.value).sort()) || [];
    });
    return items;
  }, [catalogApi]);
  return { loading, error, allKinds: allKinds != null ? allKinds : [] };
}
function filterKinds(allKinds, allowedKinds, forcedKinds) {
  let availableKinds = allKinds;
  if (allowedKinds) {
    availableKinds = availableKinds.filter(
      (k) => allowedKinds.some(
        (a) => a.toLocaleLowerCase("en-US") === k.toLocaleLowerCase("en-US")
      )
    );
  }
  if (forcedKinds && !allKinds.some(
    (a) => a.toLocaleLowerCase("en-US") === forcedKinds.toLocaleLowerCase("en-US")
  )) {
    availableKinds = availableKinds.concat([forcedKinds]);
  }
  const kindsMap = availableKinds.sort().reduce((acc, kind) => {
    acc[kind.toLocaleLowerCase("en-US")] = kind;
    return acc;
  }, {});
  return kindsMap;
}

function useEntityKindFilter(opts) {
  var _a, _b;
  const {
    filters,
    queryParameters: { kind: kindParameter },
    updateFilters
  } = useEntityList();
  const queryParamKind = useMemo(
    () => [kindParameter].flat()[0],
    [kindParameter]
  );
  const [selectedKind, setSelectedKind] = useState(
    (_b = queryParamKind != null ? queryParamKind : (_a = filters.kind) == null ? void 0 : _a.value) != null ? _b : opts.initialFilter
  );
  useEffect(() => {
    if (queryParamKind) {
      setSelectedKind(queryParamKind);
    }
  }, [queryParamKind]);
  useEffect(() => {
    var _a2, _b2;
    if ((_a2 = filters.kind) == null ? void 0 : _a2.value) {
      setSelectedKind((_b2 = filters.kind) == null ? void 0 : _b2.value);
    }
  }, [filters.kind]);
  useEffect(() => {
    updateFilters({
      kind: selectedKind ? new EntityKindFilter(selectedKind) : void 0
    });
  }, [selectedKind, updateFilters]);
  const { allKinds, loading, error } = useAllKinds();
  return {
    loading,
    error,
    allKinds: allKinds != null ? allKinds : [],
    selectedKind,
    setSelectedKind
  };
}
const EntityKindPicker = (props) => {
  const { allowedKinds, hidden, initialFilter = "component" } = props;
  const alertApi = useApi(alertApiRef);
  const { error, allKinds, selectedKind, setSelectedKind } = useEntityKindFilter({
    initialFilter
  });
  useEffect(() => {
    if (error) {
      alertApi.post({
        message: `Failed to load entity kinds`,
        severity: "error"
      });
    }
  }, [error, alertApi]);
  if (error)
    return null;
  const options = filterKinds(allKinds, allowedKinds, selectedKind);
  const items = Object.keys(options).map((key) => ({
    value: key,
    label: options[key]
  }));
  return hidden ? null : /* @__PURE__ */ React.createElement(Box, { pb: 1, pt: 1 }, /* @__PURE__ */ React.createElement(
    Select,
    {
      label: "Kind",
      items,
      selected: selectedKind.toLocaleLowerCase("en-US"),
      onChange: (value) => setSelectedKind(String(value))
    }
  ));
};

const icon$2 = /* @__PURE__ */ React.createElement(CheckBoxOutlineBlankIcon, { fontSize: "small" });
const checkedIcon$2 = /* @__PURE__ */ React.createElement(CheckBoxIcon, { fontSize: "small" });
function OptionCheckbox({ selected }) {
  return /* @__PURE__ */ React.createElement(Checkbox, { icon: icon$2, checkedIcon: checkedIcon$2, checked: selected });
}
const EntityAutocompletePickerOption = memo((props) => {
  const { selected, value, availableOptions, showCounts } = props;
  const label = showCounts ? `${value} (${availableOptions == null ? void 0 : availableOptions[value]})` : value;
  return /* @__PURE__ */ React.createElement(
    FormControlLabel,
    {
      control: /* @__PURE__ */ React.createElement(OptionCheckbox, { selected }),
      label,
      onClick: (event) => event.preventDefault()
    }
  );
});

const useStyles$h = makeStyles(
  {
    input: {}
  },
  {
    name: "CatalogReactEntityAutocompletePickerInput"
  }
);
function EntityAutocompletePickerInput(params) {
  const classes = useStyles$h();
  return /* @__PURE__ */ React.createElement(
    TextField,
    {
      variant: "outlined",
      ...params,
      className: classNames(classes.input, params.className)
    }
  );
}

function EntityAutocompletePicker(props) {
  var _a, _b;
  const {
    label,
    name,
    path,
    showCounts,
    Filter,
    InputProps,
    initialSelectedOptions = []
  } = props;
  const {
    updateFilters,
    filters,
    queryParameters: { [name]: queryParameter }
  } = useEntityList();
  const catalogApi = useApi(catalogApiRef);
  const { value: availableValues } = useAsync(async () => {
    var _a2;
    const facet = path;
    const { facets } = await catalogApi.getEntityFacets({
      facets: [facet],
      filter: (_a2 = filters.kind) == null ? void 0 : _a2.getCatalogFilters()
    });
    return Object.fromEntries(
      facets[facet].map(({ value, count }) => [value, count])
    );
  }, [filters.kind]);
  const queryParameters = useMemo(
    () => [queryParameter].flat().filter(Boolean),
    [queryParameter]
  );
  const [selectedOptions, setSelectedOptions] = useState(
    queryParameters.length ? queryParameters : (_b = (_a = filters[name]) == null ? void 0 : _a.values) != null ? _b : initialSelectedOptions
  );
  useEffect(() => {
    if (queryParameters.length) {
      setSelectedOptions(queryParameters);
    }
  }, [queryParameters]);
  const availableOptions = Object.keys(availableValues != null ? availableValues : {});
  const shouldAddFilter = selectedOptions.length && availableOptions.length;
  useEffect(() => {
    updateFilters({
      [name]: shouldAddFilter ? new Filter(selectedOptions) : void 0
    });
  }, [name, shouldAddFilter, selectedOptions, Filter, updateFilters]);
  const filter = filters[name];
  if (filter && typeof filter === "object" && !("values" in filter) || !availableOptions.length) {
    return null;
  }
  if (availableOptions.length <= 1)
    return null;
  return /* @__PURE__ */ React.createElement(Box, { pb: 1, pt: 1 }, /* @__PURE__ */ React.createElement(Typography, { variant: "button", component: "label" }, label, /* @__PURE__ */ React.createElement(
    Autocomplete,
    {
      multiple: true,
      disableCloseOnSelect: true,
      options: availableOptions,
      value: selectedOptions,
      onChange: (_event, options) => setSelectedOptions(options),
      renderOption: (option, { selected }) => /* @__PURE__ */ React.createElement(
        EntityAutocompletePickerOption,
        {
          selected,
          value: option,
          availableOptions: availableValues,
          showCounts: !!showCounts
        }
      ),
      size: "small",
      popupIcon: /* @__PURE__ */ React.createElement(ExpandMoreIcon, { "data-testid": `${String(name)}-picker-expand` }),
      renderInput: (params) => /* @__PURE__ */ React.createElement(EntityAutocompletePickerInput, { ...params, ...InputProps })
    }
  )));
}

const useStyles$g = makeStyles(
  {
    input: {}
  },
  {
    name: "CatalogReactEntityLifecyclePicker"
  }
);
const EntityLifecyclePicker = (props) => {
  const { initialFilter = [] } = props;
  const classes = useStyles$g();
  return /* @__PURE__ */ React.createElement(
    EntityAutocompletePicker,
    {
      label: "Lifecycle",
      name: "lifecycles",
      path: "spec.lifecycle",
      Filter: EntityLifecycleFilter,
      InputProps: { className: classes.input },
      initialSelectedOptions: initialFilter
    }
  );
};

function humanizeEntityRef(entityRef, opts) {
  const defaultKind = opts == null ? void 0 : opts.defaultKind;
  let kind;
  let namespace;
  let name;
  if ("metadata" in entityRef) {
    kind = entityRef.kind;
    namespace = entityRef.metadata.namespace;
    name = entityRef.metadata.name;
  } else {
    kind = entityRef.kind;
    namespace = entityRef.namespace;
    name = entityRef.name;
  }
  if (namespace === void 0 || namespace === "") {
    namespace = DEFAULT_NAMESPACE;
  }
  if ((opts == null ? void 0 : opts.defaultNamespace) !== void 0) {
    if ((opts == null ? void 0 : opts.defaultNamespace) === namespace) {
      namespace = void 0;
    }
  } else if (namespace === DEFAULT_NAMESPACE) {
    namespace = void 0;
  }
  kind = kind.toLocaleLowerCase("en-US");
  kind = defaultKind && defaultKind.toLocaleLowerCase("en-US") === kind ? void 0 : kind;
  return `${kind ? `${kind}:` : ""}${namespace ? `${namespace}/` : ""}${name}`;
}
function humanizeEntity(entity, defaultName) {
  for (const path of ["spec.profile.displayName", "metadata.title"]) {
    const value = get(entity, path);
    if (value && typeof value === "string") {
      return value;
    }
  }
  return defaultName;
}

function useFacetsEntities({ enabled }) {
  const catalogApi = useApi(catalogApiRef);
  const [facetsPromise] = useState(async () => {
    if (!enabled) {
      return [];
    }
    const facet = "relations.ownedBy";
    return catalogApi.getEntityFacets({ facets: [facet] }).then(
      (response) => response.facets[facet].map((e) => e.value).map((ref) => {
        const { kind, name, namespace } = parseEntityRef(ref);
        return {
          apiVersion: "backstage.io/v1beta1",
          kind,
          metadata: { name, namespace }
        };
      }).sort(
        (a, b) => (a.metadata.namespace || "").localeCompare(
          b.metadata.namespace || "",
          "en-US"
        ) || a.metadata.name.localeCompare(b.metadata.name, "en-US") || a.kind.localeCompare(b.kind, "en-US")
      )
    ).catch(() => []);
  });
  return useAsyncFn(
    async (request, options) => {
      var _a;
      const facets = await facetsPromise;
      if (!facets) {
        return {
          items: []
        };
      }
      const limit = (_a = options == null ? void 0 : options.limit) != null ? _a : 20;
      const { text, start } = decodeCursor(request);
      const filteredRefs = facets.filter((e) => filterEntity(text, e));
      const end = start + limit;
      return {
        items: filteredRefs.slice(0, end),
        ...encodeCursor({
          entities: filteredRefs,
          limit: end,
          payload: {
            text,
            start: end
          }
        })
      };
    },
    [facetsPromise],
    { loading: true, value: { items: [] } }
  );
}
function decodeCursor(request) {
  if (isFacetsResponse(request) && request.cursor) {
    return JSON.parse(atob(request.cursor));
  }
  return {
    text: request.text || "",
    start: 0
  };
}
function isFacetsResponse(request) {
  return !!request.cursor;
}
function encodeCursor({
  entities,
  limit,
  payload
}) {
  if (entities.length > limit) {
    return { cursor: btoa(JSON.stringify(payload)) };
  }
  return {};
}
function filterEntity(text, entity) {
  var _a;
  const normalizedText = text.trim();
  return entity.kind.includes(normalizedText) || ((_a = entity.metadata.namespace) == null ? void 0 : _a.includes(normalizedText)) || entity.metadata.name.includes(normalizedText);
}

function useQueryEntities() {
  const catalogApi = useApi(catalogApiRef);
  return useAsyncFn(
    async (request, options) => {
      var _a;
      const initialRequest = request;
      const cursorRequest = request;
      const limit = (_a = options == null ? void 0 : options.limit) != null ? _a : 20;
      if (cursorRequest.cursor) {
        const response2 = await catalogApi.queryEntities({
          cursor: cursorRequest.cursor,
          limit
        });
        return {
          cursor: response2.pageInfo.nextCursor,
          items: [...cursorRequest.items, ...response2.items]
        };
      }
      const response = await catalogApi.queryEntities({
        fullTextFilter: {
          term: initialRequest.text || "",
          fields: [
            "metadata.name",
            "kind",
            "spec.profile.displayname",
            "metadata.title"
          ]
        },
        filter: { kind: ["User", "Group"] },
        orderFields: [{ field: "metadata.name", order: "asc" }],
        limit
      });
      return {
        cursor: response.pageInfo.nextCursor,
        items: response.items
      };
    },
    [],
    { loading: true }
  );
}

function useFetchEntities({
  mode,
  initialSelectedOwnersRefs
}) {
  const isOwnersOnlyMode = mode === "owners-only";
  const queryEntitiesResponse = useQueryEntities();
  const facetsEntitiesResponse = useFacetsEntities({
    enabled: isOwnersOnlyMode
  });
  const [state, handleFetch] = isOwnersOnlyMode ? facetsEntitiesResponse : queryEntitiesResponse;
  return [
    state,
    handleFetch,
    useSelectedOwners({
      enabled: !isOwnersOnlyMode,
      initialSelectedOwnersRefs
    })
  ];
}
function useSelectedOwners({
  enabled,
  initialSelectedOwnersRefs
}) {
  const allEntities = useRef({});
  const catalogApi = useApi(catalogApiRef);
  const [, handleFetch] = useAsyncFn(async () => {
    const initialSelectedEntities = await catalogApi.getEntitiesByRefs({
      entityRefs: initialSelectedOwnersRefs
    });
    initialSelectedEntities.items.forEach((e) => {
      if (e) {
        allEntities.current[stringifyEntityRef(e)] = e;
      }
    });
  }, []);
  useMountEffect(() => {
    if (enabled && initialSelectedOwnersRefs.length > 0) {
      handleFetch();
    }
  });
  return {
    getEntity: (entityRef) => allEntities.current[entityRef],
    setEntity: (entity) => {
      allEntities.current[stringifyEntityRef(entity)] = entity;
    }
  };
}

const useStyles$f = makeStyles(
  {
    input: {}
  },
  {
    name: "CatalogReactEntityOwnerPicker"
  }
);
const icon$1 = /* @__PURE__ */ React.createElement(CheckBoxOutlineBlankIcon, { fontSize: "small" });
const checkedIcon$1 = /* @__PURE__ */ React.createElement(CheckBoxIcon, { fontSize: "small" });
const EntityOwnerPicker = (props) => {
  var _a, _b, _c;
  const classes = useStyles$f();
  const { mode = "owners-only" } = props || {};
  const {
    updateFilters,
    filters,
    queryParameters: { owners: ownersParameter }
  } = useEntityList();
  const [text, setText] = useState("");
  const queryParamOwners = useMemo(
    () => [ownersParameter].flat().filter(Boolean),
    [ownersParameter]
  );
  const [selectedOwners, setSelectedOwners] = useState(
    queryParamOwners.length ? queryParamOwners : (_b = (_a = filters.owners) == null ? void 0 : _a.values) != null ? _b : []
  );
  const [{ value, loading }, handleFetch, cache] = useFetchEntities({
    mode,
    initialSelectedOwnersRefs: selectedOwners
  });
  useDebouncedEffect(() => handleFetch({ text }), [text, handleFetch], 250);
  const availableOwners = (value == null ? void 0 : value.items) || [];
  useEffect(() => {
    if (queryParamOwners.length) {
      const filter = new EntityOwnerFilter(queryParamOwners);
      setSelectedOwners(filter.values);
    }
  }, [queryParamOwners]);
  useEffect(() => {
    updateFilters({
      owners: selectedOwners.length ? new EntityOwnerFilter(selectedOwners) : void 0
    });
  }, [selectedOwners, updateFilters]);
  if (["user", "group"].includes(
    ((_c = filters.kind) == null ? void 0 : _c.value.toLocaleLowerCase("en-US")) || ""
  )) {
    return null;
  }
  return /* @__PURE__ */ React.createElement(Box, { pb: 1, pt: 1 }, /* @__PURE__ */ React.createElement(Typography, { variant: "button", component: "label" }, "Owner", /* @__PURE__ */ React.createElement(
    Autocomplete,
    {
      multiple: true,
      disableCloseOnSelect: true,
      loading,
      options: availableOwners,
      value: selectedOwners,
      getOptionSelected: (o, v) => {
        if (typeof v === "string") {
          return stringifyEntityRef(o) === v;
        }
        return o === v;
      },
      getOptionLabel: (o) => {
        const entity = typeof o === "string" ? cache.getEntity(o) || parseEntityRef(o, {
          defaultKind: "group",
          defaultNamespace: "default"
        }) : o;
        return humanizeEntity(entity, humanizeEntityRef(entity));
      },
      onChange: (_, owners) => {
        setText("");
        setSelectedOwners(
          owners.map((e) => {
            const entityRef = typeof e === "string" ? e : stringifyEntityRef(e);
            if (typeof e !== "string") {
              cache.setEntity(e);
            }
            return entityRef;
          })
        );
      },
      filterOptions: (x) => x,
      renderOption: (entity, { selected }) => {
        const isGroup = entity.kind.toLocaleLowerCase("en-US") === "group";
        return /* @__PURE__ */ React.createElement(
          FormControlLabel,
          {
            control: /* @__PURE__ */ React.createElement(
              Checkbox,
              {
                icon: icon$1,
                checkedIcon: checkedIcon$1,
                checked: selected
              }
            ),
            onClick: (event) => event.preventDefault(),
            label: /* @__PURE__ */ React.createElement(Box, { display: "flex", flexWrap: "wrap", alignItems: "center" }, isGroup ? /* @__PURE__ */ React.createElement(GroupIcon, { fontSize: "small" }) : /* @__PURE__ */ React.createElement(PersonIcon, { fontSize: "small" }), "\xA0", humanizeEntity(
              entity,
              humanizeEntityRef(entity, { defaultKind: entity.kind })
            ))
          }
        );
      },
      size: "small",
      popupIcon: /* @__PURE__ */ React.createElement(ExpandMoreIcon, { "data-testid": "owner-picker-expand" }),
      renderInput: (params) => /* @__PURE__ */ React.createElement(
        TextField,
        {
          ...params,
          className: classes.input,
          onChange: (e) => {
            setText(e.currentTarget.value);
          },
          variant: "outlined"
        }
      ),
      ListboxProps: {
        onScroll: (e) => {
          const element = e.currentTarget;
          const hasReachedEnd = Math.abs(
            element.scrollHeight - element.clientHeight - element.scrollTop
          ) < 1;
          if (hasReachedEnd && (value == null ? void 0 : value.cursor)) {
            handleFetch({ items: value.items, cursor: value.cursor });
          }
        },
        "data-testid": "owner-picker-listbox"
      }
    }
  )));
};

const useStyles$e = makeStyles(
  (theme) => ({
    root: {
      display: "inline-flex",
      alignItems: "center"
    },
    icon: {
      marginRight: theme.spacing(0.5),
      color: theme.palette.text.secondary,
      lineHeight: 0
    }
  }),
  { name: "CatalogReactEntityDisplayName" }
);
const EntityDisplayName = (props) => {
  const { entityRef, hideIcon, disableTooltip, defaultKind, defaultNamespace } = props;
  const classes = useStyles$e();
  const { primaryTitle, secondaryTitle, Icon } = useEntityPresentation(
    entityRef,
    { defaultKind, defaultNamespace }
  );
  let content = /* @__PURE__ */ React.createElement(React.Fragment, null, primaryTitle);
  content = /* @__PURE__ */ React.createElement(Box, { component: "span", className: classes.root }, Icon && !hideIcon ? /* @__PURE__ */ React.createElement(Box, { component: "span", className: classes.icon }, /* @__PURE__ */ React.createElement(Icon, { fontSize: "inherit" })) : null, content);
  if (secondaryTitle && !disableTooltip) {
    content = /* @__PURE__ */ React.createElement(Tooltip, { enterDelay: 1500, title: secondaryTitle }, content);
  }
  return content;
};

const entityRouteRef = getOrCreateGlobalSingleton(
  "catalog:entity-route-ref",
  () => createRouteRef({
    id: "catalog:entity",
    params: ["namespace", "kind", "name"]
  })
);
function entityRouteParams(entity) {
  var _a, _b;
  return {
    kind: entity.kind.toLocaleLowerCase("en-US"),
    namespace: (_b = (_a = entity.metadata.namespace) == null ? void 0 : _a.toLocaleLowerCase("en-US")) != null ? _b : DEFAULT_NAMESPACE,
    name: entity.metadata.name
  };
}

const EntityRefLink = forwardRef(
  (props, ref) => {
    var _a;
    const {
      entityRef,
      defaultKind,
      defaultNamespace,
      title,
      children,
      hideIcon,
      ...linkProps
    } = props;
    const entityRoute = useEntityRoute(props.entityRef);
    const content = (_a = children != null ? children : title) != null ? _a : /* @__PURE__ */ React.createElement(
      EntityDisplayName,
      {
        entityRef,
        defaultKind,
        defaultNamespace,
        hideIcon
      }
    );
    return /* @__PURE__ */ React.createElement(Link, { ...linkProps, ref, to: entityRoute }, content);
  }
);
function useEntityRoute(entityRef) {
  var _a;
  const entityRoute = useRouteRef(entityRouteRef);
  let kind;
  let namespace;
  let name;
  if (typeof entityRef === "string") {
    const parsed = parseEntityRef(entityRef);
    kind = parsed.kind;
    namespace = parsed.namespace;
    name = parsed.name;
  } else if ("metadata" in entityRef) {
    kind = entityRef.kind;
    namespace = entityRef.metadata.namespace;
    name = entityRef.metadata.name;
  } else {
    kind = entityRef.kind;
    namespace = entityRef.namespace;
    name = entityRef.name;
  }
  kind = kind.toLocaleLowerCase("en-US");
  namespace = (_a = namespace == null ? void 0 : namespace.toLocaleLowerCase("en-US")) != null ? _a : DEFAULT_NAMESPACE;
  const routeParams = {
    kind: encodeURIComponent(kind),
    namespace: encodeURIComponent(namespace),
    name: encodeURIComponent(name)
  };
  return entityRoute(routeParams);
}

function EntityRefLinks(props) {
  const { entityRefs, hideIcons, ...linkProps } = props;
  return /* @__PURE__ */ React.createElement(React.Fragment, null, entityRefs.map((r, i) => {
    const entityRefString = typeof r === "string" ? r : stringifyEntityRef(r);
    return /* @__PURE__ */ React.createElement(React.Fragment, { key: `${i}.${entityRefString}` }, i > 0 && ", ", /* @__PURE__ */ React.createElement(EntityRefLink, { ...linkProps, entityRef: r, hideIcon: hideIcons }));
  }));
}

const EntityCardActions = (props) => {
  const entityRoute = useRouteRef(entityRouteRef);
  return /* @__PURE__ */ React.createElement(
    IconButton,
    {
      component: Link,
      "aria-label": "Show",
      title: "Show details",
      to: entityRoute(getCompoundEntityRef(props.entity))
    },
    /* @__PURE__ */ React.createElement(InfoIcon, null)
  );
};

const EmailCardAction = (props) => {
  return /* @__PURE__ */ React.createElement(
    IconButton,
    {
      component: Link,
      "aria-label": "Email",
      title: `Email ${props.email}`,
      to: `mailto:${props.email}`
    },
    /* @__PURE__ */ React.createElement(EmailIcon, null)
  );
};

const GroupCardActions = (props) => {
  var _a;
  const email = (_a = props.entity.spec.profile) == null ? void 0 : _a.email;
  return email ? /* @__PURE__ */ React.createElement(EmailCardAction, { email }) : null;
};

const UserCardActions = (props) => {
  var _a;
  const email = (_a = props.entity.spec.profile) == null ? void 0 : _a.email;
  return email ? /* @__PURE__ */ React.createElement(EmailCardAction, { email }) : null;
};

const useStyles$d = makeStyles(() => {
  return {
    popoverPaper: {
      width: "30em"
    },
    descriptionTypography: {
      overflow: "hidden",
      textOverflow: "ellipsis",
      display: "-webkit-box",
      WebkitLineClamp: 2,
      WebkitBoxOrient: "vertical"
    }
  };
});
const maxTagChips = 4;
const EntityPeekAheadPopover = (props) => {
  var _a, _b, _c, _d;
  const { entityRef, children, delayTime = 500 } = props;
  const classes = useStyles$d();
  const apiHolder = useApiHolder();
  const popupState = usePopupState({
    variant: "popover",
    popupId: "entity-peek-ahead"
  });
  const [isHovered, setIsHovered] = useState(false);
  const debouncedHandleMouseEnter = useMemo(
    () => debounce(() => setIsHovered(true), delayTime),
    [delayTime]
  );
  const [{ loading, error, value: entity }, load] = useAsyncFn(async () => {
    const catalogApi = apiHolder.get(catalogApiRef);
    if (catalogApi) {
      const retrievedEntity = await catalogApi.getEntityByRef(entityRef);
      if (!retrievedEntity) {
        throw new Error(`${entityRef} not found`);
      }
      return retrievedEntity;
    }
    return void 0;
  }, [apiHolder, entityRef]);
  const handleOnMouseLeave = () => {
    setIsHovered(false);
    debouncedHandleMouseEnter.cancel();
  };
  useEffect(() => {
    if (popupState.isOpen && !entity && !error && !loading) {
      load();
    }
  }, [popupState.isOpen, load, entity, error, loading]);
  return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(Typography, { component: "span", onMouseEnter: debouncedHandleMouseEnter }, /* @__PURE__ */ React.createElement(
    Typography,
    {
      component: "span",
      "data-testid": "trigger",
      ...bindHover(popupState)
    },
    children
  )), isHovered && /* @__PURE__ */ React.createElement(
    HoverPopover,
    {
      PaperProps: {
        className: classes.popoverPaper
      },
      ...bindPopover(popupState),
      anchorOrigin: {
        vertical: "bottom",
        horizontal: "center"
      },
      transformOrigin: {
        vertical: "top",
        horizontal: "center"
      },
      onMouseLeave: handleOnMouseLeave
    },
    /* @__PURE__ */ React.createElement(Card, null, /* @__PURE__ */ React.createElement(CardContent, null, error && /* @__PURE__ */ React.createElement(ResponseErrorPanel, { error }), loading && /* @__PURE__ */ React.createElement(Progress, null), entity && /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(Typography, { color: "textSecondary" }, entity.metadata.namespace), /* @__PURE__ */ React.createElement(Typography, { variant: "h5", component: "div" }, entity.metadata.name), /* @__PURE__ */ React.createElement(Typography, { color: "textSecondary", gutterBottom: true }, entity.kind), entity.metadata.description && /* @__PURE__ */ React.createElement(
      Typography,
      {
        className: classes.descriptionTypography,
        paragraph: true
      },
      entity.metadata.description
    ), /* @__PURE__ */ React.createElement(Typography, null, (_b = (_a = entity.spec) == null ? void 0 : _a.type) == null ? void 0 : _b.toString()), /* @__PURE__ */ React.createElement(Box, { marginTop: "0.5em" }, (entity.metadata.tags || []).slice(0, maxTagChips).map((tag) => {
      return /* @__PURE__ */ React.createElement(Chip, { key: tag, size: "small", label: tag });
    }), ((_c = entity.metadata.tags) == null ? void 0 : _c.length) && ((_d = entity.metadata.tags) == null ? void 0 : _d.length) > maxTagChips && /* @__PURE__ */ React.createElement(Tooltip, { title: "Drill into the entity to see all of the tags." }, /* @__PURE__ */ React.createElement(Chip, { key: "other-tags", size: "small", label: "..." }))))), !error && entity && /* @__PURE__ */ React.createElement(CardActions, null, /* @__PURE__ */ React.createElement(React.Fragment, null, isUserEntity(entity) && /* @__PURE__ */ React.createElement(UserCardActions, { entity }), isGroupEntity(entity) && /* @__PURE__ */ React.createElement(GroupCardActions, { entity }), /* @__PURE__ */ React.createElement(EntityCardActions, { entity }))))
  ));
};

const useStyles$c = makeStyles(
  (_theme) => ({
    searchToolbar: {
      paddingLeft: 0,
      paddingRight: 0
    },
    input: {}
  }),
  {
    name: "CatalogReactEntitySearchBar"
  }
);
const EntitySearchBar = () => {
  var _a, _b;
  const classes = useStyles$c();
  const { filters, updateFilters } = useEntityList();
  const [search, setSearch] = useState((_b = (_a = filters.text) == null ? void 0 : _a.value) != null ? _b : "");
  useDebounce(
    () => {
      updateFilters({
        text: search.length ? new EntityTextFilter(search) : void 0
      });
    },
    250,
    [search, updateFilters]
  );
  return /* @__PURE__ */ React.createElement(Toolbar, { className: classes.searchToolbar }, /* @__PURE__ */ React.createElement(FormControl, null, /* @__PURE__ */ React.createElement(
    Input,
    {
      "aria-label": "search",
      id: "input-with-icon-adornment",
      className: classes.input,
      placeholder: "Search",
      autoComplete: "off",
      onChange: (event) => setSearch(event.target.value),
      value: search,
      startAdornment: /* @__PURE__ */ React.createElement(InputAdornment, { position: "start" }, /* @__PURE__ */ React.createElement(Search, null)),
      endAdornment: /* @__PURE__ */ React.createElement(InputAdornment, { position: "end" }, /* @__PURE__ */ React.createElement(
        IconButton,
        {
          "aria-label": "clear search",
          onClick: () => setSearch(""),
          edge: "end",
          disabled: search.length === 0
        },
        /* @__PURE__ */ React.createElement(Clear, null)
      ))
    }
  )));
};

const columnFactories = Object.freeze({
  createEntityRefColumn(options) {
    const { defaultKind } = options;
    function formatContent(entity) {
      var _a;
      return ((_a = entity.metadata) == null ? void 0 : _a.title) || humanizeEntityRef(entity, {
        defaultKind
      });
    }
    return {
      title: "Name",
      highlight: true,
      customFilterAndSearch(filter, entity) {
        return formatContent(entity).includes(filter);
      },
      customSort(entity1, entity2) {
        return formatContent(entity1).localeCompare(formatContent(entity2));
      },
      render: (entity) => {
        var _a;
        return /* @__PURE__ */ React.createElement(
          EntityRefLink,
          {
            entityRef: entity,
            defaultKind,
            title: (_a = entity.metadata) == null ? void 0 : _a.title
          }
        );
      }
    };
  },
  createEntityRelationColumn(options) {
    const { title, relation, defaultKind, filter: entityFilter } = options;
    function getRelations(entity) {
      return getEntityRelations(entity, relation, entityFilter);
    }
    function formatContent(entity) {
      return getRelations(entity).map((r) => humanizeEntityRef(r, { defaultKind })).join(", ");
    }
    return {
      title,
      customFilterAndSearch(filter, entity) {
        return formatContent(entity).includes(filter);
      },
      customSort(entity1, entity2) {
        return formatContent(entity1).localeCompare(formatContent(entity2));
      },
      render: (entity) => {
        return /* @__PURE__ */ React.createElement(
          EntityRefLinks,
          {
            entityRefs: getRelations(entity),
            defaultKind
          }
        );
      }
    };
  },
  createOwnerColumn() {
    return this.createEntityRelationColumn({
      title: "Owner",
      relation: RELATION_OWNED_BY,
      defaultKind: "group"
    });
  },
  createDomainColumn() {
    return this.createEntityRelationColumn({
      title: "Domain",
      relation: RELATION_PART_OF,
      defaultKind: "domain",
      filter: {
        kind: "domain"
      }
    });
  },
  createSystemColumn() {
    return this.createEntityRelationColumn({
      title: "System",
      relation: RELATION_PART_OF,
      defaultKind: "system",
      filter: {
        kind: "system"
      }
    });
  },
  createMetadataDescriptionColumn() {
    return {
      title: "Description",
      field: "metadata.description",
      render: (entity) => /* @__PURE__ */ React.createElement(
        OverflowTooltip,
        {
          text: entity.metadata.description,
          placement: "bottom-start",
          line: 2
        }
      )
    };
  },
  createSpecLifecycleColumn() {
    return {
      title: "Lifecycle",
      field: "spec.lifecycle"
    };
  },
  createSpecTypeColumn() {
    return {
      title: "Type",
      field: "spec.type"
    };
  }
});

const systemEntityColumns = [
  columnFactories.createEntityRefColumn({ defaultKind: "system" }),
  columnFactories.createDomainColumn(),
  columnFactories.createOwnerColumn(),
  columnFactories.createMetadataDescriptionColumn()
];
const componentEntityColumns = [
  columnFactories.createEntityRefColumn({ defaultKind: "component" }),
  columnFactories.createSystemColumn(),
  columnFactories.createOwnerColumn(),
  columnFactories.createSpecTypeColumn(),
  columnFactories.createSpecLifecycleColumn(),
  columnFactories.createMetadataDescriptionColumn()
];

const useStyles$b = makeStyles((theme) => ({
  empty: {
    padding: theme.spacing(2),
    display: "flex",
    justifyContent: "center"
  }
}));
const EntityTable = (props) => {
  const {
    entities,
    title,
    emptyContent,
    variant = "gridItem",
    columns,
    tableOptions = {}
  } = props;
  const classes = useStyles$b();
  const tableStyle = {
    minWidth: "0",
    width: "100%"
  };
  if (variant === "gridItem") {
    tableStyle.height = "calc(100% - 10px)";
  }
  return /* @__PURE__ */ React.createElement(
    Table,
    {
      columns,
      title,
      style: tableStyle,
      emptyContent: emptyContent && /* @__PURE__ */ React.createElement("div", { className: classes.empty }, emptyContent),
      options: {
        // TODO: Toolbar padding if off compared to other cards, should be: padding: 16px 24px;
        search: false,
        paging: false,
        actionsColumnIndex: -1,
        padding: "dense",
        draggable: false,
        ...tableOptions
      },
      data: entities
    }
  );
};
EntityTable.columns = columnFactories;
EntityTable.systemEntityColumns = systemEntityColumns;
EntityTable.componentEntityColumns = componentEntityColumns;

const useStyles$a = makeStyles(
  { input: {} },
  { name: "CatalogReactEntityTagPicker" }
);
const EntityTagPicker = (props) => {
  const classes = useStyles$a();
  return /* @__PURE__ */ React.createElement(
    EntityAutocompletePicker,
    {
      label: "Tags",
      name: "tags",
      path: "metadata.tags",
      Filter: EntityTagFilter,
      showCounts: props.showCounts,
      InputProps: { className: classes.input }
    }
  );
};

const EntityTypePicker = (props) => {
  var _a;
  const { hidden, initialFilter } = props;
  const alertApi = useApi(alertApiRef);
  const { error, availableTypes, selectedTypes, setSelectedTypes } = useEntityTypeFilter();
  useEffect(() => {
    if (error) {
      alertApi.post({
        message: `Failed to load entity types`,
        severity: "error"
      });
    }
    if (initialFilter) {
      setSelectedTypes([initialFilter]);
    }
  }, [error, alertApi, initialFilter, setSelectedTypes]);
  if (availableTypes.length === 0 || error)
    return null;
  const items = [
    { value: "all", label: "all" },
    ...availableTypes.map((type) => ({
      value: type,
      label: type
    }))
  ];
  return hidden ? null : /* @__PURE__ */ React.createElement(Box, { pb: 1, pt: 1 }, /* @__PURE__ */ React.createElement(
    Select,
    {
      label: "Type",
      items,
      selected: (_a = items.length > 1 ? selectedTypes[0] : void 0) != null ? _a : "all",
      onChange: (value) => setSelectedTypes(value === "all" ? [] : [String(value)])
    }
  ));
};

const YellowStar = withStyles({
  root: {
    color: "#f3ba37"
  }
})(Star);
const FavoriteEntity = (props) => {
  const { toggleStarredEntity, isStarredEntity } = useStarredEntity(
    props.entity
  );
  return /* @__PURE__ */ React.createElement(
    IconButton,
    {
      "aria-label": "favorite",
      color: "inherit",
      ...props,
      onClick: () => toggleStarredEntity()
    },
    /* @__PURE__ */ React.createElement(
      Tooltip,
      {
        title: isStarredEntity ? "Remove from favorites" : "Add to favorites"
      },
      isStarredEntity ? /* @__PURE__ */ React.createElement(YellowStar, null) : /* @__PURE__ */ React.createElement(StarBorder, null)
    )
  );
};

const DEFAULT_ICON = WorkIcon;
function getKind(kind, entityRef) {
  if (kind) {
    return kind.toLocaleLowerCase("en-US");
  }
  if (entityRef) {
    try {
      return parseEntityRef(entityRef).kind.toLocaleLowerCase("en-US");
    } catch {
      return void 0;
    }
  }
  return void 0;
}
function useIcon(kind, entityRef) {
  const app = useApp();
  const actualKind = getKind(kind, entityRef);
  if (!actualKind) {
    return DEFAULT_ICON;
  }
  const icon = app.getSystemIcon(`kind:${actualKind}`);
  return icon || DEFAULT_ICON;
}
function EntityKindIcon(props) {
  const { kind, entityRef, ...otherProps } = props;
  const Icon = useIcon(kind, entityRef);
  return /* @__PURE__ */ React.createElement(Icon, { ...otherProps });
}

const useStyles$9 = makeStyles((theme) => ({
  node: {
    fill: theme.palette.grey[300],
    stroke: theme.palette.grey[300],
    "&.primary": {
      fill: theme.palette.primary.light,
      stroke: theme.palette.primary.light
    },
    "&.secondary": {
      fill: theme.palette.secondary.light,
      stroke: theme.palette.secondary.light
    }
  },
  text: {
    fill: theme.palette.getContrastText(theme.palette.grey[300]),
    "&.primary": {
      fill: theme.palette.primary.contrastText
    },
    "&.secondary": {
      fill: theme.palette.secondary.contrastText
    },
    "&.focused": {
      fontWeight: "bold"
    }
  },
  clickable: {
    cursor: "pointer"
  }
}));
function useAncestry(root) {
  const catalogClient = useApi(catalogApiRef);
  const entityRef = stringifyEntityRef(root);
  const { loading, error, value } = useAsync(async () => {
    const response = await catalogClient.getEntityAncestors({ entityRef });
    const nodes = new Array();
    const edges = new Array();
    for (const current of response.items) {
      const currentRef = stringifyEntityRef(current.entity);
      const isRootNode = currentRef === response.rootEntityRef;
      nodes.push({ id: currentRef, root: isRootNode, ...current.entity });
      for (const parentRef of current.parentEntityRefs) {
        edges.push({ from: currentRef, to: parentRef });
      }
    }
    return { nodes, edges };
  }, [entityRef]);
  return {
    loading,
    error,
    nodes: (value == null ? void 0 : value.nodes) || [],
    edges: (value == null ? void 0 : value.edges) || []
  };
}
function CustomNode({ node }) {
  const classes = useStyles$9();
  const navigate = useNavigate();
  const entityRoute = useRouteRef(entityRouteRef);
  const [width, setWidth] = useState(0);
  const [height, setHeight] = useState(0);
  const idRef = useRef(null);
  useLayoutEffect(() => {
    if (idRef.current) {
      let { height: renderedHeight, width: renderedWidth } = idRef.current.getBBox();
      renderedHeight = Math.round(renderedHeight);
      renderedWidth = Math.round(renderedWidth);
      if (renderedHeight !== height || renderedWidth !== width) {
        setWidth(renderedWidth);
        setHeight(renderedHeight);
      }
    }
  }, [width, height]);
  const padding = 10;
  const iconSize = height;
  const paddedIconWidth = iconSize + padding;
  const paddedWidth = paddedIconWidth + width + padding * 2;
  const paddedHeight = height + padding * 2;
  const displayTitle = node.metadata.title || (node.kind && node.metadata.name && node.metadata.namespace ? humanizeEntityRef({
    kind: node.kind,
    name: node.metadata.name,
    namespace: node.metadata.namespace || ""
  }) : node.id);
  const onClick = () => {
    navigate(
      entityRoute({
        kind: node.kind,
        namespace: node.metadata.namespace || DEFAULT_NAMESPACE,
        name: node.metadata.name
      })
    );
  };
  return /* @__PURE__ */ React.createElement("g", { onClick, className: classes.clickable }, /* @__PURE__ */ React.createElement(
    "rect",
    {
      className: classNames(
        classes.node,
        node.root ? "secondary" : "primary"
      ),
      width: paddedWidth,
      height: paddedHeight,
      rx: 10
    }
  ), /* @__PURE__ */ React.createElement(
    EntityKindIcon,
    {
      kind: node.kind,
      y: padding,
      x: padding,
      width: iconSize,
      height: iconSize,
      className: classNames(
        classes.text,
        node.root ? "secondary" : "primary"
      )
    }
  ), /* @__PURE__ */ React.createElement(
    "text",
    {
      ref: idRef,
      className: classNames(
        classes.text,
        node.root ? "secondary" : "primary"
      ),
      y: paddedHeight / 2,
      x: paddedIconWidth + (width + padding * 2) / 2,
      textAnchor: "middle",
      alignmentBaseline: "middle"
    },
    displayTitle
  ));
}
function AncestryPage(props) {
  const { loading, error, nodes, edges } = useAncestry(props.entity);
  if (loading) {
    return /* @__PURE__ */ React.createElement(Progress, null);
  } else if (error) {
    return /* @__PURE__ */ React.createElement(ResponseErrorPanel, { error });
  }
  return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(DialogContentText, { variant: "h2" }, "Ancestry"), /* @__PURE__ */ React.createElement(DialogContentText, { gutterBottom: true }, "This is the ancestry of entities above the current one - as in, the chain(s) of entities down to the current one, where", " ", /* @__PURE__ */ React.createElement(Link, { to: "https://backstage.io/docs/features/software-catalog/life-of-an-entity" }, "processors emitted"), " ", "child entities that ultimately led to the current one existing. Note that this is a completely different mechanism from relations."), /* @__PURE__ */ React.createElement(Box, { mt: 4 }, /* @__PURE__ */ React.createElement(
    DependencyGraph,
    {
      nodes,
      edges,
      renderNode: CustomNode,
      direction: DependencyGraphTypes.Direction.BOTTOM_TOP,
      zoom: "enable-on-click"
    }
  )));
}

const useStyles$8 = makeStyles((theme) => ({
  root: {
    display: "flex",
    flexDirection: "column"
  },
  marginTop: {
    marginTop: theme.spacing(2)
  },
  helpIcon: {
    marginLeft: theme.spacing(1),
    color: theme.palette.text.disabled
  },
  monospace: {
    fontFamily: "monospace"
  }
}));
function ListItemText(props) {
  const classes = useStyles$8();
  return /* @__PURE__ */ React.createElement(
    ListItemText$1,
    {
      ...props,
      primaryTypographyProps: { className: classes.monospace },
      secondaryTypographyProps: { className: classes.monospace }
    }
  );
}
function ListSubheader(props) {
  const classes = useStyles$8();
  return /* @__PURE__ */ React.createElement(ListSubheader$1, { className: classes.monospace }, props.children);
}
function Container(props) {
  return /* @__PURE__ */ React.createElement(Box, { mt: 2 }, /* @__PURE__ */ React.createElement(Card, { variant: "outlined" }, /* @__PURE__ */ React.createElement(CardContent, null, /* @__PURE__ */ React.createElement(Typography, { variant: "h6", gutterBottom: true }, props.title, props.helpLink && /* @__PURE__ */ React.createElement(HelpIcon, { to: props.helpLink })), props.children)));
}
function findLink(value) {
  if (value.match(/^url:https?:\/\//)) {
    return value.slice("url:".length);
  }
  if (value.match(/^https?:\/\//)) {
    return value;
  }
  return void 0;
}
function KeyValueListItem(props) {
  const [key, value] = props.entry;
  const link = findLink(value);
  return /* @__PURE__ */ React.createElement(ListItem, null, props.indent && /* @__PURE__ */ React.createElement(ListItemIcon, null), /* @__PURE__ */ React.createElement(
    ListItemText,
    {
      primary: key,
      secondary: link ? /* @__PURE__ */ React.createElement(Link, { to: link }, value) : value
    }
  ));
}
function HelpIcon(props) {
  const classes = useStyles$8();
  return /* @__PURE__ */ React.createElement(Link, { to: props.to, className: classes.helpIcon }, /* @__PURE__ */ React.createElement(HelpOutlineIcon, { fontSize: "inherit" }));
}

const useStyles$7 = makeStyles({
  root: {
    display: "flex",
    flexDirection: "column"
  }
});
function useColocated(entity) {
  var _a, _b;
  const catalogApi = useApi(catalogApiRef);
  const currentEntityRef = stringifyEntityRef(entity);
  const location = (_a = entity.metadata.annotations) == null ? void 0 : _a[ANNOTATION_LOCATION];
  const origin = (_b = entity.metadata.annotations) == null ? void 0 : _b[ANNOTATION_ORIGIN_LOCATION];
  const { loading, error, value } = useAsync(async () => {
    if (!location && !origin) {
      return [];
    }
    const response = await catalogApi.getEntities({
      filter: [
        ...location ? [{ [`metadata.annotations.${ANNOTATION_LOCATION}`]: location }] : [],
        ...origin ? [{ [`metadata.annotations.${ANNOTATION_ORIGIN_LOCATION}`]: origin }] : []
      ]
    });
    return response.items;
  }, [location, origin]);
  return {
    loading,
    error,
    location,
    originLocation: origin,
    colocatedEntities: value == null ? void 0 : value.filter(
      (colocated) => stringifyEntityRef(colocated) !== currentEntityRef
    )
  };
}
function EntityList(props) {
  return /* @__PURE__ */ React.createElement(List, { dense: true }, props.header && /* @__PURE__ */ React.createElement(KeyValueListItem, { key: "header", entry: props.header }), props.entities.map((entity) => /* @__PURE__ */ React.createElement(ListItem, { key: stringifyEntityRef(entity) }, /* @__PURE__ */ React.createElement(ListItemIcon, null, /* @__PURE__ */ React.createElement(EntityKindIcon, { kind: entity.kind })), /* @__PURE__ */ React.createElement(ListItemText, { primary: /* @__PURE__ */ React.createElement(EntityRefLink, { entityRef: entity }) }))));
}
function Contents$1(props) {
  const { entity } = props;
  const { loading, error, location, originLocation, colocatedEntities } = useColocated(entity);
  if (loading) {
    return /* @__PURE__ */ React.createElement(Progress, null);
  } else if (error) {
    return /* @__PURE__ */ React.createElement(ResponseErrorPanel, { error });
  }
  if (!location && !originLocation) {
    return /* @__PURE__ */ React.createElement(Alert, { severity: "warning" }, "Entity had no location information.");
  } else if (!(colocatedEntities == null ? void 0 : colocatedEntities.length)) {
    return /* @__PURE__ */ React.createElement(Alert, { severity: "info" }, "There were no other entities on this location.");
  }
  if (location === originLocation) {
    return /* @__PURE__ */ React.createElement(EntityList, { entities: colocatedEntities });
  }
  const atLocation = colocatedEntities.filter(
    (e) => {
      var _a;
      return ((_a = e.metadata.annotations) == null ? void 0 : _a[ANNOTATION_LOCATION]) === location;
    }
  );
  const atOrigin = colocatedEntities.filter(
    (e) => {
      var _a;
      return ((_a = e.metadata.annotations) == null ? void 0 : _a[ANNOTATION_ORIGIN_LOCATION]) === originLocation;
    }
  );
  return /* @__PURE__ */ React.createElement(React.Fragment, null, atLocation.length > 0 && /* @__PURE__ */ React.createElement(
    EntityList,
    {
      entities: atLocation,
      header: ["At the same location", location]
    }
  ), atOrigin.length > 0 && /* @__PURE__ */ React.createElement(
    EntityList,
    {
      entities: atOrigin,
      header: ["At the same origin", originLocation]
    }
  ));
}
function ColocatedPage(props) {
  const classes = useStyles$7();
  return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(DialogContentText, { variant: "h2" }, "Colocated"), /* @__PURE__ */ React.createElement(DialogContentText, null, "These are the entities that are colocated with this entity - as in, they originated from the same data source (e.g. came from the same YAML file), or from the same origin (e.g. the originally registered URL)."), /* @__PURE__ */ React.createElement("div", { className: classes.root }, /* @__PURE__ */ React.createElement(Contents$1, { entity: props.entity })));
}

function sortKeys(data) {
  return Object.fromEntries(
    [...Object.entries(data)].sort((a, b) => a[0] < b[0] ? -1 : 1)
  );
}

function JsonPage(props) {
  return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(DialogContentText, { variant: "h2" }, "Entity as JSON"), /* @__PURE__ */ React.createElement(DialogContentText, null, "This is the raw entity data as received from the catalog, on JSON form."), /* @__PURE__ */ React.createElement(DialogContentText, null, /* @__PURE__ */ React.createElement("div", { style: { fontSize: "75%" }, "data-testid": "code-snippet" }, /* @__PURE__ */ React.createElement(
    CodeSnippet,
    {
      text: JSON.stringify(sortKeys(props.entity), void 0, 2),
      language: "json",
      showCopyCodeButton: true
    }
  ))));
}

const useStyles$6 = makeStyles({
  root: {
    display: "flex",
    flexDirection: "column"
  }
});
function OverviewPage(props) {
  var _a, _b, _c;
  const classes = useStyles$6();
  const {
    apiVersion,
    kind,
    metadata,
    spec,
    relations = [],
    status = {}
  } = props.entity;
  const groupedRelations = groupBy(
    sortBy(relations, (r) => r.targetRef),
    "type"
  );
  const entityRef = stringifyEntityRef(props.entity);
  return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(DialogContentText, { variant: "h2" }, "Overview"), /* @__PURE__ */ React.createElement("div", { className: classes.root }, /* @__PURE__ */ React.createElement(Container, { title: "Identity" }, /* @__PURE__ */ React.createElement(List, { dense: true }, /* @__PURE__ */ React.createElement(ListItem, null, /* @__PURE__ */ React.createElement(ListItemText, { primary: "apiVersion", secondary: apiVersion })), /* @__PURE__ */ React.createElement(ListItem, null, /* @__PURE__ */ React.createElement(ListItemText, { primary: "kind", secondary: kind })), (spec == null ? void 0 : spec.type) && /* @__PURE__ */ React.createElement(ListItem, null, /* @__PURE__ */ React.createElement(
    ListItemText,
    {
      primary: "spec.type",
      secondary: (_a = spec.type) == null ? void 0 : _a.toString()
    }
  )), metadata.uid && /* @__PURE__ */ React.createElement(ListItem, null, /* @__PURE__ */ React.createElement(ListItemText, { primary: "uid", secondary: metadata.uid }), /* @__PURE__ */ React.createElement(ListItemSecondaryAction, null, /* @__PURE__ */ React.createElement(CopyTextButton, { text: metadata.uid }))), metadata.etag && /* @__PURE__ */ React.createElement(ListItem, null, /* @__PURE__ */ React.createElement(ListItemText, { primary: "etag", secondary: metadata.etag }), /* @__PURE__ */ React.createElement(ListItemSecondaryAction, null, /* @__PURE__ */ React.createElement(CopyTextButton, { text: metadata.etag }))), /* @__PURE__ */ React.createElement(ListItem, null, /* @__PURE__ */ React.createElement(ListItemText, { primary: "entityRef", secondary: entityRef }), /* @__PURE__ */ React.createElement(ListItemSecondaryAction, null, /* @__PURE__ */ React.createElement(CopyTextButton, { text: entityRef }))))), /* @__PURE__ */ React.createElement(Container, { title: "Metadata" }, !!Object.keys(metadata.annotations || {}).length && /* @__PURE__ */ React.createElement(
    List,
    {
      dense: true,
      subheader: /* @__PURE__ */ React.createElement(ListSubheader, null, "Annotations", /* @__PURE__ */ React.createElement(HelpIcon, { to: "https://backstage.io/docs/features/software-catalog/well-known-annotations" }))
    },
    Object.entries(metadata.annotations).map((entry) => /* @__PURE__ */ React.createElement(KeyValueListItem, { key: entry[0], indent: true, entry }))
  ), !!Object.keys(metadata.labels || {}).length && /* @__PURE__ */ React.createElement(List, { dense: true, subheader: /* @__PURE__ */ React.createElement(ListSubheader, null, "Labels") }, Object.entries(metadata.labels).map((entry) => /* @__PURE__ */ React.createElement(KeyValueListItem, { key: entry[0], indent: true, entry }))), !!((_b = metadata.tags) == null ? void 0 : _b.length) && /* @__PURE__ */ React.createElement(List, { dense: true, subheader: /* @__PURE__ */ React.createElement(ListSubheader, null, "Tags") }, metadata.tags.map((tag, index) => /* @__PURE__ */ React.createElement(ListItem, { key: `${tag}-${index}` }, /* @__PURE__ */ React.createElement(ListItemIcon, null), /* @__PURE__ */ React.createElement(ListItemText, { primary: tag }))))), !!relations.length && /* @__PURE__ */ React.createElement(
    Container,
    {
      title: "Relations",
      helpLink: "https://backstage.io/docs/features/software-catalog/well-known-relations"
    },
    Object.entries(groupedRelations).map(
      ([type, groupRelations], index) => /* @__PURE__ */ React.createElement("div", { key: index }, /* @__PURE__ */ React.createElement(List, { dense: true, subheader: /* @__PURE__ */ React.createElement(ListSubheader, null, type) }, groupRelations.map((group) => /* @__PURE__ */ React.createElement(ListItem, { key: group.targetRef }, /* @__PURE__ */ React.createElement(ListItemIcon, null, /* @__PURE__ */ React.createElement(EntityKindIcon, { entityRef: group.targetRef })), /* @__PURE__ */ React.createElement(
        ListItemText,
        {
          primary: /* @__PURE__ */ React.createElement(EntityRefLink, { entityRef: group.targetRef })
        }
      )))))
    )
  ), !!((_c = status.items) == null ? void 0 : _c.length) && /* @__PURE__ */ React.createElement(
    Container,
    {
      title: "Status",
      helpLink: "https://backstage.io/docs/features/software-catalog/well-known-statuses"
    },
    status.items.map((item, index) => /* @__PURE__ */ React.createElement("div", { key: index }, /* @__PURE__ */ React.createElement(Typography, null, item.level, ": ", item.type), /* @__PURE__ */ React.createElement(Box, { ml: 2 }, item.message)))
  )));
}

function YamlPage(props) {
  return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(DialogContentText$1, { variant: "h2" }, "Entity as YAML"), /* @__PURE__ */ React.createElement(DialogContentText$1, null, "This is the raw entity data as received from the catalog, on YAML form."), /* @__PURE__ */ React.createElement(DialogContentText$1, null, /* @__PURE__ */ React.createElement("div", { style: { fontSize: "75%" }, "data-testid": "code-snippet" }, /* @__PURE__ */ React.createElement(
    CodeSnippet,
    {
      text: YAML.stringify(sortKeys(props.entity)),
      language: "yaml",
      showCopyCodeButton: true
    }
  ))));
}

const useStyles$5 = makeStyles((theme) => ({
  fullHeightDialog: {
    height: "calc(100% - 64px)"
  },
  root: {
    display: "flex",
    flexGrow: 1,
    width: "100%",
    backgroundColor: theme.palette.background.paper
  },
  tabs: {
    borderRight: `1px solid ${theme.palette.divider}`,
    flexShrink: 0
  },
  tabContents: {
    flexGrow: 1,
    overflowX: "auto"
  }
}));
function TabPanel(props) {
  const { children, value, index, ...other } = props;
  const classes = useStyles$5();
  return /* @__PURE__ */ React.createElement(
    "div",
    {
      role: "tabpanel",
      hidden: value !== index,
      id: `vertical-tabpanel-${index}`,
      "aria-labelledby": `vertical-tab-${index}`,
      className: classes.tabContents,
      ...other
    },
    value === index && /* @__PURE__ */ React.createElement(Box, { pl: 3, pr: 3 }, children)
  );
}
function a11yProps(index) {
  return {
    id: `vertical-tab-${index}`,
    "aria-controls": `vertical-tabpanel-${index}`
  };
}
function InspectEntityDialog(props) {
  const classes = useStyles$5();
  const [activeTab, setActiveTab] = React.useState(0);
  useEffect(() => {
    setActiveTab(0);
  }, [props.open]);
  if (!props.entity) {
    return null;
  }
  return /* @__PURE__ */ React.createElement(
    Dialog,
    {
      fullWidth: true,
      maxWidth: "xl",
      open: props.open,
      onClose: props.onClose,
      "aria-labelledby": "entity-inspector-dialog-title",
      PaperProps: { className: classes.fullHeightDialog }
    },
    /* @__PURE__ */ React.createElement(DialogTitle, { id: "entity-inspector-dialog-title" }, "Entity Inspector"),
    /* @__PURE__ */ React.createElement(DialogContent, { dividers: true }, /* @__PURE__ */ React.createElement("div", { className: classes.root }, /* @__PURE__ */ React.createElement(
      Tabs,
      {
        orientation: "vertical",
        variant: "scrollable",
        value: activeTab,
        onChange: (_, newValue) => setActiveTab(newValue),
        "aria-label": "Inspector options",
        className: classes.tabs
      },
      /* @__PURE__ */ React.createElement(Tab, { label: "Overview", ...a11yProps(0) }),
      /* @__PURE__ */ React.createElement(Tab, { label: "Ancestry", ...a11yProps(1) }),
      /* @__PURE__ */ React.createElement(Tab, { label: "Colocated", ...a11yProps(2) }),
      /* @__PURE__ */ React.createElement(Tab, { label: "Raw JSON", ...a11yProps(3) }),
      /* @__PURE__ */ React.createElement(Tab, { label: "Raw YAML", ...a11yProps(4) })
    ), /* @__PURE__ */ React.createElement(TabPanel, { value: activeTab, index: 0 }, /* @__PURE__ */ React.createElement(OverviewPage, { entity: props.entity })), /* @__PURE__ */ React.createElement(TabPanel, { value: activeTab, index: 1 }, /* @__PURE__ */ React.createElement(AncestryPage, { entity: props.entity })), /* @__PURE__ */ React.createElement(TabPanel, { value: activeTab, index: 2 }, /* @__PURE__ */ React.createElement(ColocatedPage, { entity: props.entity })), /* @__PURE__ */ React.createElement(TabPanel, { value: activeTab, index: 3 }, /* @__PURE__ */ React.createElement(JsonPage, { entity: props.entity })), /* @__PURE__ */ React.createElement(TabPanel, { value: activeTab, index: 4 }, /* @__PURE__ */ React.createElement(YamlPage, { entity: props.entity })))),
    /* @__PURE__ */ React.createElement(DialogActions, null, /* @__PURE__ */ React.createElement(Button, { onClick: props.onClose, color: "primary" }, "Close"))
  );
}

function useUnregisterEntityDialogState(entity) {
  var _a;
  const catalogApi = useApi(catalogApiRef);
  const locationRef = (_a = entity.metadata.annotations) == null ? void 0 : _a[ANNOTATION_ORIGIN_LOCATION];
  const uid = entity.metadata.uid;
  const isBootstrap = locationRef === "bootstrap:bootstrap";
  const prerequisites = useAsync(async () => {
    const locationPromise = catalogApi.getLocationByRef(locationRef);
    let colocatedEntitiesPromise;
    if (!locationRef) {
      colocatedEntitiesPromise = Promise.resolve([]);
    } else {
      const locationAnnotationFilter = `metadata.annotations.${ANNOTATION_ORIGIN_LOCATION}`;
      colocatedEntitiesPromise = catalogApi.getEntities({
        filter: { [locationAnnotationFilter]: locationRef },
        fields: [
          "kind",
          "metadata.uid",
          "metadata.name",
          "metadata.namespace"
        ]
      }).then((response) => response.items);
    }
    return Promise.all([locationPromise, colocatedEntitiesPromise]).then(
      ([location2, colocatedEntities2]) => ({
        location: location2,
        colocatedEntities: colocatedEntities2
      })
    );
  }, [catalogApi, entity]);
  const unregisterLocation = useCallback(
    async function unregisterLocationFn() {
      const { location: location2 } = prerequisites.value;
      await catalogApi.removeLocationById(location2.id);
    },
    [catalogApi, prerequisites]
  );
  const deleteEntity = useCallback(
    async function deleteEntityFn() {
      await catalogApi.removeEntityByUid(uid);
    },
    [catalogApi, uid]
  );
  if (isBootstrap) {
    return { type: "bootstrap", location: locationRef, deleteEntity };
  }
  const { loading, error, value } = prerequisites;
  if (loading) {
    return { type: "loading" };
  } else if (error) {
    return { type: "error", error };
  }
  const { location, colocatedEntities } = value;
  if (!location) {
    return { type: "only-delete", deleteEntity };
  }
  return {
    type: "unregister",
    location: locationRef,
    colocatedEntities: colocatedEntities.map(getCompoundEntityRef),
    unregisterLocation,
    deleteEntity
  };
}

const useStyles$4 = makeStyles({
  advancedButton: {
    fontSize: "0.7em"
  },
  dialogActions: {
    display: "inline-block"
  }
});
const Contents = ({
  entity,
  onConfirm,
  onClose
}) => {
  var _a;
  const alertApi = useApi(alertApiRef);
  const configApi = useApi(configApiRef);
  const classes = useStyles$4();
  const state = useUnregisterEntityDialogState(entity);
  const [showDelete, setShowDelete] = useState(false);
  const [busy, setBusy] = useState(false);
  const appTitle = (_a = configApi.getOptionalString("app.title")) != null ? _a : "Backstage";
  const onUnregister = useCallback(
    async function onUnregisterFn() {
      if ("unregisterLocation" in state) {
        setBusy(true);
        try {
          await state.unregisterLocation();
          onConfirm();
        } catch (err) {
          assertError(err);
          alertApi.post({ message: err.message });
        } finally {
          setBusy(false);
        }
      }
    },
    [alertApi, onConfirm, state]
  );
  const onDelete = useCallback(
    async function onDeleteFn() {
      var _a2;
      if ("deleteEntity" in state) {
        setBusy(true);
        try {
          await state.deleteEntity();
          const entityName = (_a2 = entity.metadata.title) != null ? _a2 : entity.metadata.name;
          onConfirm();
          alertApi.post({
            message: `Removed entity ${entityName}`,
            severity: "success",
            display: "transient"
          });
        } catch (err) {
          assertError(err);
          alertApi.post({ message: err.message });
        } finally {
          setBusy(false);
        }
      }
    },
    [alertApi, onConfirm, state, entity]
  );
  const DialogActionsPanel = () => /* @__PURE__ */ React.createElement(DialogActions, { className: classes.dialogActions }, /* @__PURE__ */ React.createElement(Button, { onClick: onClose, color: "primary" }, "Cancel"));
  if (state.type === "loading") {
    return /* @__PURE__ */ React.createElement(Progress, null);
  }
  if (state.type === "error") {
    return /* @__PURE__ */ React.createElement(ResponseErrorPanel, { error: state.error });
  }
  if (state.type === "bootstrap") {
    return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(Alert$1, { severity: "info" }, 'You cannot unregister this entity, since it originates from a protected Backstage configuration (location "', state.location, '"). If you believe this is in error, please contact the ', appTitle, " ", "integrator."), /* @__PURE__ */ React.createElement(Box, { marginTop: 2 }, !showDelete && /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(
      Button,
      {
        variant: "text",
        size: "small",
        color: "primary",
        className: classes.advancedButton,
        onClick: () => setShowDelete(true)
      },
      "Advanced Options"
    ), /* @__PURE__ */ React.createElement(DialogActionsPanel, null)), showDelete && /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(DialogContentText, null, "You have the option to delete the entity itself from the catalog. Note that this should only be done if you know that the catalog file has been deleted at, or moved from, its origin location. If that is not the case, the entity will reappear shortly as the next refresh round is performed by the catalog."), /* @__PURE__ */ React.createElement(
      Button,
      {
        variant: "contained",
        color: "secondary",
        disabled: busy,
        onClick: onDelete
      },
      "Delete Entity"
    ), /* @__PURE__ */ React.createElement(DialogActionsPanel, null))));
  }
  if (state.type === "only-delete") {
    return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(DialogContentText, null, "This entity does not seem to originate from a registered location. You therefore only have the option to delete it outright from the catalog."), /* @__PURE__ */ React.createElement(
      Button,
      {
        variant: "contained",
        color: "secondary",
        disabled: busy,
        onClick: onDelete
      },
      "Delete Entity"
    ), /* @__PURE__ */ React.createElement(DialogActionsPanel, null));
  }
  if (state.type === "unregister") {
    return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(DialogContentText, null, "This action will unregister the following entities:"), /* @__PURE__ */ React.createElement(DialogContentText, { component: "ul" }, state.colocatedEntities.map((e) => /* @__PURE__ */ React.createElement("li", { key: `${e.kind}:${e.namespace}/${e.name}` }, /* @__PURE__ */ React.createElement(EntityRefLink, { entityRef: e })))), /* @__PURE__ */ React.createElement(DialogContentText, null, "Located at the following location:"), /* @__PURE__ */ React.createElement(DialogContentText, { component: "ul" }, /* @__PURE__ */ React.createElement("li", null, state.location)), /* @__PURE__ */ React.createElement(DialogContentText, null, "To undo, just re-register the entity in ", appTitle, "."), /* @__PURE__ */ React.createElement(Box, { marginTop: 2 }, /* @__PURE__ */ React.createElement(
      Button,
      {
        variant: "contained",
        color: "secondary",
        disabled: busy,
        onClick: onUnregister
      },
      "Unregister Location"
    ), !showDelete && /* @__PURE__ */ React.createElement(Box, { component: "span", marginLeft: 2 }, /* @__PURE__ */ React.createElement(
      Button,
      {
        variant: "text",
        size: "small",
        color: "primary",
        className: classes.advancedButton,
        onClick: () => setShowDelete(true)
      },
      "Advanced Options"
    ))), showDelete && /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(Box, { paddingTop: 4, paddingBottom: 4 }, /* @__PURE__ */ React.createElement(Divider, null)), /* @__PURE__ */ React.createElement(DialogContentText, null, "You also have the option to delete the entity itself from the catalog. Note that this should only be done if you know that the catalog file has been deleted at, or moved from, its origin location. If that is not the case, the entity will reappear shortly as the next refresh round is performed by the catalog."), /* @__PURE__ */ React.createElement(
      Button,
      {
        variant: "contained",
        color: "secondary",
        disabled: busy,
        onClick: onDelete
      },
      "Delete Entity"
    )));
  }
  return /* @__PURE__ */ React.createElement(Alert$1, { severity: "error" }, "Internal error: Unknown state");
};
const UnregisterEntityDialog = (props) => {
  const { open, onConfirm, onClose, entity } = props;
  return /* @__PURE__ */ React.createElement(Dialog, { open, onClose }, /* @__PURE__ */ React.createElement(DialogTitle, { id: "responsive-dialog-title" }, "Are you sure you want to unregister this entity?"), /* @__PURE__ */ React.createElement(DialogContent, null, /* @__PURE__ */ React.createElement(Contents, { entity, onConfirm, onClose })));
};

function useOwnedEntitiesCount() {
  const identityApi = useApi(identityApiRef);
  const catalogApi = useApi(catalogApiRef);
  const { filters } = useEntityList();
  const { value: ownershipEntityRefs, loading: loadingEntityRefs } = useAsync(
    async () => (await identityApi.getBackstageIdentity()).ownershipEntityRefs,
    // load only on mount
    []
  );
  const { user, owners, ...allFilters } = filters;
  const { ["metadata.name"]: metadata, ...filter } = reduceCatalogFilters(
    compact(Object.values(allFilters))
  );
  const [{ value: count, loading: loadingEntityOwnership }, fetchEntities] = useAsyncFn(
    async (req) => {
      const ownedClaims = getOwnedCountClaims(
        req.owners,
        req.ownershipEntityRefs
      );
      if (ownedClaims === void 0) {
        return 0;
      }
      const { totalItems } = await catalogApi.queryEntities({
        filter: {
          ...req.filter,
          "relations.ownedBy": ownedClaims
        },
        limit: 0
      });
      return totalItems;
    },
    [],
    { loading: true }
  );
  useDeepCompareEffect(() => {
    if (Object.keys(filter).length === 0) {
      return;
    }
    if (ownershipEntityRefs === void 0) {
      return;
    }
    fetchEntities({ ownershipEntityRefs, owners, filter });
  }, [ownershipEntityRefs, owners, filter]);
  const loading = loadingEntityRefs || loadingEntityOwnership;
  return {
    count,
    loading,
    filter: useMemo(
      () => EntityUserFilter.owned(ownershipEntityRefs != null ? ownershipEntityRefs : []),
      [ownershipEntityRefs]
    ),
    ownershipEntityRefs
  };
}
function getOwnedCountClaims(owners, ownershipEntityRefs) {
  var _a;
  if (ownershipEntityRefs === void 0) {
    return void 0;
  }
  const ownersRefs = (_a = owners == null ? void 0 : owners.values) != null ? _a : [];
  if (ownersRefs.length) {
    const commonOwnedBy = intersection(ownersRefs, ownershipEntityRefs);
    if (commonOwnedBy.length === 0) {
      return void 0;
    }
    return commonOwnedBy;
  }
  return ownershipEntityRefs;
}

function useAllEntitiesCount() {
  const catalogApi = useApi(catalogApiRef);
  const { filters } = useEntityList();
  const prevRequest = useRef();
  const request = useMemo(() => {
    const { user, ...allFilters } = filters;
    const compacted = compact(Object.values(allFilters));
    const filter = reduceCatalogFilters(compacted);
    const newRequest = {
      filter,
      limit: 0
    };
    if (Object.keys(filter).length === 0) {
      prevRequest.current = void 0;
      return prevRequest.current;
    }
    if (isEqual(newRequest, prevRequest.current)) {
      return prevRequest.current;
    }
    prevRequest.current = newRequest;
    return newRequest;
  }, [filters]);
  const { value: count, loading } = useAsync(async () => {
    if (request === void 0) {
      return 0;
    }
    const { totalItems } = await catalogApi.queryEntities(request);
    return totalItems;
  }, [request]);
  return { count, loading };
}

function useStarredEntitiesCount() {
  const catalogApi = useApi(catalogApiRef);
  const { filters } = useEntityList();
  const { starredEntities } = useStarredEntities();
  const prevRequest = useRef();
  const request = useMemo(() => {
    const { user, ...allFilters } = filters;
    const compacted = compact(Object.values(allFilters));
    const filter2 = reduceCatalogFilters(compacted);
    const facet = "metadata.name";
    const newRequest = {
      filter: {
        ...filter2,
        /**
         * here we are filtering entities by `name`. Given this filter,
         * the response might contain more entities than expected, in case multiple entities
         * of different kind or namespace share the same name. Those extra entities are filtered out
         * client side by `EntityUserFilter`, so they won't be visible to the user.
         */
        [facet]: Array.from(starredEntities).map((e) => parseEntityRef(e).name)
      },
      /**
       * limit is set to a high value as we are not expecting many starred entities
       */
      limit: 1e3
    };
    if (isEqual(newRequest, prevRequest.current)) {
      return prevRequest.current;
    }
    prevRequest.current = newRequest;
    return newRequest;
  }, [filters, starredEntities]);
  const { value: count, loading } = useAsync(async () => {
    if (!starredEntities.size) {
      return 0;
    }
    const response = await catalogApi.queryEntities(request);
    return response.items.map(
      (e) => stringifyEntityRef({
        kind: e.kind,
        namespace: e.metadata.namespace,
        name: e.metadata.name
      })
    ).filter((e) => starredEntities.has(e)).length;
  }, [request, starredEntities]);
  const filter = useMemo(
    () => EntityUserFilter.starred(Array.from(starredEntities)),
    [starredEntities]
  );
  return { count, loading, filter };
}

const useStyles$3 = makeStyles(
  (theme) => ({
    root: {
      backgroundColor: "rgba(0, 0, 0, .11)",
      boxShadow: "none",
      margin: theme.spacing(1, 0, 1, 0)
    },
    title: {
      margin: theme.spacing(1, 0, 0, 1),
      textTransform: "uppercase",
      fontSize: 12,
      fontWeight: "bold"
    },
    listIcon: {
      minWidth: 30,
      color: theme.palette.text.primary
    },
    menuItem: {
      minHeight: theme.spacing(6)
    },
    groupWrapper: {
      margin: theme.spacing(1, 1, 2, 1)
    }
  }),
  {
    name: "CatalogReactUserListPicker"
  }
);
function getFilterGroups(orgName) {
  return [
    {
      name: "Personal",
      items: [
        {
          id: "owned",
          label: "Owned",
          icon: SettingsIcon
        },
        {
          id: "starred",
          label: "Starred",
          icon: Star
        }
      ]
    },
    {
      name: orgName != null ? orgName : "Company",
      items: [
        {
          id: "all",
          label: "All"
        }
      ]
    }
  ];
}
const UserListPicker = (props) => {
  var _a;
  const { initialFilter, availableFilters } = props;
  const classes = useStyles$3();
  const configApi = useApi(configApiRef);
  const orgName = (_a = configApi.getOptionalString("organization.name")) != null ? _a : "Company";
  const {
    filters,
    updateFilters,
    queryParameters: { kind: kindParameter, user: userParameter }
  } = useEntityList();
  const userAndGroupFilterIds = ["starred", "all"];
  const filterGroups = getFilterGroups(orgName).map((filterGroup) => ({
    ...filterGroup,
    items: filterGroup.items.filter(
      ({ id }) => (
        // TODO: avoid hardcoding kinds here
        ["group", "user"].some((kind) => kind === kindParameter) ? userAndGroupFilterIds.includes(id) : !availableFilters || availableFilters.includes(id)
      )
    )
  })).filter(({ items }) => !!items.length);
  const {
    count: ownedEntitiesCount,
    loading: loadingOwnedEntities,
    filter: ownedEntitiesFilter
  } = useOwnedEntitiesCount();
  const { count: allCount } = useAllEntitiesCount();
  const {
    count: starredEntitiesCount,
    filter: starredEntitiesFilter,
    loading: loadingStarredEntities
  } = useStarredEntitiesCount();
  const queryParamUserFilter = useMemo(
    () => [userParameter].flat()[0],
    [userParameter]
  );
  const [selectedUserFilter, setSelectedUserFilter] = useState(
    queryParamUserFilter != null ? queryParamUserFilter : initialFilter
  );
  const filterCounts = useMemo(() => {
    return {
      all: allCount,
      starred: starredEntitiesCount,
      owned: ownedEntitiesCount
    };
  }, [starredEntitiesCount, ownedEntitiesCount, allCount]);
  useEffect(() => {
    if (queryParamUserFilter) {
      setSelectedUserFilter(queryParamUserFilter);
    }
  }, [queryParamUserFilter]);
  const loading = loadingOwnedEntities || loadingStarredEntities;
  useEffect(() => {
    if (!loading && !!selectedUserFilter && selectedUserFilter !== "all" && filterCounts[selectedUserFilter] === 0) {
      setSelectedUserFilter("all");
    }
  }, [loading, filterCounts, selectedUserFilter, setSelectedUserFilter]);
  useEffect(() => {
    if (!selectedUserFilter) {
      return;
    }
    if (loading) {
      return;
    }
    const getFilter = () => {
      if (selectedUserFilter === "owned") {
        return ownedEntitiesFilter;
      }
      if (selectedUserFilter === "starred") {
        return starredEntitiesFilter;
      }
      return EntityUserFilter.all();
    };
    updateFilters({ user: getFilter() });
  }, [
    selectedUserFilter,
    starredEntitiesFilter,
    ownedEntitiesFilter,
    updateFilters,
    loading
  ]);
  return /* @__PURE__ */ React.createElement(Card, { className: classes.root }, filterGroups.map((group) => /* @__PURE__ */ React.createElement(Fragment, { key: group.name }, /* @__PURE__ */ React.createElement(
    Typography,
    {
      variant: "subtitle2",
      component: "span",
      className: classes.title
    },
    group.name
  ), /* @__PURE__ */ React.createElement(Card, { className: classes.groupWrapper }, /* @__PURE__ */ React.createElement(List, { disablePadding: true, dense: true, role: "menu", "aria-label": group.name }, group.items.map((item) => {
    var _a2, _b;
    return /* @__PURE__ */ React.createElement(
      MenuItem,
      {
        role: "none presentation",
        key: item.id,
        divider: true,
        onClick: () => setSelectedUserFilter(item.id),
        selected: item.id === ((_a2 = filters.user) == null ? void 0 : _a2.value),
        className: classes.menuItem,
        disabled: filterCounts[item.id] === 0,
        "data-testid": `user-picker-${item.id}`,
        tabIndex: 0,
        ContainerProps: { role: "menuitem" }
      },
      item.icon && /* @__PURE__ */ React.createElement(ListItemIcon, { className: classes.listIcon }, /* @__PURE__ */ React.createElement(item.icon, { fontSize: "small" })),
      /* @__PURE__ */ React.createElement(ListItemText$1, null, /* @__PURE__ */ React.createElement(Typography, { variant: "body1" }, item.label, " ")),
      /* @__PURE__ */ React.createElement(ListItemSecondaryAction, null, (_b = filterCounts[item.id]) != null ? _b : "-")
    );
  }))))));
};

const useStyles$2 = makeStyles(
  {
    input: {}
  },
  {
    name: "CatalogReactEntityProcessingStatusPickerPicker"
  }
);
const icon = /* @__PURE__ */ React.createElement(CheckBoxOutlineBlankIcon, { fontSize: "small" });
const checkedIcon = /* @__PURE__ */ React.createElement(CheckBoxIcon, { fontSize: "small" });
const EntityProcessingStatusPicker = () => {
  const classes = useStyles$2();
  const { updateFilters } = useEntityList();
  const [selectedAdvancedItems, setSelectedAdvancedItems] = useState(
    []
  );
  function orphanChange(value) {
    updateFilters({
      orphan: value ? new EntityOrphanFilter(value) : void 0
    });
  }
  function errorChange(value) {
    updateFilters({
      error: value ? new EntityErrorFilter(value) : void 0
    });
  }
  const availableAdvancedItems = ["Is Orphan", "Has Error"];
  return /* @__PURE__ */ React.createElement(Box, { pb: 1, pt: 1 }, /* @__PURE__ */ React.createElement(Typography, { variant: "button", component: "label" }, "Processing Status", /* @__PURE__ */ React.createElement(
    Autocomplete,
    {
      multiple: true,
      disableCloseOnSelect: true,
      options: availableAdvancedItems,
      value: selectedAdvancedItems,
      onChange: (_, value) => {
        setSelectedAdvancedItems(value);
        orphanChange(value.includes("Is Orphan"));
        errorChange(value.includes("Has Error"));
      },
      renderOption: (option, { selected }) => /* @__PURE__ */ React.createElement(
        FormControlLabel,
        {
          control: /* @__PURE__ */ React.createElement(
            Checkbox,
            {
              icon,
              checkedIcon,
              checked: selected
            }
          ),
          onClick: (event) => event.preventDefault(),
          label: option
        }
      ),
      size: "small",
      popupIcon: /* @__PURE__ */ React.createElement(ExpandMoreIcon, { "data-testid": "processing-status-picker-expand" }),
      renderInput: (params) => /* @__PURE__ */ React.createElement(
        TextField,
        {
          ...params,
          className: classes.input,
          variant: "outlined"
        }
      )
    }
  )));
};

const useStyles$1 = makeStyles(
  {
    input: {}
  },
  {
    name: "CatalogReactEntityNamespacePicker"
  }
);
const EntityNamespacePicker = () => {
  const classes = useStyles$1();
  return /* @__PURE__ */ React.createElement(
    EntityAutocompletePicker,
    {
      label: "Namespace",
      name: "namespace",
      path: "metadata.namespace",
      Filter: EntityNamespaceFilter,
      InputProps: { className: classes.input }
    }
  );
};

const useStyles = makeStyles$1(
  (theme) => ({
    code: {
      borderRadius: 6,
      margin: theme.spacing(2, 0),
      background: theme.palette.type === "dark" ? "#444" : theme.palette.common.white
    }
  }),
  { name: "BackstageMissingAnnotationEmptyState" }
);
function generateYamlExample(annotations, entity) {
  var _a, _b;
  const kind = (entity == null ? void 0 : entity.kind) || "Component";
  const name = (entity == null ? void 0 : entity.metadata.name) || "example";
  const type = ((_a = entity == null ? void 0 : entity.spec) == null ? void 0 : _a.type) || "website";
  const owner = ((_b = entity == null ? void 0 : entity.spec) == null ? void 0 : _b.owner) || "user:default/guest";
  const yamlText = `apiVersion: backstage.io/v1alpha1
kind: ${kind}
metadata:
  name: ${name}
  annotations:${annotations.map((ann) => `
    ${ann}: value`).join("")}
spec:
  type: ${type}
  owner: ${owner}`;
  let line = 6;
  const lineNumbers = [];
  annotations.forEach(() => {
    lineNumbers.push(line);
    line++;
  });
  return {
    yamlText,
    lineNumbers
  };
}
function generateDescription(annotations, entityKind = "Component") {
  const isSingular = annotations.length <= 1;
  return /* @__PURE__ */ React.createElement(React.Fragment, null, "The ", isSingular ? "annotation" : "annotations", " ", annotations.map((ann) => /* @__PURE__ */ React.createElement("code", null, ann)).reduce((prev, curr) => /* @__PURE__ */ React.createElement(React.Fragment, null, prev, ", ", curr)), " ", isSingular ? "is" : "are", " missing. You need to add the", " ", isSingular ? "annotation" : "annotations", " to your ", entityKind, " if you want to enable this tool.");
}
function MissingAnnotationEmptyState(props) {
  let entity;
  try {
    const entityContext = useEntity();
    entity = entityContext.entity;
  } catch (err) {
  }
  const { annotation, readMoreUrl } = props;
  const annotations = Array.isArray(annotation) ? annotation : [annotation];
  const url = readMoreUrl || "https://backstage.io/docs/features/software-catalog/well-known-annotations";
  const classes = useStyles();
  const entityKind = (entity == null ? void 0 : entity.kind) || "Component";
  const { yamlText, lineNumbers } = generateYamlExample(annotations, entity);
  return /* @__PURE__ */ React.createElement(
    EmptyState,
    {
      missing: "field",
      title: "Missing Annotation",
      description: generateDescription(annotations, entityKind),
      action: /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(Typography$1, { variant: "body1" }, "Add the annotation to your ", entityKind, " YAML as shown in the highlighted example below:"), /* @__PURE__ */ React.createElement(Box$1, { className: classes.code }, /* @__PURE__ */ React.createElement(
        CodeSnippet,
        {
          text: yamlText,
          language: "yaml",
          showLineNumbers: true,
          highlightedNumbers: lineNumbers,
          customStyle: { background: "inherit", fontSize: "115%" }
        }
      )), /* @__PURE__ */ React.createElement(Button$1, { color: "primary", component: Link, to: url }, "Read more"))
    }
  );
}

function MockEntityListContextProvider(props) {
  var _a;
  const { children, value } = props;
  const [filters, setFilters] = useState((_a = value == null ? void 0 : value.filters) != null ? _a : {});
  const updateFilters = useCallback(
    (update) => {
      setFilters((prevFilters) => {
        const newFilters = typeof update === "function" ? update(prevFilters) : update;
        return { ...prevFilters, ...newFilters };
      });
    },
    []
  );
  const defaultValues = useMemo(
    () => ({
      entities: [],
      backendEntities: [],
      queryParameters: {}
    }),
    []
  );
  const resolvedValue = useMemo(
    () => {
      var _a2, _b, _c, _d, _e;
      return {
        entities: (_a2 = value == null ? void 0 : value.entities) != null ? _a2 : defaultValues.entities,
        backendEntities: (_b = value == null ? void 0 : value.backendEntities) != null ? _b : defaultValues.backendEntities,
        updateFilters: (_c = value == null ? void 0 : value.updateFilters) != null ? _c : updateFilters,
        filters,
        loading: (_d = value == null ? void 0 : value.loading) != null ? _d : false,
        queryParameters: (_e = value == null ? void 0 : value.queryParameters) != null ? _e : defaultValues.queryParameters,
        error: value == null ? void 0 : value.error
      };
    },
    [value, defaultValues, filters, updateFilters]
  );
  return /* @__PURE__ */ React.createElement(EntityListContext.Provider, { value: resolvedValue }, children);
}

export { CatalogFilterLayout, EntityAutocompletePicker, EntityDisplayName, EntityErrorFilter, EntityKindFilter, EntityKindPicker, EntityLifecycleFilter, EntityLifecyclePicker, EntityListContext, EntityListProvider, EntityNamespaceFilter, EntityNamespacePicker, EntityOrphanFilter, EntityOwnerFilter, EntityOwnerPicker, EntityPeekAheadPopover, EntityProcessingStatusPicker, EntityRefLink, EntityRefLinks, EntitySearchBar, EntityTable, EntityTagFilter, EntityTagPicker, EntityTextFilter, EntityTypeFilter, EntityTypePicker, EntityUserFilter, FavoriteEntity, InspectEntityDialog, MissingAnnotationEmptyState, MockEntityListContextProvider, MockStarredEntitiesApi, UnregisterEntityDialog, UserListFilter, UserListPicker, catalogApiRef, columnFactories, defaultEntityPresentation, entityPresentationApiRef, entityRouteParams, entityRouteRef, getEntitySourceLocation, humanizeEntityRef, starredEntitiesApiRef, useEntityList, useEntityOwnership, useEntityPresentation, useEntityTypeFilter, useRelatedEntities, useStarredEntities, useStarredEntity };
//# sourceMappingURL=index.esm.js.map
