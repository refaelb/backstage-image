import { scmIntegrationsApiRef, scmAuthApiRef } from '@backstage/integration-react';
import { scaffolderApiRef, useTemplateSecrets, createScaffolderFieldExtension, useTaskEventStream } from '@backstage/plugin-scaffolder-react';
import { parseEntityRef, stringifyEntityRef, KubernetesValidatorFunctions, RELATION_OWNED_BY, makeValidator } from '@backstage/catalog-model';
import { ResponseError, NotFoundError } from '@backstage/errors';
import qs from 'qs';
import ObservableImpl from 'zen-observable';
import { EventSourcePolyfill } from 'event-source-polyfill';
import { CATALOG_FILTER_EXISTS } from '@backstage/catalog-client';
import { useApi, identityApiRef, createExternalRouteRef, createRouteRef, createSubRouteRef, errorApiRef, createPlugin, createApiFactory, discoveryApiRef, fetchApiRef, createRoutableExtension, alertApiRef, useRouteRef } from '@backstage/core-plugin-api';
import { catalogApiRef, humanizeEntityRef, useEntityTypeFilter } from '@backstage/plugin-catalog-react';
import { TextField, Box, Typography, Divider, FormControl as FormControl$1, FormControlLabel, Checkbox, makeStyles, useTheme, IconButton, Popover, MenuList, MenuItem, ListItemIcon, ListItemText, Paper, Button } from '@material-ui/core';
import FormControl from '@material-ui/core/FormControl';
import Autocomplete from '@material-ui/lab/Autocomplete';
import React, { useCallback, useEffect, useState, useMemo } from 'react';
import useAsync from 'react-use/lib/useAsync';
import { z } from 'zod';
import zodToJsonSchema from 'zod-to-json-schema';
import FormHelperText from '@material-ui/core/FormHelperText';
import Input from '@material-ui/core/Input';
import InputLabel from '@material-ui/core/InputLabel';
import { Select, Progress, Page, Header, Content, ErrorPanel } from '@backstage/core-components';
import useDebounce from 'react-use/lib/useDebounce';
import useEffectOnce from 'react-use/lib/useEffectOnce';
import { Autocomplete as Autocomplete$1 } from '@material-ui/lab';
import capitalize from 'lodash/capitalize';
import CheckBoxIcon from '@material-ui/icons/CheckBox';
import CheckBoxOutlineBlankIcon from '@material-ui/icons/CheckBoxOutlineBlank';
import ExpandMoreIcon from '@material-ui/icons/ExpandMore';
import { useParams, useNavigate } from 'react-router-dom';
import { useAsync as useAsync$1 } from '@react-hookz/web';
import Cancel from '@material-ui/icons/Cancel';
import Retry from '@material-ui/icons/Repeat';
import Toc from '@material-ui/icons/Toc';
import ControlPointIcon from '@material-ui/icons/ControlPoint';
import MoreVert from '@material-ui/icons/MoreVert';
import { DefaultTemplateOutputs, TaskSteps, TaskLogStream } from '@backstage/plugin-scaffolder-react/alpha';

var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
class ScaffolderClient {
  constructor(options) {
    __publicField(this, "discoveryApi");
    __publicField(this, "scmIntegrationsApi");
    __publicField(this, "fetchApi");
    __publicField(this, "identityApi");
    __publicField(this, "useLongPollingLogs");
    var _a, _b;
    this.discoveryApi = options.discoveryApi;
    this.fetchApi = (_a = options.fetchApi) != null ? _a : { fetch };
    this.scmIntegrationsApi = options.scmIntegrationsApi;
    this.useLongPollingLogs = (_b = options.useLongPollingLogs) != null ? _b : false;
    this.identityApi = options.identityApi;
  }
  async listTasks(options) {
    if (!this.identityApi) {
      throw new Error(
        "IdentityApi is not available in the ScaffolderClient, please pass through the IdentityApi to the ScaffolderClient constructor in order to use the listTasks method"
      );
    }
    const baseUrl = await this.discoveryApi.getBaseUrl("scaffolder");
    const { userEntityRef } = await this.identityApi.getBackstageIdentity();
    const query = qs.stringify(
      options.filterByOwnership === "owned" ? { createdBy: userEntityRef } : {}
    );
    const response = await this.fetchApi.fetch(`${baseUrl}/v2/tasks?${query}`);
    if (!response.ok) {
      throw await ResponseError.fromResponse(response);
    }
    return await response.json();
  }
  async getIntegrationsList(options) {
    const integrations = [
      ...this.scmIntegrationsApi.azure.list(),
      ...this.scmIntegrationsApi.bitbucket.list().filter(
        (item) => !this.scmIntegrationsApi.bitbucketCloud.byHost(item.config.host) && !this.scmIntegrationsApi.bitbucketServer.byHost(item.config.host)
      ),
      ...this.scmIntegrationsApi.bitbucketCloud.list(),
      ...this.scmIntegrationsApi.bitbucketServer.list(),
      ...this.scmIntegrationsApi.gerrit.list(),
      ...this.scmIntegrationsApi.gitea.list(),
      ...this.scmIntegrationsApi.github.list(),
      ...this.scmIntegrationsApi.gitlab.list()
    ].map((c) => ({ type: c.type, title: c.title, host: c.config.host })).filter((c) => options.allowedHosts.includes(c.host));
    return {
      integrations
    };
  }
  async getTemplateParameterSchema(templateRef) {
    const { namespace, kind, name } = parseEntityRef(templateRef, {
      defaultKind: "template"
    });
    const baseUrl = await this.discoveryApi.getBaseUrl("scaffolder");
    const templatePath = [namespace, kind, name].map((s) => encodeURIComponent(s)).join("/");
    const url = `${baseUrl}/v2/templates/${templatePath}/parameter-schema`;
    const response = await this.fetchApi.fetch(url);
    if (!response.ok) {
      throw await ResponseError.fromResponse(response);
    }
    const schema = await response.json();
    return schema;
  }
  async scaffold(options) {
    const { templateRef, values, secrets = {} } = options;
    const url = `${await this.discoveryApi.getBaseUrl("scaffolder")}/v2/tasks`;
    const response = await this.fetchApi.fetch(url, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        templateRef,
        values: { ...values },
        secrets
      })
    });
    if (response.status !== 201) {
      const status = `${response.status} ${response.statusText}`;
      const body = await response.text();
      throw new Error(`Backend request failed, ${status} ${body.trim()}`);
    }
    const { id } = await response.json();
    return { taskId: id };
  }
  async getTask(taskId) {
    const baseUrl = await this.discoveryApi.getBaseUrl("scaffolder");
    const url = `${baseUrl}/v2/tasks/${encodeURIComponent(taskId)}`;
    const response = await this.fetchApi.fetch(url);
    if (!response.ok) {
      throw await ResponseError.fromResponse(response);
    }
    return await response.json();
  }
  streamLogs(options) {
    if (this.useLongPollingLogs) {
      return this.streamLogsPolling(options);
    }
    return this.streamLogsEventStream(options);
  }
  async dryRun(options) {
    const baseUrl = await this.discoveryApi.getBaseUrl("scaffolder");
    const response = await this.fetchApi.fetch(`${baseUrl}/v2/dry-run`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        template: options.template,
        values: options.values,
        secrets: options.secrets,
        directoryContents: options.directoryContents
      })
    });
    if (!response.ok) {
      throw await ResponseError.fromResponse(response);
    }
    return response.json();
  }
  streamLogsEventStream({
    taskId,
    after
  }) {
    return new ObservableImpl((subscriber) => {
      var _a;
      const params = new URLSearchParams();
      if (after !== void 0) {
        params.set("after", String(Number(after)));
      }
      Promise.all([
        this.discoveryApi.getBaseUrl("scaffolder"),
        (_a = this.identityApi) == null ? void 0 : _a.getCredentials()
      ]).then(
        ([baseUrl, credentials]) => {
          const url = `${baseUrl}/v2/tasks/${encodeURIComponent(
            taskId
          )}/eventstream`;
          const processEvent = (event) => {
            if (event.data) {
              try {
                subscriber.next(JSON.parse(event.data));
              } catch (ex) {
                subscriber.error(ex);
              }
            }
          };
          const eventSource = new EventSourcePolyfill(url, {
            withCredentials: true,
            headers: (credentials == null ? void 0 : credentials.token) ? { Authorization: `Bearer ${credentials.token}` } : {}
          });
          eventSource.addEventListener("log", processEvent);
          eventSource.addEventListener("cancelled", processEvent);
          eventSource.addEventListener("completion", (event) => {
            processEvent(event);
            eventSource.close();
            subscriber.complete();
          });
          eventSource.addEventListener("error", (event) => {
            subscriber.error(event);
          });
        },
        (error) => {
          subscriber.error(error);
        }
      );
    });
  }
  streamLogsPolling({
    taskId,
    after: inputAfter
  }) {
    let after = inputAfter;
    return new ObservableImpl((subscriber) => {
      this.discoveryApi.getBaseUrl("scaffolder").then(async (baseUrl) => {
        while (!subscriber.closed) {
          const url = `${baseUrl}/v2/tasks/${encodeURIComponent(
            taskId
          )}/events?${qs.stringify({ after })}`;
          const response = await this.fetchApi.fetch(url);
          if (!response.ok) {
            await new Promise((resolve) => setTimeout(resolve, 1e3));
            continue;
          }
          const logs = await response.json();
          for (const event of logs) {
            after = Number(event.id);
            subscriber.next(event);
            if (event.type === "completion") {
              subscriber.complete();
              return;
            }
          }
        }
      });
    });
  }
  async listActions() {
    const baseUrl = await this.discoveryApi.getBaseUrl("scaffolder");
    const response = await this.fetchApi.fetch(`${baseUrl}/v2/actions`);
    if (!response.ok) {
      throw await ResponseError.fromResponse(response);
    }
    return await response.json();
  }
  async cancelTask(taskId) {
    const baseUrl = await this.discoveryApi.getBaseUrl("scaffolder");
    const url = `${baseUrl}/v2/tasks/${encodeURIComponent(taskId)}/cancel`;
    const response = await this.fetchApi.fetch(url, {
      method: "POST"
    });
    if (!response.ok) {
      throw await ResponseError.fromResponse(response);
    }
    return await response.json();
  }
}

function makeFieldSchemaFromZod(returnSchema, uiOptionsSchema) {
  return {
    schema: {
      returnValue: zodToJsonSchema(returnSchema),
      uiOptions: uiOptionsSchema ? zodToJsonSchema(uiOptionsSchema) : void 0
    },
    type: null,
    uiOptionsType: null
  };
}

const entityQueryFilterExpressionSchema = z.record(
  z.string().or(z.object({ exists: z.boolean().optional() })).or(z.array(z.string()))
);
const EntityPickerFieldSchema = makeFieldSchemaFromZod(
  z.string(),
  z.object({
    /**
     * @deprecated Use `catalogFilter` instead.
     */
    allowedKinds: z.array(z.string()).optional().describe(
      "DEPRECATED: Use `catalogFilter` instead. List of kinds of entities to derive options from"
    ),
    defaultKind: z.string().optional().describe(
      "The default entity kind. Options of this kind will not be prefixed."
    ),
    allowArbitraryValues: z.boolean().optional().describe("Whether to allow arbitrary user input. Defaults to true"),
    defaultNamespace: z.union([z.string(), z.literal(false)]).optional().describe(
      "The default namespace. Options with this namespace will not be prefixed."
    ),
    catalogFilter: z.array(entityQueryFilterExpressionSchema).or(entityQueryFilterExpressionSchema).optional().describe("List of key-value filter expression for entities")
  })
);
const EntityPickerSchema = EntityPickerFieldSchema.schema;

const EntityPicker = (props) => {
  var _a, _b, _c, _d, _e;
  const {
    onChange,
    schema: { title = "Entity", description = "An entity from the catalog" },
    required,
    uiSchema,
    rawErrors,
    formData,
    idSchema
  } = props;
  const catalogFilter = buildCatalogFilter(uiSchema);
  const defaultKind = (_a = uiSchema["ui:options"]) == null ? void 0 : _a.defaultKind;
  const defaultNamespace = ((_b = uiSchema["ui:options"]) == null ? void 0 : _b.defaultNamespace) || void 0;
  const catalogApi = useApi(catalogApiRef);
  const { value: entities, loading } = useAsync(async () => {
    const { items } = await catalogApi.getEntities(
      catalogFilter ? { filter: catalogFilter } : void 0
    );
    return items;
  });
  const allowArbitraryValues = (_d = (_c = uiSchema["ui:options"]) == null ? void 0 : _c.allowArbitraryValues) != null ? _d : true;
  const getLabel = useCallback(
    (ref) => {
      try {
        return humanizeEntityRef(
          parseEntityRef(ref, { defaultKind, defaultNamespace }),
          {
            defaultKind,
            defaultNamespace
          }
        );
      } catch (err) {
        return ref;
      }
    },
    [defaultKind, defaultNamespace]
  );
  const onSelect = useCallback(
    (_, ref, reason) => {
      if (typeof ref !== "string") {
        onChange(ref ? stringifyEntityRef(ref) : void 0);
      } else {
        if (reason === "blur" || reason === "create-option") {
          let entityRef = ref;
          try {
            entityRef = stringifyEntityRef(
              parseEntityRef(ref, {
                defaultKind,
                defaultNamespace
              })
            );
          } catch (err) {
          }
          if (formData !== ref || allowArbitraryValues) {
            onChange(entityRef);
          }
        }
      }
    },
    [onChange, formData, defaultKind, defaultNamespace, allowArbitraryValues]
  );
  const selectedEntity = (_e = entities == null ? void 0 : entities.find((e) => stringifyEntityRef(e) === formData)) != null ? _e : allowArbitraryValues && formData ? getLabel(formData) : "";
  useEffect(() => {
    if ((entities == null ? void 0 : entities.length) === 1 && selectedEntity === "") {
      onChange(stringifyEntityRef(entities[0]));
    }
  }, [entities, onChange, selectedEntity]);
  return /* @__PURE__ */ React.createElement(
    FormControl,
    {
      margin: "normal",
      required,
      error: (rawErrors == null ? void 0 : rawErrors.length) > 0 && !formData
    },
    /* @__PURE__ */ React.createElement(
      Autocomplete,
      {
        disabled: (entities == null ? void 0 : entities.length) === 1,
        id: idSchema == null ? void 0 : idSchema.$id,
        value: selectedEntity,
        loading,
        onChange: onSelect,
        options: entities || [],
        getOptionLabel: (option) => (
          // option can be a string due to freeSolo.
          typeof option === "string" ? option : humanizeEntityRef(option, { defaultKind, defaultNamespace })
        ),
        autoSelect: true,
        freeSolo: allowArbitraryValues,
        renderInput: (params) => /* @__PURE__ */ React.createElement(
          TextField,
          {
            ...params,
            label: title,
            margin: "dense",
            helperText: description,
            FormHelperTextProps: { margin: "dense", style: { marginLeft: 0 } },
            variant: "outlined",
            required,
            InputProps: params.InputProps
          }
        )
      }
    )
  );
};
function convertOpsValues(value) {
  if (typeof value === "object" && value.exists) {
    return CATALOG_FILTER_EXISTS;
  }
  return value == null ? void 0 : value.toString();
}
function convertSchemaFiltersToQuery(schemaFilters) {
  const query = {};
  for (const [key, value] of Object.entries(schemaFilters)) {
    if (Array.isArray(value)) {
      query[key] = value;
    } else {
      query[key] = convertOpsValues(value);
    }
  }
  return query;
}
function buildCatalogFilter(uiSchema) {
  var _a, _b;
  const allowedKinds = (_a = uiSchema["ui:options"]) == null ? void 0 : _a.allowedKinds;
  const catalogFilter = ((_b = uiSchema["ui:options"]) == null ? void 0 : _b.catalogFilter) || allowedKinds && { kind: allowedKinds };
  if (!catalogFilter) {
    return void 0;
  }
  if (Array.isArray(catalogFilter)) {
    return catalogFilter.map(convertSchemaFiltersToQuery);
  }
  return convertSchemaFiltersToQuery(catalogFilter);
}

const entityNamePickerValidation = (value, validation) => {
  if (!KubernetesValidatorFunctions.isValidObjectName(value)) {
    validation.addError(
      "Must start and end with an alphanumeric character, and contain only alphanumeric characters, hyphens, underscores, and periods. Maximum length is 63 characters."
    );
  }
};

const EntityNamePickerFieldSchema = makeFieldSchemaFromZod(z.string());
const EntityNamePickerSchema = EntityNamePickerFieldSchema.schema;

const EntityNamePicker = (props) => {
  const {
    onChange,
    required,
    schema: { title = "Name", description = "Unique name of the component" },
    rawErrors,
    formData,
    uiSchema: { "ui:autofocus": autoFocus },
    idSchema,
    placeholder
  } = props;
  return /* @__PURE__ */ React.createElement(
    TextField,
    {
      id: idSchema == null ? void 0 : idSchema.$id,
      label: title,
      placeholder,
      helperText: description,
      required,
      value: formData != null ? formData : "",
      onChange: ({ target: { value } }) => onChange(value),
      margin: "normal",
      error: (rawErrors == null ? void 0 : rawErrors.length) > 0 && !formData,
      inputProps: { autoFocus }
    }
  );
};

const OwnerPickerFieldSchema = makeFieldSchemaFromZod(
  z.string(),
  z.object({
    /**
     * @deprecated Use `catalogFilter` instead.
     */
    allowedKinds: z.array(z.string()).default(["Group", "User"]).optional().describe(
      "DEPRECATED: Use `catalogFilter` instead. List of kinds of entities to derive options from. Defaults to Group and User"
    ),
    allowArbitraryValues: z.boolean().optional().describe("Whether to allow arbitrary user input. Defaults to true"),
    defaultNamespace: z.union([z.string(), z.literal(false)]).optional().describe(
      "The default namespace. Options with this namespace will not be prefixed."
    ),
    catalogFilter: z.array(entityQueryFilterExpressionSchema).or(entityQueryFilterExpressionSchema).optional().describe("List of key-value filter expression for entities")
  })
);
const OwnerPickerSchema = OwnerPickerFieldSchema.schema;

const OwnerPicker = (props) => {
  var _a, _b, _c, _d, _e;
  const {
    schema: { title = "Owner", description = "The owner of the component" },
    uiSchema,
    ...restProps
  } = props;
  const defaultNamespace = (_a = uiSchema["ui:options"]) == null ? void 0 : _a.defaultNamespace;
  const allowedKinds = (_b = uiSchema["ui:options"]) == null ? void 0 : _b.allowedKinds;
  const catalogFilter = ((_c = uiSchema["ui:options"]) == null ? void 0 : _c.catalogFilter) || {
    kind: allowedKinds || ["Group", "User"]
  };
  const ownerUiSchema = {
    ...uiSchema,
    "ui:options": {
      catalogFilter,
      defaultKind: "Group",
      allowArbitraryValues: (_e = (_d = uiSchema["ui:options"]) == null ? void 0 : _d.allowArbitraryValues) != null ? _e : true,
      ...defaultNamespace !== void 0 ? { defaultNamespace } : {}
    }
  };
  return /* @__PURE__ */ React.createElement(
    EntityPicker,
    {
      ...restProps,
      schema: { title, description },
      uiSchema: ownerUiSchema
    }
  );
};

const RepoUrlPickerFieldSchema = makeFieldSchemaFromZod(
  z.string(),
  z.object({
    allowedHosts: z.array(z.string()).optional().describe("List of allowed SCM platform hosts"),
    allowedOrganizations: z.array(z.string()).optional().describe("List of allowed organizations in the given SCM platform"),
    allowedOwners: z.array(z.string()).optional().describe("List of allowed owners in the given SCM platform"),
    allowedProjects: z.array(z.string()).optional().describe("List of allowed projects in the given SCM platform"),
    allowedRepos: z.array(z.string()).optional().describe("List of allowed repos in the given SCM platform"),
    requestUserCredentials: z.object({
      secretsKey: z.string().describe(
        "Key used within the template secrets context to store the credential"
      ),
      additionalScopes: z.object({
        gitea: z.array(z.string()).optional().describe("Additional Gitea scopes to request"),
        gerrit: z.array(z.string()).optional().describe("Additional Gerrit scopes to request"),
        github: z.array(z.string()).optional().describe("Additional GitHub scopes to request"),
        gitlab: z.array(z.string()).optional().describe("Additional GitLab scopes to request"),
        bitbucket: z.array(z.string()).optional().describe("Additional BitBucket scopes to request"),
        azure: z.array(z.string()).optional().describe("Additional Azure scopes to request")
      }).optional().describe("Additional permission scopes to request")
    }).optional().describe(
      "If defined will request user credentials to auth against the given SCM platform"
    )
  })
);
const RepoUrlPickerSchema = RepoUrlPickerFieldSchema.schema;

const repoPickerValidation = (value, validation, context) => {
  var _a, _b;
  try {
    const { host, searchParams } = new URL(`https://${value}`);
    const integrationApi = context.apiHolder.get(scmIntegrationsApiRef);
    if (!host) {
      validation.addError(
        "Incomplete repository location provided, host not provided"
      );
    } else {
      if (((_a = integrationApi == null ? void 0 : integrationApi.byHost(host)) == null ? void 0 : _a.type) === "bitbucket") {
        if (host === "bitbucket.org" && !searchParams.get("workspace")) {
          validation.addError(
            "Incomplete repository location provided, workspace not provided"
          );
        }
        if (!searchParams.get("project")) {
          validation.addError(
            "Incomplete repository location provided, project not provided"
          );
        }
      } else if (((_b = integrationApi == null ? void 0 : integrationApi.byHost(host)) == null ? void 0 : _b.type) !== "gerrit") {
        if (!searchParams.get("owner")) {
          validation.addError(
            "Incomplete repository location provided, owner not provided"
          );
        }
      }
      if (!searchParams.get("repo")) {
        validation.addError(
          "Incomplete repository location provided, repo not provided"
        );
      }
    }
  } catch {
    validation.addError("Unable to parse the Repository URL");
  }
};

const GithubRepoPicker = (props) => {
  const { allowedOwners = [], rawErrors, state, onChange } = props;
  const ownerItems = allowedOwners ? allowedOwners.map((i) => ({ label: i, value: i })) : [{ label: "Loading...", value: "loading" }];
  const { owner } = state;
  return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(
    FormControl,
    {
      margin: "normal",
      required: true,
      error: (rawErrors == null ? void 0 : rawErrors.length) > 0 && !owner
    },
    (allowedOwners == null ? void 0 : allowedOwners.length) ? /* @__PURE__ */ React.createElement(
      Select,
      {
        native: true,
        label: "Owner Available",
        onChange: (s) => onChange({ owner: String(Array.isArray(s) ? s[0] : s) }),
        disabled: allowedOwners.length === 1,
        selected: owner,
        items: ownerItems
      }
    ) : /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(InputLabel, { htmlFor: "ownerInput" }, "Owner"), /* @__PURE__ */ React.createElement(
      Input,
      {
        id: "ownerInput",
        onChange: (e) => onChange({ owner: e.target.value }),
        value: owner
      }
    )),
    /* @__PURE__ */ React.createElement(FormHelperText, null, "The organization, user or project that this repo will belong to")
  ));
};

const GiteaRepoPicker = (props) => {
  const { allowedOwners = [], state, onChange, rawErrors } = props;
  const ownerItems = allowedOwners ? allowedOwners.map((i) => ({ label: i, value: i })) : [{ label: "Loading...", value: "loading" }];
  const { owner } = state;
  return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(
    FormControl,
    {
      margin: "normal",
      required: true,
      error: (rawErrors == null ? void 0 : rawErrors.length) > 0 && !owner
    },
    (allowedOwners == null ? void 0 : allowedOwners.length) ? /* @__PURE__ */ React.createElement(
      Select,
      {
        native: true,
        label: "Owner Available",
        onChange: (selected) => onChange({
          owner: String(Array.isArray(selected) ? selected[0] : selected)
        }),
        disabled: allowedOwners.length === 1,
        selected: owner,
        items: ownerItems
      }
    ) : /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(InputLabel, { htmlFor: "ownerInput" }, "Owner"), /* @__PURE__ */ React.createElement(
      Input,
      {
        id: "ownerInput",
        onChange: (e) => onChange({ owner: e.target.value }),
        value: owner
      }
    )),
    /* @__PURE__ */ React.createElement(FormHelperText, null, "Gitea namespace where this repository will belong to. It can be the name of organization, group, subgroup, user, or the project.")
  ));
};

const GitlabRepoPicker = (props) => {
  const { allowedOwners = [], state, onChange, rawErrors } = props;
  const ownerItems = allowedOwners ? allowedOwners.map((i) => ({ label: i, value: i })) : [{ label: "Loading...", value: "loading" }];
  const { owner } = state;
  return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(
    FormControl,
    {
      margin: "normal",
      required: true,
      error: (rawErrors == null ? void 0 : rawErrors.length) > 0 && !owner
    },
    (allowedOwners == null ? void 0 : allowedOwners.length) ? /* @__PURE__ */ React.createElement(
      Select,
      {
        native: true,
        label: "Owner Available",
        onChange: (selected) => onChange({
          owner: String(Array.isArray(selected) ? selected[0] : selected)
        }),
        disabled: allowedOwners.length === 1,
        selected: owner,
        items: ownerItems
      }
    ) : /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(InputLabel, { htmlFor: "ownerInput" }, "Owner"), /* @__PURE__ */ React.createElement(
      Input,
      {
        id: "ownerInput",
        onChange: (e) => onChange({ owner: e.target.value }),
        value: owner
      }
    )),
    /* @__PURE__ */ React.createElement(FormHelperText, null, "GitLab namespace where this repository will belong to. It can be the name of organization, group, subgroup, user, or the project.")
  ));
};

const AzureRepoPicker = (props) => {
  const {
    allowedOrganizations = [],
    allowedOwners = [],
    rawErrors,
    state,
    onChange
  } = props;
  const organizationItems = allowedOrganizations ? allowedOrganizations.map((i) => ({ label: i, value: i })) : [{ label: "Loading...", value: "loading" }];
  const ownerItems = allowedOwners ? allowedOwners.map((i) => ({ label: i, value: i })) : [{ label: "Loading...", value: "loading" }];
  const { organization, owner } = state;
  return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(
    FormControl,
    {
      margin: "normal",
      required: true,
      error: (rawErrors == null ? void 0 : rawErrors.length) > 0 && !organization
    },
    (allowedOrganizations == null ? void 0 : allowedOrganizations.length) ? /* @__PURE__ */ React.createElement(
      Select,
      {
        native: true,
        label: "Organization",
        onChange: (s) => onChange({ organization: String(Array.isArray(s) ? s[0] : s) }),
        disabled: allowedOrganizations.length === 1,
        selected: organization,
        items: organizationItems
      }
    ) : /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(InputLabel, { htmlFor: "orgInput" }, "Organization"), /* @__PURE__ */ React.createElement(
      Input,
      {
        id: "orgInput",
        onChange: (e) => onChange({ organization: e.target.value }),
        value: organization
      }
    )),
    /* @__PURE__ */ React.createElement(FormHelperText, null, "The Organization that this repo will belong to")
  ), /* @__PURE__ */ React.createElement(
    FormControl,
    {
      margin: "normal",
      required: true,
      error: (rawErrors == null ? void 0 : rawErrors.length) > 0 && !owner
    },
    (allowedOwners == null ? void 0 : allowedOwners.length) ? /* @__PURE__ */ React.createElement(
      Select,
      {
        native: true,
        label: "Owner",
        onChange: (s) => onChange({ owner: String(Array.isArray(s) ? s[0] : s) }),
        disabled: allowedOwners.length === 1,
        selected: owner,
        items: ownerItems
      }
    ) : /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(InputLabel, { htmlFor: "ownerInput" }, "Project"), /* @__PURE__ */ React.createElement(
      Input,
      {
        id: "ownerInput",
        onChange: (e) => onChange({ owner: e.target.value }),
        value: owner
      }
    )),
    /* @__PURE__ */ React.createElement(FormHelperText, null, "The Project that this repo will belong to")
  ));
};

const BitbucketRepoPicker = (props) => {
  const {
    allowedOwners = [],
    allowedProjects = [],
    onChange,
    rawErrors,
    state
  } = props;
  const { host, workspace, project } = state;
  const ownerItems = allowedOwners ? allowedOwners == null ? void 0 : allowedOwners.map((i) => ({ label: i, value: i })) : [];
  const projectItems = allowedProjects ? allowedProjects == null ? void 0 : allowedProjects.map((i) => ({ label: i, value: i })) : [];
  useEffect(() => {
    if (host === "bitbucket.org" && allowedOwners.length) {
      onChange({ workspace: allowedOwners[0] });
    }
  }, [allowedOwners, host, onChange]);
  return /* @__PURE__ */ React.createElement(React.Fragment, null, host === "bitbucket.org" && /* @__PURE__ */ React.createElement(
    FormControl,
    {
      margin: "normal",
      required: true,
      error: (rawErrors == null ? void 0 : rawErrors.length) > 0 && !workspace
    },
    (allowedOwners == null ? void 0 : allowedOwners.length) ? /* @__PURE__ */ React.createElement(
      Select,
      {
        native: true,
        label: "Allowed Workspaces",
        onChange: (s) => onChange({ workspace: String(Array.isArray(s) ? s[0] : s) }),
        disabled: allowedOwners.length === 1,
        selected: workspace,
        items: ownerItems
      }
    ) : /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(InputLabel, { htmlFor: "workspaceInput" }, "Workspace"), /* @__PURE__ */ React.createElement(
      Input,
      {
        id: "workspaceInput",
        onChange: (e) => onChange({ workspace: e.target.value }),
        value: workspace
      }
    )),
    /* @__PURE__ */ React.createElement(FormHelperText, null, "The Workspace that this repo will belong to")
  ), /* @__PURE__ */ React.createElement(
    FormControl,
    {
      margin: "normal",
      required: true,
      error: (rawErrors == null ? void 0 : rawErrors.length) > 0 && !project
    },
    (allowedProjects == null ? void 0 : allowedProjects.length) ? /* @__PURE__ */ React.createElement(
      Select,
      {
        native: true,
        label: "Allowed Projects",
        onChange: (s) => onChange({ project: String(Array.isArray(s) ? s[0] : s) }),
        disabled: allowedProjects.length === 1,
        selected: project,
        items: projectItems
      }
    ) : /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(InputLabel, { htmlFor: "projectInput" }, "Project"), /* @__PURE__ */ React.createElement(
      Input,
      {
        id: "projectInput",
        onChange: (e) => onChange({ project: e.target.value }),
        value: project
      }
    )),
    /* @__PURE__ */ React.createElement(FormHelperText, null, "The Project that this repo will belong to")
  ));
};

const GerritRepoPicker = (props) => {
  const { onChange, rawErrors, state } = props;
  const { workspace, owner } = state;
  return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(FormControl, { margin: "normal", error: (rawErrors == null ? void 0 : rawErrors.length) > 0 && !workspace }, /* @__PURE__ */ React.createElement(InputLabel, { htmlFor: "ownerInput" }, "Owner"), /* @__PURE__ */ React.createElement(
    Input,
    {
      id: "ownerInput",
      onChange: (e) => onChange({ owner: e.target.value }),
      value: owner
    }
  ), /* @__PURE__ */ React.createElement(FormHelperText, null, "The owner of the project (optional)")), /* @__PURE__ */ React.createElement(
    FormControl,
    {
      margin: "normal",
      required: true,
      error: (rawErrors == null ? void 0 : rawErrors.length) > 0 && !workspace
    },
    /* @__PURE__ */ React.createElement(InputLabel, { htmlFor: "parentInput" }, "Parent"),
    /* @__PURE__ */ React.createElement(
      Input,
      {
        id: "parentInput",
        onChange: (e) => onChange({ workspace: e.target.value }),
        value: workspace
      }
    ),
    /* @__PURE__ */ React.createElement(FormHelperText, null, "The project parent that the repo will belong to")
  ));
};

const RepoUrlPickerHost = (props) => {
  const { host, hosts, onChange, rawErrors } = props;
  const scaffolderApi = useApi(scaffolderApiRef);
  const { value: { integrations } = { integrations: [] }, loading } = useAsync(
    async () => {
      return await scaffolderApi.getIntegrationsList({
        allowedHosts: hosts != null ? hosts : []
      });
    }
  );
  useEffect(() => {
    if (!host) {
      if (hosts == null ? void 0 : hosts.length) {
        onChange(hosts[0]);
      } else if (integrations == null ? void 0 : integrations.length) {
        onChange(integrations[0].host);
      }
    }
  }, [hosts, host, onChange, integrations]);
  const hostsOptions = integrations ? integrations.filter((i) => (hosts == null ? void 0 : hosts.length) ? hosts == null ? void 0 : hosts.includes(i.host) : true).map((i) => ({ label: i.title, value: i.host })) : [{ label: "Loading...", value: "loading" }];
  if (loading) {
    return /* @__PURE__ */ React.createElement(Progress, null);
  }
  return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(
    FormControl,
    {
      margin: "normal",
      required: true,
      error: (rawErrors == null ? void 0 : rawErrors.length) > 0 && !host
    },
    /* @__PURE__ */ React.createElement(
      Select,
      {
        native: true,
        disabled: (hosts == null ? void 0 : hosts.length) === 1,
        label: "Host",
        onChange: (s) => onChange(String(Array.isArray(s) ? s[0] : s)),
        selected: host,
        items: hostsOptions,
        "data-testid": "host-select"
      }
    ),
    /* @__PURE__ */ React.createElement(FormHelperText, null, "The host where the repository will be created")
  ));
};

const RepoUrlPickerRepoName = (props) => {
  const { repoName, allowedRepos, onChange, rawErrors } = props;
  useEffect(() => {
    if (!repoName) {
      if (allowedRepos == null ? void 0 : allowedRepos.length) {
        onChange(allowedRepos[0]);
      }
    }
  }, [allowedRepos, repoName, onChange]);
  const repoItems = allowedRepos ? allowedRepos.map((i) => ({ label: i, value: i })) : [{ label: "Loading...", value: "loading" }];
  return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(
    FormControl,
    {
      margin: "normal",
      required: true,
      error: (rawErrors == null ? void 0 : rawErrors.length) > 0 && !repoName
    },
    (allowedRepos == null ? void 0 : allowedRepos.length) ? /* @__PURE__ */ React.createElement(
      Select,
      {
        native: true,
        label: "Repositories Available",
        onChange: (selected) => onChange(String(Array.isArray(selected) ? selected[0] : selected)),
        disabled: allowedRepos.length === 1,
        selected: repoName,
        items: repoItems
      }
    ) : /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(InputLabel, { htmlFor: "repoNameInput" }, "Repository"), /* @__PURE__ */ React.createElement(
      Input,
      {
        id: "repoNameInput",
        onChange: (e) => onChange(String(e.target.value)),
        value: repoName
      }
    )),
    /* @__PURE__ */ React.createElement(FormHelperText, null, "The name of the repository")
  ));
};

function serializeRepoPickerUrl(data) {
  if (!data.host) {
    return void 0;
  }
  const params = new URLSearchParams();
  if (data.owner) {
    params.set("owner", data.owner);
  }
  if (data.repoName) {
    params.set("repo", data.repoName);
  }
  if (data.organization) {
    params.set("organization", data.organization);
  }
  if (data.workspace) {
    params.set("workspace", data.workspace);
  }
  if (data.project) {
    params.set("project", data.project);
  }
  return `${data.host}?${params.toString()}`;
}
function parseRepoPickerUrl(url) {
  let host = "";
  let owner = "";
  let repoName = "";
  let organization = "";
  let workspace = "";
  let project = "";
  try {
    if (url) {
      const parsed = new URL(`https://${url}`);
      host = parsed.host;
      owner = parsed.searchParams.get("owner") || "";
      repoName = parsed.searchParams.get("repo") || "";
      organization = parsed.searchParams.get("organization") || "";
      workspace = parsed.searchParams.get("workspace") || "";
      project = parsed.searchParams.get("project") || "";
    }
  } catch {
  }
  return { host, owner, repoName, organization, workspace, project };
}

const RepoUrlPicker = (props) => {
  var _a, _b;
  const { uiSchema, onChange, rawErrors, formData, schema } = props;
  const [state, setState] = useState(
    parseRepoPickerUrl(formData)
  );
  const integrationApi = useApi(scmIntegrationsApiRef);
  const scmAuthApi = useApi(scmAuthApiRef);
  const { setSecrets } = useTemplateSecrets();
  const allowedHosts = useMemo(
    () => {
      var _a2, _b2;
      return (_b2 = (_a2 = uiSchema == null ? void 0 : uiSchema["ui:options"]) == null ? void 0 : _a2.allowedHosts) != null ? _b2 : [];
    },
    [uiSchema]
  );
  const allowedOrganizations = useMemo(
    () => {
      var _a2, _b2;
      return (_b2 = (_a2 = uiSchema == null ? void 0 : uiSchema["ui:options"]) == null ? void 0 : _a2.allowedOrganizations) != null ? _b2 : [];
    },
    [uiSchema]
  );
  const allowedOwners = useMemo(
    () => {
      var _a2, _b2;
      return (_b2 = (_a2 = uiSchema == null ? void 0 : uiSchema["ui:options"]) == null ? void 0 : _a2.allowedOwners) != null ? _b2 : [];
    },
    [uiSchema]
  );
  const allowedProjects = useMemo(
    () => {
      var _a2, _b2;
      return (_b2 = (_a2 = uiSchema == null ? void 0 : uiSchema["ui:options"]) == null ? void 0 : _a2.allowedProjects) != null ? _b2 : [];
    },
    [uiSchema]
  );
  const allowedRepos = useMemo(
    () => {
      var _a2, _b2;
      return (_b2 = (_a2 = uiSchema == null ? void 0 : uiSchema["ui:options"]) == null ? void 0 : _a2.allowedRepos) != null ? _b2 : [];
    },
    [uiSchema]
  );
  const { owner, organization, project, repoName } = state;
  useEffect(() => {
    onChange(serializeRepoPickerUrl(state));
  }, [state, onChange]);
  useEffect(() => {
    if (allowedOrganizations.length > 0 && !organization) {
      setState((prevState) => ({
        ...prevState,
        organization: allowedOrganizations[0]
      }));
    }
  }, [setState, allowedOrganizations, organization]);
  useEffect(() => {
    if (allowedOwners.length > 0 && !owner) {
      setState((prevState) => ({
        ...prevState,
        owner: allowedOwners[0]
      }));
    }
  }, [setState, allowedOwners, owner]);
  useEffect(() => {
    if (allowedProjects.length > 0 && !project) {
      setState((prevState) => ({
        ...prevState,
        project: allowedProjects[0]
      }));
    }
  }, [setState, allowedProjects, project]);
  useEffect(() => {
    if (allowedRepos.length > 0 && !repoName) {
      setState((prevState) => ({ ...prevState, repoName: allowedRepos[0] }));
    }
  }, [setState, allowedRepos, repoName]);
  const updateLocalState = useCallback(
    (newState) => {
      setState((prevState) => ({ ...prevState, ...newState }));
    },
    [setState]
  );
  useDebounce(
    async () => {
      var _a2;
      const { requestUserCredentials } = (_a2 = uiSchema == null ? void 0 : uiSchema["ui:options"]) != null ? _a2 : {};
      const workspace = state.owner ? state.owner : state.project;
      if (!requestUserCredentials || !(state.host && workspace && state.repoName)) {
        return;
      }
      const [encodedHost, encodedRepoName] = [state.host, state.repoName].map(
        encodeURIComponent
      );
      const { token } = await scmAuthApi.getCredentials({
        url: `https://${encodedHost}/${workspace}/${encodedRepoName}`,
        additionalScope: {
          repoWrite: true,
          customScopes: requestUserCredentials.additionalScopes
        }
      });
      setSecrets({ [requestUserCredentials.secretsKey]: token });
    },
    500,
    [state, uiSchema]
  );
  const hostType = (_b = state.host && ((_a = integrationApi.byHost(state.host)) == null ? void 0 : _a.type)) != null ? _b : null;
  return /* @__PURE__ */ React.createElement(React.Fragment, null, schema.title && /* @__PURE__ */ React.createElement(Box, { my: 1 }, /* @__PURE__ */ React.createElement(Typography, { variant: "h5" }, schema.title), /* @__PURE__ */ React.createElement(Divider, null)), schema.description && /* @__PURE__ */ React.createElement(Typography, { variant: "body1" }, schema.description), /* @__PURE__ */ React.createElement(
    RepoUrlPickerHost,
    {
      host: state.host,
      hosts: allowedHosts,
      onChange: (host) => setState((prevState) => ({ ...prevState, host })),
      rawErrors
    }
  ), hostType === "github" && /* @__PURE__ */ React.createElement(
    GithubRepoPicker,
    {
      allowedOwners,
      onChange: updateLocalState,
      rawErrors,
      state
    }
  ), hostType === "gitea" && /* @__PURE__ */ React.createElement(
    GiteaRepoPicker,
    {
      allowedOwners,
      allowedRepos,
      rawErrors,
      state,
      onChange: updateLocalState
    }
  ), hostType === "gitlab" && /* @__PURE__ */ React.createElement(
    GitlabRepoPicker,
    {
      allowedOwners,
      rawErrors,
      state,
      onChange: updateLocalState
    }
  ), hostType === "bitbucket" && /* @__PURE__ */ React.createElement(
    BitbucketRepoPicker,
    {
      allowedOwners,
      allowedProjects,
      rawErrors,
      state,
      onChange: updateLocalState
    }
  ), hostType === "azure" && /* @__PURE__ */ React.createElement(
    AzureRepoPicker,
    {
      allowedOrganizations,
      allowedOwners,
      rawErrors,
      state,
      onChange: updateLocalState
    }
  ), hostType === "gerrit" && /* @__PURE__ */ React.createElement(
    GerritRepoPicker,
    {
      rawErrors,
      state,
      onChange: updateLocalState
    }
  ), /* @__PURE__ */ React.createElement(
    RepoUrlPickerRepoName,
    {
      repoName: state.repoName,
      allowedRepos,
      onChange: (repo) => setState((prevState) => ({ ...prevState, repoName: repo })),
      rawErrors
    }
  ));
};

const OwnedEntityPickerFieldSchema = makeFieldSchemaFromZod(
  z.string(),
  z.object({
    allowedKinds: z.array(z.string()).optional().describe(
      "DEPRECATED: Use `catalogFilter` instead. List of kinds of entities to derive options from"
    ),
    defaultKind: z.string().optional().describe(
      "The default entity kind. Options of this kind will not be prefixed."
    ),
    allowArbitraryValues: z.boolean().optional().describe("Whether to allow arbitrary user input. Defaults to true"),
    defaultNamespace: z.union([z.string(), z.literal(false)]).optional().describe(
      "The default namespace. Options with this namespace will not be prefixed."
    ),
    catalogFilter: z.array(entityQueryFilterExpressionSchema).or(entityQueryFilterExpressionSchema).optional().describe("List of key-value filter expression for entities")
  })
);
const OwnedEntityPickerSchema = OwnedEntityPickerFieldSchema.schema;

const OwnedEntityPicker = (props) => {
  const {
    schema: { title = "Entity", description = "An entity from the catalog" },
    uiSchema,
    required
  } = props;
  const identityApi = useApi(identityApiRef);
  const { loading, value: identityRefs } = useAsync(async () => {
    const identity = await identityApi.getBackstageIdentity();
    return identity.ownershipEntityRefs;
  });
  if (loading)
    return /* @__PURE__ */ React.createElement(
      Autocomplete,
      {
        loading,
        renderInput: (params) => /* @__PURE__ */ React.createElement(
          TextField,
          {
            ...params,
            label: title,
            margin: "dense",
            helperText: description,
            FormHelperTextProps: { margin: "dense", style: { marginLeft: 0 } },
            variant: "outlined",
            required,
            InputProps: params.InputProps
          }
        ),
        options: []
      }
    );
  const entityPickerUISchema = buildEntityPickerUISchema(
    uiSchema,
    identityRefs
  );
  return /* @__PURE__ */ React.createElement(EntityPicker, { ...props, uiSchema: entityPickerUISchema });
};
function buildEntityPickerUISchema(uiSchema, identityRefs) {
  const uiOptions = (uiSchema == null ? void 0 : uiSchema["ui:options"]) || {};
  const allowedKinds = uiOptions.allowedKinds;
  const catalogFilter = {
    ...uiOptions.catalogFilter,
    ...allowedKinds ? {
      kind: allowedKinds,
      [`relations.${RELATION_OWNED_BY}`]: identityRefs || []
    } : {
      [`relations.${RELATION_OWNED_BY}`]: identityRefs || []
    }
  };
  return {
    "ui:options": {
      catalogFilter
    }
  };
}

const EntityTagsPickerFieldSchema = makeFieldSchemaFromZod(
  z.array(z.string()),
  z.object({
    kinds: z.array(z.string()).optional().describe("List of kinds of entities to derive tags from"),
    showCounts: z.boolean().optional().describe("Whether to show usage counts per tag"),
    helperText: z.string().optional().describe("Helper text to display")
  })
);
const EntityTagsPickerSchema = EntityTagsPickerFieldSchema.schema;

const EntityTagsPicker = (props) => {
  var _a, _b, _c;
  const { formData, onChange, uiSchema } = props;
  const catalogApi = useApi(catalogApiRef);
  const [tagOptions, setTagOptions] = useState([]);
  const [inputValue, setInputValue] = useState("");
  const [inputError, setInputError] = useState(false);
  const tagValidator = makeValidator().isValidTag;
  const kinds = (_a = uiSchema["ui:options"]) == null ? void 0 : _a.kinds;
  const showCounts = (_b = uiSchema["ui:options"]) == null ? void 0 : _b.showCounts;
  const helperText = (_c = uiSchema["ui:options"]) == null ? void 0 : _c.helperText;
  const { loading, value: existingTags } = useAsync(async () => {
    const facet = "metadata.tags";
    const tagsRequest = { facets: [facet] };
    if (kinds) {
      tagsRequest.filter = { kind: kinds };
    }
    const { facets } = await catalogApi.getEntityFacets(tagsRequest);
    const tagFacets = Object.fromEntries(
      facets[facet].map(({ value, count }) => [value, count])
    );
    setTagOptions(
      Object.keys(tagFacets).sort(
        (a, b) => showCounts ? tagFacets[b] - tagFacets[a] : a.localeCompare(b)
      )
    );
    return tagFacets;
  });
  const setTags = (_, values) => {
    let hasError = false;
    let addDuplicate = false;
    const currentTags = formData || [];
    if ((values == null ? void 0 : values.length) && currentTags.length < values.length) {
      const newTag = values[values.length - 1] = values[values.length - 1].toLocaleLowerCase("en-US").trim();
      hasError = !tagValidator(newTag);
      addDuplicate = currentTags.indexOf(newTag) !== -1;
    }
    setInputError(hasError);
    setInputValue(!hasError ? "" : inputValue);
    if (!hasError && !addDuplicate) {
      onChange(values || []);
    }
  };
  useEffectOnce(() => onChange(formData || []));
  return /* @__PURE__ */ React.createElement(FormControl$1, { margin: "normal" }, /* @__PURE__ */ React.createElement(
    Autocomplete$1,
    {
      multiple: true,
      freeSolo: true,
      filterSelectedOptions: true,
      onChange: setTags,
      value: formData || [],
      inputValue,
      loading,
      options: tagOptions,
      ChipProps: { size: "small" },
      renderOption: (option) => showCounts ? `${option} (${existingTags == null ? void 0 : existingTags[option]})` : option,
      renderInput: (params) => /* @__PURE__ */ React.createElement(
        TextField,
        {
          ...params,
          label: "Tags",
          onChange: (e) => setInputValue(e.target.value),
          error: inputError,
          helperText: helperText != null ? helperText : "Add any relevant tags, hit 'Enter' to add new tags. Valid format: [a-z0-9+#] separated by [-], at most 63 characters"
        }
      )
    }
  ));
};

const registerComponentRouteRef = createExternalRouteRef({
  id: "register-component",
  optional: true
});
const viewTechDocRouteRef = createExternalRouteRef({
  id: "view-techdoc",
  optional: true,
  params: ["namespace", "kind", "name"]
});
const rootRouteRef = createRouteRef({
  id: "scaffolder"
});
const legacySelectedTemplateRouteRef = createSubRouteRef({
  id: "scaffolder/legacy/selected-template",
  parent: rootRouteRef,
  path: "/templates/:templateName"
});
const selectedTemplateRouteRef = createSubRouteRef({
  id: "scaffolder/selected-template",
  parent: rootRouteRef,
  path: "/templates/:namespace/:templateName"
});
const scaffolderTaskRouteRef = createSubRouteRef({
  id: "scaffolder/task",
  parent: rootRouteRef,
  path: "/tasks/:taskId"
});
const scaffolderListTaskRouteRef = createSubRouteRef({
  id: "scaffolder/list-tasks",
  parent: rootRouteRef,
  path: "/tasks"
});
const actionsRouteRef = createSubRouteRef({
  id: "scaffolder/actions",
  parent: rootRouteRef,
  path: "/actions"
});
const editRouteRef = createSubRouteRef({
  id: "scaffolder/edit",
  parent: rootRouteRef,
  path: "/edit"
});

const MyGroupsPickerFieldSchema = makeFieldSchemaFromZod(
  z.string(),
  z.object({
    title: z.string().default("Group").describe("Group"),
    description: z.string().default("A group you are part of").describe("The group to which the entity belongs")
  })
);
const MyGroupsPickerSchema = MyGroupsPickerFieldSchema.schema;

const MyGroupsPicker = (props) => {
  const {
    schema: { title, description },
    required,
    rawErrors,
    onChange
  } = props;
  const identityApi = useApi(identityApiRef);
  const catalogApi = useApi(catalogApiRef);
  const errorApi = useApi(errorApiRef);
  const [groups, setGroups] = useState([]);
  const [selectedGroup, setSelectedGroup] = useState(null);
  useAsync(async () => {
    const { userEntityRef } = await identityApi.getBackstageIdentity();
    if (!userEntityRef) {
      errorApi.post(new NotFoundError("No user entity ref found"));
      return;
    }
    const { items } = await catalogApi.getEntities({
      filter: {
        kind: "Group",
        ["relations.hasMember"]: [userEntityRef]
      }
    });
    const groupValues = items.filter((e) => Boolean(e)).map((item) => {
      var _a;
      return {
        label: (_a = item.metadata.title) != null ? _a : item.metadata.name,
        ref: stringifyEntityRef(item)
      };
    });
    setGroups(groupValues);
  });
  const updateChange = (_, value) => {
    var _a;
    setSelectedGroup(value);
    onChange((_a = value == null ? void 0 : value.ref) != null ? _a : "");
  };
  return /* @__PURE__ */ React.createElement(
    FormControl$1,
    {
      margin: "normal",
      required,
      error: (rawErrors == null ? void 0 : rawErrors.length) > 0
    },
    /* @__PURE__ */ React.createElement(
      Autocomplete$1,
      {
        id: "OwnershipEntityRefPicker-dropdown",
        options: groups || [],
        value: selectedGroup,
        onChange: updateChange,
        getOptionLabel: (group) => group.label,
        renderInput: (params) => /* @__PURE__ */ React.createElement(
          TextField,
          {
            ...params,
            label: title,
            margin: "dense",
            helperText: description,
            FormHelperTextProps: { margin: "dense", style: { marginLeft: 0 } },
            variant: "outlined",
            required
          }
        )
      }
    )
  );
};

const scaffolderPlugin = createPlugin({
  id: "scaffolder",
  apis: [
    createApiFactory({
      api: scaffolderApiRef,
      deps: {
        discoveryApi: discoveryApiRef,
        scmIntegrationsApi: scmIntegrationsApiRef,
        fetchApi: fetchApiRef,
        identityApi: identityApiRef
      },
      factory: ({ discoveryApi, scmIntegrationsApi, fetchApi, identityApi }) => new ScaffolderClient({
        discoveryApi,
        scmIntegrationsApi,
        fetchApi,
        identityApi
      })
    })
  ],
  routes: {
    root: rootRouteRef,
    selectedTemplate: selectedTemplateRouteRef,
    ongoingTask: scaffolderTaskRouteRef,
    actions: actionsRouteRef,
    listTasks: scaffolderListTaskRouteRef,
    edit: editRouteRef
  },
  externalRoutes: {
    registerComponent: registerComponentRouteRef,
    viewTechDoc: viewTechDocRouteRef
  }
});
const EntityPickerFieldExtension = scaffolderPlugin.provide(
  createScaffolderFieldExtension({
    component: EntityPicker,
    name: "EntityPicker",
    schema: EntityPickerSchema
  })
);
const EntityNamePickerFieldExtension = scaffolderPlugin.provide(
  createScaffolderFieldExtension({
    component: EntityNamePicker,
    name: "EntityNamePicker",
    validation: entityNamePickerValidation,
    schema: EntityNamePickerSchema
  })
);
const RepoUrlPickerFieldExtension = scaffolderPlugin.provide(
  createScaffolderFieldExtension({
    component: RepoUrlPicker,
    name: "RepoUrlPicker",
    validation: repoPickerValidation,
    schema: RepoUrlPickerSchema
  })
);
const OwnerPickerFieldExtension = scaffolderPlugin.provide(
  createScaffolderFieldExtension({
    component: OwnerPicker,
    name: "OwnerPicker",
    schema: OwnerPickerSchema
  })
);
const MyGroupsPickerFieldExtension = scaffolderPlugin.provide(
  createScaffolderFieldExtension({
    component: MyGroupsPicker,
    name: "MyGroupsPicker",
    schema: MyGroupsPickerSchema
  })
);
const ScaffolderPage = scaffolderPlugin.provide(
  createRoutableExtension({
    name: "ScaffolderPage",
    component: () => import('./index-38156f16.esm.js').then((m) => m.Router),
    mountPoint: rootRouteRef
  })
);
const OwnedEntityPickerFieldExtension = scaffolderPlugin.provide(
  createScaffolderFieldExtension({
    component: OwnedEntityPicker,
    name: "OwnedEntityPicker",
    schema: OwnedEntityPickerSchema
  })
);
const EntityTagsPickerFieldExtension = scaffolderPlugin.provide(
  createScaffolderFieldExtension({
    component: EntityTagsPicker,
    name: "EntityTagsPicker",
    schema: EntityTagsPickerSchema
  })
);
const LegacyScaffolderPage = scaffolderPlugin.provide(
  createRoutableExtension({
    name: "LegacyScaffolderPage",
    component: () => import('./Router-5d4d36fb.esm.js').then((m) => m.LegacyRouter),
    mountPoint: rootRouteRef
  })
);

const icon = /* @__PURE__ */ React.createElement(CheckBoxOutlineBlankIcon, { fontSize: "small" });
const checkedIcon = /* @__PURE__ */ React.createElement(CheckBoxIcon, { fontSize: "small" });
const TemplateTypePicker = () => {
  const alertApi = useApi(alertApiRef);
  const { error, loading, availableTypes, selectedTypes, setSelectedTypes } = useEntityTypeFilter();
  if (loading)
    return /* @__PURE__ */ React.createElement(Progress, null);
  if (!availableTypes)
    return null;
  if (error) {
    alertApi.post({
      message: `Failed to load entity types`,
      severity: "error"
    });
    return null;
  }
  return /* @__PURE__ */ React.createElement(Box, { pb: 1, pt: 1 }, /* @__PURE__ */ React.createElement(
    Typography,
    {
      variant: "button",
      component: "label",
      htmlFor: "categories-picker"
    },
    "Categories"
  ), /* @__PURE__ */ React.createElement(
    Autocomplete$1,
    {
      id: "categories-picker",
      multiple: true,
      options: availableTypes,
      value: selectedTypes,
      onChange: (_, value) => setSelectedTypes(value),
      renderOption: (option, { selected }) => /* @__PURE__ */ React.createElement(
        FormControlLabel,
        {
          control: /* @__PURE__ */ React.createElement(
            Checkbox,
            {
              icon,
              checkedIcon,
              checked: selected
            }
          ),
          label: capitalize(option)
        }
      ),
      size: "small",
      popupIcon: /* @__PURE__ */ React.createElement(ExpandMoreIcon, { "data-testid": "categories-picker-expand" }),
      renderInput: (params) => /* @__PURE__ */ React.createElement(TextField, { ...params, variant: "outlined" })
    }
  ));
};

const useStyles$1 = makeStyles(() => ({
  button: {
    color: ({ fontColor }) => fontColor
  }
}));
const ContextMenu = (props) => {
  const {
    cancelEnabled,
    logsVisible,
    buttonBarVisible,
    onStartOver,
    onToggleLogs,
    onToggleButtonBar,
    taskId
  } = props;
  const { getPageTheme } = useTheme();
  const pageTheme = getPageTheme({ themeId: "website" });
  const classes = useStyles$1({ fontColor: pageTheme.fontColor });
  const scaffolderApi = useApi(scaffolderApiRef);
  const [anchorEl, setAnchorEl] = useState();
  const [{ status: cancelStatus }, { execute: cancel }] = useAsync$1(async () => {
    if (taskId) {
      await scaffolderApi.cancelTask(taskId);
    }
  });
  return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(
    IconButton,
    {
      "aria-label": "more",
      "aria-controls": "long-menu",
      "aria-haspopup": "true",
      onClick: (event) => {
        setAnchorEl(event.currentTarget);
      },
      "data-testid": "menu-button",
      className: classes.button
    },
    /* @__PURE__ */ React.createElement(MoreVert, null)
  ), /* @__PURE__ */ React.createElement(
    Popover,
    {
      open: Boolean(anchorEl),
      onClose: () => setAnchorEl(void 0),
      anchorEl,
      anchorOrigin: { vertical: "bottom", horizontal: "right" },
      transformOrigin: { vertical: "top", horizontal: "right" }
    },
    /* @__PURE__ */ React.createElement(MenuList, null, /* @__PURE__ */ React.createElement(MenuItem, { onClick: () => onToggleLogs == null ? void 0 : onToggleLogs(!logsVisible) }, /* @__PURE__ */ React.createElement(ListItemIcon, null, /* @__PURE__ */ React.createElement(Toc, { fontSize: "small" })), /* @__PURE__ */ React.createElement(ListItemText, { primary: logsVisible ? "Hide Logs" : "Show Logs" })), /* @__PURE__ */ React.createElement(MenuItem, { onClick: () => onToggleButtonBar == null ? void 0 : onToggleButtonBar(!buttonBarVisible) }, /* @__PURE__ */ React.createElement(ListItemIcon, null, /* @__PURE__ */ React.createElement(ControlPointIcon, { fontSize: "small" })), /* @__PURE__ */ React.createElement(
      ListItemText,
      {
        primary: buttonBarVisible ? "Hide Button Bar" : "Show Button Bar"
      }
    )), /* @__PURE__ */ React.createElement(MenuItem, { onClick: onStartOver }, /* @__PURE__ */ React.createElement(ListItemIcon, null, /* @__PURE__ */ React.createElement(Retry, { fontSize: "small" })), /* @__PURE__ */ React.createElement(ListItemText, { primary: "Start Over" })), /* @__PURE__ */ React.createElement(
      MenuItem,
      {
        onClick: cancel,
        disabled: !cancelEnabled || cancelStatus !== "not-executed",
        "data-testid": "cancel-task"
      },
      /* @__PURE__ */ React.createElement(ListItemIcon, null, /* @__PURE__ */ React.createElement(Cancel, { fontSize: "small" })),
      /* @__PURE__ */ React.createElement(ListItemText, { primary: "Cancel" })
    ))
  ));
};

const useStyles = makeStyles((theme) => ({
  contentWrapper: {
    display: "flex",
    flexDirection: "column"
  },
  buttonBar: {
    display: "flex",
    flexDirection: "row",
    justifyContent: "right"
  },
  cancelButton: {
    marginRight: theme.spacing(1)
  },
  logsVisibilityButton: {
    marginRight: theme.spacing(1)
  }
}));
const OngoingTask = (props) => {
  var _a, _b, _c, _d, _e, _f, _g, _h;
  const { taskId } = useParams();
  const templateRouteRef = useRouteRef(selectedTemplateRouteRef);
  const navigate = useNavigate();
  const scaffolderApi = useApi(scaffolderApiRef);
  const taskStream = useTaskEventStream(taskId);
  const classes = useStyles();
  const steps = useMemo(
    () => {
      var _a2, _b2;
      return (_b2 = (_a2 = taskStream.task) == null ? void 0 : _a2.spec.steps.map((step) => {
        var _a3;
        return {
          ...step,
          ...(_a3 = taskStream == null ? void 0 : taskStream.steps) == null ? void 0 : _a3[step.id]
        };
      })) != null ? _b2 : [];
    },
    [taskStream]
  );
  const [logsVisible, setLogVisibleState] = useState(false);
  const [buttonBarVisible, setButtonBarVisibleState] = useState(true);
  useEffect(() => {
    if (taskStream.error) {
      setLogVisibleState(true);
    }
  }, [taskStream.error]);
  useEffect(() => {
    if (taskStream.completed && !taskStream.error) {
      setButtonBarVisibleState(false);
    }
  }, [taskStream.error, taskStream.completed]);
  const activeStep = useMemo(() => {
    for (let i = steps.length - 1; i >= 0; i--) {
      if (steps[i].status !== "open") {
        return i;
      }
    }
    return 0;
  }, [steps]);
  const startOver = useCallback(() => {
    var _a2, _b2, _c2, _d2, _e2, _f2;
    const { namespace, name } = (_d2 = (_c2 = (_b2 = (_a2 = taskStream.task) == null ? void 0 : _a2.spec.templateInfo) == null ? void 0 : _b2.entity) == null ? void 0 : _c2.metadata) != null ? _d2 : {};
    const formData = (_f2 = (_e2 = taskStream.task) == null ? void 0 : _e2.spec.parameters) != null ? _f2 : {};
    if (!namespace || !name) {
      return;
    }
    navigate({
      pathname: templateRouteRef({
        namespace,
        templateName: name
      }),
      search: `?${qs.stringify({ formData: JSON.stringify(formData) })}`
    });
  }, [
    navigate,
    (_a = taskStream.task) == null ? void 0 : _a.spec.parameters,
    (_d = (_c = (_b = taskStream.task) == null ? void 0 : _b.spec.templateInfo) == null ? void 0 : _c.entity) == null ? void 0 : _d.metadata,
    templateRouteRef
  ]);
  const [{ status: cancelStatus }, { execute: triggerCancel }] = useAsync$1(
    async () => {
      if (taskId) {
        await scaffolderApi.cancelTask(taskId);
      }
    }
  );
  const Outputs = (_e = props.TemplateOutputsComponent) != null ? _e : DefaultTemplateOutputs;
  const templateName = (_h = (_g = (_f = taskStream.task) == null ? void 0 : _f.spec.templateInfo) == null ? void 0 : _g.entity) == null ? void 0 : _h.metadata.name;
  const cancelEnabled = !(taskStream.cancelled || taskStream.completed);
  return /* @__PURE__ */ React.createElement(Page, { themeId: "website" }, /* @__PURE__ */ React.createElement(
    Header,
    {
      pageTitleOverride: `Run of ${templateName}`,
      title: /* @__PURE__ */ React.createElement("div", null, "Run of ", /* @__PURE__ */ React.createElement("code", null, templateName)),
      subtitle: `Task ${taskId}`
    },
    /* @__PURE__ */ React.createElement(
      ContextMenu,
      {
        cancelEnabled,
        logsVisible,
        buttonBarVisible,
        onStartOver: startOver,
        onToggleLogs: setLogVisibleState,
        onToggleButtonBar: setButtonBarVisibleState,
        taskId
      }
    )
  ), /* @__PURE__ */ React.createElement(Content, { className: classes.contentWrapper }, taskStream.error ? /* @__PURE__ */ React.createElement(Box, { paddingBottom: 2 }, /* @__PURE__ */ React.createElement(
    ErrorPanel,
    {
      error: taskStream.error,
      titleFormat: "markdown",
      title: taskStream.error.message
    }
  )) : null, /* @__PURE__ */ React.createElement(Box, { paddingBottom: 2 }, /* @__PURE__ */ React.createElement(
    TaskSteps,
    {
      steps,
      activeStep,
      isComplete: taskStream.completed,
      isError: Boolean(taskStream.error)
    }
  )), /* @__PURE__ */ React.createElement(Outputs, { output: taskStream.output }), buttonBarVisible ? /* @__PURE__ */ React.createElement(Box, { paddingBottom: 2 }, /* @__PURE__ */ React.createElement(Paper, null, /* @__PURE__ */ React.createElement(Box, { padding: 2 }, /* @__PURE__ */ React.createElement("div", { className: classes.buttonBar }, /* @__PURE__ */ React.createElement(
    Button,
    {
      className: classes.cancelButton,
      disabled: !cancelEnabled || cancelStatus !== "not-executed",
      onClick: triggerCancel,
      "data-testid": "cancel-button"
    },
    "Cancel"
  ), /* @__PURE__ */ React.createElement(
    Button,
    {
      className: classes.logsVisibilityButton,
      color: "primary",
      variant: "outlined",
      onClick: () => setLogVisibleState(!logsVisible)
    },
    logsVisible ? "Hide Logs" : "Show Logs"
  ), /* @__PURE__ */ React.createElement(
    Button,
    {
      variant: "contained",
      color: "primary",
      disabled: cancelEnabled,
      onClick: startOver
    },
    "Start Over"
  ))))) : null, logsVisible ? /* @__PURE__ */ React.createElement(Box, { paddingBottom: 2, height: "100%" }, /* @__PURE__ */ React.createElement(Paper, { style: { height: "100%" } }, /* @__PURE__ */ React.createElement(Box, { padding: 2, height: "100%" }, /* @__PURE__ */ React.createElement(TaskLogStream, { logs: taskStream.stepLogs })))) : null));
};

export { EntityNamePicker as A, entityNamePickerValidation as B, EntityNamePickerSchema as C, EntityTagsPicker as D, EntityPickerFieldExtension as E, EntityTagsPickerSchema as F, RepoUrlPicker as G, RepoUrlPickerSchema as H, OwnerPicker as I, OwnerPickerSchema as J, OwnedEntityPicker as K, LegacyScaffolderPage as L, MyGroupsPickerFieldExtension as M, OwnedEntityPickerSchema as N, OwnerPickerFieldExtension as O, MyGroupsPicker as P, RepoUrlPickerFieldExtension as R, ScaffolderClient as S, TemplateTypePicker as T, EntityNamePickerFieldExtension as a, EntityTagsPickerFieldExtension as b, OwnedEntityPickerFieldExtension as c, ScaffolderPage as d, OngoingTask as e, EntityPickerFieldSchema as f, OwnerPickerFieldSchema as g, RepoUrlPickerFieldSchema as h, repoPickerValidation as i, OwnedEntityPickerFieldSchema as j, EntityTagsPickerFieldSchema as k, MyGroupsPickerSchema as l, makeFieldSchemaFromZod as m, MyGroupsPickerFieldSchema as n, selectedTemplateRouteRef as o, editRouteRef as p, actionsRouteRef as q, rootRouteRef as r, scaffolderPlugin as s, scaffolderListTaskRouteRef as t, registerComponentRouteRef as u, viewTechDocRouteRef as v, scaffolderTaskRouteRef as w, legacySelectedTemplateRouteRef as x, EntityPicker as y, EntityPickerSchema as z };
//# sourceMappingURL=OngoingTask-87c6761c.esm.js.map
