import React, { useMemo, Children, isValidElement, Fragment } from 'react';
import { createVersionedContext, createVersionedValueMap, getOrCreateGlobalSingleton, useVersionedContext } from '@backstage/version-bridge';
import { UrlPatternDiscovery, AlertApiForwarder, NoOpAnalyticsApi, ErrorAlerter, ErrorApiForwarder, UnhandledErrorForwarder, WebStorage, createFetchApi, FetchMiddlewares, OAuthRequestManager, GoogleAuth, MicrosoftAuth, GithubAuth, OktaAuth, GitlabAuth, OneLoginAuth, BitbucketAuth, BitbucketServerAuth, AtlassianAuth } from '@backstage/core-app-api';
import { createApiFactory, discoveryApiRef, configApiRef, alertApiRef, analyticsApiRef, errorApiRef, storageApiRef, fetchApiRef, identityApiRef, oauthRequestApiRef, googleAuthApiRef, microsoftAuthApiRef, githubAuthApiRef, oktaAuthApiRef, gitlabAuthApiRef, oneloginAuthApiRef, bitbucketAuthApiRef, bitbucketServerAuthApiRef, atlassianAuthApiRef, getComponentData } from '@backstage/core-plugin-api';
import { permissionApiRef, IdentityPermissionApi } from '@backstage/plugin-permission-react';
import Button from '@material-ui/core/Button';
import { Progress, ErrorPage, ErrorPanel } from '@backstage/core-components';
import { BrowserRouter, useInRouterContext, MemoryRouter, Route, Routes } from 'react-router-dom';
import MuiApartmentIcon from '@material-ui/icons/Apartment';
import MuiBrokenImageIcon from '@material-ui/icons/BrokenImage';
import MuiCategoryIcon from '@material-ui/icons/Category';
import MuiCreateNewFolderIcon from '@material-ui/icons/CreateNewFolder';
import MuiSubjectIcon from '@material-ui/icons/Subject';
import MuiSearchIcon from '@material-ui/icons/Search';
import MuiChatIcon from '@material-ui/icons/Chat';
import MuiDashboardIcon from '@material-ui/icons/Dashboard';
import MuiDocsIcon from '@material-ui/icons/Description';
import MuiEmailIcon from '@material-ui/icons/Email';
import MuiExtensionIcon from '@material-ui/icons/Extension';
import MuiGitHubIcon from '@material-ui/icons/GitHub';
import MuiHelpIcon from '@material-ui/icons/Help';
import MuiLocationOnIcon from '@material-ui/icons/LocationOn';
import MuiMemoryIcon from '@material-ui/icons/Memory';
import MuiMenuBookIcon from '@material-ui/icons/MenuBook';
import MuiPeopleIcon from '@material-ui/icons/People';
import MuiPersonIcon from '@material-ui/icons/Person';
import MuiWarningIcon from '@material-ui/icons/Warning';
import MuiWorkIcon from '@material-ui/icons/Work';
import MuiFeaturedPlayListIcon from '@material-ui/icons/FeaturedPlayList';
import '@backstage/theme';
import '@material-ui/icons/Brightness2';
import '@material-ui/icons/WbSunny';
import { useApi, appTreeApiRef, createRouteRef, createSubRouteRef, createExternalRouteRef, createPageExtension, createExtensionInput, coreExtensionData, createPlugin, createApiExtension, createExtension, createExtensionOverrides } from '@backstage/frontend-plugin-api';

const AppContext = createVersionedContext("app-context");
const AppContextProvider = ({
  appContext,
  children
}) => {
  const versionedValue = createVersionedValueMap({ 1: appContext });
  return /* @__PURE__ */ React.createElement(AppContext.Provider, { value: versionedValue, children });
};

[
  createApiFactory({
    api: discoveryApiRef,
    deps: { configApi: configApiRef },
    factory: ({ configApi }) => UrlPatternDiscovery.compile(
      `${configApi.getString("backend.baseUrl")}/api/{{ pluginId }}`
    )
  }),
  createApiFactory({
    api: alertApiRef,
    deps: {},
    factory: () => new AlertApiForwarder()
  }),
  createApiFactory({
    api: analyticsApiRef,
    deps: {},
    factory: () => new NoOpAnalyticsApi()
  }),
  createApiFactory({
    api: errorApiRef,
    deps: { alertApi: alertApiRef },
    factory: ({ alertApi }) => {
      const errorApi = new ErrorAlerter(alertApi, new ErrorApiForwarder());
      UnhandledErrorForwarder.forward(errorApi, { hidden: false });
      return errorApi;
    }
  }),
  createApiFactory({
    api: storageApiRef,
    deps: { errorApi: errorApiRef },
    factory: ({ errorApi }) => WebStorage.create({ errorApi })
  }),
  createApiFactory({
    api: fetchApiRef,
    deps: {
      configApi: configApiRef,
      identityApi: identityApiRef,
      discoveryApi: discoveryApiRef
    },
    factory: ({ configApi, identityApi, discoveryApi }) => {
      return createFetchApi({
        middleware: [
          FetchMiddlewares.resolvePluginProtocol({
            discoveryApi
          }),
          FetchMiddlewares.injectIdentityAuth({
            identityApi,
            config: configApi
          })
        ]
      });
    }
  }),
  createApiFactory({
    api: oauthRequestApiRef,
    deps: {},
    factory: () => new OAuthRequestManager()
  }),
  createApiFactory({
    api: googleAuthApiRef,
    deps: {
      discoveryApi: discoveryApiRef,
      oauthRequestApi: oauthRequestApiRef,
      configApi: configApiRef
    },
    factory: ({ discoveryApi, oauthRequestApi, configApi }) => GoogleAuth.create({
      configApi,
      discoveryApi,
      oauthRequestApi,
      environment: configApi.getOptionalString("auth.environment")
    })
  }),
  createApiFactory({
    api: microsoftAuthApiRef,
    deps: {
      discoveryApi: discoveryApiRef,
      oauthRequestApi: oauthRequestApiRef,
      configApi: configApiRef
    },
    factory: ({ discoveryApi, oauthRequestApi, configApi }) => MicrosoftAuth.create({
      configApi,
      discoveryApi,
      oauthRequestApi,
      environment: configApi.getOptionalString("auth.environment")
    })
  }),
  createApiFactory({
    api: githubAuthApiRef,
    deps: {
      discoveryApi: discoveryApiRef,
      oauthRequestApi: oauthRequestApiRef,
      configApi: configApiRef
    },
    factory: ({ discoveryApi, oauthRequestApi, configApi }) => GithubAuth.create({
      configApi,
      discoveryApi,
      oauthRequestApi,
      defaultScopes: ["read:user"],
      environment: configApi.getOptionalString("auth.environment")
    })
  }),
  createApiFactory({
    api: oktaAuthApiRef,
    deps: {
      discoveryApi: discoveryApiRef,
      oauthRequestApi: oauthRequestApiRef,
      configApi: configApiRef
    },
    factory: ({ discoveryApi, oauthRequestApi, configApi }) => OktaAuth.create({
      configApi,
      discoveryApi,
      oauthRequestApi,
      environment: configApi.getOptionalString("auth.environment")
    })
  }),
  createApiFactory({
    api: gitlabAuthApiRef,
    deps: {
      discoveryApi: discoveryApiRef,
      oauthRequestApi: oauthRequestApiRef,
      configApi: configApiRef
    },
    factory: ({ discoveryApi, oauthRequestApi, configApi }) => GitlabAuth.create({
      configApi,
      discoveryApi,
      oauthRequestApi,
      environment: configApi.getOptionalString("auth.environment")
    })
  }),
  createApiFactory({
    api: oneloginAuthApiRef,
    deps: {
      discoveryApi: discoveryApiRef,
      oauthRequestApi: oauthRequestApiRef,
      configApi: configApiRef
    },
    factory: ({ discoveryApi, oauthRequestApi, configApi }) => OneLoginAuth.create({
      configApi,
      discoveryApi,
      oauthRequestApi,
      environment: configApi.getOptionalString("auth.environment")
    })
  }),
  createApiFactory({
    api: bitbucketAuthApiRef,
    deps: {
      discoveryApi: discoveryApiRef,
      oauthRequestApi: oauthRequestApiRef,
      configApi: configApiRef
    },
    factory: ({ discoveryApi, oauthRequestApi, configApi }) => BitbucketAuth.create({
      configApi,
      discoveryApi,
      oauthRequestApi,
      defaultScopes: ["team"],
      environment: configApi.getOptionalString("auth.environment")
    })
  }),
  createApiFactory({
    api: bitbucketServerAuthApiRef,
    deps: {
      discoveryApi: discoveryApiRef,
      oauthRequestApi: oauthRequestApiRef,
      configApi: configApiRef
    },
    factory: ({ discoveryApi, oauthRequestApi, configApi }) => BitbucketServerAuth.create({
      configApi,
      discoveryApi,
      oauthRequestApi,
      defaultScopes: ["REPO_READ"]
    })
  }),
  createApiFactory({
    api: atlassianAuthApiRef,
    deps: {
      discoveryApi: discoveryApiRef,
      oauthRequestApi: oauthRequestApiRef,
      configApi: configApiRef
    },
    factory: ({ discoveryApi, oauthRequestApi, configApi }) => {
      return AtlassianAuth.create({
        configApi,
        discoveryApi,
        oauthRequestApi,
        environment: configApi.getOptionalString("auth.environment")
      });
    }
  }),
  createApiFactory({
    api: permissionApiRef,
    deps: {
      discovery: discoveryApiRef,
      identity: identityApiRef,
      config: configApiRef
    },
    factory: ({ config, discovery, identity }) => IdentityPermissionApi.create({ config, discovery, identity })
  })
];

function OptionallyWrapInRouter({ children }) {
  if (useInRouterContext()) {
    return /* @__PURE__ */ React.createElement(React.Fragment, null, children);
  }
  return /* @__PURE__ */ React.createElement(MemoryRouter, null, children);
}
const DefaultNotFoundPage = () => /* @__PURE__ */ React.createElement(ErrorPage, { status: "404", statusMessage: "PAGE NOT FOUND" });
const DefaultBootErrorPage = ({ step, error }) => {
  let message = "";
  if (step === "load-config") {
    message = `The configuration failed to load, someone should have a look at this error: ${error.message}`;
  } else if (step === "load-chunk") {
    message = `Lazy loaded chunk failed to load, try to reload the page: ${error.message}`;
  }
  return /* @__PURE__ */ React.createElement(OptionallyWrapInRouter, null, /* @__PURE__ */ React.createElement(ErrorPage, { status: "501", statusMessage: message }));
};
const DefaultErrorBoundaryFallback = ({
  error,
  resetError,
  plugin
}) => {
  return /* @__PURE__ */ React.createElement(
    ErrorPanel,
    {
      title: `Error in ${plugin == null ? void 0 : plugin.getId()}`,
      defaultExpanded: true,
      error
    },
    /* @__PURE__ */ React.createElement(Button, { variant: "outlined", onClick: resetError }, "Retry")
  );
};
const components = {
  Progress,
  Router: BrowserRouter,
  NotFoundErrorPage: DefaultNotFoundPage,
  BootErrorPage: DefaultBootErrorPage,
  ErrorBoundaryFallback: DefaultErrorBoundaryFallback
};

const icons = {
  brokenImage: MuiBrokenImageIcon,
  // To be confirmed: see https://github.com/backstage/backstage/issues/4970
  catalog: MuiMenuBookIcon,
  scaffolder: MuiCreateNewFolderIcon,
  techdocs: MuiSubjectIcon,
  search: MuiSearchIcon,
  chat: MuiChatIcon,
  dashboard: MuiDashboardIcon,
  docs: MuiDocsIcon,
  email: MuiEmailIcon,
  github: MuiGitHubIcon,
  group: MuiPeopleIcon,
  help: MuiHelpIcon,
  "kind:api": MuiExtensionIcon,
  "kind:component": MuiMemoryIcon,
  "kind:domain": MuiApartmentIcon,
  "kind:group": MuiPeopleIcon,
  "kind:location": MuiLocationOnIcon,
  "kind:system": MuiCategoryIcon,
  "kind:user": MuiPersonIcon,
  "kind:resource": MuiWorkIcon,
  "kind:template": MuiFeaturedPlayListIcon,
  user: MuiPersonIcon,
  warning: MuiWarningIcon
};

const legacyPluginStore = getOrCreateGlobalSingleton(
  "legacy-plugin-compatibility-store",
  () => /* @__PURE__ */ new WeakMap()
);
function toLegacyPlugin(plugin) {
  let legacy = legacyPluginStore.get(plugin);
  if (legacy) {
    return legacy;
  }
  const errorMsg = "Not implemented in legacy plugin compatibility layer";
  const notImplemented = () => {
    throw new Error(errorMsg);
  };
  legacy = {
    getId() {
      return plugin.id;
    },
    get routes() {
      return {};
    },
    get externalRoutes() {
      return {};
    },
    getApis: notImplemented,
    getFeatureFlags: notImplemented,
    provide: notImplemented
  };
  legacyPluginStore.set(plugin, legacy);
  return legacy;
}
function LegacyAppContextProvider(props) {
  const appTreeApi = useApi(appTreeApiRef);
  const appContext = useMemo(() => {
    const { tree } = appTreeApi.getTree();
    let gatheredPlugins = void 0;
    return {
      getPlugins() {
        if (gatheredPlugins) {
          return gatheredPlugins;
        }
        const pluginSet = /* @__PURE__ */ new Set();
        for (const node of tree.nodes.values()) {
          const plugin = node.spec.source;
          if (plugin) {
            pluginSet.add(toLegacyPlugin(plugin));
          }
        }
        gatheredPlugins = Array.from(pluginSet);
        return gatheredPlugins;
      },
      // TODO: Grab these from new API once it exists
      getSystemIcon(key) {
        return key in icons ? icons[key] : void 0;
      },
      // TODO: Grab these from new API once it exists
      getSystemIcons() {
        return icons;
      },
      // TODO: Grab these from new API once it exists
      getComponents() {
        return components;
      }
    };
  }, [appTreeApi]);
  return /* @__PURE__ */ React.createElement(AppContextProvider, { appContext }, props.children);
}
function BackwardsCompatProvider(props) {
  return /* @__PURE__ */ React.createElement(LegacyAppContextProvider, null, props.children);
}

function ForwardsCompatProvider(props) {
  return /* @__PURE__ */ React.createElement(React.Fragment, null, props.children);
}

function BidirectionalCompatProvider(props) {
  const isInNewApp = !useVersionedContext("app-context");
  if (isInNewApp) {
    return /* @__PURE__ */ React.createElement(BackwardsCompatProvider, { ...props });
  }
  return /* @__PURE__ */ React.createElement(ForwardsCompatProvider, { ...props });
}
function compatWrapper(element) {
  return /* @__PURE__ */ React.createElement(BidirectionalCompatProvider, null, element);
}

const routeRefType = getOrCreateGlobalSingleton(
  "route-ref-type",
  () => Symbol("route-ref-type")
);

function toInternalRouteRef(resource) {
  const r = resource;
  if (r.$$type !== "@backstage/RouteRef") {
    throw new Error(`Invalid RouteRef, bad type '${r.$$type}'`);
  }
  return r;
}

function toInternalSubRouteRef(resource) {
  const r = resource;
  if (r.$$type !== "@backstage/SubRouteRef") {
    throw new Error(`Invalid SubRouteRef, bad type '${r.$$type}'`);
  }
  return r;
}

function toInternalExternalRouteRef(resource) {
  const r = resource;
  if (r.$$type !== "@backstage/ExternalRouteRef") {
    throw new Error(`Invalid ExternalRouteRef, bad type '${r.$$type}'`);
  }
  return r;
}

function convertLegacyRouteRef(ref) {
  if ("$$type" in ref) {
    return ref;
  }
  const type = ref[routeRefType];
  if (type === "absolute") {
    const legacyRef = ref;
    const legacyRefStr = String(legacyRef);
    const newRef = toInternalRouteRef(
      createRouteRef({
        params: legacyRef.params
      })
    );
    return Object.assign(legacyRef, {
      $$type: "@backstage/RouteRef",
      version: "v1",
      T: newRef.T,
      getParams() {
        return newRef.getParams();
      },
      getDescription() {
        return legacyRefStr;
      },
      setId(id) {
        newRef.setId(id);
      },
      toString() {
        return legacyRefStr;
      }
    });
  }
  if (type === "sub") {
    const legacyRef = ref;
    const legacyRefStr = String(legacyRef);
    const newRef = toInternalSubRouteRef(
      createSubRouteRef({
        path: legacyRef.path,
        parent: convertLegacyRouteRef(legacyRef.parent)
      })
    );
    return Object.assign(legacyRef, {
      $$type: "@backstage/SubRouteRef",
      version: "v1",
      T: newRef.T,
      getParams() {
        return newRef.getParams();
      },
      getParent() {
        return newRef.getParent();
      },
      getDescription() {
        return legacyRefStr;
      },
      toString() {
        return legacyRefStr;
      }
    });
  }
  if (type === "external") {
    const legacyRef = ref;
    const legacyRefStr = String(legacyRef);
    const newRef = toInternalExternalRouteRef(
      createExternalRouteRef({
        params: legacyRef.params,
        optional: legacyRef.optional
      })
    );
    return Object.assign(legacyRef, {
      $$type: "@backstage/ExternalRouteRef",
      version: "v1",
      T: newRef.T,
      optional: newRef.optional,
      getParams() {
        return newRef.getParams();
      },
      getDescription() {
        return legacyRefStr;
      },
      setId(id) {
        newRef.setId(id);
      },
      toString() {
        return legacyRefStr;
      }
    });
  }
  throw new Error(`Failed to convert legacy route ref, unknown type '${type}'`);
}

function makeRoutingShimExtension(options) {
  const { name, parentExtensionId, routePath, routeRef } = options;
  return createExtension({
    kind: "routing-shim",
    name,
    attachTo: { id: parentExtensionId, input: "childRoutingShims" },
    inputs: {
      childRoutingShims: createExtensionInput({
        routePath: coreExtensionData.routePath.optional(),
        routeRef: coreExtensionData.routeRef.optional()
      })
    },
    output: {
      routePath: coreExtensionData.routePath.optional(),
      routeRef: coreExtensionData.routeRef.optional()
    },
    factory: () => ({
      routePath,
      routeRef: routeRef ? convertLegacyRouteRef(routeRef) : void 0
    })
  });
}
function visitRouteChildren(options) {
  const { children, parentExtensionId, context } = options;
  const { pluginId, extensions, getUniqueName, discoverPlugin } = context;
  Children.forEach(children, (node) => {
    var _a;
    if (!isValidElement(node)) {
      return;
    }
    const plugin = getComponentData(node, "core.plugin");
    const routeRef = getComponentData(
      node,
      "core.mountPoint"
    );
    const routePath = (_a = node.props) == null ? void 0 : _a.path;
    if (plugin) {
      discoverPlugin(plugin);
    }
    let nextParentExtensionId = parentExtensionId;
    if (routeRef || routePath) {
      const nextParentExtensionName = getUniqueName();
      nextParentExtensionId = `routing-shim:${pluginId}/${nextParentExtensionName}`;
      extensions.push(
        makeRoutingShimExtension({
          name: nextParentExtensionName,
          parentExtensionId,
          routePath,
          routeRef
        })
      );
    }
    visitRouteChildren({
      children: node.props.children,
      parentExtensionId: nextParentExtensionId,
      context
    });
  });
}
function collectLegacyRoutes(flatRoutesElement) {
  const pluginExtensions = /* @__PURE__ */ new Map();
  const getUniqueName = /* @__PURE__ */ (() => {
    let currentIndex = 1;
    return () => String(currentIndex++);
  })();
  const getPluginExtensions = (plugin) => {
    let extensions = pluginExtensions.get(plugin);
    if (!extensions) {
      extensions = [];
      pluginExtensions.set(plugin, extensions);
    }
    return extensions;
  };
  React.Children.forEach(
    flatRoutesElement.props.children,
    (route) => {
      if (!React.isValidElement(route) || route.type !== Route) {
        return;
      }
      const routeElement = route.props.element;
      const path = route.props.path;
      const plugin = getComponentData(
        routeElement,
        "core.plugin"
      );
      const routeRef = getComponentData(
        routeElement,
        "core.mountPoint"
      );
      if (!plugin || !path) {
        return;
      }
      const extensions = getPluginExtensions(plugin);
      const pageExtensionName = extensions.length ? getUniqueName() : void 0;
      const pageExtensionId = `page:${plugin.getId()}${pageExtensionName ? `/${pageExtensionName}` : pageExtensionName}`;
      extensions.push(
        createPageExtension({
          name: pageExtensionName,
          defaultPath: path[0] === "/" ? path.slice(1) : path,
          routeRef: routeRef ? convertLegacyRouteRef(routeRef) : void 0,
          inputs: {
            childRoutingShims: createExtensionInput({
              routePath: coreExtensionData.routePath.optional(),
              routeRef: coreExtensionData.routeRef.optional()
            })
          },
          loader: async () => compatWrapper(
            route.props.children ? /* @__PURE__ */ React.createElement(Routes, null, /* @__PURE__ */ React.createElement(Route, { path: "*", element: routeElement }, /* @__PURE__ */ React.createElement(Route, { path: "*", element: route.props.children }))) : routeElement
          )
        })
      );
      visitRouteChildren({
        children: route.props.children,
        parentExtensionId: pageExtensionId,
        context: {
          pluginId: plugin.getId(),
          extensions,
          getUniqueName,
          discoverPlugin: getPluginExtensions
        }
      });
    }
  );
  return Array.from(pluginExtensions).map(
    ([plugin, extensions]) => createPlugin({
      id: plugin.getId(),
      extensions: [
        ...extensions,
        ...Array.from(plugin.getApis()).map(
          (factory) => createApiExtension({ factory })
        )
      ]
    })
  );
}

function selectChildren(rootNode, selector, strictError) {
  return Children.toArray(rootNode).flatMap((node) => {
    if (!isValidElement(node)) {
      return [];
    }
    if (node.type === Fragment) {
      return selectChildren(node.props.children, selector, strictError);
    }
    if (selector === void 0 || selector(node)) {
      return [node];
    }
    if (strictError) {
      throw new Error(strictError);
    }
    return selectChildren(node.props.children, selector, strictError);
  });
}
function convertLegacyApp(rootElement) {
  if (getComponentData(rootElement, "core.type") === "FlatRoutes") {
    return collectLegacyRoutes(rootElement);
  }
  const appRouterEls = selectChildren(
    rootElement,
    (el) => getComponentData(el, "core.type") === "AppRouter"
  );
  if (appRouterEls.length !== 1) {
    throw new Error(
      "Failed to convert legacy app, AppRouter element could not been found. Make sure it's at the top level of the App element tree"
    );
  }
  const rootEls = selectChildren(
    appRouterEls[0].props.children,
    (el) => Boolean(el.props.children) && selectChildren(
      el.props.children,
      (innerEl) => getComponentData(innerEl, "core.type") === "FlatRoutes"
    ).length === 1
  );
  if (rootEls.length !== 1) {
    throw new Error(
      "Failed to convert legacy app, Root element containing FlatRoutes could not been found. Make sure it's within the AppRouter element of the App element tree"
    );
  }
  const [rootEl] = rootEls;
  const routesEls = selectChildren(
    rootEls[0].props.children,
    (el) => getComponentData(el, "core.type") === "FlatRoutes"
  );
  if (routesEls.length !== 1) {
    throw new Error(
      "Unexpectedly failed to find FlatRoutes in app element tree"
    );
  }
  const [routesEl] = routesEls;
  const CoreLayoutOverride = createExtension({
    namespace: "app",
    name: "layout",
    attachTo: { id: "app", input: "root" },
    inputs: {
      content: createExtensionInput(
        {
          element: coreExtensionData.reactElement
        },
        { singleton: true }
      )
    },
    output: {
      element: coreExtensionData.reactElement
    },
    factory({ inputs }) {
      return {
        element: React.cloneElement(
          rootEl,
          void 0,
          inputs.content.output.element
        )
      };
    }
  });
  const CoreNavOverride = createExtension({
    namespace: "app",
    name: "nav",
    attachTo: { id: "app/layout", input: "nav" },
    output: {},
    factory: () => ({}),
    disabled: true
  });
  const collectedRoutes = collectLegacyRoutes(routesEl);
  return [
    ...collectedRoutes,
    createExtensionOverrides({
      extensions: [CoreLayoutOverride, CoreNavOverride]
    })
  ];
}

export { compatWrapper, convertLegacyApp, convertLegacyRouteRef };
//# sourceMappingURL=index.esm.js.map
