'use strict';

var Router = require('express-promise-router');
var httpProxyMiddleware = require('http-proxy-middleware');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var Router__default = /*#__PURE__*/_interopDefaultLegacy(Router);

const safeForwardHeaders = [
  // https://fetch.spec.whatwg.org/#cors-safelisted-request-header
  "cache-control",
  "content-language",
  "content-length",
  "content-type",
  "expires",
  "last-modified",
  "pragma",
  // host is overridden by default. if changeOrigin is configured to false,
  // we assume this is a intentional and should also be forwarded.
  "host",
  // other headers that we assume to be ok
  "accept",
  "accept-language",
  "user-agent"
];
function buildMiddleware(pathPrefix, logger, route, config, reviveConsumedRequestBodies) {
  var _a;
  const fullConfig = typeof config === "string" ? { target: config } : { ...config };
  const targetType = typeof fullConfig.target;
  if (targetType !== "string") {
    throw new Error(
      `Proxy target for route "${route}" must be a string, but is of type ${targetType}`
    );
  }
  try {
    new URL(fullConfig.target);
  } catch {
    throw new Error(
      `Proxy target is not a valid URL: ${(_a = fullConfig.target) != null ? _a : ""}`
    );
  }
  if (fullConfig.pathRewrite === void 0) {
    let routeWithSlash = route.endsWith("/") ? route : `${route}/`;
    if (!pathPrefix.endsWith("/") && !routeWithSlash.startsWith("/")) {
      routeWithSlash = `/${routeWithSlash}`;
    } else if (pathPrefix.endsWith("/") && routeWithSlash.startsWith("/")) {
      routeWithSlash = routeWithSlash.substring(1);
    }
    fullConfig.pathRewrite = {
      [`^${pathPrefix}${routeWithSlash}?`]: "/"
    };
  }
  if (fullConfig.changeOrigin === void 0) {
    fullConfig.changeOrigin = true;
  }
  fullConfig.logProvider = () => logger;
  fullConfig.logLevel = "debug";
  const requestHeaderAllowList = new Set(
    [
      // allow all safe headers
      ...safeForwardHeaders,
      // allow all headers that are set by the proxy
      ...fullConfig.headers && Object.keys(fullConfig.headers) || [],
      // allow all configured headers
      ...fullConfig.allowedHeaders || []
    ].map((h) => h.toLocaleLowerCase())
  );
  const filter = (_pathname, req) => {
    var _a2, _b;
    const headerNames = Object.keys(req.headers);
    headerNames.forEach((h) => {
      if (!requestHeaderAllowList.has(h.toLocaleLowerCase())) {
        delete req.headers[h];
      }
    });
    return (_b = (_a2 = fullConfig == null ? void 0 : fullConfig.allowedMethods) == null ? void 0 : _a2.includes(req.method)) != null ? _b : true;
  };
  filter.toString = () => route;
  const responseHeaderAllowList = new Set(
    [
      // allow all safe headers
      ...safeForwardHeaders,
      // allow all configured headers
      ...fullConfig.allowedHeaders || []
    ].map((h) => h.toLocaleLowerCase())
  );
  fullConfig.onProxyRes = (proxyRes) => {
    const headerNames = Object.keys(proxyRes.headers);
    headerNames.forEach((h) => {
      if (!responseHeaderAllowList.has(h.toLocaleLowerCase())) {
        delete proxyRes.headers[h];
      }
    });
  };
  if (reviveConsumedRequestBodies) {
    fullConfig.onProxyReq = httpProxyMiddleware.fixRequestBody;
  }
  return httpProxyMiddleware.createProxyMiddleware(filter, fullConfig);
}
function readProxyConfig(config, logger) {
  var _a, _b;
  const endpoints = (_a = config.getOptionalConfig("proxy.endpoints")) == null ? void 0 : _a.get();
  if (endpoints) {
    return endpoints;
  }
  const root = (_b = config.getOptionalConfig("proxy")) == null ? void 0 : _b.get();
  if (!root) {
    return {};
  }
  const rootEndpoints = Object.fromEntries(
    Object.entries(root).filter(([key]) => key.startsWith("/"))
  );
  if (Object.keys(rootEndpoints).length === 0) {
    return {};
  }
  logger.warn(
    "Configuring proxy endpoints in the root 'proxy' configuration is deprecated. Move this configuration to 'proxy.endpoints' instead."
  );
  return rootEndpoints;
}
async function createRouter(options) {
  var _a, _b, _c, _d;
  const router = Router__default["default"]();
  let currentRouter = Router__default["default"]();
  const skipInvalidProxies = (_b = (_a = options.skipInvalidProxies) != null ? _a : options.config.getOptionalBoolean("proxy.skipInvalidProxies")) != null ? _b : false;
  const reviveConsumedRequestBodies = (_d = (_c = options.reviveConsumedRequestBodies) != null ? _c : options.config.getOptionalBoolean("proxy.reviveConsumedRequestBodies")) != null ? _d : false;
  const proxyOptions = {
    skipInvalidProxies,
    reviveConsumedRequestBodies,
    logger: options.logger
  };
  const externalUrl = await options.discovery.getExternalBaseUrl("proxy");
  const { pathname: pathPrefix } = new URL(externalUrl);
  const proxyConfig = readProxyConfig(options.config, options.logger);
  configureMiddlewares(proxyOptions, currentRouter, pathPrefix, proxyConfig);
  router.use((...args) => currentRouter(...args));
  if (options.config.subscribe) {
    let currentKey = JSON.stringify(proxyConfig);
    options.config.subscribe(() => {
      const newProxyConfig = readProxyConfig(options.config, options.logger);
      const newKey = JSON.stringify(newProxyConfig);
      if (currentKey !== newKey) {
        currentKey = newKey;
        currentRouter = Router__default["default"]();
        configureMiddlewares(
          proxyOptions,
          currentRouter,
          pathPrefix,
          newProxyConfig
        );
      }
    });
  }
  return router;
}
function configureMiddlewares(options, router, pathPrefix, proxyConfig) {
  Object.entries(proxyConfig).forEach(([route, proxyRouteConfig]) => {
    try {
      router.use(
        route,
        buildMiddleware(
          pathPrefix,
          options.logger,
          route,
          proxyRouteConfig,
          options.reviveConsumedRequestBodies
        )
      );
    } catch (e) {
      if (options.skipInvalidProxies) {
        options.logger.warn(`skipped configuring ${route} due to ${e.message}`);
      } else {
        throw e;
      }
    }
  });
}

exports.createRouter = createRouter;
//# sourceMappingURL=router-6fef2ff7.cjs.js.map
