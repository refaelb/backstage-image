{"version":3,"file":"index.cjs.js","sources":["../src/collators/NewlineDelimitedJsonCollatorFactory.ts","../src/errors.ts","../src/indexing/BatchSearchEngineIndexer.ts","../src/indexing/DecoratorBase.ts","../src/engines/LunrSearchEngineIndexer.ts","../src/engines/LunrSearchEngine.ts","../src/test-utils/TestPipeline.ts"],"sourcesContent":["/*\n * Copyright 2021 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Config } from '@backstage/config';\nimport { DocumentCollatorFactory } from '@backstage/plugin-search-common';\nimport { Logger } from 'winston';\nimport { Permission } from '@backstage/plugin-permission-common';\nimport { Readable } from 'stream';\nimport { UrlReader } from '@backstage/backend-common';\nimport { parse as parseNdjson } from 'ndjson';\n\n/**\n * Options for instantiate NewlineDelimitedJsonCollatorFactory\n * @public\n */\nexport type NewlineDelimitedJsonCollatorFactoryOptions = {\n  type: string;\n  searchPattern: string;\n  reader: UrlReader;\n  logger: Logger;\n  visibilityPermission?: Permission;\n};\n\n/**\n * Factory class producing a collator that can be used to index documents\n * sourced from the latest newline delimited JSON file matching a given search\n * pattern. \"Latest\" is determined by the name of the file (last alphabetically\n * is considered latest).\n *\n * @remarks\n * The reader provided must implement the `search()` method as well as the\n * `readUrl` method whose response includes the `stream()` method. Naturally,\n * the reader must also be configured to understand the given search pattern.\n *\n * @example\n * Here's an example configuration using Google Cloud Storage, which would\n * return the latest file under the `bucket` GCS bucket with files like\n * `xyz-2021.ndjson` or `xyz-2022.ndjson`.\n * ```ts\n * indexBuilder.addCollator({\n *   schedule,\n *   factory: NewlineDelimitedJsonCollatorFactory.fromConfig(env.config, {\n *     type: 'techdocs',\n *     searchPattern: 'https://storage.cloud.google.com/bucket/xyz-*',\n *     reader: env.reader,\n *     logger: env.logger,\n *   })\n * });\n * ```\n *\n * @public\n */\nexport class NewlineDelimitedJsonCollatorFactory\n  implements DocumentCollatorFactory\n{\n  readonly type: string;\n\n  public readonly visibilityPermission: Permission | undefined;\n\n  private constructor(\n    type: string,\n    private readonly searchPattern: string,\n    private readonly reader: UrlReader,\n    private readonly logger: Logger,\n    visibilityPermission: Permission | undefined,\n  ) {\n    this.type = type;\n    this.visibilityPermission = visibilityPermission;\n  }\n\n  /**\n   * Returns a NewlineDelimitedJsonCollatorFactory instance from configuration\n   * and a set of options.\n   */\n  static fromConfig(\n    _config: Config,\n    options: NewlineDelimitedJsonCollatorFactoryOptions,\n  ): NewlineDelimitedJsonCollatorFactory {\n    return new NewlineDelimitedJsonCollatorFactory(\n      options.type,\n      options.searchPattern,\n      options.reader,\n      options.logger.child({ documentType: options.type }),\n      options.visibilityPermission,\n    );\n  }\n\n  /**\n   * Returns the \"latest\" URL for the given search pattern (e.g. the one at the\n   * end of the list, sorted alphabetically).\n   */\n  private async lastUrl(): Promise<string | undefined> {\n    try {\n      // Search for files matching the given pattern, then sort/reverse. The\n      // first item in the list will be the \"latest\" file.\n      this.logger.info(\n        `Attempting to find latest .ndjson matching ${this.searchPattern}`,\n      );\n      const { files } = await this.reader.search(this.searchPattern);\n      const candidates = files\n        .filter(file => file.url.endsWith('.ndjson'))\n        .sort((a, b) => a.url.localeCompare(b.url))\n        .reverse();\n\n      return candidates[0]?.url;\n    } catch (e) {\n      this.logger.error(`Could not search for ${this.searchPattern}`, e);\n      throw e;\n    }\n  }\n\n  async getCollator(): Promise<Readable> {\n    // Search for files matching the given pattern.\n    const lastUrl = await this.lastUrl();\n\n    // Abort if no such file could be found.\n    if (!lastUrl) {\n      const noMatchingFile = `Could not find an .ndjson file matching ${this.searchPattern}`;\n      this.logger.error(noMatchingFile);\n      throw new Error(noMatchingFile);\n    } else {\n      this.logger.info(`Using latest .ndjson file ${lastUrl}`);\n    }\n\n    // Use the UrlReader to try and stream the file.\n    const readerResponse = await this.reader.readUrl!(lastUrl);\n    const stream = readerResponse.stream!();\n\n    // Use ndjson's parser to turn the raw file into an object-mode stream.\n    return stream.pipe(parseNdjson());\n  }\n}\n","/*\n * Copyright 2021 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { isError } from '@backstage/errors';\n\n/**\n *  Failed to query documents for index that does not exist.\n *  @public\n */\nexport class MissingIndexError extends Error {\n  /**\n   * An inner error that caused this error to be thrown, if any.\n   */\n  readonly cause?: Error | undefined;\n\n  constructor(message?: string, cause?: Error | unknown) {\n    super(message);\n\n    Error.captureStackTrace?.(this, this.constructor);\n\n    this.name = this.constructor.name;\n    this.cause = isError(cause) ? cause : undefined;\n  }\n}\n","/*\n * Copyright 2022 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { assertError } from '@backstage/errors';\nimport { IndexableDocument } from '@backstage/plugin-search-common';\nimport { Writable } from 'stream';\n\n/**\n * Options for {@link BatchSearchEngineIndexer}\n * @public\n */\nexport type BatchSearchEngineOptions = {\n  batchSize: number;\n};\n\n/**\n * Base class encapsulating batch-based stream processing. Useful as a base\n * class for search engine indexers.\n * @public\n */\nexport abstract class BatchSearchEngineIndexer extends Writable {\n  private batchSize: number;\n  private currentBatch: IndexableDocument[] = [];\n\n  constructor(options: BatchSearchEngineOptions) {\n    super({ objectMode: true });\n    this.batchSize = options.batchSize;\n  }\n\n  /**\n   * Receives an array of indexable documents (of size this.batchSize) which\n   * should be written to the search engine. This method won't be called again\n   * at least until it resolves.\n   */\n  public abstract index(documents: IndexableDocument[]): Promise<void>;\n\n  /**\n   * Any asynchronous setup tasks can be performed here.\n   */\n  public abstract initialize(): Promise<void>;\n\n  /**\n   * Any asynchronous teardown tasks can be performed here.\n   */\n  public abstract finalize(): Promise<void>;\n\n  /**\n   * Encapsulates initialization logic.\n   * @internal\n   */\n  async _construct(done: (error?: Error | null | undefined) => void) {\n    try {\n      await this.initialize();\n      done();\n    } catch (e) {\n      assertError(e);\n      done(e);\n    }\n  }\n\n  /**\n   * Encapsulates batch stream write logic.\n   * @internal\n   */\n  async _write(\n    doc: IndexableDocument,\n    _e: any,\n    done: (error?: Error | null) => void,\n  ) {\n    this.currentBatch.push(doc);\n    if (this.currentBatch.length < this.batchSize) {\n      done();\n      return;\n    }\n\n    try {\n      await this.index(this.currentBatch);\n      this.currentBatch = [];\n      done();\n    } catch (e) {\n      assertError(e);\n      done(e);\n    }\n  }\n\n  /**\n   * Encapsulates finalization and final error handling logic.\n   * @internal\n   */\n  async _final(done: (error?: Error | null) => void) {\n    try {\n      // Index any remaining documents.\n      if (this.currentBatch.length) {\n        await this.index(this.currentBatch);\n        this.currentBatch = [];\n      }\n      await this.finalize();\n      done();\n    } catch (e) {\n      assertError(e);\n      done(e);\n    }\n  }\n}\n","/*\n * Copyright 2022 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { assertError } from '@backstage/errors';\nimport { IndexableDocument } from '@backstage/plugin-search-common';\nimport { Transform } from 'stream';\n\n/**\n * Base class encapsulating simple async transformations. Useful as a base\n * class for Backstage search decorators.\n * @public\n */\nexport abstract class DecoratorBase extends Transform {\n  constructor() {\n    super({ objectMode: true });\n  }\n\n  /**\n   * Any asynchronous setup tasks can be performed here.\n   */\n  public abstract initialize(): Promise<void>;\n\n  /**\n   * Receives a single indexable document. In your decorate method, you can:\n   *\n   * - Resolve `undefined` to indicate the record should be omitted.\n   * - Resolve a single modified document, which could contain new fields,\n   *   edited fields, or removed fields.\n   * - Resolve an array of indexable documents, if the purpose if the decorator\n   *   is to convert one document into multiple derivative documents.\n   */\n  public abstract decorate(\n    document: IndexableDocument,\n  ): Promise<IndexableDocument | IndexableDocument[] | undefined>;\n\n  /**\n   * Any asynchronous teardown tasks can be performed here.\n   */\n  public abstract finalize(): Promise<void>;\n\n  /**\n   * Encapsulates initialization logic.\n   * @internal\n   */\n  async _construct(done: (error?: Error | null | undefined) => void) {\n    try {\n      await this.initialize();\n      done();\n    } catch (e) {\n      assertError(e);\n      done(e);\n    }\n  }\n\n  /**\n   * Encapsulates simple transform stream logic.\n   * @internal\n   */\n  async _transform(\n    document: IndexableDocument,\n    _: any,\n    done: (error?: Error | null) => void,\n  ) {\n    try {\n      const decorated = await this.decorate(document);\n\n      // If undefined was returned, omit the record and move on.\n      if (decorated === undefined) {\n        done();\n        return;\n      }\n\n      // If an array of documents was given, push them all.\n      if (Array.isArray(decorated)) {\n        decorated.forEach(doc => {\n          this.push(doc);\n        });\n        done();\n        return;\n      }\n\n      // Otherwise, just push the decorated document.\n      this.push(decorated);\n      done();\n    } catch (e) {\n      assertError(e);\n      done(e);\n    }\n  }\n\n  /**\n   * Encapsulates finalization and final error handling logic.\n   * @internal\n   */\n  async _final(done: (error?: Error | null) => void) {\n    try {\n      await this.finalize();\n      done();\n    } catch (e) {\n      assertError(e);\n      done(e);\n    }\n  }\n}\n","/*\n * Copyright 2022 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { IndexableDocument } from '@backstage/plugin-search-common';\nimport lunr from 'lunr';\nimport { BatchSearchEngineIndexer } from '../indexing';\n\n/**\n * Lunr specific search engine indexer\n * @public\n */\nexport class LunrSearchEngineIndexer extends BatchSearchEngineIndexer {\n  private schemaInitialized = false;\n  private builder: lunr.Builder;\n  private docStore: Record<string, IndexableDocument> = {};\n\n  constructor() {\n    super({ batchSize: 1000 });\n\n    this.builder = new lunr.Builder();\n    this.builder.pipeline.add(lunr.trimmer, lunr.stopWordFilter, lunr.stemmer);\n    this.builder.searchPipeline.add(lunr.stemmer);\n    this.builder.metadataWhitelist = ['position'];\n  }\n\n  // No async initialization required.\n  async initialize(): Promise<void> {}\n  async finalize(): Promise<void> {}\n\n  async index(documents: IndexableDocument[]): Promise<void> {\n    if (!this.schemaInitialized) {\n      // Make this lunr index aware of all relevant fields.\n      Object.keys(documents[0]).forEach(field => {\n        this.builder.field(field);\n      });\n\n      // Set \"location\" field as reference field\n      this.builder.ref('location');\n\n      this.schemaInitialized = true;\n    }\n\n    documents.forEach(document => {\n      // Add document to Lunar index\n      this.builder.add(document);\n\n      // Store documents in memory to be able to look up document using the ref during query time\n      // This is not how you should implement your SearchEngine implementation! Do not copy!\n      this.docStore[document.location] = document;\n    });\n  }\n\n  buildIndex() {\n    return this.builder.build();\n  }\n\n  getDocumentStore() {\n    return this.docStore;\n  }\n}\n","/*\n * Copyright 2021 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  IndexableDocument,\n  IndexableResultSet,\n  SearchQuery,\n  QueryTranslator,\n  SearchEngine,\n} from '@backstage/plugin-search-common';\nimport { MissingIndexError } from '../errors';\nimport lunr from 'lunr';\nimport { v4 as uuid } from 'uuid';\nimport { Logger } from 'winston';\nimport { LunrSearchEngineIndexer } from './LunrSearchEngineIndexer';\n\n/**\n * Type of translated query for the Lunr Search Engine.\n * @public\n */\nexport type ConcreteLunrQuery = {\n  lunrQueryBuilder: lunr.Index.QueryBuilder;\n  documentTypes?: string[];\n  pageSize: number;\n};\n\ntype LunrResultEnvelope = {\n  result: lunr.Index.Result;\n  type: string;\n};\n\n/**\n * Translator responsible for translating search term and filters to a query that the Lunr Search Engine understands.\n * @public\n */\nexport type LunrQueryTranslator = (query: SearchQuery) => ConcreteLunrQuery;\n\n/**\n * Lunr specific search engine implementation.\n * @public\n */\nexport class LunrSearchEngine implements SearchEngine {\n  protected lunrIndices: Record<string, lunr.Index> = {};\n  protected docStore: Record<string, IndexableDocument>;\n  protected logger: Logger;\n  protected highlightPreTag: string;\n  protected highlightPostTag: string;\n\n  constructor(options: { logger: Logger }) {\n    this.logger = options.logger;\n    this.docStore = {};\n    const uuidTag = uuid();\n    this.highlightPreTag = `<${uuidTag}>`;\n    this.highlightPostTag = `</${uuidTag}>`;\n  }\n\n  protected translator: QueryTranslator = ({\n    term,\n    filters,\n    types,\n    pageLimit,\n  }: SearchQuery): ConcreteLunrQuery => {\n    const pageSize = pageLimit || 25;\n\n    return {\n      lunrQueryBuilder: q => {\n        const termToken = lunr.tokenizer(term);\n\n        // Support for typeahead search is based on https://github.com/olivernn/lunr.js/issues/256#issuecomment-295407852\n        // look for an exact match and apply a large positive boost\n        q.term(termToken, {\n          usePipeline: true,\n          boost: 100,\n        });\n        // look for terms that match the beginning of this term and apply a\n        // medium boost\n        q.term(termToken, {\n          usePipeline: false,\n          boost: 10,\n          wildcard: lunr.Query.wildcard.TRAILING,\n        });\n        // look for terms that match with an edit distance of 2 and apply a\n        // small boost\n        q.term(termToken, {\n          usePipeline: false,\n          editDistance: 2,\n          boost: 1,\n        });\n\n        if (filters) {\n          Object.entries(filters).forEach(([field, fieldValue]) => {\n            if (!q.allFields.includes(field)) {\n              // Throw for unknown field, as this will be a non match\n              throw new Error(`unrecognised field ${field}`);\n            }\n            // Arrays are poorly supported, but we can make it better for single-item arrays,\n            // which should be a common case\n            const value =\n              Array.isArray(fieldValue) && fieldValue.length === 1\n                ? fieldValue[0]\n                : fieldValue;\n\n            // Require that the given field has the given value\n            if (['string', 'number', 'boolean'].includes(typeof value)) {\n              q.term(\n                lunr\n                  .tokenizer(value?.toString())\n                  .map(lunr.stopWordFilter)\n                  .filter(element => element !== undefined),\n                {\n                  presence: lunr.Query.presence.REQUIRED,\n                  fields: [field],\n                },\n              );\n            } else if (Array.isArray(value)) {\n              // Illustrate how multi-value filters could work.\n              // But warn that Lurn supports this poorly.\n              this.logger.warn(\n                `Non-scalar filter value used for field ${field}. Consider using a different Search Engine for better results.`,\n              );\n              q.term(lunr.tokenizer(value), {\n                presence: lunr.Query.presence.OPTIONAL,\n                fields: [field],\n              });\n            } else {\n              // Log a warning or something about unknown filter value\n              this.logger.warn(`Unknown filter type used on field ${field}`);\n            }\n          });\n        }\n      },\n      documentTypes: types,\n      pageSize,\n    };\n  };\n\n  setTranslator(translator: LunrQueryTranslator) {\n    this.translator = translator;\n  }\n\n  async getIndexer(type: string) {\n    const indexer = new LunrSearchEngineIndexer();\n    const indexerLogger = this.logger.child({ documentType: type });\n    let errorThrown: Error | undefined;\n\n    indexer.on('error', err => {\n      errorThrown = err;\n    });\n\n    indexer.on('close', () => {\n      // Once the stream is closed, build the index and store the documents in\n      // memory for later retrieval.\n      const newDocuments = indexer.getDocumentStore();\n      const docStoreExists = this.lunrIndices[type] !== undefined;\n      const documentsIndexed = Object.keys(newDocuments).length;\n\n      // Do not set the index if there was an error or if no documents were\n      // indexed. This ensures search continues to work for an index, even in\n      // case of transient issues in underlying collators.\n      if (!errorThrown && documentsIndexed > 0) {\n        this.lunrIndices[type] = indexer.buildIndex();\n        this.docStore = { ...this.docStore, ...newDocuments };\n      } else {\n        indexerLogger.warn(\n          `Index for ${type} was not ${\n            docStoreExists ? 'replaced' : 'created'\n          }: ${\n            errorThrown\n              ? 'an error was encountered'\n              : 'indexer received 0 documents'\n          }`,\n        );\n      }\n    });\n\n    return indexer;\n  }\n\n  async query(query: SearchQuery): Promise<IndexableResultSet> {\n    const { lunrQueryBuilder, documentTypes, pageSize } = this.translator(\n      query,\n    ) as ConcreteLunrQuery;\n\n    const results: LunrResultEnvelope[] = [];\n\n    const indexKeys = Object.keys(this.lunrIndices).filter(\n      type => !documentTypes || documentTypes.includes(type),\n    );\n\n    if (documentTypes?.length && !indexKeys.length) {\n      throw new MissingIndexError(\n        `Missing index for ${documentTypes?.toString()}. This could be because the index hasn't been created yet or there was a problem during index creation.`,\n      );\n    }\n\n    // Iterate over the filtered list of this.lunrIndex keys.\n    indexKeys.forEach(type => {\n      try {\n        results.push(\n          ...this.lunrIndices[type].query(lunrQueryBuilder).map(result => {\n            return {\n              result: result,\n              type: type,\n            };\n          }),\n        );\n      } catch (err) {\n        // if a field does not exist on a index, we can see that as a no-match\n        if (\n          err instanceof Error &&\n          err.message.startsWith('unrecognised field')\n        ) {\n          return;\n        }\n        throw err;\n      }\n    });\n\n    // Sort results.\n    results.sort((doc1, doc2) => {\n      return doc2.result.score - doc1.result.score;\n    });\n\n    // Perform paging\n    const { page } = decodePageCursor(query.pageCursor);\n    const offset = page * pageSize;\n    const hasPreviousPage = page > 0;\n    const hasNextPage = results.length > offset + pageSize;\n    const nextPageCursor = hasNextPage\n      ? encodePageCursor({ page: page + 1 })\n      : undefined;\n    const previousPageCursor = hasPreviousPage\n      ? encodePageCursor({ page: page - 1 })\n      : undefined;\n\n    // Translate results into IndexableResultSet\n    const realResultSet: IndexableResultSet = {\n      results: results.slice(offset, offset + pageSize).map((d, index) => ({\n        type: d.type,\n        document: this.docStore[d.result.ref],\n        rank: page * pageSize + index + 1,\n        highlight: {\n          preTag: this.highlightPreTag,\n          postTag: this.highlightPostTag,\n          fields: parseHighlightFields({\n            preTag: this.highlightPreTag,\n            postTag: this.highlightPostTag,\n            doc: this.docStore[d.result.ref],\n            positionMetadata: d.result.matchData.metadata as any,\n          }),\n        },\n      })),\n      numberOfResults: results.length,\n      nextPageCursor,\n      previousPageCursor,\n    };\n\n    return realResultSet;\n  }\n}\n\nexport function decodePageCursor(pageCursor?: string): { page: number } {\n  if (!pageCursor) {\n    return { page: 0 };\n  }\n\n  return {\n    page: Number(Buffer.from(pageCursor, 'base64').toString('utf-8')),\n  };\n}\n\nexport function encodePageCursor({ page }: { page: number }): string {\n  return Buffer.from(`${page}`, 'utf-8').toString('base64');\n}\n\ntype ParseHighlightFieldsProps = {\n  preTag: string;\n  postTag: string;\n  doc: any;\n  positionMetadata: {\n    [term: string]: {\n      [field: string]: {\n        position: number[][];\n      };\n    };\n  };\n};\n\nexport function parseHighlightFields({\n  preTag,\n  postTag,\n  doc,\n  positionMetadata,\n}: ParseHighlightFieldsProps): { [field: string]: string } {\n  // Merge the field positions across all query terms\n  const highlightFieldPositions = Object.values(positionMetadata).reduce(\n    (fieldPositions, metadata) => {\n      Object.keys(metadata).map(fieldKey => {\n        const validFieldMetadataPositions = metadata[\n          fieldKey\n        ]?.position?.filter(position => Array.isArray(position));\n        if (validFieldMetadataPositions.length) {\n          fieldPositions[fieldKey] = fieldPositions[fieldKey] ?? [];\n          fieldPositions[fieldKey].push(...validFieldMetadataPositions);\n        }\n      });\n\n      return fieldPositions;\n    },\n    {} as { [field: string]: number[][] },\n  );\n\n  return Object.fromEntries(\n    Object.entries(highlightFieldPositions).map(([field, positions]) => {\n      positions.sort((a, b) => b[0] - a[0]);\n\n      const highlightedField = positions.reduce((content, pos) => {\n        return (\n          `${String(content).substring(0, pos[0])}${preTag}` +\n          `${String(content).substring(pos[0], pos[0] + pos[1])}` +\n          `${postTag}${String(content).substring(pos[0] + pos[1])}`\n        );\n      }, doc[field] ?? '');\n\n      return [field, highlightedField];\n    }),\n  );\n}\n","/*\n * Copyright 2022 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { IndexableDocument } from '@backstage/plugin-search-common';\nimport { pipeline, Readable, Transform, Writable } from 'stream';\n\n/**\n * Object resolved after a test pipeline is executed.\n * @public\n */\nexport type TestPipelineResult = {\n  /**\n   * If an error was emitted by the pipeline, it will be set here.\n   */\n  error: unknown;\n\n  /**\n   * A list of documents collected at the end of the pipeline. If the subject\n   * under test is an indexer, this will be an empty array (because your\n   * indexer should have received the documents instead).\n   */\n  documents: IndexableDocument[];\n};\n\n/**\n * Test utility for Backstage Search collators, decorators, and indexers.\n *\n * @example\n * An example test checking that a collator provides expected documents.\n * ```\n * it('provides expected documents', async () => {\n *   const testSubject = await yourCollatorFactory.getCollator();\n *   const pipeline = TestPipeline.fromCollator(testSubject);\n *\n *   const { documents } = await pipeline.execute();\n *\n *   expect(documents).toHaveLength(2);\n * })\n * ```\n *\n * @example\n * An example test checking that a decorator behaves as expected.\n * ```\n * it('filters private documents', async () => {\n *   const testSubject = await yourDecoratorFactory.getDecorator();\n *   const pipeline = TestPipeline\n *     .fromDecorator(testSubject)\n *     .withDocuments([{ title: 'Private', location: '/private', text: '' }]);\n *\n *   const { documents } = await pipeline.execute();\n *\n *   expect(documents).toHaveLength(0);\n * })\n * ```\n *\n * @public\n */\nexport class TestPipeline {\n  private collator?: Readable;\n  private decorator?: Transform;\n  private indexer?: Writable;\n\n  private constructor({\n    collator,\n    decorator,\n    indexer,\n  }: {\n    collator?: Readable;\n    decorator?: Transform;\n    indexer?: Writable;\n  }) {\n    this.collator = collator;\n    this.decorator = decorator;\n    this.indexer = indexer;\n  }\n\n  /**\n   * Provide the collator, decorator, or indexer to be tested.\n   *\n   * @deprecated Use `fromCollator`, `fromDecorator` or `fromIndexer` static\n   *   methods to create a test pipeline instead.\n   */\n  static withSubject(subject: Readable | Transform | Writable) {\n    if (subject instanceof Transform) {\n      return new TestPipeline({ decorator: subject });\n    }\n\n    if (subject instanceof Writable) {\n      return new TestPipeline({ indexer: subject });\n    }\n\n    if (subject.readable || subject instanceof Readable) {\n      return new TestPipeline({ collator: subject });\n    }\n\n    throw new Error(\n      'Unknown test subject: are you passing a readable, writable, or transform stream?',\n    );\n  }\n\n  /**\n   * Create a test pipeline given a collator you want to test.\n   */\n  static fromCollator(collator: Readable) {\n    return new TestPipeline({ collator });\n  }\n\n  /**\n   * Add a collator to the test pipeline.\n   */\n  withCollator(collator: Readable): this {\n    this.collator = collator;\n    return this;\n  }\n\n  /**\n   * Create a test pipeline given a decorator you want to test.\n   */\n  static fromDecorator(decorator: Transform) {\n    return new TestPipeline({ decorator });\n  }\n\n  /**\n   * Add a decorator to the test pipeline.\n   */\n  withDecorator(decorator: Transform): this {\n    this.decorator = decorator;\n    return this;\n  }\n\n  /**\n   * Create a test pipeline given an indexer you want to test.\n   */\n  static fromIndexer(indexer: Writable) {\n    return new TestPipeline({ indexer });\n  }\n\n  /**\n   * Add an indexer to the test pipeline.\n   */\n  withIndexer(indexer: Writable): this {\n    this.indexer = indexer;\n    return this;\n  }\n\n  /**\n   * Provide documents for testing decorators and indexers.\n   */\n  withDocuments(documents: IndexableDocument[]): TestPipeline {\n    if (this.collator) {\n      throw new Error('Cannot provide documents when testing a collator.');\n    }\n\n    // Set a naive readable stream that just pushes all given documents.\n    this.collator = new Readable({ objectMode: true });\n    this.collator._read = () => {};\n    process.nextTick(() => {\n      documents.forEach(document => {\n        this.collator!.push(document);\n      });\n      this.collator!.push(null);\n    });\n\n    return this;\n  }\n\n  /**\n   * Execute the test pipeline so that you can make assertions about the result\n   * or behavior of the given test subject.\n   */\n  async execute(): Promise<TestPipelineResult> {\n    const documents: IndexableDocument[] = [];\n    if (!this.collator) {\n      throw new Error(\n        'Cannot execute pipeline without a collator or documents',\n      );\n    }\n\n    // If we are here and there is no indexer, we are testing a collator or a\n    // decorator. Set up a naive writable that captures documents in memory.\n    if (!this.indexer) {\n      this.indexer = new Writable({ objectMode: true });\n      this.indexer._write = (document: IndexableDocument, _, done) => {\n        documents.push(document);\n        done();\n      };\n    }\n\n    return new Promise<TestPipelineResult>(done => {\n      const pipes: (Readable | Transform | Writable)[] = [this.collator!];\n      if (this.decorator) {\n        pipes.push(this.decorator);\n      }\n      pipes.push(this.indexer!);\n\n      pipeline(pipes, (error: NodeJS.ErrnoException | null) => {\n        done({\n          error,\n          documents,\n        });\n      });\n    });\n  }\n}\n"],"names":["__publicField","parseNdjson","isError","Writable","assertError","Transform","lunr","uuid","Readable","pipeline"],"mappings":"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"}