'use strict';

var fs = require('fs-extra');
var path = require('path');
var webpack = require('webpack');
require('eslint-webpack-plugin');
require('fork-ts-checker-webpack-plugin');
require('html-webpack-plugin');
require('@backstage/cli-common');
require('react-dev-utils/ModuleScopePlugin');
require('run-script-webpack-plugin');
require('./index-f60e95c6.cjs.js');
require('@manypkg/get-packages');
require('webpack-node-externals');
var packageDetection = require('./packageDetection-7835e3a7.cjs.js');
require('lodash/pickBy');
require('./run-92501f36.cjs.js');
require('mini-css-extract-plugin');
require('@pmmmwh/react-refresh-webpack-plugin');
var yn = require('yn');
var FileSizeReporter = require('react-dev-utils/FileSizeReporter');
var formatWebpackMessages = require('react-dev-utils/formatWebpackMessages');
var chalk = require('chalk');
require('@backstage/cli-node');
require('lodash/uniq');
require('react-dev-utils/openBrowser');
require('webpack-dev-server');
require('semver');
require('@yarnpkg/parsers');
require('@yarnpkg/lockfile');
require('minimatch');
require('./yarn-6cd89e16.cjs.js');
require('lodash/partition');
var config = require('./config-49d4900d.cjs.js');
require('@backstage/config');
require('chokidar');
var parallel = require('./parallel-2d9d247e.cjs.js');
var os = require('os');
var tar = require('tar');
var createDistWorkspace = require('./createDistWorkspace-d32f2b07.cjs.js');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var fs__default = /*#__PURE__*/_interopDefaultLegacy(fs);
var webpack__default = /*#__PURE__*/_interopDefaultLegacy(webpack);
var yn__default = /*#__PURE__*/_interopDefaultLegacy(yn);
var formatWebpackMessages__default = /*#__PURE__*/_interopDefaultLegacy(formatWebpackMessages);
var chalk__default = /*#__PURE__*/_interopDefaultLegacy(chalk);
var os__default = /*#__PURE__*/_interopDefaultLegacy(os);
var tar__default = /*#__PURE__*/_interopDefaultLegacy(tar);

const WARN_AFTER_BUNDLE_GZIP_SIZE = 512 * 1024;
const WARN_AFTER_CHUNK_GZIP_SIZE = 1024 * 1024;
function applyContextToError(error, moduleName) {
  return `Failed to compile '${moduleName}':
  ${error}`;
}
async function buildBundle(options) {
  const { statsJsonEnabled, schema: configSchema } = options;
  const paths = packageDetection.resolveBundlingPaths(options);
  const detectedModulesEntryPoint = await packageDetection.createDetectedModulesEntryPoint({
    config: options.fullConfig,
    targetPath: paths.targetPath
  });
  const config = await packageDetection.createConfig(paths, {
    ...options,
    checksEnabled: false,
    isDev: false,
    baseUrl: packageDetection.resolveBaseUrl(options.frontendConfig),
    getFrontendAppConfigs: () => options.frontendAppConfigs,
    additionalEntryPoints: detectedModulesEntryPoint
  });
  const isCi = yn__default["default"](process.env.CI, { default: false });
  const previousFileSizes = await FileSizeReporter.measureFileSizesBeforeBuild(paths.targetDist);
  await fs__default["default"].emptyDir(paths.targetDist);
  if (paths.targetPublic) {
    await fs__default["default"].copy(paths.targetPublic, paths.targetDist, {
      dereference: true,
      filter: (file) => file !== paths.targetHtml
    });
  }
  if (configSchema) {
    await fs__default["default"].writeJson(
      path.resolve(paths.targetDist, ".config-schema.json"),
      configSchema.serialize(),
      { spaces: 2 }
    );
  }
  const { stats } = await build(config, isCi);
  if (!stats) {
    throw new Error("No stats returned");
  }
  if (statsJsonEnabled) {
    await require("bfj").write(
      path.resolve(paths.targetDist, "bundle-stats.json"),
      stats.toJson()
    );
  }
  FileSizeReporter.printFileSizesAfterBuild(
    stats,
    previousFileSizes,
    paths.targetDist,
    WARN_AFTER_BUNDLE_GZIP_SIZE,
    WARN_AFTER_CHUNK_GZIP_SIZE
  );
}
async function build(config, isCi) {
  var _a, _b, _c;
  const stats = await new Promise(
    (resolve, reject) => {
      webpack__default["default"](config, (err, buildStats) => {
        if (err) {
          if (err.message) {
            const { errors: errors2 } = formatWebpackMessages__default["default"]({
              errors: [err.message],
              warnings: new Array(),
              _showErrors: true,
              _showWarnings: true
            });
            throw new Error(errors2[0]);
          } else {
            reject(err);
          }
        } else {
          resolve(buildStats);
        }
      });
    }
  );
  if (!stats) {
    throw new Error("Failed to compile: No stats provided");
  }
  const serializedStats = stats.toJson({
    all: false,
    warnings: true,
    errors: true
  });
  const { errors, warnings } = formatWebpackMessages__default["default"]({
    errors: serializedStats.errors,
    warnings: serializedStats.warnings
  });
  if (errors.length) {
    const errorWithContext = applyContextToError(
      errors[0],
      (_c = (_b = (_a = serializedStats.errors) == null ? void 0 : _a[0]) == null ? void 0 : _b.moduleName) != null ? _c : ""
    );
    throw new Error(errorWithContext);
  }
  if (isCi && warnings.length) {
    const warningsWithContext = warnings.map((warning, i) => {
      var _a2, _b2, _c2;
      return applyContextToError(
        warning,
        (_c2 = (_b2 = (_a2 = serializedStats.warnings) == null ? void 0 : _a2[i]) == null ? void 0 : _b2.moduleName) != null ? _c2 : ""
      );
    });
    console.log(
      chalk__default["default"].yellow(
        "\nTreating warnings as errors because process.env.CI = true.\n"
      )
    );
    throw new Error(warningsWithContext.join("\n\n"));
  }
  return { stats };
}

async function buildFrontend(options) {
  const { targetDir, writeStats, configPaths } = options;
  const { name } = await fs__default["default"].readJson(path.resolve(targetDir, "package.json"));
  await buildBundle({
    targetDir,
    entry: "src/index",
    parallelism: parallel.getEnvironmentParallelism(),
    statsJsonEnabled: writeStats,
    ...await config.loadCliConfig({
      args: configPaths,
      fromPackage: name
    })
  });
}

const BUNDLE_FILE = "bundle.tar.gz";
const SKELETON_FILE = "skeleton.tar.gz";
async function buildBackend(options) {
  const { targetDir, skipBuildDependencies, configPaths } = options;
  const pkg = await fs__default["default"].readJson(path.resolve(targetDir, "package.json"));
  await createDistWorkspace.buildPackage({
    targetDir: options.targetDir,
    packageJson: pkg,
    outputs: /* @__PURE__ */ new Set([createDistWorkspace.Output.cjs])
  });
  const tmpDir = await fs__default["default"].mkdtemp(path.resolve(os__default["default"].tmpdir(), "backstage-bundle"));
  try {
    await createDistWorkspace.createDistWorkspace([pkg.name], {
      targetDir: tmpDir,
      configPaths,
      buildDependencies: !skipBuildDependencies,
      buildExcludes: [pkg.name],
      parallelism: parallel.getEnvironmentParallelism(),
      skeleton: SKELETON_FILE
    });
    const distDir = path.resolve(targetDir, "dist");
    await fs__default["default"].remove(distDir);
    await fs__default["default"].mkdir(distDir);
    await fs__default["default"].move(
      path.resolve(tmpDir, SKELETON_FILE),
      path.resolve(distDir, SKELETON_FILE)
    );
    await tar__default["default"].create(
      {
        file: path.resolve(distDir, BUNDLE_FILE),
        cwd: tmpDir,
        portable: true,
        noMtime: true,
        gzip: true
      },
      [""]
    );
  } finally {
    await fs__default["default"].remove(tmpDir);
  }
}

exports.buildBackend = buildBackend;
exports.buildFrontend = buildFrontend;
//# sourceMappingURL=buildBackend-1c2c26f2.cjs.js.map
