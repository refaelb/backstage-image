'use strict';

var chalk = require('chalk');
var inquirer = require('inquirer');
var tasks = require('./tasks-84de240c.cjs.js');
var oauthApp = require('@octokit/oauth-app');
var fs = require('fs-extra');
var yaml = require('yaml');
var cliCommon = require('@backstage/cli-common');
var path = require('path');
var differ = require('diff');
var config = require('./config-49d4900d.cjs.js');
var catalogModel = require('@backstage/catalog-model');
var z = require('zod');
var integration = require('@backstage/integration');
var graphql = require('@octokit/graphql');
var parseGitUrl = require('git-url-parse');
var fetch = require('node-fetch');
require('handlebars');
require('ora');
require('util');
require('recursive-readdir');
require('child_process');
require('@backstage/errors');
require('@backstage/config-loader');
require('@backstage/config');
require('./index-f60e95c6.cjs.js');
require('commander');
require('semver');
require('@manypkg/get-packages');
require('@backstage/cli-node');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var chalk__default = /*#__PURE__*/_interopDefaultLegacy(chalk);
var inquirer__default = /*#__PURE__*/_interopDefaultLegacy(inquirer);
var fs__namespace = /*#__PURE__*/_interopNamespace(fs);
var fs__default = /*#__PURE__*/_interopDefaultLegacy(fs);
var yaml__default = /*#__PURE__*/_interopDefaultLegacy(yaml);
var path__namespace = /*#__PURE__*/_interopNamespace(path);
var differ__namespace = /*#__PURE__*/_interopNamespace(differ);
var z__default = /*#__PURE__*/_interopDefaultLegacy(z);
var parseGitUrl__default = /*#__PURE__*/_interopDefaultLegacy(parseGitUrl);
var fetch__default = /*#__PURE__*/_interopDefaultLegacy(fetch);

const readYaml = async (file) => {
  return yaml__default["default"].parse(await fs__namespace.readFile(file, "utf8"));
};
const updateConfigFile = async (file, config) => {
  const staticContent = "# Backstage override configuration for your local development environment \n";
  const content = fs__namespace.existsSync(file) ? yaml__default["default"].stringify(
    { ...await readYaml(file), ...config },
    {
      indent: 2
    }
  ) : staticContent.concat(
    yaml__default["default"].stringify(
      { ...config },
      {
        indent: 2
      }
    )
  );
  return await fs__namespace.writeFile(file, content, "utf8");
};

const { targetRoot: targetRoot$1, ownDir } = cliCommon.findPaths(__dirname);
const APP_CONFIG_FILE = path__namespace.join(targetRoot$1, "app-config.local.yaml");
const DISCOVERED_ENTITIES_FILE = path__namespace.join(
  targetRoot$1,
  "examples",
  "discovered-entities.yaml"
);
const PATCH_FOLDER = path__namespace.join(
  ownDir,
  "src",
  "commands",
  "onboard",
  "auth",
  "patches"
);

const { targetRoot } = cliCommon.findPaths(__dirname);
const patch = async (patchFile) => {
  const patchContent = await fs__namespace.readFile(
    path__namespace.join(PATCH_FOLDER, patchFile),
    "utf8"
  );
  const targetName = patchContent.split("\n")[0].replace("--- a", "");
  const targetFile = path__namespace.join(targetRoot, targetName);
  const oldContent = await fs__namespace.readFile(targetFile, "utf8");
  const newContent = differ__namespace.applyPatch(oldContent, patchContent);
  if (!newContent) {
    throw new Error(
      `Patch ${patchFile} was not applied correctly.
       Did you change ${targetName} manually before running this command?`
    );
  }
  return await fs__namespace.writeFile(targetFile, newContent, "utf8");
};

const validateCredentials = async (clientId, clientSecret) => {
  try {
    const app = new oauthApp.OAuthApp({
      clientId,
      clientSecret
    });
    await app.createToken({
      code: "%NOT-VALID-CODE%"
    });
  } catch (error) {
    if (error.response.status !== 200 && error.response.data.error !== "bad_verification_code") {
      throw new Error(`Validating GitHub Credentials failed.`);
    }
  }
};
const getConfig$2 = (answers) => {
  const { clientId, clientSecret, hasEnterprise, enterpriseInstanceUrl } = answers;
  return {
    auth: {
      providers: {
        github: {
          development: {
            clientId,
            clientSecret,
            ...hasEnterprise && {
              enterpriseInstanceUrl
            }
          }
        }
      }
    }
  };
};
const github$1 = async () => {
  tasks.Task.log(`
    To add GitHub authentication, you must create an OAuth App from the GitHub developer settings: ${chalk__default["default"].blue(
    "https://github.com/settings/developers"
  )}
    The Homepage URL should point to Backstage's frontend, while the Authorization callback URL will point to the auth backend.

    Settings for local development:
    ${chalk__default["default"].cyan(`
      Homepage URL: http://localhost:3000
      Authorization callback URL: http://localhost:7007/api/auth/github/handler/frame`)}

    You can find the full documentation page here: ${chalk__default["default"].blue(
    "https://backstage.io/docs/auth/github/provider"
  )}
    `);
  const answers = await inquirer__default["default"].prompt([
    {
      type: "input",
      name: "clientId",
      message: "What is your Client Id?",
      validate: (input) => input.length ? true : false
    },
    {
      type: "input",
      name: "clientSecret",
      message: "What is your Client Secret?",
      validate: (input) => input.length ? true : false
    },
    {
      type: "confirm",
      name: "hasEnterprise",
      message: "Are you using GitHub Enterprise?"
    },
    {
      type: "input",
      name: "enterpriseInstanceUrl",
      message: "What is your URL for GitHub Enterprise?",
      when: ({ hasEnterprise }) => hasEnterprise,
      validate: (input) => Boolean(new URL(input))
    }
  ]);
  const { clientId, clientSecret } = answers;
  const config = getConfig$2(answers);
  tasks.Task.log("Setting up GitHub Authentication for you...");
  await tasks.Task.forItem(
    "Validating",
    "credentials",
    async () => await validateCredentials(clientId, clientSecret)
  );
  await tasks.Task.forItem(
    "Updating",
    APP_CONFIG_FILE,
    async () => await updateConfigFile(APP_CONFIG_FILE, config)
  );
  const patches = await fs__namespace.readdir(PATCH_FOLDER);
  for (const patchFile of patches.filter((p) => p.includes("github"))) {
    await tasks.Task.forItem("Patching", patchFile, async () => {
      await patch(patchFile);
    });
  }
  return answers;
};

const getConfig$1 = (answers) => {
  const { clientId, clientSecret, hasAudience, audience } = answers;
  return {
    auth: {
      providers: {
        gitlab: {
          development: {
            clientId,
            clientSecret,
            ...hasAudience && {
              audience
            }
          }
        }
      }
    }
  };
};
const gitlab = async () => {
  tasks.Task.log(`
    To add GitLab authentication, you must create an Application from the GitLab Settings: ${chalk__default["default"].blue(
    "https://gitlab.com/-/profile/applications"
  )}
    The Redirect URI should point to your Backstage backend auth handler.

    Settings for local development:
    ${chalk__default["default"].cyan(`
        Name: Backstage (or your custom app name)
        Redirect URI: http://localhost:7007/api/auth/gitlab/handler/frame
        Scopes: read_api and read_user`)}

    You can find the full documentation page here: ${chalk__default["default"].blue(
    "https://backstage.io/docs/auth/gitlab/provider"
  )}
    `);
  const answers = await inquirer__default["default"].prompt([
    {
      type: "input",
      name: "clientId",
      message: "What is your Application Id?",
      validate: (input) => input.length ? true : false
    },
    {
      type: "input",
      name: "clientSecret",
      message: "What is your Application Secret?",
      validate: (input) => input.length ? true : false
    },
    {
      type: "confirm",
      name: "hasAudience",
      message: "Do you have a self-hosted instance of GitLab?"
    },
    {
      type: "input",
      name: "audience",
      message: "What is the URL for your GitLab instance?",
      when: ({ hasAudience }) => hasAudience,
      validate: (input) => Boolean(new URL(input))
    }
  ]);
  const config = getConfig$1(answers);
  tasks.Task.log("Setting up GitLab Authentication for you...");
  await tasks.Task.forItem(
    "Updating",
    APP_CONFIG_FILE,
    async () => await updateConfigFile(APP_CONFIG_FILE, config)
  );
  const patches = await fs__namespace.readdir(PATCH_FOLDER);
  for (const patchFile of patches.filter((p) => p.includes("gitlab"))) {
    await tasks.Task.forItem("Patching", patchFile, async () => {
      await patch(patchFile);
    });
  }
  return answers;
};

async function auth() {
  const answers = await inquirer__default["default"].prompt([
    {
      type: "list",
      name: "provider",
      message: "Please select an authentication provider:",
      choices: ["GitHub", "GitLab"]
    }
  ]);
  const { provider } = answers;
  let providerAnswers;
  switch (provider) {
    case "GitHub": {
      providerAnswers = await github$1();
      break;
    }
    case "GitLab": {
      providerAnswers = await gitlab();
      break;
    }
    default:
      throw new Error(`Provider ${provider} not implemented yet.`);
  }
  tasks.Task.log();
  tasks.Task.log(`Done setting up ${provider} Authentication!`);
  tasks.Task.log();
  return {
    provider,
    answers: providerAnswers
  };
}

const getConfig = ({
  hasEnterprise,
  apiBaseUrl,
  host,
  token
}) => ({
  integrations: {
    github: [
      {
        host,
        token,
        ...hasEnterprise && {
          apiBaseUrl
        }
      }
    ]
  }
});
const github = async (providerAnswers) => {
  var _a, _b, _c;
  const answers = await inquirer__default["default"].prompt([
    {
      type: "confirm",
      name: "hasEnterprise",
      message: "Are you using GitHub Enterprise?",
      when: () => typeof providerAnswers === "undefined"
    },
    {
      type: "input",
      name: "enterpriseInstanceUrl",
      message: "What is your URL for GitHub Enterprise?",
      when: ({ hasEnterprise }) => hasEnterprise,
      validate: (input) => Boolean(new URL(input))
    },
    {
      type: "input",
      name: "apiBaseUrl",
      message: "What is your GitHub Enterprise API path?",
      default: "/api/v3",
      when: ({ hasEnterprise }) => hasEnterprise || (providerAnswers == null ? void 0 : providerAnswers.hasEnterprise)
      // TODO(tudi2d): Fetch API using OAuth Token if Auth was set up
    }
  ]);
  const host = new URL(
    (_b = (_a = providerAnswers == null ? void 0 : providerAnswers.enterpriseInstanceUrl) != null ? _a : answers == null ? void 0 : answers.enterpriseInstanceUrl) != null ? _b : "http://github.com"
  );
  tasks.Task.log(`
      To create new repositories in GitHub using Software Templates you first need to create a personal access token: ${chalk__default["default"].blue(
    `${host.origin}/settings/tokens/new`
  )}
  
      Select the following scopes:

      Reading software components:${chalk__default["default"].cyan(`
            - "repo"`)}
            
      Reading organization data:${chalk__default["default"].cyan(`
            - "read:org"
            - "read:user"
            - "user:email"`)}

      Publishing software templates:${chalk__default["default"].cyan(`
            - "repo"
            - "workflow"    (if templates include GitHub workflows)
    `)}

      You can find the full documentation page here: ${chalk__default["default"].blue(
    "https://backstage.io/docs/integrations/github/locations"
  )}
      `);
  const { token } = await inquirer__default["default"].prompt([
    {
      type: "input",
      name: "token",
      message: "Please insert your personal access token to setup the GitHub Integration"
      // TODO(tudi2d): validate
    }
  ]);
  const config = getConfig({
    hasEnterprise: (_c = providerAnswers == null ? void 0 : providerAnswers.hasEnterprise) != null ? _c : answers.hasEnterprise,
    apiBaseUrl: host.origin + answers.apiBaseUrl,
    host: host.hostname,
    token
  });
  tasks.Task.log("Setting up Software Templates using GitHub integration for you...");
  await tasks.Task.forItem(
    "Updating",
    APP_CONFIG_FILE,
    async () => await updateConfigFile(APP_CONFIG_FILE, config)
  );
};

const Integrations = ["GitHub" /* GITHUB */];
async function integrations(providerInfo) {
  const answers = await inquirer__default["default"].prompt([
    {
      type: "confirm",
      name: "shouldUsePreviousProvider",
      message: `Do you want to keep using ${providerInfo == null ? void 0 : providerInfo.provider} as your provider when setting up Software Templates?`,
      when: () => (providerInfo == null ? void 0 : providerInfo.provider) && Object.values(Integrations).includes(
        providerInfo.provider
      )
    },
    {
      // TODO(tudi2d): Let's start with one, but it should be multiple choice in the future
      type: "list",
      name: "integration",
      message: "Please select an integration provider:",
      choices: Integrations,
      when: ({ shouldUsePreviousProvider }) => !shouldUsePreviousProvider
    }
  ]);
  if (answers.shouldUsePreviousProvider) {
    answers.integration = providerInfo.provider;
  }
  switch (answers.integration) {
    case "GitHub" /* GITHUB */: {
      const providerAnswers = (providerInfo == null ? void 0 : providerInfo.provider) === "GitHub" ? providerInfo.answers : void 0;
      await github(providerAnswers);
      break;
    }
  }
  tasks.Task.log();
  tasks.Task.log(`Done setting up ${answers.integration} Integration!`);
  tasks.Task.log();
}

var __accessCheck$7 = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet$6 = (obj, member, getter) => {
  __accessCheck$7(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd$7 = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var _outputs;
class DefaultAnalysisOutputs {
  constructor() {
    __privateAdd$7(this, _outputs, /* @__PURE__ */ new Map());
  }
  produce(output) {
    __privateGet$6(this, _outputs).set(output.entity.metadata.name, output);
  }
  list() {
    return Array.from(__privateGet$6(this, _outputs)).map(([_, output]) => output);
  }
}
_outputs = new WeakMap();

var __accessCheck$6 = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet$5 = (obj, member, getter) => {
  __accessCheck$6(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd$6 = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var _providers, _analyzers;
class Discovery {
  constructor() {
    __privateAdd$6(this, _providers, []);
    __privateAdd$6(this, _analyzers, []);
  }
  addProvider(provider) {
    __privateGet$5(this, _providers).push(provider);
  }
  addAnalyzer(analyzer) {
    __privateGet$5(this, _analyzers).push(analyzer);
  }
  async run(url) {
    tasks.Task.log(`Running discovery for ${chalk__default["default"].cyan(url)}`);
    const result = [];
    for (const provider of __privateGet$5(this, _providers)) {
      const repositories = await provider.discover(url);
      if (repositories && repositories.length) {
        tasks.Task.log(
          `Discovered ${chalk__default["default"].cyan(
            repositories.length
          )} repositories for ${chalk__default["default"].cyan(provider.name())}`
        );
        for (const repository of repositories) {
          await tasks.Task.forItem("Analyzing", repository.name, async () => {
            const output = new DefaultAnalysisOutputs();
            for (const analyzer of __privateGet$5(this, _analyzers)) {
              await analyzer.analyzeRepository({ repository, output });
            }
            output.list().filter((entry) => entry.type === "entity").forEach(({ entity }) => result.push(entity));
          });
        }
        tasks.Task.log(`Produced ${chalk__default["default"].cyan(result.length || "no")} entities`);
      }
    }
    return {
      entities: result
    };
  }
}
_providers = new WeakMap();
_analyzers = new WeakMap();

class BasicRepositoryAnalyzer {
  name() {
    return BasicRepositoryAnalyzer.name;
  }
  async analyzeRepository(options) {
    const entity = {
      apiVersion: "backstage.io/v1alpha1",
      kind: "Component",
      metadata: {
        name: options.repository.name,
        ...options.repository.description ? { description: options.repository.description } : {}
      },
      spec: {
        type: "service",
        lifecycle: "production",
        owner: "user:guest"
      }
    };
    options.output.produce({
      type: "entity",
      path: "/",
      entity
    });
  }
}

class PackageJsonAnalyzer {
  name() {
    return PackageJsonAnalyzer.name;
  }
  async analyzeRepository(options) {
    var _a, _b;
    const packageJson = await options.repository.file("package.json");
    if (!packageJson) {
      return;
    }
    const content = await readPackageJson(packageJson);
    if (!content) {
      return;
    }
    const name = (_a = sanitizeName(content == null ? void 0 : content.name)) != null ? _a : options.repository.name;
    const entity = {
      apiVersion: "backstage.io/v1alpha1",
      kind: "Component",
      metadata: {
        name,
        ...options.repository.description ? { description: options.repository.description } : {},
        tags: ["javascript"],
        annotations: {
          [catalogModel.ANNOTATION_SOURCE_LOCATION]: `url:${options.repository.url}`
        }
      },
      spec: {
        type: "website",
        lifecycle: "production",
        owner: "user:guest"
      }
    };
    const decorate = options.output.list().find((entry) => entry.entity.metadata.name === name);
    if (decorate) {
      decorate.entity.spec = {
        ...decorate.entity.spec,
        type: "website"
      };
      decorate.entity.metadata.tags = [
        ...(_b = decorate.entity.metadata.tags) != null ? _b : [],
        "javascript"
      ];
      decorate.entity.metadata.annotations = {
        ...decorate.entity.metadata.annotations,
        [catalogModel.ANNOTATION_SOURCE_LOCATION]: `url:${options.repository.url}`
      };
      return;
    }
    options.output.produce({
      type: "entity",
      path: "/",
      entity
    });
  }
}
const packageSchema = z__default["default"].object({
  name: z__default["default"].string().optional()
});
function sanitizeName(name) {
  return name && name !== "root" ? name.replace(/[^a-z0-9A-Z]/g, "_").substring(0, 62) : void 0;
}
async function readPackageJson(file) {
  try {
    const text = await file.text();
    const result = packageSchema.safeParse(JSON.parse(text));
    if (!result.success) {
      return void 0;
    }
    return { name: result.data.name };
  } catch (e) {
    return void 0;
  }
}

var __accessCheck$5 = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet$4 = (obj, member, getter) => {
  __accessCheck$5(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd$5 = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet$4 = (obj, member, value, setter) => {
  __accessCheck$5(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var _path$1, _content$1;
class GithubFile {
  constructor(path, content) {
    __privateAdd$5(this, _path$1, void 0);
    __privateAdd$5(this, _content$1, void 0);
    __privateSet$4(this, _path$1, path);
    __privateSet$4(this, _content$1, content);
  }
  get path() {
    return __privateGet$4(this, _path$1);
  }
  async text() {
    return __privateGet$4(this, _content$1);
  }
}
_path$1 = new WeakMap();
_content$1 = new WeakMap();

var __accessCheck$4 = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet$3 = (obj, member, getter) => {
  __accessCheck$4(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd$4 = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet$3 = (obj, member, value, setter) => {
  __accessCheck$4(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var __privateMethod$3 = (obj, member, method) => {
  __accessCheck$4(obj, member, "access private method");
  return method;
};
var _client, _repo, _org, _getFileContent$1, getFileContent_fn$1;
class GithubRepository {
  constructor(client, repo, org) {
    __privateAdd$4(this, _getFileContent$1);
    __privateAdd$4(this, _client, void 0);
    __privateAdd$4(this, _repo, void 0);
    __privateAdd$4(this, _org, void 0);
    __privateSet$3(this, _client, client);
    __privateSet$3(this, _repo, repo);
    __privateSet$3(this, _org, org);
  }
  get url() {
    return __privateGet$3(this, _repo).url;
  }
  get name() {
    return __privateGet$3(this, _repo).name;
  }
  get owner() {
    return __privateGet$3(this, _org);
  }
  get description() {
    var _a;
    return (_a = __privateGet$3(this, _repo).description) != null ? _a : void 0;
  }
  async file(filename) {
    var _a;
    const content = await __privateMethod$3(this, _getFileContent$1, getFileContent_fn$1).call(this, filename);
    if (!content || content.isBinary || !content.text) {
      return void 0;
    }
    return new GithubFile(filename, (_a = content.text) != null ? _a : "");
  }
}
_client = new WeakMap();
_repo = new WeakMap();
_org = new WeakMap();
_getFileContent$1 = new WeakSet();
getFileContent_fn$1 = async function(filename) {
  const query = `query RepoFiles($owner: String!, $name: String!, $expr: String!) {
      repository(owner: $owner, name: $name) {
        object(expression: $expr) {
          ...on Blob {
            text
            isBinary
          }
        }
      }
    }`;
  const response = await __privateGet$3(this, _client).call(this, query, {
    name: __privateGet$3(this, _repo).name,
    owner: __privateGet$3(this, _org),
    expr: `HEAD:${filename}`
  });
  return response.repository.object;
};

var __accessCheck$3 = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet$2 = (obj, member, getter) => {
  __accessCheck$3(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd$3 = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet$2 = (obj, member, value, setter) => {
  __accessCheck$3(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var __privateMethod$2 = (obj, member, method) => {
  __accessCheck$3(obj, member, "access private method");
  return method;
};
var _envToken$1, _scmIntegrations$1, _credentialsProvider$1, _getRequestHeaders$1, getRequestHeaders_fn$1, _getOrganizationRepositories, getOrganizationRepositories_fn;
const _GithubDiscoveryProvider = class _GithubDiscoveryProvider {
  constructor(envToken, integrations, credentialsProvider) {
    __privateAdd$3(this, _getRequestHeaders$1);
    __privateAdd$3(this, _getOrganizationRepositories);
    __privateAdd$3(this, _envToken$1, void 0);
    __privateAdd$3(this, _scmIntegrations$1, void 0);
    __privateAdd$3(this, _credentialsProvider$1, void 0);
    __privateSet$2(this, _envToken$1, envToken);
    __privateSet$2(this, _scmIntegrations$1, integrations);
    __privateSet$2(this, _credentialsProvider$1, credentialsProvider);
  }
  static fromConfig(config) {
    const envToken = process.env.GITHUB_TOKEN || void 0;
    const scmIntegrations = integration.ScmIntegrations.fromConfig(config);
    const credentialsProvider = integration.DefaultGithubCredentialsProvider.fromIntegrations(scmIntegrations);
    return new _GithubDiscoveryProvider(
      envToken,
      scmIntegrations,
      credentialsProvider
    );
  }
  name() {
    return "GitHub";
  }
  async discover(url) {
    if (!url.startsWith("https://github.com/")) {
      return false;
    }
    const scmIntegration = __privateGet$2(this, _scmIntegrations$1).github.byUrl(url);
    if (!scmIntegration) {
      throw new Error(`No GitHub integration found for ${url}`);
    }
    const parsed = parseGitUrl__default["default"](url);
    const { name, organization } = parsed;
    const org = organization || name;
    const client = graphql.graphql.defaults({
      baseUrl: scmIntegration.config.apiBaseUrl,
      headers: await __privateMethod$2(this, _getRequestHeaders$1, getRequestHeaders_fn$1).call(this, url)
    });
    const { repositories } = await __privateMethod$2(this, _getOrganizationRepositories, getOrganizationRepositories_fn).call(this, client, org);
    return repositories.filter((repo) => repo.url.startsWith(url)).map((repo) => new GithubRepository(client, repo, org));
  }
};
_envToken$1 = new WeakMap();
_scmIntegrations$1 = new WeakMap();
_credentialsProvider$1 = new WeakMap();
_getRequestHeaders$1 = new WeakSet();
getRequestHeaders_fn$1 = async function(url) {
  const credentials = await __privateGet$2(this, _credentialsProvider$1).getCredentials({
    url
  });
  if (credentials.headers) {
    return credentials.headers;
  } else if (credentials.token) {
    return { authorization: `token ${credentials.token}` };
  }
  if (__privateGet$2(this, _envToken$1)) {
    return { authorization: `token ${__privateGet$2(this, _envToken$1)}` };
  }
  throw new Error(
    "No token available for GitHub, please configure your integrations or set a GITHUB_TOKEN env variable"
  );
};
_getOrganizationRepositories = new WeakSet();
getOrganizationRepositories_fn = async function(client, org) {
  var _a, _b;
  const query = `query repositories($org: String!, $cursor: String) {
      repositoryOwner(login: $org) {
        login
        repositories(first: 50, after: $cursor) {
          nodes {
            name
            url
            description
            isArchived
            isFork
          }
          pageInfo {
            hasNextPage
            endCursor
          }
        }
      }
    }`;
  const result = [];
  let cursor = void 0;
  let hasNextPage = true;
  while (hasNextPage) {
    const response = await client(query, {
      org,
      cursor
    });
    const { repositories: connection } = (_a = response.repositoryOwner) != null ? _a : {};
    if (!connection) {
      throw new Error(`Found no repositories for ${org}`);
    }
    for (const repository of (_b = connection.nodes) != null ? _b : []) {
      if (repository && !repository.isArchived && !repository.isFork) {
        result.push(repository);
      }
    }
    cursor = connection.pageInfo.endCursor;
    hasNextPage = connection.pageInfo.hasNextPage;
  }
  return {
    repositories: result
  };
};
let GithubDiscoveryProvider = _GithubDiscoveryProvider;

var __accessCheck$2 = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet$1 = (obj, member, getter) => {
  __accessCheck$2(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd$2 = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet$1 = (obj, member, value, setter) => {
  __accessCheck$2(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var _path, _content;
class GitlabFile {
  constructor(path, content) {
    __privateAdd$2(this, _path, void 0);
    __privateAdd$2(this, _content, void 0);
    __privateSet$1(this, _path, path);
    __privateSet$1(this, _content, content);
  }
  get path() {
    return __privateGet$1(this, _path);
  }
  async text() {
    return __privateGet$1(this, _content);
  }
}
_path = new WeakMap();
_content = new WeakMap();

var __accessCheck$1 = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateAdd$1 = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateMethod$1 = (obj, member, method) => {
  __accessCheck$1(obj, member, "access private method");
  return method;
};
var _getFileContent, getFileContent_fn, _getMainBranch, getMainBranch_fn;
class GitlabProject {
  constructor(project, apiBaseUrl, headers) {
    this.project = project;
    this.apiBaseUrl = apiBaseUrl;
    this.headers = headers;
    __privateAdd$1(this, _getFileContent);
    __privateAdd$1(this, _getMainBranch);
  }
  get url() {
    return this.project.web_url;
  }
  get name() {
    return this.project.name;
  }
  get owner() {
    return this.project.owner.username;
  }
  get description() {
    return this.project.description;
  }
  async file(filename) {
    const mainBranch = await __privateMethod$1(this, _getMainBranch, getMainBranch_fn).call(this);
    const content = await __privateMethod$1(this, _getFileContent, getFileContent_fn).call(this, filename, mainBranch);
    return new GitlabFile(filename, content);
  }
}
_getFileContent = new WeakSet();
getFileContent_fn = async function(path, mainBranch) {
  const response = await fetch__default["default"](
    `${this.apiBaseUrl}/projects/${this.project.id}/repository/files/${path}?ref=${mainBranch}`,
    { headers: this.headers }
  );
  const { content } = await response.json();
  return Buffer.from(content, "base64").toString("ascii");
};
_getMainBranch = new WeakSet();
getMainBranch_fn = async function() {
  var _a, _b;
  const response = await fetch__default["default"](
    `${this.apiBaseUrl}/projects/${this.project.id}/repository/branches`,
    { headers: this.headers }
  );
  const branches = await response.json();
  return (_b = (_a = branches.find((branch) => branch.default)) == null ? void 0 : _a.name) != null ? _b : "main";
};

var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var __privateMethod = (obj, member, method) => {
  __accessCheck(obj, member, "access private method");
  return method;
};
var _envToken, _scmIntegrations, _credentialsProvider, _getRequestHeaders, getRequestHeaders_fn;
const _GitlabDiscoveryProvider = class _GitlabDiscoveryProvider {
  constructor(envToken, integrations, credentialsProvider) {
    __privateAdd(this, _getRequestHeaders);
    __privateAdd(this, _envToken, void 0);
    __privateAdd(this, _scmIntegrations, void 0);
    __privateAdd(this, _credentialsProvider, void 0);
    __privateSet(this, _envToken, envToken);
    __privateSet(this, _scmIntegrations, integrations);
    __privateSet(this, _credentialsProvider, credentialsProvider);
  }
  static fromConfig(config) {
    const envToken = process.env.GITLAB_TOKEN || void 0;
    const scmIntegrations = integration.ScmIntegrations.fromConfig(config);
    const credentialsProvider = integration.DefaultGitlabCredentialsProvider.fromIntegrations(scmIntegrations);
    return new _GitlabDiscoveryProvider(
      envToken,
      scmIntegrations,
      credentialsProvider
    );
  }
  name() {
    return "GitLab";
  }
  async discover(url) {
    const { origin, pathname } = new URL(url);
    const [, user] = pathname.split("/");
    const scmIntegration = __privateGet(this, _scmIntegrations).gitlab.byUrl(origin);
    if (!scmIntegration) {
      throw new Error(`No GitLab integration found for ${origin}`);
    }
    const headers = await __privateMethod(this, _getRequestHeaders, getRequestHeaders_fn).call(this, origin);
    const response = await fetch__default["default"](
      `${scmIntegration.config.apiBaseUrl}/users/${user}/projects`,
      { headers }
    );
    if (!response.ok) {
      throw new Error(`${response.status} ${response.statusText}`);
    }
    const projects = await response.json();
    return projects.map(
      (project) => new GitlabProject(project, scmIntegration.config.apiBaseUrl, headers)
    );
  }
};
_envToken = new WeakMap();
_scmIntegrations = new WeakMap();
_credentialsProvider = new WeakMap();
_getRequestHeaders = new WeakSet();
getRequestHeaders_fn = async function(url) {
  const credentials = await __privateGet(this, _credentialsProvider).getCredentials({
    url
  });
  if (credentials.headers) {
    return credentials.headers;
  } else if (credentials.token) {
    return { authorization: `Bearer ${credentials.token}` };
  }
  if (__privateGet(this, _envToken)) {
    return { authorization: `Bearer ${__privateGet(this, _envToken)}` };
  }
  throw new Error(
    "No token available for GitLab, please set a GITLAB_TOKEN env variable"
  );
};
let GitlabDiscoveryProvider = _GitlabDiscoveryProvider;

async function discover(providerInfo) {
  tasks.Task.log(`
    Would you like to scan for - and create - Software Catalog entities?

    You will need to select which SCM (Source Code Management) provider you are using, 
    and then which repository or organization you want to scan.

    This will generate a new file in the root of your app containing discovered entities,
    which will be included in the Software Catalog when you start up Backstage next time.

    Note that this command requires an access token, which can be either added through the integration config or
    provided as an environment variable.
  `);
  const answers = await inquirer__default["default"].prompt([
    {
      type: "confirm",
      name: "shouldContinue",
      message: "Do you want to continue?"
    },
    {
      type: "list",
      name: "provider",
      message: "Please select which SCM provider you want to use:",
      choices: ["GitHub", "GitLab"],
      default: providerInfo == null ? void 0 : providerInfo.provider,
      when: ({ shouldContinue }) => shouldContinue
    },
    {
      type: "input",
      name: "url",
      message: `Which repository do you want to scan?`,
      when: ({ shouldContinue }) => shouldContinue,
      filter: (input, { provider }) => {
        if (provider === "GitLab") {
          return `https://gitlab.com/${input}`;
        }
        if (provider === "GitHub") {
          return `https://github.com/${input}`;
        }
        return false;
      }
    }
  ]);
  if (!answers.shouldContinue) {
    tasks.Task.log(
      chalk__default["default"].yellow(
        "If you change your mind, feel free to re-run this command."
      )
    );
    return;
  }
  const { fullConfig: config$1 } = await config.loadCliConfig({ args: [] });
  const discovery = new Discovery();
  if (answers.provider === "GitHub") {
    discovery.addProvider(GithubDiscoveryProvider.fromConfig(config$1));
  }
  if (answers.provider === "GitLab") {
    discovery.addProvider(GitlabDiscoveryProvider.fromConfig(config$1));
  }
  discovery.addAnalyzer(new BasicRepositoryAnalyzer());
  discovery.addAnalyzer(new PackageJsonAnalyzer());
  const { entities } = await discovery.run(answers.url);
  if (!entities.length) {
    tasks.Task.log(
      chalk__default["default"].yellow(`
      We could not find enough information to be able to generate any Software Catalog entities for you.
      Perhaps you can try again with a different repository?`)
    );
    return;
  }
  await tasks.Task.forItem("Creating", DISCOVERED_ENTITIES_FILE, async () => {
    const payload = [];
    for (const entity of entities) {
      payload.push("---\n", yaml__default["default"].stringify(entity));
    }
    await fs__default["default"].writeFile(DISCOVERED_ENTITIES_FILE, payload.join(""));
  });
  await tasks.Task.forItem(
    "Updating",
    APP_CONFIG_FILE,
    async () => await updateConfigFile(APP_CONFIG_FILE, {
      catalog: {
        locations: [
          {
            type: "file",
            target: DISCOVERED_ENTITIES_FILE
          }
        ]
      }
    })
  );
}

async function command() {
  const answers = await inquirer__default["default"].prompt([
    {
      type: "confirm",
      name: "shouldSetupAuth",
      message: "Do you want to set up Authentication for this project?",
      default: true
    },
    {
      type: "confirm",
      name: "shouldSetupScaffolder",
      message: "Do you want to use Software Templates in this project?",
      default: true
    },
    {
      type: "confirm",
      name: "shouldDiscoverEntities",
      message: "Do you want to discover entities and add them to the Software Catalog?",
      default: true
    }
  ]);
  const { shouldSetupAuth, shouldSetupScaffolder, shouldDiscoverEntities } = answers;
  if (!shouldSetupAuth && !shouldSetupScaffolder && !shouldDiscoverEntities) {
    tasks.Task.log(
      chalk__default["default"].yellow(
        "If you change your mind, feel free to re-run this command."
      )
    );
    return;
  }
  let providerInfo;
  if (shouldSetupAuth) {
    providerInfo = await auth();
  }
  if (shouldSetupScaffolder) {
    await integrations(providerInfo);
  }
  if (shouldDiscoverEntities) {
    await discover(providerInfo);
  }
  tasks.Task.log();
  tasks.Task.log(
    `You can now start your app with ${chalk__default["default"].inverse(
      chalk__default["default"].italic("yarn dev")
    )}`
  );
  tasks.Task.log();
}

exports.command = command;
//# sourceMappingURL=index-912f8b03.cjs.js.map
