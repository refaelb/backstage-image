'use strict';

var cliNode = require('@backstage/cli-node');
var fs = require('fs-extra');
var path = require('path');
var index = require('./index-f60e95c6.cjs.js');
require('commander');
require('chalk');
require('semver');
require('@backstage/cli-common');
require('@backstage/errors');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var fs__default = /*#__PURE__*/_interopDefaultLegacy(fs);

async function readFixablePackages() {
  const packages = await cliNode.PackageGraph.listTargetPackages();
  return packages.map((pkg) => ({ ...pkg, changed: false }));
}
function printPackageFixHint(packages) {
  var _a;
  const changed = packages.filter((pkg) => pkg.changed);
  if (changed.length > 0) {
    const rootPkg = require(index.paths.resolveTargetRoot("package.json"));
    const fixCmd = ((_a = rootPkg.scripts) == null ? void 0 : _a.fix) === "backstage-cli repo fix" ? "fix" : "backstage-cli repo fix";
    console.log(
      `The following packages are out of sync, run 'yarn ${fixCmd}' to fix them:`
    );
    for (const pkg of changed) {
      console.log(`  ${pkg.packageJson.name}`);
    }
    return true;
  }
  return false;
}
async function writeFixedPackages(packages) {
  await Promise.all(
    packages.map(async (pkg) => {
      if (!pkg.changed) {
        return;
      }
      await fs__default["default"].writeJson(
        path.resolve(pkg.dir, "package.json"),
        pkg.packageJson,
        {
          spaces: 2
        }
      );
    })
  );
}
function trimRelative(path) {
  if (path.startsWith("./")) {
    return path.slice(2);
  }
  return path;
}
function fixPackageExports(pkg) {
  let { exports: exp } = pkg.packageJson;
  if (!exp) {
    return;
  }
  if (Array.isArray(exp)) {
    throw new Error("Unexpected array in package.json exports field");
  }
  if (typeof exp === "string") {
    pkg.changed = true;
    exp = { ".": exp };
    pkg.packageJson.exports = exp;
  } else if (typeof exp !== "object") {
    return;
  }
  if (!exp["./package.json"]) {
    pkg.changed = true;
    exp["./package.json"] = "./package.json";
  }
  const existingTypesVersions = JSON.stringify(pkg.packageJson.typesVersions);
  const typeEntries = {};
  for (const [path, value] of Object.entries(exp)) {
    if (path === ".") {
      continue;
    }
    const newPath = trimRelative(path);
    if (typeof value === "string") {
      typeEntries[newPath] = [trimRelative(value)];
    } else if (value && typeof value === "object" && !Array.isArray(value)) {
      if (typeof value.types === "string") {
        typeEntries[newPath] = [trimRelative(value.types)];
      } else if (typeof value.default === "string") {
        typeEntries[newPath] = [trimRelative(value.default)];
      }
    }
  }
  const typesVersions = { "*": typeEntries };
  if (existingTypesVersions !== JSON.stringify(typesVersions)) {
    const newPkgEntries = Object.entries(pkg.packageJson).filter(
      ([name]) => name !== "typesVersions"
    );
    newPkgEntries.splice(
      newPkgEntries.findIndex(([name]) => name === "exports") + 1,
      0,
      ["typesVersions", typesVersions]
    );
    pkg.packageJson = Object.fromEntries(newPkgEntries);
    pkg.changed = true;
  }
  const publishConfig = pkg.packageJson.publishConfig;
  if (publishConfig) {
    for (const field of ["main", "module", "browser", "types"]) {
      if (publishConfig[field]) {
        delete publishConfig[field];
        pkg.changed = true;
      }
    }
  }
}
function fixSideEffects(pkg) {
  const role = cliNode.PackageRoles.getRoleFromPackage(pkg.packageJson);
  if (!role) {
    return;
  }
  const roleInfo = cliNode.PackageRoles.getRoleInfo(role);
  if (roleInfo.platform === "node") {
    return;
  }
  if (roleInfo.output.length === 1 && roleInfo.output[0] === "bundle") {
    return;
  }
  if ("sideEffects" in pkg.packageJson) {
    return;
  }
  const pkgEntries = Object.entries(pkg.packageJson);
  pkgEntries.splice(
    // Place it just above the scripts field
    pkgEntries.findIndex(([name]) => name === "scripts"),
    0,
    ["sideEffects", false]
  );
  pkg.packageJson = Object.fromEntries(pkgEntries);
  pkg.changed = true;
}
async function command(opts) {
  const packages = await readFixablePackages();
  for (const pkg of packages) {
    fixPackageExports(pkg);
    fixSideEffects(pkg);
  }
  if (opts.check) {
    if (printPackageFixHint(packages)) {
      process.exit(1);
    }
  } else {
    await writeFixedPackages(packages);
  }
}

exports.command = command;
exports.fixPackageExports = fixPackageExports;
exports.fixSideEffects = fixSideEffects;
exports.printPackageFixHint = printPackageFixHint;
exports.readFixablePackages = readFixablePackages;
exports.writeFixedPackages = writeFixedPackages;
//# sourceMappingURL=fix-2454d405.cjs.js.map
