'use strict';

var configLoader = require('@backstage/config-loader');
var config = require('@backstage/config');
var index = require('./index-f60e95c6.cjs.js');
var getPackages = require('@manypkg/get-packages');
var cliNode = require('@backstage/cli-node');

function isValidUrl(url) {
  try {
    new URL(url);
    return true;
  } catch {
    return false;
  }
}

async function loadCliConfig(options) {
  const configTargets = [];
  options.args.forEach((arg) => {
    if (!isValidUrl(arg)) {
      configTargets.push({ path: index.paths.resolveTarget(arg) });
    }
  });
  const { packages } = await getPackages.getPackages(index.paths.targetDir);
  let localPackageNames;
  if (options.fromPackage) {
    if (packages.length) {
      const graph = cliNode.PackageGraph.fromPackages(packages);
      localPackageNames = Array.from(
        graph.collectPackageNames([options.fromPackage], (node) => {
          if (node.name === "@backstage/cli") {
            return void 0;
          }
          return node.localDependencies.keys();
        })
      );
    } else {
      localPackageNames = [options.fromPackage];
    }
  } else {
    localPackageNames = packages.map((p) => p.packageJson.name);
  }
  const schema = await configLoader.loadConfigSchema({
    dependencies: localPackageNames,
    // Include the package.json in the project root if it exists
    packagePaths: [index.paths.resolveTargetRoot("package.json")],
    noUndeclaredProperties: options.strict
  });
  const { appConfigs } = await configLoader.loadConfig({
    experimentalEnvFunc: options.mockEnv ? async (name) => process.env[name] || "x" : void 0,
    configRoot: index.paths.targetRoot,
    configTargets,
    watch: options.watch && {
      onChange(newAppConfigs) {
        var _a;
        const newFrontendAppConfigs = schema.process(newAppConfigs, {
          visibility: options.fullVisibility ? ["frontend", "backend", "secret"] : ["frontend"],
          withFilteredKeys: options.withFilteredKeys,
          withDeprecatedKeys: options.withDeprecatedKeys,
          ignoreSchemaErrors: !options.strict
        });
        (_a = options.watch) == null ? void 0 : _a.call(options, newFrontendAppConfigs);
      }
    }
  });
  process.stderr.write(
    `Loaded config from ${appConfigs.map((c) => c.context).join(", ")}
`
  );
  try {
    const frontendAppConfigs = schema.process(appConfigs, {
      visibility: options.fullVisibility ? ["frontend", "backend", "secret"] : ["frontend"],
      withFilteredKeys: options.withFilteredKeys,
      withDeprecatedKeys: options.withDeprecatedKeys,
      ignoreSchemaErrors: !options.strict
    });
    const frontendConfig = config.ConfigReader.fromConfigs(frontendAppConfigs);
    const fullConfig = config.ConfigReader.fromConfigs(appConfigs);
    return {
      schema,
      appConfigs,
      frontendConfig,
      frontendAppConfigs,
      fullConfig
    };
  } catch (error) {
    const maybeSchemaError = error;
    if (maybeSchemaError.messages) {
      const messages = maybeSchemaError.messages.join("\n  ");
      throw new Error(`Configuration does not match schema

  ${messages}`);
    }
    throw error;
  }
}

exports.isValidUrl = isValidUrl;
exports.loadCliConfig = loadCliConfig;
//# sourceMappingURL=config-49d4900d.cjs.js.map
