'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var errors = require('@backstage/errors');
var catalogModel = require('@backstage/catalog-model');
var crypto = require('crypto');

const processingResult = Object.freeze({
  /**
   * Associates a NotFoundError with the processing state of the current entity.
   */
  notFoundError(atLocation, message) {
    return {
      type: "error",
      location: atLocation,
      error: new errors.NotFoundError(message)
    };
  },
  /**
   * Associates an InputError with the processing state of the current entity.
   */
  inputError(atLocation, message) {
    return {
      type: "error",
      location: atLocation,
      error: new errors.InputError(message)
    };
  },
  /**
   * Associates a general Error with the processing state of the current entity.
   */
  generalError(atLocation, message) {
    return { type: "error", location: atLocation, error: new Error(message) };
  },
  /**
   * Emits a location. In effect, this is analogous to emitting a Location kind
   * child entity. This is commonly used in discovery processors. Do not use
   * this while processing Location entities.
   */
  location(newLocation) {
    return { type: "location", location: newLocation };
  },
  /**
   * Emits a child of the current entity, associated with a certain location.
   */
  entity(atLocation, newEntity) {
    return { type: "entity", location: atLocation, entity: newEntity };
  },
  /**
   * Emits a relation owned by the current entity. The relation does not have to
   * start or end at the current entity. The relation only lives for as long as
   * the current entity lives.
   */
  relation(spec) {
    return { type: "relation", relation: spec };
  },
  /**
   * Associates the given refresh key with the current entity. The effect of
   * this is that the entity will be marked for refresh when such requests are
   * made.
   */
  refresh(key) {
    return { type: "refresh", key };
  }
});

function locationSpecToMetadataName(location) {
  const hash = crypto.createHash("sha1").update(`${location.type}:${location.target}`).digest("hex");
  return `generated-${hash}`;
}
function locationSpecToLocationEntity(opts) {
  var _a, _b;
  const location = opts.location;
  const parentEntity = opts.parentEntity;
  let ownLocation;
  let originLocation;
  if (parentEntity) {
    const maybeOwnLocation = (_a = parentEntity.metadata.annotations) == null ? void 0 : _a[catalogModel.ANNOTATION_LOCATION];
    if (!maybeOwnLocation) {
      throw new Error(
        `Parent entity '${catalogModel.stringifyEntityRef(
          parentEntity
        )}' of location '${catalogModel.stringifyLocationRef(
          location
        )}' does not have a location annotation`
      );
    }
    ownLocation = maybeOwnLocation;
    const maybeOriginLocation = (_b = parentEntity.metadata.annotations) == null ? void 0 : _b[catalogModel.ANNOTATION_ORIGIN_LOCATION];
    if (!maybeOriginLocation) {
      throw new Error(
        `Parent entity '${catalogModel.stringifyEntityRef(
          parentEntity
        )}' of location '${catalogModel.stringifyLocationRef(
          location
        )}' does not have an origin location annotation`
      );
    }
    originLocation = maybeOriginLocation;
  } else {
    ownLocation = catalogModel.stringifyLocationRef(location);
    originLocation = ownLocation;
  }
  const result = {
    apiVersion: "backstage.io/v1alpha1",
    kind: "Location",
    metadata: {
      name: locationSpecToMetadataName(location),
      annotations: {
        [catalogModel.ANNOTATION_LOCATION]: ownLocation,
        [catalogModel.ANNOTATION_ORIGIN_LOCATION]: originLocation
      }
    },
    spec: {
      type: location.type,
      target: location.target,
      presence: location.presence
    }
  };
  return result;
}

exports.locationSpecToLocationEntity = locationSpecToLocationEntity;
exports.locationSpecToMetadataName = locationSpecToMetadataName;
exports.processingResult = processingResult;
//# sourceMappingURL=index.cjs.js.map
