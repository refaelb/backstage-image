{"version":3,"file":"index.cjs.js","sources":["../src/types/api.ts","../src/utils.ts","../src/generated/pluginId.ts","../src/generated/apis/DefaultApi.client.ts","../src/CatalogClient.ts","../src/types/status.ts"],"sourcesContent":["/*\n * Copyright 2021 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { CompoundEntityRef, Entity } from '@backstage/catalog-model';\nimport { SerializedError } from '@backstage/errors';\n\n/**\n * This symbol can be used in place of a value when passed to filters in e.g.\n * {@link CatalogClient.getEntities}, to signify that you want to filter on the\n * presence of that key no matter what its value is.\n *\n * @public\n */\nexport const CATALOG_FILTER_EXISTS = Symbol.for(\n  // Random UUID to ensure no collisions\n  'CATALOG_FILTER_EXISTS_0e15b590c0b343a2bae3e787e84c2111',\n);\n\n/**\n * A key-value based filter expression for entities.\n *\n * @remarks\n *\n * Each key of a record is a dot-separated path into the entity structure, e.g.\n * `metadata.name`.\n *\n * The values are literal values to match against. As a value you can also pass\n * in the symbol `CATALOG_FILTER_EXISTS` (exported from this package), which\n * means that you assert on the existence of that key, no matter what its value\n * is.\n *\n * All matching of keys and values is case insensitive.\n *\n * If multiple filter sets are given as an array, then there is effectively an\n * OR between each filter set.\n *\n * Within one filter set, there is effectively an AND between the various keys.\n *\n * Within one key, if there are more than one value, then there is effectively\n * an OR between them.\n *\n * Example: For an input of\n *\n * ```\n * [\n *   { kind: ['API', 'Component'] },\n *   { 'metadata.name': 'a', 'metadata.namespace': 'b' }\n * ]\n * ```\n *\n * This effectively means\n *\n * ```\n * (kind = EITHER 'API' OR 'Component')\n * OR\n * (metadata.name = 'a' AND metadata.namespace = 'b' )\n * ```\n *\n * @public\n */\nexport type EntityFilterQuery =\n  | Record<string, string | symbol | (string | symbol)[]>[]\n  | Record<string, string | symbol | (string | symbol)[]>;\n\n/**\n * A set of dot-separated paths into an entity's keys, showing what parts of an\n * entity to include in a response, and excluding all others.\n *\n * @remarks\n *\n * Example: For an input of `['kind', 'metadata.annotations']`, then response\n * objects will be shaped like\n *\n * ```\n * {\n *   \"kind\": \"Component\",\n *   \"metadata\": {\n *     \"annotations\": {\n *       \"foo\": \"bar\"\n *     }\n *   }\n * }\n * ```\n * @public\n */\nexport type EntityFieldsQuery = string[];\n\n/**\n * Dot-separated field based ordering directives, controlling the sort order of\n * the output entities.\n *\n * @remarks\n *\n * Each field is a dot-separated path into an entity's keys. The order is either\n * ascending (`asc`, lexicographical order) or descending (`desc`, reverse\n * lexicographical order). The ordering is case insensitive.\n *\n * If more than one order directive is given, later directives have lower\n * precedence (they are applied only when directives of higher precedence have\n * equal values).\n *\n * Example:\n *\n * ```\n * [\n *   { field: 'kind', order: 'asc' },\n *   { field: 'metadata.name', order: 'desc' },\n * ]\n * ```\n *\n * This will order the output first by kind ascending, and then within each kind\n * (if there's more than one of a given kind) by their name descending.\n *\n * When given a field that does NOT exist on all entities in the result set,\n * those entities that do not have the field will always be sorted last in that\n * particular order step, no matter what the desired order was.\n *\n * @public\n */\nexport type EntityOrderQuery =\n  | {\n      field: string;\n      order: 'asc' | 'desc';\n    }\n  | Array<{\n      field: string;\n      order: 'asc' | 'desc';\n    }>;\n\n/**\n * The request type for {@link CatalogClient.getEntities}.\n *\n * @public\n */\nexport interface GetEntitiesRequest {\n  /**\n   * If given, return only entities that match the given filter.\n   */\n  filter?: EntityFilterQuery;\n  /**\n   * If given, return only the parts of each entity that match the field\n   * declarations.\n   */\n  fields?: EntityFieldsQuery;\n  /**\n   *If given, order the result set by those directives.\n   */\n  order?: EntityOrderQuery;\n  /**\n   * If given, skips over the first N items in the result set.\n   */\n  offset?: number;\n  /**\n   * If given, returns at most N items from the result set.\n   */\n  limit?: number;\n  /**\n   * If given, skips over all items before that cursor as returned by a previous\n   * request.\n   */\n  after?: string;\n}\n\n/**\n * The response type for {@link CatalogClient.getEntities}.\n *\n * @public\n */\nexport interface GetEntitiesResponse {\n  items: Entity[];\n}\n\n/**\n * The request type for {@link CatalogClient.getEntitiesByRefs}.\n *\n * @public\n */\nexport interface GetEntitiesByRefsRequest {\n  /**\n   * The list of entity refs to fetch.\n   *\n   * @remarks\n   *\n   * The returned list of entities will be in the same order as the refs, and\n   * null will be returned in those positions that were not found.\n   */\n  entityRefs: string[];\n  /**\n   * If given, return only the parts of each entity that match the field\n   * declarations.\n   */\n  fields?: EntityFieldsQuery | undefined;\n}\n\n/**\n * The response type for {@link CatalogClient.getEntitiesByRefs}.\n *\n * @public\n */\nexport interface GetEntitiesByRefsResponse {\n  /**\n   * The returned list of entities.\n   *\n   * @remarks\n   *\n   * The list will be in the same order as the refs given in the request, and\n   * null will be returned in those positions that were not found.\n   */\n  items: Array<Entity | undefined>;\n}\n\n/**\n * The request type for {@link CatalogClient.getEntityAncestors}.\n *\n * @public\n */\nexport interface GetEntityAncestorsRequest {\n  entityRef: string;\n}\n\n/**\n * The response type for {@link CatalogClient.getEntityAncestors}.\n *\n * @public\n */\nexport interface GetEntityAncestorsResponse {\n  rootEntityRef: string;\n  items: Array<{\n    entity: Entity;\n    parentEntityRefs: string[];\n  }>;\n}\n\n/**\n * The request type for {@link CatalogClient.getEntityFacets}.\n *\n * @public\n */\nexport interface GetEntityFacetsRequest {\n  /**\n   * If given, return only entities that match the given patterns.\n   *\n   * @remarks\n   *\n   * If multiple filter sets are given as an array, then there is effectively an\n   * OR between each filter set.\n   *\n   * Within one filter set, there is effectively an AND between the various\n   * keys.\n   *\n   * Within one key, if there are more than one value, then there is effectively\n   * an OR between them.\n   *\n   * Example: For an input of\n   *\n   * ```\n   * [\n   *   { kind: ['API', 'Component'] },\n   *   { 'metadata.name': 'a', 'metadata.namespace': 'b' }\n   * ]\n   * ```\n   *\n   * This effectively means\n   *\n   * ```\n   * (kind = EITHER 'API' OR 'Component')\n   * OR\n   * (metadata.name = 'a' AND metadata.namespace = 'b' )\n   * ```\n   *\n   * Each key is a dot separated path in each object.\n   *\n   * As a value you can also pass in the symbol `CATALOG_FILTER_EXISTS`\n   * (exported from this package), which means that you assert on the existence\n   * of that key, no matter what its value is.\n   */\n  filter?: EntityFilterQuery;\n  /**\n   * Dot separated paths for the facets to extract from each entity.\n   *\n   * @remarks\n   *\n   * Example: For an input of `['kind', 'metadata.annotations.backstage.io/orphan']`, then the\n   * response will be shaped like\n   *\n   * ```\n   * {\n   *   \"facets\": {\n   *     \"kind\": [\n   *       { \"key\": \"Component\", \"count\": 22 },\n   *       { \"key\": \"API\", \"count\": 13 }\n   *     ],\n   *     \"metadata.annotations.backstage.io/orphan\": [\n   *       { \"key\": \"true\", \"count\": 2 }\n   *     ]\n   *   }\n   * }\n   * ```\n   */\n  facets: string[];\n}\n\n/**\n * The response type for {@link CatalogClient.getEntityFacets}.\n *\n * @public\n */\nexport interface GetEntityFacetsResponse {\n  /**\n   * The computed facets, one entry per facet in the request.\n   */\n  facets: Record<string, Array<{ value: string; count: number }>>;\n}\n\n/**\n * Options you can pass into a catalog request for additional information.\n *\n * @public\n */\nexport interface CatalogRequestOptions {\n  token?: string;\n}\n\n/**\n * Entity location for a specific entity.\n *\n * @public\n */\nexport type Location = {\n  id: string;\n  type: string;\n  target: string;\n};\n\n/**\n * The request type for {@link CatalogClient.addLocation}.\n *\n * @public\n */\nexport type AddLocationRequest = {\n  type?: string;\n  target: string;\n  /**\n   * If set to true, the location will not be added, but the response will\n   * contain the entities that match the given location.\n   */\n  dryRun?: boolean;\n};\n\n/**\n * The response type for {@link CatalogClient.addLocation}.\n *\n * @public\n */\nexport type AddLocationResponse = {\n  location: Location;\n  /**\n   * The entities matching this location. Will only be filled in dryRun mode\n   */\n  entities: Entity[];\n  /**\n   * True, if the location exists. Will only be filled in dryRun mode\n   */\n  exists?: boolean;\n};\n\n/**\n * The response type for {@link CatalogClient.validateEntity}\n *\n * @public\n */\nexport type ValidateEntityResponse =\n  | { valid: true }\n  | { valid: false; errors: SerializedError[] };\n\n/**\n * The request type for {@link CatalogClient.queryEntities}.\n *\n * @public\n */\nexport type QueryEntitiesRequest =\n  | QueryEntitiesInitialRequest\n  | QueryEntitiesCursorRequest;\n\n/**\n * A request type for {@link CatalogClient.queryEntities}.\n * The method takes this type in an initial pagination request,\n * when requesting the first batch of entities.\n *\n * The properties filter, sortField, query and sortFieldOrder, are going\n * to be immutable for the entire lifecycle of the following requests.\n *\n * @public\n */\nexport type QueryEntitiesInitialRequest = {\n  fields?: string[];\n  limit?: number;\n  filter?: EntityFilterQuery;\n  orderFields?: EntityOrderQuery;\n  fullTextFilter?: {\n    term: string;\n    fields?: string[];\n  };\n};\n\n/**\n * A request type for {@link CatalogClient.queryEntities}.\n * The method takes this type in a pagination request, following\n * the initial request.\n *\n * @public\n */\nexport type QueryEntitiesCursorRequest = {\n  fields?: string[];\n  limit?: number;\n  cursor: string;\n};\n\n/**\n * The response type for {@link CatalogClient.queryEntities}.\n *\n * @public\n */\nexport type QueryEntitiesResponse = {\n  /* The list of entities for the current request */\n  items: Entity[];\n  /* The number of entities among all the requests */\n  totalItems: number;\n  pageInfo: {\n    /* The cursor for the next batch of entities */\n    nextCursor?: string;\n    /* The cursor for the previous batch of entities */\n    prevCursor?: string;\n  };\n};\n\n/**\n * A client for interacting with the Backstage software catalog through its API.\n *\n * @public\n */\nexport interface CatalogApi {\n  /**\n   * Lists catalog entities.\n   *\n   * @param request - Request parameters\n   * @param options - Additional options\n   */\n  getEntities(\n    request?: GetEntitiesRequest,\n    options?: CatalogRequestOptions,\n  ): Promise<GetEntitiesResponse>;\n\n  /**\n   * Gets a batch of entities, by their entity refs.\n   *\n   * @remarks\n   *\n   * The output list of entities is of the same size and in the same order as\n   * the requested list of entity refs. Entries that are not found are returned\n   * as null.\n   *\n   * @param request - Request parameters\n   * @param options - Additional options\n   */\n  getEntitiesByRefs(\n    request: GetEntitiesByRefsRequest,\n    options?: CatalogRequestOptions,\n  ): Promise<GetEntitiesByRefsResponse>;\n\n  /**\n   * Gets paginated entities from the catalog.\n   *\n   * @remarks\n   *\n   * @example\n   *\n   * ```\n   * const response = await catalogClient.queryEntities({\n   *   filter: [{ kind: 'group' }],\n   *   limit: 20,\n   *   fullTextFilter: {\n   *     term: 'A',\n   *   }\n   *   orderFields: { field: 'metadata.name' order: 'asc' },\n   * });\n   * ```\n   *\n   * this will match all entities of type group having a name starting\n   * with 'A', ordered by name ascending.\n   *\n   * The response will contain a maximum of 20 entities. In case\n   * more than 20 entities exist, the response will contain a nextCursor\n   * property that can be used to fetch the next batch of entities.\n   *\n   * ```\n   * const secondBatchResponse = await catalogClient\n   *  .queryEntities({ cursor: response.nextCursor });\n   * ```\n   *\n   * secondBatchResponse will contain the next batch of (maximum) 20 entities,\n   * together with a prevCursor property, useful to fetch the previous batch.\n   *\n   * @public\n   *\n   * @param request - Request parameters\n   * @param options - Additional options\n   */\n  queryEntities(\n    request?: QueryEntitiesRequest,\n    options?: CatalogRequestOptions,\n  ): Promise<QueryEntitiesResponse>;\n\n  /**\n   * Gets entity ancestor information, i.e. the hierarchy of parent entities\n   * whose processing resulted in a given entity appearing in the catalog.\n   *\n   * @param request - Request parameters\n   * @param options - Additional options\n   */\n  getEntityAncestors(\n    request: GetEntityAncestorsRequest,\n    options?: CatalogRequestOptions,\n  ): Promise<GetEntityAncestorsResponse>;\n\n  /**\n   * Gets a single entity from the catalog by its ref (kind, namespace, name)\n   * triplet.\n   *\n   * @param entityRef - A complete entity ref, either on string or compound form\n   * @param options - Additional options\n   * @returns The matching entity, or undefined if there was no entity with that ref\n   */\n  getEntityByRef(\n    entityRef: string | CompoundEntityRef,\n    options?: CatalogRequestOptions,\n  ): Promise<Entity | undefined>;\n\n  /**\n   * Removes a single entity from the catalog by entity UID.\n   *\n   * @param uid - An entity UID\n   * @param options - Additional options\n   */\n  removeEntityByUid(\n    uid: string,\n    options?: CatalogRequestOptions,\n  ): Promise<void>;\n\n  /**\n   * Refreshes (marks for reprocessing) an entity in the catalog.\n   *\n   * @param entityRef - An entity ref on string form (e.g.\n   *        'component/default:my-component')\n   * @param options - Additional options\n   */\n  refreshEntity(\n    entityRef: string,\n    options?: CatalogRequestOptions,\n  ): Promise<void>;\n\n  /**\n   * Gets a summary of field facets of entities in the catalog.\n   *\n   * @param request - Request parameters\n   * @param options - Additional options\n   */\n  getEntityFacets(\n    request: GetEntityFacetsRequest,\n    options?: CatalogRequestOptions,\n  ): Promise<GetEntityFacetsResponse>;\n\n  // Locations\n\n  /**\n   * Gets a registered location by its ID.\n   *\n   * @param id - A location ID\n   * @param options - Additional options\n   */\n  getLocationById(\n    id: string,\n    options?: CatalogRequestOptions,\n  ): Promise<Location | undefined>;\n\n  /**\n   * Gets a registered location by its ref.\n   *\n   * @param locationRef - A location ref, e.g. \"url:https://github.com/...\"\n   * @param options - Additional options\n   */\n  getLocationByRef(\n    locationRef: string,\n    options?: CatalogRequestOptions,\n  ): Promise<Location | undefined>;\n\n  /**\n   * Registers a new location.\n   *\n   * @param location - Request parameters\n   * @param options - Additional options\n   */\n  addLocation(\n    location: AddLocationRequest,\n    options?: CatalogRequestOptions,\n  ): Promise<AddLocationResponse>;\n\n  /**\n   * Removes a registered Location by its ID.\n   *\n   * @param id - A location ID\n   * @param options - Additional options\n   */\n  removeLocationById(\n    id: string,\n    options?: CatalogRequestOptions,\n  ): Promise<void>;\n\n  /**\n   * Validate entity and its location.\n   *\n   * @param entity - Entity to validate\n   * @param locationRef - Location ref in format `url:http://example.com/file`\n   */\n  validateEntity(\n    entity: Entity,\n    locationRef: string,\n    options?: CatalogRequestOptions,\n  ): Promise<ValidateEntityResponse>;\n}\n","/*\n * Copyright 2022 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  QueryEntitiesCursorRequest,\n  QueryEntitiesInitialRequest,\n  QueryEntitiesRequest,\n} from './types/api';\n\nexport function isQueryEntitiesInitialRequest(\n  request: QueryEntitiesInitialRequest,\n): request is QueryEntitiesInitialRequest {\n  return !(request as QueryEntitiesCursorRequest).cursor;\n}\n\nexport function isQueryEntitiesCursorRequest(\n  request: QueryEntitiesRequest,\n): request is QueryEntitiesCursorRequest {\n  return !isQueryEntitiesInitialRequest(request);\n}\n","/*\n * Copyright 2023 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport const pluginId = 'catalog';\n","/*\n * Copyright 2023 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { DiscoveryApi } from '../types/discovery';\nimport { FetchApi } from '../types/fetch';\nimport crossFetch from 'cross-fetch';\nimport { pluginId } from '../pluginId';\nimport * as parser from 'uri-template';\n\nimport { AnalyzeLocationRequest } from '../models/AnalyzeLocationRequest.model';\nimport { AnalyzeLocationResponse } from '../models/AnalyzeLocationResponse.model';\nimport { CreateLocation201Response } from '../models/CreateLocation201Response.model';\nimport { CreateLocationRequest } from '../models/CreateLocationRequest.model';\nimport { EntitiesBatchResponse } from '../models/EntitiesBatchResponse.model';\nimport { EntitiesQueryResponse } from '../models/EntitiesQueryResponse.model';\nimport { Entity } from '../models/Entity.model';\nimport { EntityAncestryResponse } from '../models/EntityAncestryResponse.model';\nimport { EntityFacetsResponse } from '../models/EntityFacetsResponse.model';\nimport { GetEntitiesByRefsRequest } from '../models/GetEntitiesByRefsRequest.model';\nimport { GetLocations200ResponseInner } from '../models/GetLocations200ResponseInner.model';\nimport { Location } from '../models/Location.model';\nimport { RefreshEntityRequest } from '../models/RefreshEntityRequest.model';\nimport { ValidateEntityRequest } from '../models/ValidateEntityRequest.model';\n\n/**\n * Wraps the Response type to convey a type on the json call.\n *\n * @public\n */\nexport type TypedResponse<T> = Omit<Response, 'json'> & {\n  json: () => Promise<T>;\n};\n\n/**\n * Options you can pass into a request for additional information.\n *\n * @public\n */\nexport interface RequestOptions {\n  token?: string;\n}\n\n/**\n * no description\n */\nexport class DefaultApiClient {\n  private readonly discoveryApi: DiscoveryApi;\n  private readonly fetchApi: FetchApi;\n\n  constructor(options: {\n    discoveryApi: { getBaseUrl(pluginId: string): Promise<string> };\n    fetchApi?: { fetch: typeof fetch };\n  }) {\n    this.discoveryApi = options.discoveryApi;\n    this.fetchApi = options.fetchApi || { fetch: crossFetch };\n  }\n\n  /**\n   * Validate a given location.\n   * @param analyzeLocationRequest\n   */\n  public async analyzeLocation(\n    // @ts-ignore\n    request: {\n      body: AnalyzeLocationRequest;\n    },\n    options?: RequestOptions,\n  ): Promise<TypedResponse<AnalyzeLocationResponse>> {\n    const baseUrl = await this.discoveryApi.getBaseUrl(pluginId);\n\n    const uriTemplate = `/analyze-location`;\n\n    const uri = parser.parse(uriTemplate).expand({});\n\n    return await this.fetchApi.fetch(`${baseUrl}${uri}`, {\n      headers: {\n        'Content-Type': 'application/json',\n        ...(options?.token && { Authorization: `Bearer ${options?.token}` }),\n      },\n      method: 'POST',\n      body: JSON.stringify(request.body),\n    });\n  }\n\n  /**\n   * Create a location for a given target.\n   * @param createLocationRequest\n   * @param dryRun\n   */\n  public async createLocation(\n    // @ts-ignore\n    request: {\n      body: CreateLocationRequest;\n      query: {\n        dryRun?: string;\n      };\n    },\n    options?: RequestOptions,\n  ): Promise<TypedResponse<CreateLocation201Response>> {\n    const baseUrl = await this.discoveryApi.getBaseUrl(pluginId);\n\n    const uriTemplate = `/locations{?dryRun}`;\n\n    const uri = parser.parse(uriTemplate).expand({\n      ...request.query,\n    });\n\n    return await this.fetchApi.fetch(`${baseUrl}${uri}`, {\n      headers: {\n        'Content-Type': 'application/json',\n        ...(options?.token && { Authorization: `Bearer ${options?.token}` }),\n      },\n      method: 'POST',\n      body: JSON.stringify(request.body),\n    });\n  }\n\n  /**\n   * Delete a single entity by UID.\n   * @param uid\n   */\n  public async deleteEntityByUid(\n    // @ts-ignore\n    request: {\n      path: {\n        uid: string;\n      };\n    },\n    options?: RequestOptions,\n  ): Promise<TypedResponse<void>> {\n    const baseUrl = await this.discoveryApi.getBaseUrl(pluginId);\n\n    const uriTemplate = `/entities/by-uid/{uid}`;\n\n    const uri = parser.parse(uriTemplate).expand({\n      uid: request.path.uid,\n    });\n\n    return await this.fetchApi.fetch(`${baseUrl}${uri}`, {\n      headers: {\n        'Content-Type': 'application/json',\n        ...(options?.token && { Authorization: `Bearer ${options?.token}` }),\n      },\n      method: 'DELETE',\n    });\n  }\n\n  /**\n   * Delete a location by id.\n   * @param id\n   */\n  public async deleteLocation(\n    // @ts-ignore\n    request: {\n      path: {\n        id: string;\n      };\n    },\n    options?: RequestOptions,\n  ): Promise<TypedResponse<void>> {\n    const baseUrl = await this.discoveryApi.getBaseUrl(pluginId);\n\n    const uriTemplate = `/locations/{id}`;\n\n    const uri = parser.parse(uriTemplate).expand({\n      id: request.path.id,\n    });\n\n    return await this.fetchApi.fetch(`${baseUrl}${uri}`, {\n      headers: {\n        'Content-Type': 'application/json',\n        ...(options?.token && { Authorization: `Bearer ${options?.token}` }),\n      },\n      method: 'DELETE',\n    });\n  }\n\n  /**\n   * Get all entities matching a given filter.\n   * @param fields Restrict to just these fields in the response.\n   * @param limit Number of records to return in the response.\n   * @param filter Filter for just the entities defined by this filter.\n   * @param offset Number of records to skip in the query page.\n   * @param after Pointer to the previous page of results.\n   * @param order\n   */\n  public async getEntities(\n    // @ts-ignore\n    request: {\n      query: {\n        fields?: Array<string>;\n        limit?: number;\n        filter?: Array<string>;\n        offset?: number;\n        after?: string;\n        order?: Array<string>;\n      };\n    },\n    options?: RequestOptions,\n  ): Promise<TypedResponse<Array<Entity>>> {\n    const baseUrl = await this.discoveryApi.getBaseUrl(pluginId);\n\n    const uriTemplate = `/entities{?fields,limit,filter*,offset,after,order*}`;\n\n    const uri = parser.parse(uriTemplate).expand({\n      ...request.query,\n    });\n\n    return await this.fetchApi.fetch(`${baseUrl}${uri}`, {\n      headers: {\n        'Content-Type': 'application/json',\n        ...(options?.token && { Authorization: `Bearer ${options?.token}` }),\n      },\n      method: 'GET',\n    });\n  }\n\n  /**\n   * Search for entities by a given query.\n   * @param fields Restrict to just these fields in the response.\n   * @param limit Number of records to return in the response.\n   * @param orderField The fields to sort returned results by.\n   * @param cursor Cursor to a set page of results.\n   * @param filter Filter for just the entities defined by this filter.\n   * @param fullTextFilterTerm Text search term.\n   * @param fullTextFilterFields A comma separated list of fields to sort returned results by.\n   */\n  public async getEntitiesByQuery(\n    // @ts-ignore\n    request: {\n      query: {\n        fields?: Array<string>;\n        limit?: number;\n        orderField?: Array<string>;\n        cursor?: string;\n        filter?: Array<string>;\n        fullTextFilterTerm?: string;\n        fullTextFilterFields?: Array<string>;\n      };\n    },\n    options?: RequestOptions,\n  ): Promise<TypedResponse<EntitiesQueryResponse>> {\n    const baseUrl = await this.discoveryApi.getBaseUrl(pluginId);\n\n    const uriTemplate = `/entities/by-query{?fields,limit,orderField*,cursor,filter*,fullTextFilterTerm,fullTextFilterFields}`;\n\n    const uri = parser.parse(uriTemplate).expand({\n      ...request.query,\n    });\n\n    return await this.fetchApi.fetch(`${baseUrl}${uri}`, {\n      headers: {\n        'Content-Type': 'application/json',\n        ...(options?.token && { Authorization: `Bearer ${options?.token}` }),\n      },\n      method: 'GET',\n    });\n  }\n\n  /**\n   * Get a batch set of entities given an array of entityRefs.\n   * @param getEntitiesByRefsRequest\n   */\n  public async getEntitiesByRefs(\n    // @ts-ignore\n    request: {\n      body: GetEntitiesByRefsRequest;\n    },\n    options?: RequestOptions,\n  ): Promise<TypedResponse<EntitiesBatchResponse>> {\n    const baseUrl = await this.discoveryApi.getBaseUrl(pluginId);\n\n    const uriTemplate = `/entities/by-refs`;\n\n    const uri = parser.parse(uriTemplate).expand({});\n\n    return await this.fetchApi.fetch(`${baseUrl}${uri}`, {\n      headers: {\n        'Content-Type': 'application/json',\n        ...(options?.token && { Authorization: `Bearer ${options?.token}` }),\n      },\n      method: 'POST',\n      body: JSON.stringify(request.body),\n    });\n  }\n\n  /**\n   * Get an entity's ancestry by entity ref.\n   * @param kind\n   * @param namespace\n   * @param name\n   */\n  public async getEntityAncestryByName(\n    // @ts-ignore\n    request: {\n      path: {\n        kind: string;\n        namespace: string;\n        name: string;\n      };\n    },\n    options?: RequestOptions,\n  ): Promise<TypedResponse<EntityAncestryResponse>> {\n    const baseUrl = await this.discoveryApi.getBaseUrl(pluginId);\n\n    const uriTemplate = `/entities/by-name/{kind}/{namespace}/{name}/ancestry`;\n\n    const uri = parser.parse(uriTemplate).expand({\n      kind: request.path.kind,\n      namespace: request.path.namespace,\n      name: request.path.name,\n    });\n\n    return await this.fetchApi.fetch(`${baseUrl}${uri}`, {\n      headers: {\n        'Content-Type': 'application/json',\n        ...(options?.token && { Authorization: `Bearer ${options?.token}` }),\n      },\n      method: 'GET',\n    });\n  }\n\n  /**\n   * Get an entity by an entity ref.\n   * @param kind\n   * @param namespace\n   * @param name\n   */\n  public async getEntityByName(\n    // @ts-ignore\n    request: {\n      path: {\n        kind: string;\n        namespace: string;\n        name: string;\n      };\n    },\n    options?: RequestOptions,\n  ): Promise<TypedResponse<Entity>> {\n    const baseUrl = await this.discoveryApi.getBaseUrl(pluginId);\n\n    const uriTemplate = `/entities/by-name/{kind}/{namespace}/{name}`;\n\n    const uri = parser.parse(uriTemplate).expand({\n      kind: request.path.kind,\n      namespace: request.path.namespace,\n      name: request.path.name,\n    });\n\n    return await this.fetchApi.fetch(`${baseUrl}${uri}`, {\n      headers: {\n        'Content-Type': 'application/json',\n        ...(options?.token && { Authorization: `Bearer ${options?.token}` }),\n      },\n      method: 'GET',\n    });\n  }\n\n  /**\n   * Get a single entity by the UID.\n   * @param uid\n   */\n  public async getEntityByUid(\n    // @ts-ignore\n    request: {\n      path: {\n        uid: string;\n      };\n    },\n    options?: RequestOptions,\n  ): Promise<TypedResponse<Entity>> {\n    const baseUrl = await this.discoveryApi.getBaseUrl(pluginId);\n\n    const uriTemplate = `/entities/by-uid/{uid}`;\n\n    const uri = parser.parse(uriTemplate).expand({\n      uid: request.path.uid,\n    });\n\n    return await this.fetchApi.fetch(`${baseUrl}${uri}`, {\n      headers: {\n        'Content-Type': 'application/json',\n        ...(options?.token && { Authorization: `Bearer ${options?.token}` }),\n      },\n      method: 'GET',\n    });\n  }\n\n  /**\n   * Get all entity facets that match the given filters.\n   * @param facet\n   * @param filter Filter for just the entities defined by this filter.\n   */\n  public async getEntityFacets(\n    // @ts-ignore\n    request: {\n      query: {\n        facet: Array<string>;\n        filter?: Array<string>;\n      };\n    },\n    options?: RequestOptions,\n  ): Promise<TypedResponse<EntityFacetsResponse>> {\n    const baseUrl = await this.discoveryApi.getBaseUrl(pluginId);\n\n    const uriTemplate = `/entity-facets{?facet*,filter*}`;\n\n    const uri = parser.parse(uriTemplate).expand({\n      ...request.query,\n    });\n\n    return await this.fetchApi.fetch(`${baseUrl}${uri}`, {\n      headers: {\n        'Content-Type': 'application/json',\n        ...(options?.token && { Authorization: `Bearer ${options?.token}` }),\n      },\n      method: 'GET',\n    });\n  }\n\n  /**\n   * Get a location by id.\n   * @param id\n   */\n  public async getLocation(\n    // @ts-ignore\n    request: {\n      path: {\n        id: string;\n      };\n    },\n    options?: RequestOptions,\n  ): Promise<TypedResponse<Location>> {\n    const baseUrl = await this.discoveryApi.getBaseUrl(pluginId);\n\n    const uriTemplate = `/locations/{id}`;\n\n    const uri = parser.parse(uriTemplate).expand({\n      id: request.path.id,\n    });\n\n    return await this.fetchApi.fetch(`${baseUrl}${uri}`, {\n      headers: {\n        'Content-Type': 'application/json',\n        ...(options?.token && { Authorization: `Bearer ${options?.token}` }),\n      },\n      method: 'GET',\n    });\n  }\n\n  /**\n   * Get all locations\n   */\n  public async getLocations(\n    // @ts-ignore\n    request: {},\n    options?: RequestOptions,\n  ): Promise<TypedResponse<Array<GetLocations200ResponseInner>>> {\n    const baseUrl = await this.discoveryApi.getBaseUrl(pluginId);\n\n    const uriTemplate = `/locations`;\n\n    const uri = parser.parse(uriTemplate).expand({});\n\n    return await this.fetchApi.fetch(`${baseUrl}${uri}`, {\n      headers: {\n        'Content-Type': 'application/json',\n        ...(options?.token && { Authorization: `Bearer ${options?.token}` }),\n      },\n      method: 'GET',\n    });\n  }\n\n  /**\n   * Refresh the entity related to entityRef.\n   * @param refreshEntityRequest\n   */\n  public async refreshEntity(\n    // @ts-ignore\n    request: {\n      body: RefreshEntityRequest;\n    },\n    options?: RequestOptions,\n  ): Promise<TypedResponse<void>> {\n    const baseUrl = await this.discoveryApi.getBaseUrl(pluginId);\n\n    const uriTemplate = `/refresh`;\n\n    const uri = parser.parse(uriTemplate).expand({});\n\n    return await this.fetchApi.fetch(`${baseUrl}${uri}`, {\n      headers: {\n        'Content-Type': 'application/json',\n        ...(options?.token && { Authorization: `Bearer ${options?.token}` }),\n      },\n      method: 'POST',\n      body: JSON.stringify(request.body),\n    });\n  }\n\n  /**\n   * Validate that a passed in entity has no errors in schema.\n   * @param validateEntityRequest\n   */\n  public async validateEntity(\n    // @ts-ignore\n    request: {\n      body: ValidateEntityRequest;\n    },\n    options?: RequestOptions,\n  ): Promise<TypedResponse<void>> {\n    const baseUrl = await this.discoveryApi.getBaseUrl(pluginId);\n\n    const uriTemplate = `/validate-entity`;\n\n    const uri = parser.parse(uriTemplate).expand({});\n\n    return await this.fetchApi.fetch(`${baseUrl}${uri}`, {\n      headers: {\n        'Content-Type': 'application/json',\n        ...(options?.token && { Authorization: `Bearer ${options?.token}` }),\n      },\n      method: 'POST',\n      body: JSON.stringify(request.body),\n    });\n  }\n}\n","/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  Entity,\n  CompoundEntityRef,\n  parseEntityRef,\n  stringifyEntityRef,\n  stringifyLocationRef,\n} from '@backstage/catalog-model';\nimport { ResponseError } from '@backstage/errors';\nimport {\n  CATALOG_FILTER_EXISTS,\n  AddLocationRequest,\n  AddLocationResponse,\n  CatalogApi,\n  GetEntitiesRequest,\n  GetEntitiesResponse,\n  CatalogRequestOptions,\n  GetEntityAncestorsRequest,\n  GetEntityAncestorsResponse,\n  Location,\n  GetEntityFacetsRequest,\n  GetEntityFacetsResponse,\n  ValidateEntityResponse,\n  GetEntitiesByRefsRequest,\n  GetEntitiesByRefsResponse,\n  QueryEntitiesRequest,\n  EntityFilterQuery,\n  QueryEntitiesResponse,\n} from './types/api';\nimport { isQueryEntitiesInitialRequest } from './utils';\nimport { DefaultApiClient, TypedResponse } from './generated';\n\n/**\n * A frontend and backend compatible client for communicating with the Backstage\n * software catalog.\n *\n * @public\n */\nexport class CatalogClient implements CatalogApi {\n  private readonly apiClient: DefaultApiClient;\n\n  constructor(options: {\n    discoveryApi: { getBaseUrl(pluginId: string): Promise<string> };\n    fetchApi?: { fetch: typeof fetch };\n  }) {\n    this.apiClient = new DefaultApiClient(options);\n  }\n\n  /**\n   * {@inheritdoc CatalogApi.getEntityAncestors}\n   */\n  async getEntityAncestors(\n    request: GetEntityAncestorsRequest,\n    options?: CatalogRequestOptions,\n  ): Promise<GetEntityAncestorsResponse> {\n    return await this.requestRequired(\n      await this.apiClient.getEntityAncestryByName(\n        { path: parseEntityRef(request.entityRef) },\n        options,\n      ),\n    );\n  }\n\n  /**\n   * {@inheritdoc CatalogApi.getLocationById}\n   */\n  async getLocationById(\n    id: string,\n    options?: CatalogRequestOptions,\n  ): Promise<Location | undefined> {\n    return await this.requestOptional(\n      await this.apiClient.getLocation({ path: { id } }, options),\n    );\n  }\n\n  /**\n   * {@inheritdoc CatalogApi.getEntities}\n   */\n  async getEntities(\n    request?: GetEntitiesRequest,\n    options?: CatalogRequestOptions,\n  ): Promise<GetEntitiesResponse> {\n    const {\n      filter = [],\n      fields = [],\n      order,\n      offset,\n      limit,\n      after,\n    } = request ?? {};\n    const encodedOrder = [];\n    if (order) {\n      for (const directive of [order].flat()) {\n        if (directive) {\n          encodedOrder.push(`${directive.order}:${directive.field}`);\n        }\n      }\n    }\n\n    const entities = await this.requestRequired(\n      await this.apiClient.getEntities(\n        {\n          query: {\n            fields,\n            limit,\n            filter: this.getFilterValue(filter),\n            offset,\n            after,\n            order: order ? encodedOrder : undefined,\n          },\n        },\n        options,\n      ),\n    );\n\n    const refCompare = (a: Entity, b: Entity) => {\n      // in case field filtering is used, these fields might not be part of the response\n      if (\n        a.metadata?.name === undefined ||\n        a.kind === undefined ||\n        b.metadata?.name === undefined ||\n        b.kind === undefined\n      ) {\n        return 0;\n      }\n\n      const aRef = stringifyEntityRef(a);\n      const bRef = stringifyEntityRef(b);\n      if (aRef < bRef) {\n        return -1;\n      }\n      if (aRef > bRef) {\n        return 1;\n      }\n      return 0;\n    };\n\n    return { items: entities.sort(refCompare) };\n  }\n\n  /**\n   * {@inheritdoc CatalogApi.getEntitiesByRefs}\n   */\n  async getEntitiesByRefs(\n    request: GetEntitiesByRefsRequest,\n    options?: CatalogRequestOptions,\n  ): Promise<GetEntitiesByRefsResponse> {\n    const response = await this.apiClient.getEntitiesByRefs(\n      {\n        body: request,\n      },\n      options,\n    );\n\n    if (!response.ok) {\n      throw await ResponseError.fromResponse(response);\n    }\n\n    const { items } = (await response.json()) as {\n      items: Array<Entity | null>;\n    };\n\n    return { items: items.map(i => i ?? undefined) };\n  }\n\n  /**\n   * {@inheritdoc CatalogApi.queryEntities}\n   */\n  async queryEntities(\n    request: QueryEntitiesRequest = {},\n    options?: CatalogRequestOptions,\n  ): Promise<QueryEntitiesResponse> {\n    const params: Partial<\n      Parameters<typeof this.apiClient.getEntitiesByQuery>[0]['query']\n    > = {};\n\n    if (isQueryEntitiesInitialRequest(request)) {\n      const {\n        fields = [],\n        filter,\n        limit,\n        orderFields,\n        fullTextFilter,\n      } = request;\n      params.filter = this.getFilterValue(filter);\n\n      if (limit !== undefined) {\n        params.limit = limit;\n      }\n      if (orderFields !== undefined) {\n        params.orderField = (\n          Array.isArray(orderFields) ? orderFields : [orderFields]\n        ).map(({ field, order }) => `${field},${order}`);\n      }\n      if (fields.length) {\n        params.fields = fields;\n      }\n\n      const normalizedFullTextFilterTerm = fullTextFilter?.term?.trim();\n      if (normalizedFullTextFilterTerm) {\n        params.fullTextFilterTerm = normalizedFullTextFilterTerm;\n      }\n      if (fullTextFilter?.fields?.length) {\n        params.fullTextFilterFields = fullTextFilter.fields;\n      }\n    } else {\n      const { fields = [], limit, cursor } = request;\n\n      params.cursor = cursor;\n      if (limit !== undefined) {\n        params.limit = limit;\n      }\n      if (fields.length) {\n        params.fields = fields;\n      }\n    }\n\n    return this.apiClient\n      .getEntitiesByQuery({ query: params }, options)\n      .then(r => r.json());\n  }\n\n  /**\n   * {@inheritdoc CatalogApi.getEntityByRef}\n   */\n  async getEntityByRef(\n    entityRef: string | CompoundEntityRef,\n    options?: CatalogRequestOptions,\n  ): Promise<Entity | undefined> {\n    return this.requestOptional(\n      await this.apiClient.getEntityByName(\n        {\n          path: parseEntityRef(entityRef),\n        },\n        options,\n      ),\n    );\n  }\n\n  // NOTE(freben): When we deprecate getEntityByName from the interface, we may\n  // still want to leave this implementation in place for quite some time\n  // longer, to minimize the risk for breakages. Suggested date for removal:\n  // August 2022\n  /**\n   * @deprecated Use getEntityByRef instead\n   */\n  async getEntityByName(\n    compoundName: CompoundEntityRef,\n    options?: CatalogRequestOptions,\n  ): Promise<Entity | undefined> {\n    const { kind, namespace = 'default', name } = compoundName;\n    return this.requestOptional(\n      await this.apiClient.getEntityByName(\n        { path: { kind, namespace, name } },\n        options,\n      ),\n    );\n  }\n\n  /**\n   * {@inheritdoc CatalogApi.refreshEntity}\n   */\n  async refreshEntity(entityRef: string, options?: CatalogRequestOptions) {\n    const response = await this.apiClient.refreshEntity(\n      { body: { entityRef } },\n      options,\n    );\n\n    if (response.status !== 200) {\n      throw new Error(await response.text());\n    }\n  }\n\n  /**\n   * {@inheritdoc CatalogApi.getEntityFacets}\n   */\n  async getEntityFacets(\n    request: GetEntityFacetsRequest,\n    options?: CatalogRequestOptions,\n  ): Promise<GetEntityFacetsResponse> {\n    const { filter = [], facets } = request;\n    return await this.requestOptional(\n      await this.apiClient.getEntityFacets(\n        {\n          query: { facet: facets, filter: this.getFilterValue(filter) },\n        },\n        options,\n      ),\n    );\n  }\n\n  /**\n   * {@inheritdoc CatalogApi.addLocation}\n   */\n  async addLocation(\n    request: AddLocationRequest,\n    options?: CatalogRequestOptions,\n  ): Promise<AddLocationResponse> {\n    const { type = 'url', target, dryRun } = request;\n\n    const response = await this.apiClient.createLocation(\n      {\n        body: { type, target },\n        query: { dryRun: dryRun ? 'true' : undefined },\n      },\n      options,\n    );\n\n    if (response.status !== 201) {\n      throw new Error(await response.text());\n    }\n\n    const { location, entities, exists } = await response.json();\n\n    if (!location) {\n      throw new Error(`Location wasn't added: ${target}`);\n    }\n\n    return {\n      location,\n      entities,\n      exists,\n    };\n  }\n\n  /**\n   * {@inheritdoc CatalogApi.getLocationByRef}\n   */\n  async getLocationByRef(\n    locationRef: string,\n    options?: CatalogRequestOptions,\n  ): Promise<Location | undefined> {\n    const all = await this.requestRequired(\n      await this.apiClient.getLocations({}, options),\n    );\n    return all\n      .map(r => r.data)\n      .find(l => locationRef === stringifyLocationRef(l));\n  }\n\n  /**\n   * {@inheritdoc CatalogApi.removeLocationById}\n   */\n  async removeLocationById(\n    id: string,\n    options?: CatalogRequestOptions,\n  ): Promise<void> {\n    await this.requestIgnored(\n      await this.apiClient.deleteLocation({ path: { id } }, options),\n    );\n  }\n\n  /**\n   * {@inheritdoc CatalogApi.removeEntityByUid}\n   */\n  async removeEntityByUid(\n    uid: string,\n    options?: CatalogRequestOptions,\n  ): Promise<void> {\n    await this.requestIgnored(\n      await this.apiClient.deleteEntityByUid({ path: { uid } }, options),\n    );\n  }\n\n  /**\n   * {@inheritdoc CatalogApi.validateEntity}\n   */\n  async validateEntity(\n    entity: Entity,\n    locationRef: string,\n    options?: CatalogRequestOptions,\n  ): Promise<ValidateEntityResponse> {\n    const response = await this.apiClient.validateEntity(\n      { body: { entity, location: locationRef } },\n      options,\n    );\n\n    if (response.ok) {\n      return {\n        valid: true,\n      };\n    }\n\n    if (response.status !== 400) {\n      throw await ResponseError.fromResponse(response);\n    }\n\n    const { errors = [] } = (await response.json()) as any;\n\n    return {\n      valid: false,\n      errors,\n    };\n  }\n\n  //\n  // Private methods\n  //\n\n  private async requestIgnored(response: Response): Promise<void> {\n    if (!response.ok) {\n      throw await ResponseError.fromResponse(response);\n    }\n  }\n\n  private async requestRequired<T>(response: TypedResponse<T>): Promise<T> {\n    if (!response.ok) {\n      throw await ResponseError.fromResponse(response);\n    }\n\n    return response.json();\n  }\n\n  private async requestOptional(response: Response): Promise<any | undefined> {\n    if (!response.ok) {\n      if (response.status === 404) {\n        return undefined;\n      }\n      throw await ResponseError.fromResponse(response);\n    }\n\n    return await response.json();\n  }\n\n  private getFilterValue(filter: EntityFilterQuery = []) {\n    const filters: string[] = [];\n    // filter param can occur multiple times, for example\n    // /api/catalog/entities?filter=metadata.name=wayback-search,kind=component&filter=metadata.name=www-artist,kind=component'\n    // the \"outer array\" defined by `filter` occurrences corresponds to \"anyOf\" filters\n    // the \"inner array\" defined within a `filter` param corresponds to \"allOf\" filters\n    for (const filterItem of [filter].flat()) {\n      const filterParts: string[] = [];\n      for (const [key, value] of Object.entries(filterItem)) {\n        for (const v of [value].flat()) {\n          if (v === CATALOG_FILTER_EXISTS) {\n            filterParts.push(key);\n          } else if (typeof v === 'string') {\n            filterParts.push(`${key}=${v}`);\n          }\n        }\n      }\n\n      if (filterParts.length) {\n        filters.push(filterParts.join(','));\n      }\n    }\n    return filters;\n  }\n}\n","/*\n * Copyright 2021 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * The entity `status.items[].type` for the status of the processing engine in\n * regards to an entity.\n *\n * @public\n */\nexport const ENTITY_STATUS_CATALOG_PROCESSING_TYPE =\n  'backstage.io/catalog-processing';\n"],"names":["__publicField","crossFetch","parser","parseEntityRef","stringifyEntityRef","ResponseError","stringifyLocationRef","errors"],"mappings":"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"}