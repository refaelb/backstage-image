'use strict';

var zod = require('zod');
var backendCommon = require('@backstage/backend-common');
var errors = require('@backstage/errors');
var pluginAuthNode = require('@backstage/plugin-auth-node');
var pluginPermissionCommon = require('@backstage/plugin-permission-common');
var lodash = require('lodash');
var qs = require('qs');
var DataLoader = require('dataloader');
var backendOpenapiUtils = require('@backstage/backend-openapi-utils');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var qs__default = /*#__PURE__*/_interopDefaultLegacy(qs);
var DataLoader__default = /*#__PURE__*/_interopDefaultLegacy(DataLoader);

var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
function decodePageCursor(pageCursor) {
  if (!pageCursor) {
    return { page: 0 };
  }
  const page = Number(Buffer.from(pageCursor, "base64").toString("utf-8"));
  if (isNaN(page)) {
    throw new errors.InputError("Invalid page cursor");
  }
  if (page < 0) {
    throw new errors.InputError("Invalid page cursor");
  }
  return {
    page
  };
}
function encodePageCursor({ page }) {
  return Buffer.from(`${page}`, "utf-8").toString("base64");
}
class AuthorizedSearchEngine {
  constructor(searchEngine, types, permissions, config) {
    this.searchEngine = searchEngine;
    this.types = types;
    this.permissions = permissions;
    __publicField(this, "pageSize", 25);
    __publicField(this, "queryLatencyBudgetMs");
    var _a;
    this.queryLatencyBudgetMs = (_a = config.getOptionalNumber("search.permissions.queryLatencyBudgetMs")) != null ? _a : 1e3;
  }
  setTranslator(translator) {
    this.searchEngine.setTranslator(translator);
  }
  async getIndexer(type) {
    return this.searchEngine.getIndexer(type);
  }
  async query(query, options) {
    const queryStartTime = Date.now();
    const conditionFetcher = new DataLoader__default["default"](
      (requests) => this.permissions.authorizeConditional(requests.slice(), options),
      {
        cacheKeyFn: ({ permission: { name } }) => name
      }
    );
    const authorizer = new DataLoader__default["default"](
      (requests) => this.permissions.authorize(requests.slice(), options),
      {
        // Serialize the permission name and resourceRef as
        // a query string to avoid collisions from overlapping
        // permission names and resourceRefs.
        cacheKeyFn: ({ permission: { name }, resourceRef }) => qs__default["default"].stringify({ name, resourceRef })
      }
    );
    const requestedTypes = query.types || Object.keys(this.types);
    const typeDecisions = lodash.zipObject(
      requestedTypes,
      await Promise.all(
        requestedTypes.map((type) => {
          var _a;
          const permission = (_a = this.types[type]) == null ? void 0 : _a.visibilityPermission;
          if (!permission) {
            return { result: pluginPermissionCommon.AuthorizeResult.ALLOW };
          }
          if (pluginPermissionCommon.isResourcePermission(permission)) {
            return conditionFetcher.load({ permission });
          }
          return authorizer.load({ permission });
        })
      )
    );
    const authorizedTypes = requestedTypes.filter(
      (type) => {
        var _a;
        return ((_a = typeDecisions[type]) == null ? void 0 : _a.result) !== pluginPermissionCommon.AuthorizeResult.DENY;
      }
    );
    const resultByResultFilteringRequired = authorizedTypes.some(
      (type) => {
        var _a;
        return ((_a = typeDecisions[type]) == null ? void 0 : _a.result) === pluginPermissionCommon.AuthorizeResult.CONDITIONAL;
      }
    );
    if (!resultByResultFilteringRequired) {
      return this.searchEngine.query(
        { ...query, types: authorizedTypes },
        options
      );
    }
    const { page } = decodePageCursor(query.pageCursor);
    const targetResults = (page + 1) * this.pageSize;
    let filteredResults = [];
    let nextPageCursor;
    let latencyBudgetExhausted = false;
    do {
      const nextPage = await this.searchEngine.query(
        { ...query, types: authorizedTypes, pageCursor: nextPageCursor },
        options
      );
      filteredResults = filteredResults.concat(
        await this.filterResults(nextPage.results, typeDecisions, authorizer)
      );
      nextPageCursor = nextPage.nextPageCursor;
      latencyBudgetExhausted = Date.now() - queryStartTime > this.queryLatencyBudgetMs;
    } while (nextPageCursor && filteredResults.length < targetResults && !latencyBudgetExhausted);
    return {
      results: filteredResults.slice(page * this.pageSize, (page + 1) * this.pageSize).map((result, index) => {
        return {
          ...result,
          rank: page * this.pageSize + index + 1
        };
      }),
      previousPageCursor: page === 0 ? void 0 : encodePageCursor({ page: page - 1 }),
      nextPageCursor: !latencyBudgetExhausted && (nextPageCursor || filteredResults.length > targetResults) ? encodePageCursor({ page: page + 1 }) : void 0,
      numberOfResults: void 0
    };
  }
  async filterResults(results, typeDecisions, authorizer) {
    return lodash.compact(
      await Promise.all(
        results.map((result) => {
          var _a, _b, _c;
          if (((_a = typeDecisions[result.type]) == null ? void 0 : _a.result) === pluginPermissionCommon.AuthorizeResult.ALLOW) {
            return result;
          }
          const permission = (_b = this.types[result.type]) == null ? void 0 : _b.visibilityPermission;
          const resourceRef = (_c = result.document.authorization) == null ? void 0 : _c.resourceRef;
          if (!permission || !resourceRef) {
            return result;
          }
          if (!pluginPermissionCommon.isResourcePermission(permission)) {
            throw new Error(
              `Unexpected conditional decision returned for non-resource permission "${permission.name}"`
            );
          }
          return authorizer.load({ permission, resourceRef }).then(
            (decision) => decision.result === pluginPermissionCommon.AuthorizeResult.ALLOW ? result : void 0
          );
        })
      )
    );
  }
}

const spec = {
  openapi: "3.0.3",
  info: {
    title: "@backstage/plugin-search-backend",
    version: "1",
    description: "The Backstage backend plugin that provides search functionality.",
    license: {
      name: "Apache-2.0",
      url: "http://www.apache.org/licenses/LICENSE-2.0.html"
    },
    contact: {}
  },
  servers: [
    {
      url: "/"
    }
  ],
  components: {
    examples: {},
    headers: {},
    parameters: {},
    requestBodies: {},
    responses: {
      ErrorResponse: {
        description: "An error response from the backend.",
        content: {
          "application/json; charset=utf-8": {
            schema: {
              $ref: "#/components/schemas/Error"
            }
          }
        }
      }
    },
    schemas: {
      Error: {
        type: "object",
        properties: {
          error: {
            type: "object",
            properties: {
              name: {
                type: "string"
              },
              message: {
                type: "string"
              }
            },
            required: ["name", "message"]
          },
          request: {
            type: "object",
            properties: {
              method: {
                type: "string"
              },
              url: {
                type: "string"
              }
            },
            required: ["method", "url"]
          },
          response: {
            type: "object",
            properties: {
              statusCode: {
                type: "number"
              }
            },
            required: ["statusCode"]
          }
        },
        required: ["error", "request", "response"]
      },
      JsonObject: {
        type: "object",
        properties: {},
        additionalProperties: {}
      }
    },
    securitySchemes: {
      JWT: {
        type: "http",
        scheme: "bearer",
        bearerFormat: "JWT"
      }
    }
  },
  paths: {
    "/query": {
      get: {
        operationId: "Query",
        description: "Query documents with a given filter.",
        responses: {
          "200": {
            description: "Ok",
            content: {
              "application/json": {
                schema: {
                  type: "object",
                  properties: {
                    results: {
                      type: "array",
                      items: {
                        type: "object",
                        properties: {
                          type: {
                            type: "string",
                            description: 'The "type" of the given document.'
                          },
                          document: {
                            type: "object",
                            description: "The raw value of the document, as indexed.",
                            properties: {
                              title: {
                                type: "string",
                                description: "The primary name of the document (e.g. name, title, identifier, etc)."
                              },
                              text: {
                                type: "string",
                                description: "Free-form text of the document (e.g. description, content, etc)."
                              },
                              location: {
                                type: "string",
                                description: "The relative or absolute URL of the document (target when a search result is clicked)."
                              }
                            }
                          },
                          highlight: {
                            type: "object",
                            description: "Optional result highlight. Useful for improving the search result\ndisplay/experience."
                          },
                          rank: {
                            type: "integer",
                            description: "Optional result rank, where 1 is the first/top result returned. \nUseful for understanding search effectiveness in analytics."
                          }
                        },
                        required: ["type", "document"],
                        additionalProperties: false
                      }
                    },
                    nextPageCursor: {
                      type: "string"
                    },
                    previousPageCursor: {
                      type: "string"
                    },
                    numberOfResults: {
                      type: "integer"
                    }
                  },
                  required: ["results"]
                }
              }
            }
          },
          default: {
            $ref: "#/components/responses/ErrorResponse"
          }
        },
        security: [
          {},
          {
            JWT: []
          }
        ],
        parameters: [
          {
            name: "term",
            in: "query",
            required: false,
            schema: {
              type: "string",
              default: ""
            }
          },
          {
            name: "filters",
            in: "query",
            required: false,
            style: "deepObject",
            explode: true,
            schema: {
              $ref: "#/components/schemas/JsonObject"
            }
          },
          {
            name: "types",
            in: "query",
            required: false,
            schema: {
              type: "array",
              items: {
                type: "string"
              }
            }
          },
          {
            name: "pageCursor",
            in: "query",
            required: false,
            schema: {
              type: "string"
            }
          },
          {
            name: "pageLimit",
            in: "query",
            required: false,
            schema: {
              type: "integer"
            }
          }
        ]
      }
    }
  }
};
const createOpenApiRouter = async (options) => backendOpenapiUtils.createValidatedOpenApiRouter(spec, options);

const jsonObjectSchema = zod.z.lazy(() => {
  const jsonValueSchema = zod.z.lazy(
    () => zod.z.union([
      zod.z.string(),
      zod.z.number(),
      zod.z.boolean(),
      zod.z.null(),
      zod.z.array(jsonValueSchema),
      jsonObjectSchema
    ])
  );
  return zod.z.record(jsonValueSchema);
});
const defaultMaxPageLimit = 100;
const defaultMaxTermLength = 100;
const allowedLocationProtocols = ["http:", "https:"];
async function createRouter(options) {
  var _a, _b;
  const router = await createOpenApiRouter();
  const { engine: inputEngine, types, permissions, config, logger } = options;
  const maxPageLimit = (_a = config.getOptionalNumber("search.maxPageLimit")) != null ? _a : defaultMaxPageLimit;
  const maxTermLength = (_b = config.getOptionalNumber("search.maxTermLength")) != null ? _b : defaultMaxTermLength;
  const requestSchema = zod.z.object({
    term: zod.z.string().refine(
      (term) => term.length <= maxTermLength,
      (term) => ({
        message: `The term length "${term.length}" is greater than "${maxTermLength}"`
      })
    ).default(""),
    filters: jsonObjectSchema.optional(),
    types: zod.z.array(zod.z.string().refine((type) => Object.keys(types).includes(type))).optional(),
    pageCursor: zod.z.string().optional(),
    pageLimit: zod.z.number().refine(
      (pageLimit) => pageLimit <= maxPageLimit,
      (pageLimit) => ({
        message: `The page limit "${pageLimit}" is greater than "${maxPageLimit}"`
      })
    ).optional()
  });
  let permissionEvaluator;
  if ("authorizeConditional" in permissions) {
    permissionEvaluator = permissions;
  } else {
    logger.warn(
      "PermissionAuthorizer is deprecated. Please use an instance of PermissionEvaluator instead of PermissionAuthorizer in PluginEnvironment#permissions"
    );
    permissionEvaluator = pluginPermissionCommon.toPermissionEvaluator(permissions);
  }
  const engine = config.getOptionalBoolean("permission.enabled") ? new AuthorizedSearchEngine(
    inputEngine,
    types,
    permissionEvaluator,
    config
  ) : inputEngine;
  const filterResultSet = ({ results, ...resultSet }) => ({
    ...resultSet,
    results: results.filter((result) => {
      const protocol = new URL(result.document.location, "https://example.com").protocol;
      const isAllowed = allowedLocationProtocols.includes(protocol);
      if (!isAllowed) {
        logger.info(
          `Rejected search result for "${result.document.title}" as location protocol "${protocol}" is unsafe`
        );
      }
      return isAllowed;
    })
  });
  const toSearchResults = (resultSet) => ({
    ...resultSet,
    results: resultSet.results.map((result) => ({
      ...result,
      document: {
        ...result.document,
        authorization: void 0
      }
    }))
  });
  router.get("/query", async (req, res) => {
    var _a2;
    const parseResult = requestSchema.passthrough().safeParse(req.query);
    if (!parseResult.success) {
      throw new errors.InputError(`Invalid query string: ${parseResult.error}`);
    }
    const query = parseResult.data;
    logger.info(
      `Search request received: term="${query.term}", filters=${JSON.stringify(
        query.filters
      )}, types=${query.types ? query.types.join(",") : ""}, pageCursor=${(_a2 = query.pageCursor) != null ? _a2 : ""}`
    );
    const token = pluginAuthNode.getBearerTokenFromAuthorizationHeader(
      req.header("authorization")
    );
    try {
      const resultSet = await (engine == null ? void 0 : engine.query(query, { token }));
      res.json(filterResultSet(toSearchResults(resultSet)));
    } catch (error) {
      if (error.name === "MissingIndexError") {
        throw error;
      }
      throw new Error(
        `There was a problem performing the search query: ${error.message}`
      );
    }
  });
  router.use(backendCommon.errorHandler());
  return router;
}

exports.createRouter = createRouter;
//# sourceMappingURL=router-25d5bb35.cjs.js.map
