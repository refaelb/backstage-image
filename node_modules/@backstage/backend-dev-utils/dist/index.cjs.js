'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var __accessCheck$1 = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet$1 = (obj, member, getter) => {
  __accessCheck$1(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd$1 = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet$1 = (obj, member, value, setter) => {
  __accessCheck$1(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var __privateWrapper = (obj, member, setter, getter) => ({
  set _(value) {
    __privateSet$1(obj, member, value, setter);
  },
  get _() {
    return __privateGet$1(obj, member, getter);
  }
});
var _messageId, _sendMessage;
const requestType = "@backstage/cli/channel/request";
const responseType = "@backstage/cli/channel/response";
const IPC_TIMEOUT_MS = 5e3;
const _BackstageIpcClient = class _BackstageIpcClient {
  constructor(sendMessage) {
    __privateAdd$1(this, _messageId, 0);
    __privateAdd$1(this, _sendMessage, void 0);
    __privateSet$1(this, _sendMessage, sendMessage);
  }
  /**
   * Creates a new client if we're in a child process with IPC and BACKSTAGE_CLI_CHANNEL is set.
   */
  static create() {
    var _a;
    const sendMessage = (_a = process.send) == null ? void 0 : _a.bind(process);
    return sendMessage && process.env.BACKSTAGE_CLI_CHANNEL ? new _BackstageIpcClient(sendMessage) : void 0;
  }
  /**
   * Send a request to the parent process and wait for a response.
   */
  async request(method, body) {
    return new Promise((resolve, reject) => {
      const id = __privateWrapper(this, _messageId)._++;
      const request = {
        type: requestType,
        id,
        method,
        body
      };
      let timeout = void 0;
      const messageHandler = (response) => {
        if ((response == null ? void 0 : response.type) !== responseType) {
          return;
        }
        if (response.id !== id) {
          return;
        }
        clearTimeout(timeout);
        timeout = void 0;
        process.removeListener("message", messageHandler);
        if ("error" in response) {
          const error = new Error(response.error.message);
          if (response.error.name) {
            error.name = response.error.name;
          }
          reject(error);
        } else {
          resolve(response.body);
        }
      };
      timeout = setTimeout(() => {
        reject(new Error(`IPC request '${method}' with ID ${id} timed out`));
        process.removeListener("message", messageHandler);
      }, IPC_TIMEOUT_MS);
      timeout.unref();
      process.addListener("message", messageHandler);
      __privateGet$1(this, _sendMessage).call(this, request, (e) => {
        if (e) {
          reject(e);
        }
      });
    });
  }
};
_messageId = new WeakMap();
_sendMessage = new WeakMap();
let BackstageIpcClient = _BackstageIpcClient;
const ipcClient = BackstageIpcClient.create();

var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var _instance, _client;
const _DevDataStore = class _DevDataStore {
  constructor(client) {
    __privateAdd(this, _client, void 0);
    __privateSet(this, _client, client);
  }
  /**
   * Tries to acquire a DevDataStore instance. This will only succeed when the backend
   * process is being run through the `@backstage/cli` in development mode.
   *
   * @returns A DevDataStore instance, or undefined if not available.
   */
  static get() {
    if (ipcClient) {
      if (!__privateGet(this, _instance)) {
        __privateSet(this, _instance, new _DevDataStore(ipcClient));
      }
      return __privateGet(this, _instance);
    }
    return void 0;
  }
  /** @internal */
  static forTest(client) {
    return new _DevDataStore(client);
  }
  /**
   * Save data to the data store.
   *
   * @param key - The key used to identify the data.
   * @param data - The data to save. The data will be serialized using advanced IPC serialization.
   * @returns A promise that resolves to a result object that indicates whether the data was saved.
   */
  async save(key, data) {
    return __privateGet(this, _client).request(
      "DevDataStore.save",
      { key, data }
    );
  }
  /**
   * Loads data from the data store.
   *
   * @param key - The key used to identify the data.
   * @returns A promise that resolves to a result object that indicates whether the data was loaded, as well as the data.
   */
  async load(key) {
    const result = await __privateGet(this, _client).request(
      "DevDataStore.load",
      { key }
    );
    return result;
  }
};
_instance = new WeakMap();
_client = new WeakMap();
__privateAdd(_DevDataStore, _instance, void 0);
let DevDataStore = _DevDataStore;

exports.DevDataStore = DevDataStore;
//# sourceMappingURL=index.cjs.js.map
