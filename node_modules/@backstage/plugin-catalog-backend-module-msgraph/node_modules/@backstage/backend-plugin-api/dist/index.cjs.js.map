{"version":3,"file":"index.cjs.js","sources":["../src/services/system/types.ts","../src/services/definitions/coreServices.ts","../src/wiring/factories.ts"],"sourcesContent":["/*\n * Copyright 2022 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { BackendFeature } from '../../types';\n\n/**\n * TODO\n *\n * @public\n */\nexport type ServiceRef<\n  TService,\n  TScope extends 'root' | 'plugin' = 'root' | 'plugin',\n> = {\n  id: string;\n\n  /**\n   * This determines the scope at which this service is available.\n   *\n   * Root scoped services are available to all other services but\n   * may only depend on other root scoped services.\n   *\n   * Plugin scoped services are only available to other plugin scoped\n   * services but may depend on all other services.\n   */\n  scope: TScope;\n\n  /**\n   * Utility for getting the type of the service, using `typeof serviceRef.T`.\n   * Attempting to actually read this value will result in an exception.\n   */\n  T: TService;\n\n  toString(): string;\n\n  $$type: '@backstage/ServiceRef';\n};\n\n/** @public */\nexport interface ServiceFactory<\n  TService = unknown,\n  TScope extends 'plugin' | 'root' = 'plugin' | 'root',\n> extends BackendFeature {\n  service: ServiceRef<TService, TScope>;\n}\n\n/** @internal */\nexport interface InternalServiceFactory<\n  TService = unknown,\n  TScope extends 'plugin' | 'root' = 'plugin' | 'root',\n> extends ServiceFactory<TService, TScope> {\n  version: 'v1';\n  deps: { [key in string]: ServiceRef<unknown> };\n  createRootContext?(deps: { [key in string]: unknown }): Promise<unknown>;\n  factory(\n    deps: { [key in string]: unknown },\n    context: unknown,\n  ): Promise<TService>;\n}\n\n/**\n * Represents either a {@link ServiceFactory} or a function that returns one.\n *\n * @public\n */\nexport type ServiceFactoryOrFunction = ServiceFactory | (() => ServiceFactory);\n\n/** @public */\nexport interface ServiceRefConfig<TService, TScope extends 'root' | 'plugin'> {\n  id: string;\n  scope?: TScope;\n  defaultFactory?: (\n    service: ServiceRef<TService, TScope>,\n  ) => Promise<ServiceFactoryOrFunction>;\n}\n\n/**\n * Creates a new service definition. This overload is used to create plugin scoped services.\n *\n * @public\n */\nexport function createServiceRef<TService>(\n  config: ServiceRefConfig<TService, 'plugin'>,\n): ServiceRef<TService, 'plugin'>;\n\n/**\n * Creates a new service definition. This overload is used to create root scoped services.\n *\n * @public\n */\nexport function createServiceRef<TService>(\n  config: ServiceRefConfig<TService, 'root'>,\n): ServiceRef<TService, 'root'>;\nexport function createServiceRef<TService>(\n  config: ServiceRefConfig<TService, any>,\n): ServiceRef<TService, any> {\n  const { id, scope = 'plugin', defaultFactory } = config;\n  return {\n    id,\n    scope,\n    get T(): TService {\n      throw new Error(`tried to read ServiceRef.T of ${this}`);\n    },\n    toString() {\n      return `serviceRef{${config.id}}`;\n    },\n    $$type: '@backstage/ServiceRef',\n    __defaultFactory: defaultFactory,\n  } as ServiceRef<TService, typeof scope> & {\n    __defaultFactory?: (\n      service: ServiceRef<TService>,\n    ) => Promise<ServiceFactory<TService> | (() => ServiceFactory<TService>)>;\n  };\n}\n\n/** @ignore */\ntype ServiceRefsToInstances<\n  T extends { [key in string]: ServiceRef<unknown> },\n  TScope extends 'root' | 'plugin' = 'root' | 'plugin',\n> = {\n  [key in keyof T as T[key]['scope'] extends TScope ? key : never]: T[key]['T'];\n};\n\n/** @public */\nexport interface RootServiceFactoryConfig<\n  TService,\n  TImpl extends TService,\n  TDeps extends { [name in string]: ServiceRef<unknown> },\n> {\n  service: ServiceRef<TService, 'root'>;\n  deps: TDeps;\n  factory(deps: ServiceRefsToInstances<TDeps, 'root'>): TImpl | Promise<TImpl>;\n}\n\n/** @public */\nexport interface PluginServiceFactoryConfig<\n  TService,\n  TContext,\n  TImpl extends TService,\n  TDeps extends { [name in string]: ServiceRef<unknown> },\n> {\n  service: ServiceRef<TService, 'plugin'>;\n  deps: TDeps;\n  createRootContext?(\n    deps: ServiceRefsToInstances<TDeps, 'root'>,\n  ): TContext | Promise<TContext>;\n  factory(\n    deps: ServiceRefsToInstances<TDeps>,\n    context: TContext,\n  ): TImpl | Promise<TImpl>;\n}\n\n/**\n * Creates a root scoped service factory without options.\n *\n * @public\n * @param config - The service factory configuration.\n */\nexport function createServiceFactory<\n  TService,\n  TImpl extends TService,\n  TDeps extends { [name in string]: ServiceRef<unknown, 'root'> },\n  TOpts extends object | undefined = undefined,\n>(\n  config: RootServiceFactoryConfig<TService, TImpl, TDeps>,\n): () => ServiceFactory<TService, 'root'>;\n/**\n * Creates a root scoped service factory with optional options.\n *\n * @public\n * @param config - The service factory configuration.\n */\nexport function createServiceFactory<\n  TService,\n  TImpl extends TService,\n  TDeps extends { [name in string]: ServiceRef<unknown, 'root'> },\n  TOpts extends object | undefined = undefined,\n>(\n  config: (options?: TOpts) => RootServiceFactoryConfig<TService, TImpl, TDeps>,\n): (options?: TOpts) => ServiceFactory<TService, 'root'>;\n/**\n * Creates a plugin scoped service factory without options.\n *\n * @public\n * @param config - The service factory configuration.\n */\nexport function createServiceFactory<\n  TService,\n  TImpl extends TService,\n  TDeps extends { [name in string]: ServiceRef<unknown> },\n  TContext = undefined,\n  TOpts extends object | undefined = undefined,\n>(\n  config: PluginServiceFactoryConfig<TService, TContext, TImpl, TDeps>,\n): () => ServiceFactory<TService, 'plugin'>;\n/**\n * Creates a plugin scoped service factory with optional options.\n *\n * @public\n * @param config - The service factory configuration.\n */\nexport function createServiceFactory<\n  TService,\n  TImpl extends TService,\n  TDeps extends { [name in string]: ServiceRef<unknown> },\n  TContext = undefined,\n  TOpts extends object | undefined = undefined,\n>(\n  config: (\n    options?: TOpts,\n  ) => PluginServiceFactoryConfig<TService, TContext, TImpl, TDeps>,\n): (options?: TOpts) => ServiceFactory<TService, 'plugin'>;\nexport function createServiceFactory<\n  TService,\n  TImpl extends TService,\n  TDeps extends { [name in string]: ServiceRef<unknown> },\n  TContext,\n  TOpts extends object | undefined = undefined,\n>(\n  config:\n    | RootServiceFactoryConfig<TService, TImpl, TDeps>\n    | PluginServiceFactoryConfig<TService, TContext, TImpl, TDeps>\n    | ((options: TOpts) => RootServiceFactoryConfig<TService, TImpl, TDeps>)\n    | ((\n        options: TOpts,\n      ) => PluginServiceFactoryConfig<TService, TContext, TImpl, TDeps>)\n    | (() => RootServiceFactoryConfig<TService, TImpl, TDeps>)\n    | (() => PluginServiceFactoryConfig<TService, TContext, TImpl, TDeps>),\n): (options: TOpts) => ServiceFactory {\n  const configCallback = typeof config === 'function' ? config : () => config;\n  const factory = (\n    options: TOpts,\n  ): InternalServiceFactory<TService, 'plugin' | 'root'> => {\n    const anyConf = configCallback(options);\n    if (anyConf.service.scope === 'root') {\n      const c = anyConf as RootServiceFactoryConfig<TService, TImpl, TDeps>;\n      return {\n        $$type: '@backstage/BackendFeature',\n        version: 'v1',\n        service: c.service,\n        deps: c.deps,\n        factory: async (deps: TDeps) => c.factory(deps),\n      };\n    }\n    const c = anyConf as PluginServiceFactoryConfig<\n      TService,\n      TContext,\n      TImpl,\n      TDeps\n    >;\n    return {\n      $$type: '@backstage/BackendFeature',\n      version: 'v1',\n      service: c.service,\n      ...('createRootContext' in c\n        ? {\n            createRootContext: async (deps: TDeps) =>\n              c?.createRootContext?.(deps),\n          }\n        : {}),\n      deps: c.deps,\n      factory: async (deps: TDeps, ctx: TContext) => c.factory(deps, ctx),\n    };\n  };\n\n  factory.$$type = '@backstage/BackendFeatureFactory';\n\n  return factory;\n}\n","/*\n * Copyright 2022 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { createServiceRef } from '../system';\n\n/**\n * All core services references\n *\n * @public\n */\nexport namespace coreServices {\n  /**\n   * The service reference for the plugin scoped {@link CacheService}.\n   *\n   * @public\n   */\n  export const cache = createServiceRef<import('./CacheService').CacheService>({\n    id: 'core.cache',\n  });\n\n  /**\n   * The service reference for the root scoped {@link RootConfigService}.\n   *\n   * @public\n   */\n  export const rootConfig = createServiceRef<\n    import('./RootConfigService').RootConfigService\n  >({ id: 'core.rootConfig', scope: 'root' });\n\n  /**\n   * The service reference for the plugin scoped {@link DatabaseService}.\n   *\n   * @public\n   */\n  export const database = createServiceRef<\n    import('./DatabaseService').DatabaseService\n  >({ id: 'core.database' });\n\n  /**\n   * The service reference for the plugin scoped {@link DiscoveryService}.\n   *\n   * @public\n   */\n  export const discovery = createServiceRef<\n    import('./DiscoveryService').DiscoveryService\n  >({ id: 'core.discovery' });\n\n  /**\n   * The service reference for the plugin scoped {@link HttpRouterService}.\n   *\n   * @public\n   */\n  export const httpRouter = createServiceRef<\n    import('./HttpRouterService').HttpRouterService\n  >({ id: 'core.httpRouter' });\n\n  /**\n   * The service reference for the plugin scoped {@link LifecycleService}.\n   *\n   * @public\n   */\n  export const lifecycle = createServiceRef<\n    import('./LifecycleService').LifecycleService\n  >({ id: 'core.lifecycle' });\n\n  /**\n   * The service reference for the plugin scoped {@link LoggerService}.\n   *\n   * @public\n   */\n  export const logger = createServiceRef<\n    import('./LoggerService').LoggerService\n  >({ id: 'core.logger' });\n\n  /**\n   * The service reference for the plugin scoped {@link PermissionsService}.\n   *\n   * @public\n   */\n  export const permissions = createServiceRef<\n    import('./PermissionsService').PermissionsService\n  >({ id: 'core.permissions' });\n\n  /**\n   * The service reference for the plugin scoped {@link PluginMetadataService}.\n   *\n   * @public\n   */\n  export const pluginMetadata = createServiceRef<\n    import('./PluginMetadataService').PluginMetadataService\n  >({ id: 'core.pluginMetadata' });\n\n  /**\n   * The service reference for the root scoped {@link RootHttpRouterService}.\n   *\n   * @public\n   */\n  export const rootHttpRouter = createServiceRef<\n    import('./RootHttpRouterService').RootHttpRouterService\n  >({ id: 'core.rootHttpRouter', scope: 'root' });\n\n  /**\n   * The service reference for the root scoped {@link RootLifecycleService}.\n   *\n   * @public\n   */\n  export const rootLifecycle = createServiceRef<\n    import('./RootLifecycleService').RootLifecycleService\n  >({ id: 'core.rootLifecycle', scope: 'root' });\n\n  /**\n   * The service reference for the root scoped {@link RootLoggerService}.\n   *\n   * @public\n   */\n  export const rootLogger = createServiceRef<\n    import('./RootLoggerService').RootLoggerService\n  >({ id: 'core.rootLogger', scope: 'root' });\n\n  /**\n   * The service reference for the plugin scoped {@link SchedulerService}.\n   *\n   * @public\n   */\n  export const scheduler = createServiceRef<\n    import('./SchedulerService').SchedulerService\n  >({ id: 'core.scheduler' });\n\n  /**\n   * The service reference for the plugin scoped {@link TokenManagerService}.\n   *\n   * @public\n   */\n  export const tokenManager = createServiceRef<\n    import('./TokenManagerService').TokenManagerService\n  >({ id: 'core.tokenManager' });\n\n  /**\n   * The service reference for the plugin scoped {@link UrlReaderService}.\n   *\n   * @public\n   */\n  export const urlReader = createServiceRef<\n    import('./UrlReaderService').UrlReaderService\n  >({ id: 'core.urlReader' });\n\n  /**\n   * The service reference for the plugin scoped {@link IdentityService}.\n   *\n   * @public\n   */\n  export const identity = createServiceRef<\n    import('./IdentityService').IdentityService\n  >({ id: 'core.identity' });\n}\n","/*\n * Copyright 2022 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { BackendFeature, BackendFeatureFactory } from '../types';\nimport {\n  BackendModuleRegistrationPoints,\n  BackendPluginRegistrationPoints,\n  ExtensionPoint,\n  InternalBackendModuleRegistration,\n  InternalBackendPluginRegistration,\n} from './types';\n\n/**\n * The configuration options passed to {@link createExtensionPoint}.\n *\n * @public\n * @see {@link https://backstage.io/docs/backend-system/architecture/extension-points | The architecture of extension points}\n * @see {@link https://backstage.io/docs/backend-system/architecture/naming-patterns | Recommended naming patterns}\n */\nexport interface ExtensionPointConfig {\n  /**\n   * The ID of this extension point.\n   *\n   * @see {@link https://backstage.io/docs/backend-system/architecture/naming-patterns | Recommended naming patterns}\n   */\n  id: string;\n}\n\n/**\n * Creates a new backend extension point.\n *\n * @public\n * @see {@link https://backstage.io/docs/backend-system/architecture/extension-points | The architecture of extension points}\n */\nexport function createExtensionPoint<T>(\n  config: ExtensionPointConfig,\n): ExtensionPoint<T> {\n  return {\n    id: config.id,\n    get T(): T {\n      throw new Error(`tried to read ExtensionPoint.T of ${this}`);\n    },\n    toString() {\n      return `extensionPoint{${config.id}}`;\n    },\n    $$type: '@backstage/ExtensionPoint',\n  };\n}\n\n/**\n * The configuration options passed to {@link createBackendPlugin}.\n *\n * @public\n * @see {@link https://backstage.io/docs/backend-system/architecture/plugins | The architecture of plugins}\n * @see {@link https://backstage.io/docs/backend-system/architecture/naming-patterns | Recommended naming patterns}\n */\nexport interface BackendPluginConfig {\n  /**\n   * The ID of this plugin.\n   *\n   * @see {@link https://backstage.io/docs/backend-system/architecture/naming-patterns | Recommended naming patterns}\n   */\n  pluginId: string;\n  register(reg: BackendPluginRegistrationPoints): void;\n}\n\n/**\n * Creates a new backend plugin.\n *\n * @public\n * @see {@link https://backstage.io/docs/backend-system/architecture/plugins | The architecture of plugins}\n * @see {@link https://backstage.io/docs/backend-system/architecture/naming-patterns | Recommended naming patterns}\n */\nexport function createBackendPlugin(\n  config: BackendPluginConfig,\n): () => BackendFeature {\n  const factory: BackendFeatureFactory = () => {\n    let registrations: InternalBackendPluginRegistration[];\n\n    return {\n      $$type: '@backstage/BackendFeature',\n      version: 'v1',\n      getRegistrations() {\n        if (registrations) {\n          return registrations;\n        }\n        const extensionPoints: InternalBackendPluginRegistration['extensionPoints'] =\n          [];\n        let init: InternalBackendPluginRegistration['init'] | undefined =\n          undefined;\n\n        config.register({\n          registerExtensionPoint(ext, impl) {\n            if (init) {\n              throw new Error(\n                'registerExtensionPoint called after registerInit',\n              );\n            }\n            extensionPoints.push([ext, impl]);\n          },\n          registerInit(regInit) {\n            if (init) {\n              throw new Error('registerInit must only be called once');\n            }\n            init = {\n              deps: regInit.deps,\n              func: regInit.init,\n            };\n          },\n        });\n\n        if (!init) {\n          throw new Error(\n            `registerInit was not called by register in ${config.pluginId}`,\n          );\n        }\n\n        registrations = [\n          {\n            type: 'plugin',\n            pluginId: config.pluginId,\n            extensionPoints,\n            init,\n          },\n        ];\n        return registrations;\n      },\n    };\n  };\n  factory.$$type = '@backstage/BackendFeatureFactory';\n\n  return factory;\n}\n\n/**\n * The configuration options passed to {@link createBackendModule}.\n *\n * @public\n * @see {@link https://backstage.io/docs/backend-system/architecture/modules | The architecture of modules}\n * @see {@link https://backstage.io/docs/backend-system/architecture/naming-patterns | Recommended naming patterns}\n */\nexport interface BackendModuleConfig {\n  /**\n   * Should exactly match the `id` of the plugin that the module extends.\n   *\n   * @see {@link https://backstage.io/docs/backend-system/architecture/naming-patterns | Recommended naming patterns}\n   */\n  pluginId: string;\n\n  /**\n   * The ID of this module, used to identify the module and ensure that it is not installed twice.\n   */\n  moduleId: string;\n  register(reg: BackendModuleRegistrationPoints): void;\n}\n\n/**\n * Creates a new backend module for a given plugin.\n *\n * @public\n * @see {@link https://backstage.io/docs/backend-system/architecture/modules | The architecture of modules}\n * @see {@link https://backstage.io/docs/backend-system/architecture/naming-patterns | Recommended naming patterns}\n */\nexport function createBackendModule(\n  config: BackendModuleConfig,\n): () => BackendFeature {\n  const factory: BackendFeatureFactory = () => {\n    let registrations: InternalBackendModuleRegistration[];\n\n    return {\n      $$type: '@backstage/BackendFeature',\n      version: 'v1',\n      getRegistrations() {\n        if (registrations) {\n          return registrations;\n        }\n        const extensionPoints: InternalBackendPluginRegistration['extensionPoints'] =\n          [];\n        let init: InternalBackendModuleRegistration['init'] | undefined =\n          undefined;\n\n        config.register({\n          registerExtensionPoint(ext, impl) {\n            if (init) {\n              throw new Error(\n                'registerExtensionPoint called after registerInit',\n              );\n            }\n            extensionPoints.push([ext, impl]);\n          },\n          registerInit(regInit) {\n            if (init) {\n              throw new Error('registerInit must only be called once');\n            }\n            init = {\n              deps: regInit.deps,\n              func: regInit.init,\n            };\n          },\n        });\n\n        if (!init) {\n          throw new Error(\n            `registerInit was not called by register in ${config.moduleId} module for ${config.pluginId}`,\n          );\n        }\n\n        registrations = [\n          {\n            type: 'module',\n            pluginId: config.pluginId,\n            moduleId: config.moduleId,\n            extensionPoints,\n            init,\n          },\n        ];\n        return registrations;\n      },\n    };\n  };\n  factory.$$type = '@backstage/BackendFeatureFactory';\n\n  return factory;\n}\n"],"names":["c","coreServices"],"mappings":"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"}