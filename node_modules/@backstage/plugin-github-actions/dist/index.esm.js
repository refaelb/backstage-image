import { createApiRef, createRouteRef, createSubRouteRef, createPlugin, createApiFactory, configApiRef, createRoutableExtension, createComponentExtension, useApi, useRouteRefParams, errorApiRef, useRouteRef } from '@backstage/core-plugin-api';
import { readGithubIntegrationConfigs } from '@backstage/integration';
import { Octokit } from '@octokit/rest';
import { scmAuthApiRef } from '@backstage/integration-react';
import React, { useState, useEffect } from 'react';
import { useEntity, MissingAnnotationEmptyState } from '@backstage/plugin-catalog-react';
import { Link as Link$1, Routes, Route } from 'react-router-dom';
import { makeStyles, Accordion, AccordionSummary, Typography, CircularProgress, Tooltip, Zoom, Modal, Fade, LinearProgress, Box, TableContainer, Paper, Table, TableBody, TableRow, TableCell, AccordionDetails, ListItemText, createStyles, Grid, Button, Select, MenuItem, Chip, ButtonGroup, IconButton, TablePagination, TextField } from '@material-ui/core';
import ExpandMoreIcon from '@material-ui/icons/ExpandMore';
import ExternalLinkIcon from '@material-ui/icons/Launch';
import { DateTime } from 'luxon';
import { StatusPending, StatusOK, StatusError, StatusWarning, StatusAborted, StatusRunning, LogViewer, Breadcrumbs, Link, EmptyState, InfoCard, MarkdownContent, Table as Table$1, StructuredMetadataTable, ErrorPanel } from '@backstage/core-components';
import useAsync from 'react-use/lib/useAsync';
import DescriptionIcon from '@material-ui/icons/Description';
import { ANNOTATION_SOURCE_LOCATION, ANNOTATION_LOCATION } from '@backstage/catalog-model';
import gitUrlParse from 'git-url-parse';
import GitHubIcon from '@material-ui/icons/GitHub';
import RetryIcon from '@material-ui/icons/Replay';
import SyncIcon from '@material-ui/icons/Sync';
import useAsyncRetry from 'react-use/lib/useAsyncRetry';
import { Alert } from '@material-ui/lab';

const githubActionsApiRef = createApiRef({
  id: "plugin.githubactions.service"
});

var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
class GithubActionsClient {
  constructor(options) {
    __publicField(this, "configApi");
    __publicField(this, "scmAuthApi");
    this.configApi = options.configApi;
    this.scmAuthApi = options.scmAuthApi;
  }
  async getOctokit(hostname = "github.com") {
    var _a;
    const { token } = await this.scmAuthApi.getCredentials({
      url: `https://${hostname}/`,
      additionalScope: {
        customScopes: {
          github: ["repo"]
        }
      }
    });
    const configs = readGithubIntegrationConfigs(
      (_a = this.configApi.getOptionalConfigArray("integrations.github")) != null ? _a : []
    );
    const githubIntegrationConfig = configs.find((v) => v.host === hostname);
    const baseUrl = githubIntegrationConfig == null ? void 0 : githubIntegrationConfig.apiBaseUrl;
    return new Octokit({ auth: token, baseUrl });
  }
  async reRunWorkflow(options) {
    const { hostname, owner, repo, runId } = options;
    const octokit = await this.getOctokit(hostname);
    return octokit.actions.reRunWorkflow({
      owner,
      repo,
      run_id: runId
    });
  }
  async listWorkflowRuns(options) {
    const { hostname, owner, repo, pageSize = 100, page = 0, branch } = options;
    const octokit = await this.getOctokit(hostname);
    const workflowRuns = await octokit.actions.listWorkflowRunsForRepo({
      owner,
      repo,
      per_page: pageSize,
      page,
      ...branch ? { branch } : {}
    });
    return workflowRuns.data;
  }
  async getWorkflow(options) {
    const { hostname, owner, repo, id } = options;
    const octokit = await this.getOctokit(hostname);
    const workflow = await octokit.actions.getWorkflow({
      owner,
      repo,
      workflow_id: id
    });
    return workflow.data;
  }
  async getWorkflowRun(options) {
    const { hostname, owner, repo, id } = options;
    const octokit = await this.getOctokit(hostname);
    const run = await octokit.actions.getWorkflowRun({
      owner,
      repo,
      run_id: id
    });
    return run.data;
  }
  async listJobsForWorkflowRun(options) {
    const { hostname, owner, repo, id, pageSize = 100, page = 0 } = options;
    const octokit = await this.getOctokit(hostname);
    const jobs = await octokit.actions.listJobsForWorkflowRun({
      owner,
      repo,
      run_id: id,
      per_page: pageSize,
      page
    });
    return jobs.data;
  }
  async downloadJobLogsForWorkflowRun(options) {
    const { hostname, owner, repo, runId } = options;
    const octokit = await this.getOctokit(hostname);
    const workflow = await octokit.actions.downloadJobLogsForWorkflowRun({
      owner,
      repo,
      job_id: runId
    });
    return workflow.data;
  }
  async listBranches(options) {
    const { hostname, owner, repo, page = 0 } = options;
    const octokit = await this.getOctokit(hostname);
    const response = await octokit.rest.repos.listBranches({
      owner,
      repo,
      per_page: 100,
      page
    });
    return response.data;
  }
  async getDefaultBranch(options) {
    const { hostname, owner, repo } = options;
    const octokit = await this.getOctokit(hostname);
    const response = await octokit.rest.repos.get({
      owner,
      repo
    });
    return response.data.default_branch;
  }
}

var BuildStatus = /* @__PURE__ */ ((BuildStatus2) => {
  BuildStatus2[BuildStatus2["success"] = 0] = "success";
  BuildStatus2[BuildStatus2["failure"] = 1] = "failure";
  BuildStatus2[BuildStatus2["pending"] = 2] = "pending";
  BuildStatus2[BuildStatus2["running"] = 3] = "running";
  return BuildStatus2;
})(BuildStatus || {});

const rootRouteRef = createRouteRef({
  id: "github-actions"
});
const buildRouteRef = createSubRouteRef({
  id: "github-actions/build",
  path: "/:id",
  parent: rootRouteRef
});

const githubActionsPlugin = createPlugin({
  id: "github-actions",
  apis: [
    createApiFactory({
      api: githubActionsApiRef,
      deps: { configApi: configApiRef, scmAuthApi: scmAuthApiRef },
      factory: ({ configApi, scmAuthApi }) => new GithubActionsClient({ configApi, scmAuthApi })
    })
  ],
  routes: {
    entityContent: rootRouteRef
  }
});
const EntityGithubActionsContent = githubActionsPlugin.provide(
  createRoutableExtension({
    name: "EntityGithubActionsContent",
    component: () => Promise.resolve().then(function () { return Router$1; }).then((m) => m.Router),
    mountPoint: rootRouteRef
  })
);
const EntityLatestGithubActionRunCard = githubActionsPlugin.provide(
  createComponentExtension({
    name: "EntityLatestGithubActionRunCard",
    component: {
      lazy: () => import('./esm/index-36d0a162.esm.js').then((m) => m.LatestWorkflowRunCard)
    }
  })
);
const EntityLatestGithubActionsForBranchCard = githubActionsPlugin.provide(
  createComponentExtension({
    name: "EntityLatestGithubActionsForBranchCard",
    component: {
      lazy: () => import('./esm/index-36d0a162.esm.js').then(
        (m) => m.LatestWorkflowsForBranchCard
      )
    }
  })
);
const EntityRecentGithubActionsRunsCard = githubActionsPlugin.provide(
  createComponentExtension({
    name: "EntityRecentGithubActionsRunsCard",
    component: {
      lazy: () => import('./esm/index-36d0a162.esm.js').then((m) => m.RecentWorkflowRunsCard)
    }
  })
);

const GITHUB_ACTIONS_ANNOTATION = "github.com/project-slug";
const getProjectNameFromEntity = (entity) => {
  var _a, _b;
  return (_b = (_a = entity == null ? void 0 : entity.metadata.annotations) == null ? void 0 : _a[GITHUB_ACTIONS_ANNOTATION]) != null ? _b : "";
};

const WorkflowRunStatus = (props) => {
  return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(WorkflowIcon, { ...props }), getStatusDescription(props));
};
function WorkflowIcon({
  status,
  conclusion
}) {
  if (status === void 0)
    return null;
  switch (status.toLocaleLowerCase("en-US")) {
    case "queued":
      return /* @__PURE__ */ React.createElement(StatusPending, null);
    case "in_progress":
      return /* @__PURE__ */ React.createElement(StatusRunning, null);
    case "completed":
      switch (conclusion == null ? void 0 : conclusion.toLocaleLowerCase("en-US")) {
        case "skipped":
          return /* @__PURE__ */ React.createElement(StatusAborted, null);
        case "timed_out":
          return /* @__PURE__ */ React.createElement(StatusWarning, null);
        case "failure":
          return /* @__PURE__ */ React.createElement(StatusError, null);
        default:
          return /* @__PURE__ */ React.createElement(StatusOK, null);
      }
    default:
      return /* @__PURE__ */ React.createElement(StatusPending, null);
  }
}
function getStatusDescription({
  status,
  conclusion
}) {
  if (status === void 0)
    return "";
  switch (status.toLocaleLowerCase("en-US")) {
    case "queued":
      return "Queued";
    case "in_progress":
      return "In progress";
    case "completed":
      switch (conclusion == null ? void 0 : conclusion.toLocaleLowerCase("en-US")) {
        case "skipped":
          return "Aborted";
        case "timed_out":
          return "Timed out";
        case "failure":
          return "Error";
        default:
          return "Completed";
      }
    default:
      return "Pending";
  }
}

const useWorkflowRunJobs = ({
  hostname,
  owner,
  repo
}) => {
  const api = useApi(githubActionsApiRef);
  const { id } = useRouteRefParams(buildRouteRef);
  return useAsync(async () => {
    if (!repo || !owner) {
      throw new Error("No repo/owner provided");
    }
    const jobs = await api.listJobsForWorkflowRun({
      hostname,
      owner,
      repo,
      id: parseInt(id, 10)
    });
    return {
      total_count: jobs.total_count,
      jobs: jobs.jobs.map((job) => {
        var _a, _b, _c, _d;
        return {
          html_url: (_a = job.html_url) != null ? _a : void 0,
          status: job.status,
          conclusion: (_b = job.conclusion) != null ? _b : void 0,
          started_at: job.started_at,
          completed_at: (_c = job.completed_at) != null ? _c : void 0,
          id: job.id,
          name: job.name,
          steps: (_d = job.steps) == null ? void 0 : _d.map((step) => {
            var _a2, _b2, _c2;
            return {
              name: step.name,
              status: step.status,
              conclusion: (_a2 = step.conclusion) != null ? _a2 : void 0,
              number: step.number,
              started_at: (_b2 = step.started_at) != null ? _b2 : void 0,
              completed_at: (_c2 = step.completed_at) != null ? _c2 : void 0
            };
          })
        };
      })
    };
  }, [repo, owner, id]);
};

const useWorkflowRunsDetails = ({
  hostname,
  owner,
  repo
}) => {
  const api = useApi(githubActionsApiRef);
  const { id } = useRouteRefParams(buildRouteRef);
  const details = useAsync(async () => {
    return repo && owner ? api.getWorkflowRun({
      hostname,
      owner,
      repo,
      id: parseInt(id, 10)
    }) : Promise.reject(new Error("No repo/owner provided"));
  }, [repo, owner, id]);
  return details;
};

const useDownloadWorkflowRunLogs = ({
  hostname,
  owner,
  repo,
  id
}) => {
  const api = useApi(githubActionsApiRef);
  const details = useAsync(async () => {
    return repo && owner ? api.downloadJobLogsForWorkflowRun({
      hostname,
      owner,
      repo,
      runId: id
    }) : Promise.reject("No repo/owner provided");
  }, [repo, owner, id]);
  return details;
};

const getHostnameFromEntity = (entity) => {
  var _a, _b, _c;
  const location = (_c = (_a = entity == null ? void 0 : entity.metadata.annotations) == null ? void 0 : _a[ANNOTATION_SOURCE_LOCATION]) != null ? _c : (_b = entity == null ? void 0 : entity.metadata.annotations) == null ? void 0 : _b[ANNOTATION_LOCATION];
  return (location == null ? void 0 : location.startsWith("url:")) ? gitUrlParse(location.slice(4)).resource : void 0;
};

const useStyles$3 = makeStyles((theme) => ({
  button: {
    order: -1,
    marginRight: 0,
    marginLeft: "-20px"
  },
  modal: {
    display: "flex",
    alignItems: "center",
    width: "85%",
    height: "85%",
    justifyContent: "center",
    margin: "auto"
  },
  normalLogContainer: {
    height: "75vh",
    width: "100%"
  },
  modalLogContainer: {
    height: "100%",
    width: "100%"
  },
  log: {
    background: theme.palette.background.default
  }
}));
const WorkflowRunLogs = ({
  entity,
  runId,
  inProgress
}) => {
  const classes = useStyles$3();
  const projectName = getProjectNameFromEntity(entity);
  const hostname = getHostnameFromEntity(entity);
  const [owner, repo] = projectName && projectName.split("/") || [];
  const jobLogs = useDownloadWorkflowRunLogs({
    hostname,
    owner,
    repo,
    id: runId
  });
  const logText = jobLogs.value ? String(jobLogs.value) : void 0;
  const [open, setOpen] = React.useState(false);
  const handleOpen = () => {
    setOpen(true);
  };
  const handleClose = () => {
    setOpen(false);
  };
  return /* @__PURE__ */ React.createElement(Accordion, { TransitionProps: { unmountOnExit: true }, disabled: inProgress }, /* @__PURE__ */ React.createElement(
    AccordionSummary,
    {
      expandIcon: /* @__PURE__ */ React.createElement(ExpandMoreIcon, null),
      IconButtonProps: {
        className: classes.button
      }
    },
    /* @__PURE__ */ React.createElement(Typography, { variant: "button" }, jobLogs.loading ? /* @__PURE__ */ React.createElement(CircularProgress, null) : "Job Log"),
    /* @__PURE__ */ React.createElement(Tooltip, { title: "Open Log", TransitionComponent: Zoom, arrow: true }, /* @__PURE__ */ React.createElement(
      DescriptionIcon,
      {
        onClick: (event) => {
          event.stopPropagation();
          handleOpen();
        },
        style: { marginLeft: "auto" }
      }
    )),
    /* @__PURE__ */ React.createElement(
      Modal,
      {
        className: classes.modal,
        onClick: (event) => event.stopPropagation(),
        open,
        onClose: handleClose
      },
      /* @__PURE__ */ React.createElement(Fade, { in: open }, /* @__PURE__ */ React.createElement("div", { className: classes.modalLogContainer }, /* @__PURE__ */ React.createElement(
        LogViewer,
        {
          text: logText != null ? logText : "No Values Found",
          classes: { root: classes.log }
        }
      )))
    )
  ), logText && /* @__PURE__ */ React.createElement("div", { className: classes.normalLogContainer }, /* @__PURE__ */ React.createElement(LogViewer, { text: logText, classes: { root: classes.log } })));
};

const useStyles$2 = makeStyles((theme) => ({
  root: {
    maxWidth: 720,
    margin: theme.spacing(2)
  },
  title: {
    padding: theme.spacing(1, 0, 2, 0)
  },
  table: {
    padding: theme.spacing(1)
  },
  accordionDetails: {
    padding: 0
  },
  button: {
    order: -1,
    marginRight: 0,
    marginLeft: "-20px"
  },
  externalLinkIcon: {
    fontSize: "inherit",
    verticalAlign: "bottom"
  }
}));
const getElapsedTime = (start, end) => {
  if (!start || !end) {
    return "";
  }
  const startDate = DateTime.fromISO(start);
  const endDate = end ? DateTime.fromISO(end) : DateTime.now();
  const diff = endDate.diff(startDate);
  const timeElapsed = diff.toFormat(`m 'minutes' s 'seconds'`);
  return timeElapsed;
};
const StepView = ({ step }) => {
  var _a;
  return /* @__PURE__ */ React.createElement(TableRow, null, /* @__PURE__ */ React.createElement(TableCell, null, /* @__PURE__ */ React.createElement(
    ListItemText,
    {
      primary: step.name,
      secondary: getElapsedTime(step.started_at, step.completed_at)
    }
  )), /* @__PURE__ */ React.createElement(TableCell, null, /* @__PURE__ */ React.createElement(
    WorkflowRunStatus,
    {
      status: step.status.toLocaleUpperCase("en-US"),
      conclusion: (_a = step.conclusion) == null ? void 0 : _a.toLocaleUpperCase("en-US")
    }
  )));
};
const JobListItem = ({
  job,
  className,
  entity
}) => {
  var _a;
  const classes = useStyles$2();
  return /* @__PURE__ */ React.createElement(Accordion, { TransitionProps: { unmountOnExit: true }, className }, /* @__PURE__ */ React.createElement(
    AccordionSummary,
    {
      expandIcon: /* @__PURE__ */ React.createElement(ExpandMoreIcon, null),
      IconButtonProps: {
        className: classes.button
      }
    },
    /* @__PURE__ */ React.createElement(Typography, { variant: "button" }, job.name, " (", getElapsedTime(job.started_at, job.completed_at), ")")
  ), /* @__PURE__ */ React.createElement(AccordionDetails, { className: classes.accordionDetails }, /* @__PURE__ */ React.createElement(TableContainer, null, /* @__PURE__ */ React.createElement(Table, null, (_a = job.steps) == null ? void 0 : _a.map((step) => /* @__PURE__ */ React.createElement(StepView, { key: step.number, step }))))), job.status === "queued" || job.status === "in_progress" ? /* @__PURE__ */ React.createElement(WorkflowRunLogs, { runId: job.id, inProgress: true, entity }) : /* @__PURE__ */ React.createElement(WorkflowRunLogs, { runId: job.id, inProgress: false, entity }));
};
const JobsList = ({ jobs, entity }) => {
  const classes = useStyles$2();
  return /* @__PURE__ */ React.createElement(Box, null, jobs && jobs.total_count > 0 && jobs.jobs.map((job) => /* @__PURE__ */ React.createElement(
    JobListItem,
    {
      key: job.id,
      job,
      className: job.status !== "success" ? classes.failed : classes.success,
      entity
    }
  )));
};
const WorkflowRunDetails = ({ entity }) => {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o;
  const projectName = getProjectNameFromEntity(entity);
  const hostname = getHostnameFromEntity(entity);
  const [owner, repo] = projectName && projectName.split("/") || [];
  const details = useWorkflowRunsDetails({ hostname, owner, repo });
  const jobs = useWorkflowRunJobs({ hostname, owner, repo });
  const classes = useStyles$2();
  if (details.error && details.error.message) {
    return /* @__PURE__ */ React.createElement(Typography, { variant: "h6", color: "error" }, "Failed to load build, ", details.error.message);
  } else if (details.loading) {
    return /* @__PURE__ */ React.createElement(LinearProgress, null);
  }
  return /* @__PURE__ */ React.createElement("div", { className: classes.root }, /* @__PURE__ */ React.createElement(Box, { mb: 3 }, /* @__PURE__ */ React.createElement(Breadcrumbs, { "aria-label": "breadcrumb" }, /* @__PURE__ */ React.createElement(Link, { to: ".." }, "Workflow runs"), /* @__PURE__ */ React.createElement(Typography, null, "Workflow run details"))), /* @__PURE__ */ React.createElement(TableContainer, { component: Paper, className: classes.table }, /* @__PURE__ */ React.createElement(Table, null, /* @__PURE__ */ React.createElement(TableBody, null, /* @__PURE__ */ React.createElement(TableRow, null, /* @__PURE__ */ React.createElement(TableCell, null, /* @__PURE__ */ React.createElement(Typography, { noWrap: true }, "Branch")), /* @__PURE__ */ React.createElement(TableCell, null, (_a = details.value) == null ? void 0 : _a.head_branch)), /* @__PURE__ */ React.createElement(TableRow, null, /* @__PURE__ */ React.createElement(TableCell, null, /* @__PURE__ */ React.createElement(Typography, { noWrap: true }, "Message")), /* @__PURE__ */ React.createElement(TableCell, null, (_c = (_b = details.value) == null ? void 0 : _b.head_commit) == null ? void 0 : _c.message)), /* @__PURE__ */ React.createElement(TableRow, null, /* @__PURE__ */ React.createElement(TableCell, null, /* @__PURE__ */ React.createElement(Typography, { noWrap: true }, "Commit ID")), /* @__PURE__ */ React.createElement(TableCell, null, (_e = (_d = details.value) == null ? void 0 : _d.head_commit) == null ? void 0 : _e.id)), /* @__PURE__ */ React.createElement(TableRow, null, /* @__PURE__ */ React.createElement(TableCell, null, /* @__PURE__ */ React.createElement(Typography, { noWrap: true }, "Workflow")), /* @__PURE__ */ React.createElement(TableCell, null, (_f = details.value) == null ? void 0 : _f.name)), /* @__PURE__ */ React.createElement(TableRow, null, /* @__PURE__ */ React.createElement(TableCell, null, /* @__PURE__ */ React.createElement(Typography, { noWrap: true }, "Status")), /* @__PURE__ */ React.createElement(TableCell, null, /* @__PURE__ */ React.createElement(
    WorkflowRunStatus,
    {
      status: ((_g = details.value) == null ? void 0 : _g.status) || void 0,
      conclusion: ((_h = details.value) == null ? void 0 : _h.conclusion) || void 0
    }
  ))), /* @__PURE__ */ React.createElement(TableRow, null, /* @__PURE__ */ React.createElement(TableCell, null, /* @__PURE__ */ React.createElement(Typography, { noWrap: true }, "Author")), /* @__PURE__ */ React.createElement(TableCell, null, `${(_k = (_j = (_i = details.value) == null ? void 0 : _i.head_commit) == null ? void 0 : _j.author) == null ? void 0 : _k.name} (${(_n = (_m = (_l = details.value) == null ? void 0 : _l.head_commit) == null ? void 0 : _m.author) == null ? void 0 : _n.email})`)), /* @__PURE__ */ React.createElement(TableRow, null, /* @__PURE__ */ React.createElement(TableCell, null, /* @__PURE__ */ React.createElement(Typography, { noWrap: true }, "Links")), /* @__PURE__ */ React.createElement(TableCell, null, ((_o = details.value) == null ? void 0 : _o.html_url) && /* @__PURE__ */ React.createElement(Link, { to: details.value.html_url }, "Workflow runs on GitHub", " ", /* @__PURE__ */ React.createElement(ExternalLinkIcon, { className: classes.externalLinkIcon })))), /* @__PURE__ */ React.createElement(TableRow, null, /* @__PURE__ */ React.createElement(TableCell, { colSpan: 2 }, /* @__PURE__ */ React.createElement(Typography, { noWrap: true }, "Jobs"), jobs.loading ? /* @__PURE__ */ React.createElement(CircularProgress, null) : /* @__PURE__ */ React.createElement(JobsList, { jobs: jobs.value, entity })))))));
};

function useWorkflowRuns({
  hostname,
  owner,
  repo,
  branch,
  initialPageSize = 6
}) {
  const api = useApi(githubActionsApiRef);
  const errorApi = useApi(errorApiRef);
  const [total, setTotal] = useState(0);
  const [page, setPage] = useState(0);
  const [pageSize, setPageSize] = useState(initialPageSize);
  const [branches, setBranches] = useState([]);
  const [defaultBranch, setDefaultBranch] = useState("");
  const {
    loading,
    value: runs,
    retry,
    error
  } = useAsyncRetry(async () => {
    const fetchedDefaultBranch = await api.getDefaultBranch({
      hostname,
      owner,
      repo
    });
    setDefaultBranch(fetchedDefaultBranch);
    let selectedBranch = branch;
    if (branch === "default") {
      selectedBranch = fetchedDefaultBranch;
    }
    const fetchBranches = async () => {
      let next = true;
      let iteratePage = 0;
      const branchSet2 = [];
      while (next) {
        const branchesData = await api.listBranches({
          hostname,
          owner,
          repo,
          page: iteratePage
        });
        if (branchesData.length === 0) {
          next = false;
        }
        iteratePage++;
        branchSet2.push(...branchesData);
      }
      return branchSet2;
    };
    const branchSet = await fetchBranches();
    setBranches(branchSet);
    const workflowRunsData = await api.listWorkflowRuns({
      hostname,
      owner,
      repo,
      pageSize,
      page: page + 1,
      branch: selectedBranch
    });
    setTotal(workflowRunsData.total_count);
    return workflowRunsData.workflow_runs.map((run) => {
      var _a, _b, _c, _d, _e, _f, _g, _h, _i;
      return {
        workflowName: (_a = run.name) != null ? _a : void 0,
        message: (_b = run.head_commit) == null ? void 0 : _b.message,
        id: `${run.id}`,
        onReRunClick: async () => {
          try {
            await api.reRunWorkflow({
              hostname,
              owner,
              repo,
              runId: run.id
            });
          } catch (e) {
            errorApi.post(
              new Error(`Failed to rerun the workflow: ${e.message}`)
            );
          }
        },
        source: {
          branchName: (_c = run.head_branch) != null ? _c : void 0,
          commit: {
            hash: (_d = run.head_commit) == null ? void 0 : _d.id,
            url: (_g = (_e = run.head_repository) == null ? void 0 : _e.branches_url) == null ? void 0 : _g.replace(
              "{/branch}",
              (_f = run.head_branch) != null ? _f : ""
            )
          }
        },
        status: (_h = run.status) != null ? _h : void 0,
        conclusion: (_i = run.conclusion) != null ? _i : void 0,
        url: run.url,
        githubUrl: run.html_url
      };
    });
  }, [page, pageSize, repo, owner]);
  return [
    {
      page,
      pageSize,
      loading,
      runs,
      branches,
      defaultBranch,
      projectName: `${owner}/${repo}`,
      total,
      error
    },
    {
      runs,
      setPage,
      setPageSize,
      retry
    }
  ];
}

const useStyles$1 = makeStyles(
  (theme) => createStyles({
    card: {
      border: `1px solid ${theme.palette.divider}`,
      boxShadow: theme.shadows[2],
      borderRadius: "4px",
      overflow: "visible",
      position: "relative",
      margin: theme.spacing(4, 1, 1),
      flex: "1",
      minWidth: "0px"
    },
    externalLinkIcon: {
      fontSize: "inherit",
      verticalAlign: "middle"
    },
    bottomline: {
      display: "flex",
      justifyContent: "space-between",
      alignItems: "center",
      marginTop: "-5px"
    },
    pagination: {
      width: "100%"
    }
  })
);
const statusColors = {
  skipped: "warning",
  canceled: "info",
  timed_out: "error",
  failure: "error",
  success: "success"
};
const matchesSearchTerm = (run, searchTerm) => {
  var _a, _b, _c, _d;
  const lowerCaseSearchTerm = searchTerm.toLocaleLowerCase();
  return ((_a = run.workflowName) == null ? void 0 : _a.toLocaleLowerCase().includes(lowerCaseSearchTerm)) || ((_b = run.source.branchName) == null ? void 0 : _b.toLocaleLowerCase().includes(lowerCaseSearchTerm)) || ((_c = run.status) == null ? void 0 : _c.toLocaleLowerCase().includes(lowerCaseSearchTerm)) || ((_d = run.id) == null ? void 0 : _d.toLocaleLowerCase().includes(lowerCaseSearchTerm));
};
const WorkflowRunsCardView = ({
  runs,
  searchTerm,
  loading,
  onChangePageSize,
  onChangePage,
  page,
  total,
  pageSize
}) => {
  const classes = useStyles$1();
  const routeLink = useRouteRef(buildRouteRef);
  const filteredRuns = runs == null ? void 0 : runs.filter((run) => matchesSearchTerm(run, searchTerm));
  return /* @__PURE__ */ React.createElement(Grid, { container: true, spacing: 3 }, filteredRuns && (runs == null ? void 0 : runs.length) !== 0 ? filteredRuns.map((run) => {
    var _a, _b;
    return /* @__PURE__ */ React.createElement(Grid, { key: run.id, item: true, container: true, xs: 12, sm: 4, md: 4, xl: 4 }, /* @__PURE__ */ React.createElement(Box, { className: classes.card }, /* @__PURE__ */ React.createElement(
      Box,
      {
        display: "flex",
        flexDirection: "column",
        m: 3,
        alignItems: "center",
        justifyContent: "center"
      },
      /* @__PURE__ */ React.createElement(Box, { pt: 2, sx: { width: "100%" }, textAlign: "center" }, /* @__PURE__ */ React.createElement(
        Tooltip,
        {
          title: (_a = run.status) != null ? _a : "No Status",
          placement: "top-start"
        },
        /* @__PURE__ */ React.createElement(
          Alert,
          {
            variant: "outlined",
            severity: statusColors[run.conclusion],
            style: { alignItems: "center" }
          },
          /* @__PURE__ */ React.createElement(Typography, { variant: "h6" }, /* @__PURE__ */ React.createElement(Link, { to: routeLink({ id: run.id }) }, /* @__PURE__ */ React.createElement(Typography, { color: "primary", variant: "h6" }, run.workflowName)))
        )
      ), /* @__PURE__ */ React.createElement(Tooltip, { title: (_b = run.message) != null ? _b : "No run message" }, /* @__PURE__ */ React.createElement(
        Typography,
        {
          variant: "body2",
          component: "span",
          style: { fontSize: "smaller" }
        },
        /* @__PURE__ */ React.createElement(
          MarkdownContent,
          {
            content: `Commit ID : ${run.source.commit.hash}`
          }
        )
      )), run.source.branchName && /* @__PURE__ */ React.createElement(
        MarkdownContent,
        {
          content: `Branch : ${run.source.branchName}`
        }
      ), /* @__PURE__ */ React.createElement(
        Chip,
        {
          key: run.id,
          size: "small",
          label: `Workflow ID : ${run.id}`
        }
      ), /* @__PURE__ */ React.createElement(
        Chip,
        {
          size: "small",
          label: /* @__PURE__ */ React.createElement(Box, { display: "flex", alignItems: "center" }, /* @__PURE__ */ React.createElement(
            WorkflowRunStatus,
            {
              status: run.status,
              conclusion: run.conclusion
            }
          ))
        }
      ), /* @__PURE__ */ React.createElement("div", { className: classes.bottomline }, run.githubUrl && /* @__PURE__ */ React.createElement(Link, { to: run.githubUrl }, "Workflow runs on GitHub", " ", /* @__PURE__ */ React.createElement(
        ExternalLinkIcon,
        {
          className: classes.externalLinkIcon
        }
      )), /* @__PURE__ */ React.createElement(ButtonGroup, null, /* @__PURE__ */ React.createElement(Tooltip, { title: "Rerun workflow" }, /* @__PURE__ */ React.createElement(
        IconButton,
        {
          onClick: run.onReRunClick,
          style: { fontSize: "12px" }
        },
        /* @__PURE__ */ React.createElement(RetryIcon, null)
      )))))
    )));
  }) : /* @__PURE__ */ React.createElement(Box, { p: 2 }, loading ? /* @__PURE__ */ React.createElement(CircularProgress, null) : "No matching runs found."), /* @__PURE__ */ React.createElement("div", { className: classes.pagination }, /* @__PURE__ */ React.createElement(
    TablePagination,
    {
      component: "div",
      count: total,
      page,
      rowsPerPage: pageSize,
      onPageChange: (_, newPage) => onChangePage(newPage),
      onRowsPerPageChange: (event) => onChangePageSize(parseInt(event.target.value, 6)),
      labelRowsPerPage: "Workflows per page",
      rowsPerPageOptions: [6, 12, 18, { label: "All", value: -1 }]
    }
  )));
};
const WorkflowRunsCardSearch = ({
  searchTerm,
  handleSearch,
  retry
}) => {
  return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(Box, { flexGrow: 1 }), /* @__PURE__ */ React.createElement(
    TextField,
    {
      type: "search",
      label: "Search",
      value: searchTerm,
      onChange: handleSearch,
      "data-testid": "search-control",
      style: { marginRight: "20px" }
    }
  ), /* @__PURE__ */ React.createElement(ButtonGroup, null, /* @__PURE__ */ React.createElement(Tooltip, { title: "Reload workflow runs" }, /* @__PURE__ */ React.createElement(IconButton, { onClick: retry }, /* @__PURE__ */ React.createElement(SyncIcon, null)))));
};
const WorkflowRunsCard = ({ entity }) => {
  const projectName = getProjectNameFromEntity(entity);
  const hostname = getHostnameFromEntity(entity);
  const [owner, repo] = (projectName != null ? projectName : "/").split("/");
  const [branch, setBranch] = useState("default");
  const [runs, setRuns] = useState([]);
  const [searchTerm, setSearchTerm] = useState("");
  const handleSearch = (event) => {
    setSearchTerm(event.target.value);
  };
  const [
    { runs: runsData, branches, defaultBranch, ...cardProps },
    { retry, setPage, setPageSize }
  ] = useWorkflowRuns({
    hostname,
    owner,
    repo,
    branch: branch === "all" ? void 0 : branch
  });
  const githubHost = hostname || "github.com";
  const hasNoRuns = !cardProps.loading && !runsData;
  const handleMenuChange = (event) => {
    const selectedValue = event.target.value;
    setBranch(selectedValue);
    setPage(0);
    retry();
  };
  useEffect(() => {
    setRuns(runsData);
  }, [runsData, branch]);
  useEffect(() => {
    setBranch(defaultBranch);
  }, [defaultBranch]);
  return /* @__PURE__ */ React.createElement(Grid, { item: true }, hasNoRuns ? /* @__PURE__ */ React.createElement(
    EmptyState,
    {
      missing: "data",
      title: "No Workflow Data",
      description: "This component has GitHub Actions enabled, but no data was found. Have you created any Workflows? Click the button below to create a new Workflow.",
      action: /* @__PURE__ */ React.createElement(
        Button,
        {
          variant: "contained",
          color: "primary",
          href: `https://${githubHost}/${projectName}/actions/new`
        },
        "Create new Workflow"
      )
    }
  ) : /* @__PURE__ */ React.createElement(
    InfoCard,
    {
      title: /* @__PURE__ */ React.createElement(Box, { display: "flex", alignItems: "center" }, /* @__PURE__ */ React.createElement(GitHubIcon, null), /* @__PURE__ */ React.createElement(Box, { mr: 1 }), /* @__PURE__ */ React.createElement(Typography, { variant: "h6" }, projectName), /* @__PURE__ */ React.createElement(
        Select,
        {
          value: branch,
          key: branch,
          label: "Branch",
          onChange: handleMenuChange,
          "data-testid": "menu-control",
          style: {
            marginLeft: "30px",
            marginRight: "20px",
            width: "230px"
          }
        },
        branches.map((branchItem) => /* @__PURE__ */ React.createElement(MenuItem, { key: branchItem.name, value: branchItem.name }, branchItem.name === defaultBranch ? /* @__PURE__ */ React.createElement(Typography, { variant: "body2", component: "span" }, branchItem.name, " ", /* @__PURE__ */ React.createElement(
          Typography,
          {
            variant: "body2",
            component: "span",
            style: { color: "lightgray", fontSize: "x-small" }
          },
          "(default)"
        )) : branchItem.name)),
        /* @__PURE__ */ React.createElement(
          MenuItem,
          {
            value: "all",
            key: "all",
            style: { color: "lightGrey", fontSize: "small" }
          },
          "select all branches"
        )
      ), /* @__PURE__ */ React.createElement(
        WorkflowRunsCardSearch,
        {
          searchTerm,
          handleSearch,
          retry
        }
      ))
    },
    /* @__PURE__ */ React.createElement(
      WorkflowRunsCardView,
      {
        runs,
        loading: cardProps.loading,
        onChangePageSize: setPageSize,
        onChangePage: setPage,
        page: cardProps.page,
        total: cardProps.total,
        pageSize: cardProps.pageSize,
        searchTerm,
        projectName
      }
    )
  ));
};

const generatedColumns = [
  {
    title: "ID",
    field: "id",
    type: "numeric",
    width: "150px"
  },
  {
    title: "Message",
    field: "message",
    highlight: true,
    render: (row) => {
      const LinkWrapper = () => {
        const routeLink = useRouteRef(buildRouteRef);
        return /* @__PURE__ */ React.createElement(Link, { component: Link$1, to: routeLink({ id: row.id }) }, row.message);
      };
      return /* @__PURE__ */ React.createElement(LinkWrapper, null);
    }
  },
  {
    title: "Source",
    render: (row) => {
      var _a, _b;
      return /* @__PURE__ */ React.createElement(Typography, { variant: "body2", noWrap: true }, /* @__PURE__ */ React.createElement(Typography, { paragraph: true, variant: "body2" }, (_a = row.source) == null ? void 0 : _a.branchName), /* @__PURE__ */ React.createElement(Typography, { paragraph: true, variant: "body2" }, (_b = row.source) == null ? void 0 : _b.commit.hash));
    }
  },
  {
    title: "Workflow",
    field: "workflowName"
  },
  {
    title: "Status",
    customSort: (d1, d2) => {
      return getStatusDescription(d1).localeCompare(getStatusDescription(d2));
    },
    render: (row) => /* @__PURE__ */ React.createElement(Box, { display: "flex", alignItems: "center" }, /* @__PURE__ */ React.createElement(WorkflowRunStatus, { status: row.status, conclusion: row.conclusion }))
  },
  {
    title: "Actions",
    render: (row) => /* @__PURE__ */ React.createElement(Tooltip, { title: "Rerun workflow" }, /* @__PURE__ */ React.createElement(IconButton, { onClick: row.onReRunClick }, /* @__PURE__ */ React.createElement(RetryIcon, null))),
    width: "10%"
  }
];
const WorkflowRunsTableView = ({
  projectName,
  loading,
  pageSize,
  page,
  retry,
  runs,
  onChangePage,
  onChangePageSize,
  total
}) => {
  return /* @__PURE__ */ React.createElement(
    Table$1,
    {
      isLoading: loading,
      options: { paging: true, pageSize, padding: "dense" },
      totalCount: total,
      page,
      actions: [
        {
          icon: () => /* @__PURE__ */ React.createElement(SyncIcon, null),
          tooltip: "Reload workflow runs",
          isFreeAction: true,
          onClick: () => retry()
        }
      ],
      data: runs != null ? runs : [],
      onPageChange: onChangePage,
      onRowsPerPageChange: onChangePageSize,
      style: { width: "100%" },
      title: /* @__PURE__ */ React.createElement(Box, { display: "flex", alignItems: "center" }, /* @__PURE__ */ React.createElement(GitHubIcon, null), /* @__PURE__ */ React.createElement(Box, { mr: 1 }), /* @__PURE__ */ React.createElement(Typography, { variant: "h6" }, projectName)),
      columns: generatedColumns
    }
  );
};
const WorkflowRunsTable = ({
  entity,
  branch
}) => {
  const projectName = getProjectNameFromEntity(entity);
  const hostname = getHostnameFromEntity(entity);
  const [owner, repo] = (projectName != null ? projectName : "/").split("/");
  const [{ runs, ...tableProps }, { retry, setPage, setPageSize }] = useWorkflowRuns({
    hostname,
    owner,
    repo,
    branch
  });
  const githubHost = hostname || "github.com";
  const hasNoRuns = !tableProps.loading && !runs;
  return hasNoRuns ? /* @__PURE__ */ React.createElement(
    EmptyState,
    {
      missing: "data",
      title: "No Workflow Data",
      description: "This component has GitHub Actions enabled, but no data was found. Have you created any Workflows? Click the button below to create a new Workflow.",
      action: /* @__PURE__ */ React.createElement(
        Button,
        {
          variant: "contained",
          color: "primary",
          href: `https://${githubHost}/${projectName}/actions/new`
        },
        "Create new Workflow"
      )
    }
  ) : /* @__PURE__ */ React.createElement(
    WorkflowRunsTableView,
    {
      ...tableProps,
      runs,
      loading: tableProps.loading,
      retry,
      onChangePageSize: setPageSize,
      onChangePage: setPage
    }
  );
};

const isGithubActionsAvailable = (entity) => {
  var _a;
  return Boolean((_a = entity.metadata.annotations) == null ? void 0 : _a[GITHUB_ACTIONS_ANNOTATION]);
};
const Router = (props) => {
  const { view = "table" } = props;
  const { entity } = useEntity();
  if (!isGithubActionsAvailable(entity)) {
    return /* @__PURE__ */ React.createElement(MissingAnnotationEmptyState, { annotation: GITHUB_ACTIONS_ANNOTATION });
  }
  const workflowRunsComponent = view === "cards" ? /* @__PURE__ */ React.createElement(WorkflowRunsCard, { entity }) : /* @__PURE__ */ React.createElement(WorkflowRunsTable, { entity });
  return /* @__PURE__ */ React.createElement(Routes, null, /* @__PURE__ */ React.createElement(Route, { path: "/", element: workflowRunsComponent }), /* @__PURE__ */ React.createElement(
    Route,
    {
      path: `${buildRouteRef.path}`,
      element: /* @__PURE__ */ React.createElement(WorkflowRunDetails, { entity })
    }
  ));
};

var Router$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  isGithubActionsAvailable: isGithubActionsAvailable,
  Router: Router
});

const useStyles = makeStyles({
  externalLinkIcon: {
    fontSize: "inherit",
    verticalAlign: "bottom"
  }
});
const WidgetContent = (props) => {
  var _a;
  const { error, loading, lastRun, branch } = props;
  const classes = useStyles();
  if (error)
    return /* @__PURE__ */ React.createElement(Typography, null, "Couldn't fetch latest ", branch, " run");
  if (loading)
    return /* @__PURE__ */ React.createElement(LinearProgress, null);
  return /* @__PURE__ */ React.createElement(
    StructuredMetadataTable,
    {
      metadata: {
        status: /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(
          WorkflowRunStatus,
          {
            status: lastRun.status,
            conclusion: lastRun.conclusion
          }
        )),
        message: lastRun.message,
        url: /* @__PURE__ */ React.createElement(Link, { to: (_a = lastRun.githubUrl) != null ? _a : "" }, "See more on GitHub", " ", /* @__PURE__ */ React.createElement(ExternalLinkIcon, { className: classes.externalLinkIcon }))
      }
    }
  );
};
const LatestWorkflowRunCard = (props) => {
  var _a, _b, _c;
  const { branch = "master", variant } = props;
  const { entity } = useEntity();
  const errorApi = useApi(errorApiRef);
  const hostname = getHostnameFromEntity(entity);
  const [owner, repo] = ((_b = (_a = entity == null ? void 0 : entity.metadata.annotations) == null ? void 0 : _a[GITHUB_ACTIONS_ANNOTATION]) != null ? _b : "/").split("/");
  const [{ runs, loading, error }] = useWorkflowRuns({
    hostname,
    owner,
    repo,
    branch
  });
  const lastRun = (_c = runs == null ? void 0 : runs[0]) != null ? _c : {};
  useEffect(() => {
    if (error) {
      errorApi.post(error);
    }
  }, [error, errorApi]);
  return /* @__PURE__ */ React.createElement(InfoCard, { title: `Last ${branch} build`, variant }, /* @__PURE__ */ React.createElement(
    WidgetContent,
    {
      error,
      loading,
      branch,
      lastRun
    }
  ));
};
const LatestWorkflowsForBranchCard = (props) => {
  const { branch = "master", variant } = props;
  const { entity } = useEntity();
  return /* @__PURE__ */ React.createElement(InfoCard, { title: `Last ${branch} build`, variant }, /* @__PURE__ */ React.createElement(WorkflowRunsTable, { branch, entity }));
};

const firstLine = (message) => message.split("\n")[0];
const RecentWorkflowRunsCard = (props) => {
  var _a, _b;
  const { branch, dense = false, limit = 5, variant } = props;
  const { entity } = useEntity();
  const errorApi = useApi(errorApiRef);
  const hostname = getHostnameFromEntity(entity);
  const [owner, repo] = ((_b = (_a = entity == null ? void 0 : entity.metadata.annotations) == null ? void 0 : _a[GITHUB_ACTIONS_ANNOTATION]) != null ? _b : "/").split("/");
  const [{ runs = [], loading, error }] = useWorkflowRuns({
    hostname,
    owner,
    repo,
    branch,
    initialPageSize: limit
  });
  useEffect(() => {
    if (error) {
      errorApi.post(error);
    }
  }, [error, errorApi]);
  const githubHost = hostname || "github.com";
  const routeLink = useRouteRef(buildRouteRef);
  if (error) {
    return /* @__PURE__ */ React.createElement(ErrorPanel, { title: error.message, error });
  }
  return /* @__PURE__ */ React.createElement(
    InfoCard,
    {
      title: "Recent Workflow Runs",
      subheader: branch ? `Branch: ${branch}` : "All Branches",
      noPadding: true,
      variant
    },
    !runs.length ? /* @__PURE__ */ React.createElement("div", { style: { textAlign: "center" } }, /* @__PURE__ */ React.createElement(Typography, { variant: "body1" }, "This component has GitHub Actions enabled, but no workflows were found."), /* @__PURE__ */ React.createElement(Typography, { variant: "body2" }, /* @__PURE__ */ React.createElement(Link, { to: `https://${githubHost}/${owner}/${repo}/actions/new` }, "Create a new workflow"))) : /* @__PURE__ */ React.createElement(
      Table$1,
      {
        isLoading: loading,
        options: {
          search: false,
          paging: false,
          padding: dense ? "dense" : "default",
          toolbar: false
        },
        columns: [
          {
            title: "Commit Message",
            field: "message",
            render: (data) => {
              var _a2;
              return /* @__PURE__ */ React.createElement(Link, { component: Link$1, to: routeLink({ id: data.id }) }, firstLine((_a2 = data.message) != null ? _a2 : ""));
            }
          },
          { title: "Branch", field: "source.branchName" },
          { title: "Status", field: "status", render: WorkflowRunStatus }
        ],
        data: runs
      }
    )
  );
};

export { BuildStatus, EntityGithubActionsContent, EntityLatestGithubActionRunCard, EntityLatestGithubActionsForBranchCard, EntityRecentGithubActionsRunsCard, GITHUB_ACTIONS_ANNOTATION, GithubActionsClient, LatestWorkflowRunCard, LatestWorkflowsForBranchCard, RecentWorkflowRunsCard, Router, githubActionsApiRef, githubActionsPlugin, isGithubActionsAvailable, isGithubActionsAvailable as isPluginApplicableToEntity, githubActionsPlugin as plugin };
//# sourceMappingURL=index.esm.js.map
