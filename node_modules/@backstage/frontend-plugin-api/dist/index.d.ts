/// <reference types="react" />
import React, { ReactNode, JSX as JSX$1, ComponentType, PropsWithChildren } from 'react';
import * as _backstage_core_plugin_api from '@backstage/core-plugin-api';
import { ApiRef, AnyApiRef, AnyApiFactory, IconComponent as IconComponent$1, SignInPageProps, AppTheme } from '@backstage/core-plugin-api';
export { AlertApi, AlertMessage, AnyApiFactory, AnyApiRef, ApiFactory, ApiHolder, ApiRef, ApiRefConfig, AppTheme, AppThemeApi, AuthProviderInfo, AuthRequestOptions, BackstageIdentityApi, BackstageIdentityResponse, BackstageUserIdentity, ConfigApi, DiscoveryApi, ErrorApi, ErrorApiError, ErrorApiErrorContext, FeatureFlag, FeatureFlagState, FeatureFlagsApi, FeatureFlagsSaveOptions, FetchApi, IdentityApi, OAuthApi, OAuthRequestApi, OAuthRequester, OAuthRequesterOptions, OAuthScope, OpenIdConnectApi, PendingOAuthRequest, ProfileInfo, ProfileInfoApi, SessionApi, SessionState, StorageApi, StorageValueSnapshot, TypesToApiRefs, alertApiRef, appThemeApiRef, atlassianAuthApiRef, bitbucketAuthApiRef, bitbucketServerAuthApiRef, configApiRef, createApiFactory, createApiRef, discoveryApiRef, errorApiRef, featureFlagsApiRef, fetchApiRef, githubAuthApiRef, gitlabAuthApiRef, googleAuthApiRef, identityApiRef, microsoftAuthApiRef, oauthRequestApiRef, oktaAuthApiRef, oneloginAuthApiRef, storageApiRef, useApi, useApiHolder, withApis } from '@backstage/core-plugin-api';
import { JsonObject } from '@backstage/types';
import { TranslationResource, TranslationMessages } from '@backstage/core-plugin-api/alpha';
export { TranslationMessages, TranslationMessagesOptions, TranslationRef, TranslationRefOptions, TranslationResource, TranslationResourceOptions, createTranslationMessages, createTranslationRef, createTranslationResource, useTranslationRef } from '@backstage/core-plugin-api/alpha';
import { z, ZodSchema, ZodTypeDef } from 'zod';

/**
 * Common analytics context attributes.
 *
 * @public
 */
type CommonAnalyticsContext = {
    /**
     * The nearest known parent plugin where the event was captured.
     */
    pluginId: string;
    /**
     * The nearest known parent extension where the event was captured.
     */
    /**
     * The nearest known parent extension where the event was captured.
     */
    extensionId: string;
};
/**
 * Analytics context envelope.
 *
 * @public
 */
type AnalyticsContextValue = CommonAnalyticsContext & {
    [param in string]: string | boolean | number | undefined;
};

/**
 * Provides components in the child react tree an Analytics Context, ensuring
 * all analytics events captured within the context have relevant attributes.
 *
 * @remarks
 *
 * Analytics contexts are additive, meaning the context ultimately emitted with
 * an event is the combination of all contexts in the parent tree.
 *
 * @public
 */
declare const AnalyticsContext: (options: {
    attributes: Partial<AnalyticsContextValue>;
    children: ReactNode;
}) => React.JSX.Element;

/**
 * Catch-all type for route params.
 *
 * @public
 */
type AnyRouteRefParams = {
    [param in string]: string;
} | undefined;

/**
 * Absolute route reference.
 *
 * @remarks
 *
 * See {@link https://backstage.io/docs/plugins/composability#routing-system}.
 *
 * @public
 */
interface RouteRef<TParams extends AnyRouteRefParams = AnyRouteRefParams> {
    readonly $$type: '@backstage/RouteRef';
    readonly T: TParams;
}
/**
 * Create a {@link RouteRef} from a route descriptor.
 *
 * @param config - Description of the route reference to be created.
 * @public
 */
declare function createRouteRef<TParams extends {
    [param in TParamKeys]: string;
} | undefined = undefined, TParamKeys extends string = string>(config?: {
    /** A list of parameter names that the path that this route ref is bound to must contain */
    readonly params: string extends TParamKeys ? (keyof TParams)[] : TParamKeys[];
}): RouteRef<keyof TParams extends never ? undefined : string extends TParamKeys ? TParams : {
    [param in TParamKeys]: string;
}>;

/**
 * Descriptor of a route relative to an absolute {@link RouteRef}.
 *
 * @remarks
 *
 * See {@link https://backstage.io/docs/plugins/composability#routing-system}.
 *
 * @public
 */
interface SubRouteRef<TParams extends AnyRouteRefParams = AnyRouteRefParams> {
    readonly $$type: '@backstage/SubRouteRef';
    readonly T: TParams;
    readonly path: string;
}
/**
 * Used in {@link PathParams} type declaration.
 * @ignore
 */
type ParamPart<S extends string> = S extends `:${infer Param}` ? Param : never;
/**
 * Used in {@link PathParams} type declaration.
 * @ignore
 */
type ParamNames<S extends string> = S extends `${infer Part}/${infer Rest}` ? ParamPart<Part> | ParamNames<Rest> : ParamPart<S>;
/**
 * This utility type helps us infer a Param object type from a string path
 * For example, `/foo/:bar/:baz` inferred to `{ bar: string, baz: string }`
 * @ignore
 */
type PathParams<S extends string> = {
    [name in ParamNames<S>]: string;
};
/**
 * Merges a param object type with an optional params type into a params object.
 * @ignore
 */
type MergeParams<P1 extends {
    [param in string]: string;
}, P2 extends AnyRouteRefParams> = (P1[keyof P1] extends never ? {} : P1) & (P2 extends undefined ? {} : P2);
/**
 * Convert empty params to undefined.
 * @ignore
 */
type TrimEmptyParams<Params extends {
    [param in string]: string;
}> = keyof Params extends never ? undefined : Params;
/**
 * Creates a SubRouteRef type given the desired parameters and parent route parameters.
 * The parameters types are merged together while ensuring that there is no overlap between the two.
 *
 * @ignore
 */
type MakeSubRouteRef<Params extends {
    [param in string]: string;
}, ParentParams extends AnyRouteRefParams> = keyof Params & keyof ParentParams extends never ? SubRouteRef<TrimEmptyParams<MergeParams<Params, ParentParams>>> : never;
/**
 * Create a {@link SubRouteRef} from a route descriptor.
 *
 * @param config - Description of the route reference to be created.
 * @public
 */
declare function createSubRouteRef<Path extends string, ParentParams extends AnyRouteRefParams = never>(config: {
    path: Path;
    parent: RouteRef<ParentParams>;
}): MakeSubRouteRef<PathParams<Path>, ParentParams>;

/**
 * Route descriptor, to be later bound to a concrete route by the app. Used to implement cross-plugin route references.
 *
 * @remarks
 *
 * See {@link https://backstage.io/docs/plugins/composability#routing-system}.
 *
 * @public
 */
interface ExternalRouteRef<TParams extends AnyRouteRefParams = AnyRouteRefParams, TOptional extends boolean = boolean> {
    readonly $$type: '@backstage/ExternalRouteRef';
    readonly T: TParams;
    readonly optional: TOptional;
}
/**
 * Creates a route descriptor, to be later bound to a concrete route by the app. Used to implement cross-plugin route references.
 *
 * @remarks
 *
 * See {@link https://backstage.io/docs/plugins/composability#routing-system}.
 *
 * @param options - Description of the route reference to be created.
 * @public
 */
declare function createExternalRouteRef<TParams extends {
    [param in TParamKeys]: string;
} | undefined = undefined, TOptional extends boolean = false, TParamKeys extends string = string>(options?: {
    /**
     * The parameters that will be provided to the external route reference.
     */
    readonly params?: string extends TParamKeys ? (keyof TParams)[] : TParamKeys[];
    /**
     * Whether or not this route is optional, defaults to false.
     *
     * Optional external routes are not required to be bound in the app, and
     * if they aren't, `useExternalRouteRef` will return `undefined`.
     */
    optional?: TOptional;
}): ExternalRouteRef<keyof TParams extends never ? undefined : string extends TParamKeys ? TParams : {
    [param in TParamKeys]: string;
}, TOptional>;

/**
 * TS magic for handling route parameters.
 *
 * @remarks
 *
 * The extra TS magic here is to require a single params argument if the RouteRef
 * had at least one param defined, but require 0 arguments if there are no params defined.
 * Without this we'd have to pass in empty object to all parameter-less RouteRefs
 * just to make TypeScript happy, or we would have to make the argument optional in
 * which case you might forget to pass it in when it is actually required.
 *
 * @public
 */
type RouteFunc<TParams extends AnyRouteRefParams> = (...[params]: TParams extends undefined ? readonly [] : readonly [params: TParams]) => string;
/**
 * React hook for constructing URLs to routes.
 *
 * @remarks
 *
 * See {@link https://backstage.io/docs/plugins/composability#routing-system}
 *
 * @param routeRef - The ref to route that should be converted to URL.
 * @returns A function that will in turn return the concrete URL of the `routeRef`.
 * @public
 */
declare function useRouteRef<TOptional extends boolean, TParams extends AnyRouteRefParams>(routeRef: ExternalRouteRef<TParams, TOptional>): TParams extends true ? RouteFunc<TParams> | undefined : RouteFunc<TParams>;
/**
 * React hook for constructing URLs to routes.
 *
 * @remarks
 *
 * See {@link https://backstage.io/docs/plugins/composability#routing-system}
 *
 * @param routeRef - The ref to route that should be converted to URL.
 * @returns A function that will in turn return the concrete URL of the `routeRef`.
 * @public
 */
declare function useRouteRef<TParams extends AnyRouteRefParams>(routeRef: RouteRef<TParams> | SubRouteRef<TParams>): RouteFunc<TParams>;

/**
 * React hook for retrieving dynamic params from the current URL.
 * @param _routeRef - Ref of the current route.
 * @public
 */
declare function useRouteRefParams<Params extends AnyRouteRefParams>(_routeRef: RouteRef<Params> | SubRouteRef<Params>): Params;

/** @public */
type ExtensionDataRef<TData, TConfig extends {
    optional?: true;
} = {}> = {
    id: string;
    T: TData;
    config: TConfig;
    $$type: '@backstage/ExtensionDataRef';
};
/** @public */
interface ConfigurableExtensionDataRef<TData, TConfig extends {
    optional?: true;
} = {}> extends ExtensionDataRef<TData, TConfig> {
    optional(): ConfigurableExtensionDataRef<TData, TData & {
        optional: true;
    }>;
}
/** @public */
declare function createExtensionDataRef<TData>(id: string): ConfigurableExtensionDataRef<TData>;

/** @public */
declare const coreExtensionData: {
    reactElement: ConfigurableExtensionDataRef<JSX$1.Element, {}>;
    routePath: ConfigurableExtensionDataRef<string, {}>;
    routeRef: ConfigurableExtensionDataRef<RouteRef<AnyRouteRefParams>, {}>;
};

/** @public */
type PortableSchema<TOutput> = {
    parse: (input: unknown) => TOutput;
    schema: JsonObject;
};

/** @public */
declare function createSchemaFromZod<TOutput, TInput>(schemaCreator: (zImpl: typeof z) => ZodSchema<TOutput, ZodTypeDef, TInput>): PortableSchema<TOutput>;

/**
 * Utility type to expand type aliases into their equivalent type.
 * @ignore
 */
type Expand<T> = T extends infer O ? {
    [K in keyof O]: O[K];
} : never;
/** @public */
type CoreProgressProps = {};
/** @public */
type CoreNotFoundErrorPageProps = {
    children?: ReactNode;
};
/** @public */
type CoreErrorBoundaryFallbackProps = {
    plugin?: BackstagePlugin;
    error: Error;
    resetError: () => void;
};

/** @public */
interface ExtensionInput<TExtensionData extends AnyExtensionDataMap, TConfig extends {
    singleton: boolean;
    optional: boolean;
}> {
    $$type: '@backstage/ExtensionInput';
    extensionData: TExtensionData;
    config: TConfig;
}
/** @public */
declare function createExtensionInput<TExtensionData extends AnyExtensionDataMap, TConfig extends {
    singleton?: boolean;
    optional?: boolean;
}>(extensionData: TExtensionData, config?: TConfig): ExtensionInput<TExtensionData, {
    singleton: TConfig['singleton'] extends true ? true : false;
    optional: TConfig['optional'] extends true ? true : false;
}>;

/** @public */
type AnyExtensionDataMap = {
    [name in string]: ExtensionDataRef<unknown, {
        optional?: true;
    }>;
};
/** @public */
type AnyExtensionInputMap = {
    [inputName in string]: ExtensionInput<AnyExtensionDataMap, {
        optional: boolean;
        singleton: boolean;
    }>;
};
/**
 * Converts an extension data map into the matching concrete data values type.
 * @public
 */
type ExtensionDataValues<TExtensionData extends AnyExtensionDataMap> = {
    [DataName in keyof TExtensionData as TExtensionData[DataName]['config'] extends {
        optional: true;
    } ? never : DataName]: TExtensionData[DataName]['T'];
} & {
    [DataName in keyof TExtensionData as TExtensionData[DataName]['config'] extends {
        optional: true;
    } ? DataName : never]?: TExtensionData[DataName]['T'];
};
/**
 * Convert a single extension input into a matching resolved input.
 * @public
 */
type ResolvedExtensionInput<TExtensionData extends AnyExtensionDataMap> = {
    node: AppNode;
    output: ExtensionDataValues<TExtensionData>;
};
/**
 * Converts an extension input map into a matching collection of resolved inputs.
 * @public
 */
type ResolvedExtensionInputs<TInputs extends {
    [name in string]: ExtensionInput<any, any>;
}> = {
    [InputName in keyof TInputs]: false extends TInputs[InputName]['config']['singleton'] ? Array<Expand<ResolvedExtensionInput<TInputs[InputName]['extensionData']>>> : false extends TInputs[InputName]['config']['optional'] ? Expand<ResolvedExtensionInput<TInputs[InputName]['extensionData']>> : Expand<ResolvedExtensionInput<TInputs[InputName]['extensionData']> | undefined>;
};
/** @public */
interface CreateExtensionOptions<TOutput extends AnyExtensionDataMap, TInputs extends AnyExtensionInputMap, TConfig> {
    kind?: string;
    namespace?: string;
    name?: string;
    attachTo: {
        id: string;
        input: string;
    };
    disabled?: boolean;
    inputs?: TInputs;
    output: TOutput;
    configSchema?: PortableSchema<TConfig>;
    factory(options: {
        node: AppNode;
        config: TConfig;
        inputs: Expand<ResolvedExtensionInputs<TInputs>>;
    }): Expand<ExtensionDataValues<TOutput>>;
}
/** @public */
interface ExtensionDefinition<TConfig> {
    $$type: '@backstage/ExtensionDefinition';
    readonly kind?: string;
    readonly namespace?: string;
    readonly name?: string;
    readonly attachTo: {
        id: string;
        input: string;
    };
    readonly disabled: boolean;
    readonly configSchema?: PortableSchema<TConfig>;
}
/** @public */
declare function createExtension<TOutput extends AnyExtensionDataMap, TInputs extends AnyExtensionInputMap, TConfig = never>(options: CreateExtensionOptions<TOutput, TInputs, TConfig>): ExtensionDefinition<TConfig>;

/** @public */
interface Extension<TConfig> {
    $$type: '@backstage/Extension';
    readonly id: string;
    readonly attachTo: {
        id: string;
        input: string;
    };
    readonly disabled: boolean;
    readonly configSchema?: PortableSchema<TConfig>;
}

/**
 * Feature flag configuration.
 *
 * @public
 */
type FeatureFlagConfig = {
    /** Feature flag name */
    name: string;
};
/** @public */
type AnyRoutes = {
    [name in string]: RouteRef | SubRouteRef;
};
/** @public */
type AnyExternalRoutes = {
    [name in string]: ExternalRouteRef;
};
/** @public */
interface BackstagePlugin<Routes extends AnyRoutes = AnyRoutes, ExternalRoutes extends AnyExternalRoutes = AnyExternalRoutes> {
    readonly $$type: '@backstage/BackstagePlugin';
    readonly id: string;
    readonly routes: Routes;
    readonly externalRoutes: ExternalRoutes;
}
/** @public */
interface ExtensionOverrides {
    readonly $$type: '@backstage/ExtensionOverrides';
}
/** @public */
type FrontendFeature = BackstagePlugin | ExtensionOverrides;

/** @public */
interface PluginOptions<Routes extends AnyRoutes, ExternalRoutes extends AnyExternalRoutes> {
    id: string;
    routes?: Routes;
    externalRoutes?: ExternalRoutes;
    extensions?: ExtensionDefinition<unknown>[];
    featureFlags?: FeatureFlagConfig[];
}
/** @public */
declare function createPlugin<Routes extends AnyRoutes = {}, ExternalRoutes extends AnyExternalRoutes = {}>(options: PluginOptions<Routes, ExternalRoutes>): BackstagePlugin<Routes, ExternalRoutes>;

/** @public */
interface ExtensionOverridesOptions {
    extensions: ExtensionDefinition<unknown>[];
    featureFlags?: FeatureFlagConfig[];
}
/** @public */
declare function createExtensionOverrides(options: ExtensionOverridesOptions): ExtensionOverrides;

/**
 * The specification for this {@link AppNode} in the {@link AppTree}.
 *
 * @public
 * @remarks
 *
 * The specifications for a collection of app nodes is all the information needed
 * to build the tree and instantiate the nodes.
 */
interface AppNodeSpec {
    readonly id: string;
    readonly attachTo: {
        id: string;
        input: string;
    };
    readonly extension: Extension<unknown>;
    readonly disabled: boolean;
    readonly config?: unknown;
    readonly source?: BackstagePlugin;
}
/**
 * The connections from this {@link AppNode} to other nodes.
 *
 * @public
 * @remarks
 *
 * The app node edges are resolved based on the app node specs, regardless of whether
 * adjacent nodes are disabled or not. If no parent attachment is present or
 */
interface AppNodeEdges {
    readonly attachedTo?: {
        node: AppNode;
        input: string;
    };
    readonly attachments: ReadonlyMap<string, AppNode[]>;
}
/**
 * The instance of this {@link AppNode} in the {@link AppTree}.
 *
 * @public
 * @remarks
 *
 * The app node instance is created when the `factory` function of an extension is called.
 * Instances will only be present for nodes in the app that are connected to the root
 * node and not disabled
 */
interface AppNodeInstance {
    /** Returns a sequence of all extension data refs that were output by this instance */
    getDataRefs(): Iterable<ExtensionDataRef<unknown>>;
    /** Get the output data for a single extension data ref */
    getData<T>(ref: ExtensionDataRef<T>): T | undefined;
}
/**
 * A node in the {@link AppTree}.
 *
 * @public
 */
interface AppNode {
    /** The specification for how this node should be instantiated */
    readonly spec: AppNodeSpec;
    /** The edges from this node to other nodes in the app tree */
    readonly edges: AppNodeEdges;
    /** The instance of this node, if it was instantiated */
    readonly instance?: AppNodeInstance;
}
/**
 * The app tree containing all {@link AppNode}s of the app.
 *
 * @public
 */
interface AppTree {
    /** The root node of the app */
    readonly root: AppNode;
    /** A map of all nodes in the app by ID, including orphaned or disabled nodes */
    readonly nodes: ReadonlyMap<string, AppNode>;
    /** A sequence of all nodes with a parent that is not reachable from the app root node */
    readonly orphans: Iterable<AppNode>;
}
/**
 * The API for interacting with the {@link AppTree}.
 *
 * @public
 */
interface AppTreeApi {
    /**
     * Get the {@link AppTree} for the app.
     */
    getTree(): {
        tree: AppTree;
    };
}
/**
 * The `ApiRef` of {@link AppTreeApi}.
 *
 * @public
 */
declare const appTreeApiRef: _backstage_core_plugin_api.ApiRef<AppTreeApi>;

/** @public */
interface ExtensionBoundaryProps {
    node: AppNode;
    routable?: boolean;
    children: ReactNode;
}
/** @public */
declare function ExtensionBoundary(props: ExtensionBoundaryProps): React.JSX.Element;

/** @public */
type ComponentRef<T extends {} = {}> = {
    id: string;
    T: T;
};
/** @public */
declare function createComponentRef<T extends {} = {}>(options: {
    id: string;
}): ComponentRef<T>;

/** @public */
declare const coreComponentRefs: {
    progress: ComponentRef<CoreProgressProps>;
    notFoundErrorPage: ComponentRef<CoreNotFoundErrorPageProps>;
    errorBoundaryFallback: ComponentRef<CoreErrorBoundaryFallbackProps>;
};

/**
 * API for looking up components based on component refs.
 *
 * @public
 */
interface ComponentsApi {
    getComponent<T extends {}>(ref: ComponentRef<T>): ComponentType<T>;
}
/**
 * The `ApiRef` of {@link ComponentsApi}.
 *
 * @public
 */
declare const componentsApiRef: _backstage_core_plugin_api.ApiRef<ComponentsApi>;
/**
 * @public
 * Returns the component associated with the given ref.
 */
declare function useComponentRef<T extends {}>(ref: ComponentRef<T>): ComponentType<T>;

/**
 * Represents an event worth tracking in an analytics system that could inform
 * how users of a Backstage instance are using its features.
 *
 * @public
 */
type AnalyticsEvent = {
    /**
     * A string that identifies the event being tracked by the type of action the
     * event represents. Be careful not to encode extra metadata in this string
     * that should instead be placed in the Analytics Context or attributes.
     * Examples include:
     *
     * - view
     * - click
     * - filter
     * - search
     * - hover
     * - scroll
     */
    action: string;
    /**
     * A string that uniquely identifies the object that the action is being
     * taken on. Examples include:
     *
     * - The path of the page viewed
     * - The url of the link clicked
     * - The value that was filtered by
     * - The text that was searched for
     */
    subject: string;
    /**
     * An optional numeric value relevant to the event that could be aggregated
     * by analytics tools. Examples include:
     *
     * - The index or position of the clicked element in an ordered list
     * - The percentage of an element that has been scrolled through
     * - The amount of time that has elapsed since a fixed point
     * - A satisfaction score on a fixed scale
     */
    value?: number;
    /**
     * Optional, additional attributes (representing dimensions or metrics)
     * specific to the event that could be forwarded on to analytics systems.
     */
    attributes?: AnalyticsEventAttributes;
    /**
     * Contextual metadata relating to where the event was captured and by whom.
     * This could include information about the route, plugin, or extension in
     * which an event was captured.
     */
    context: AnalyticsContextValue;
};
/**
 * A structure allowing other arbitrary metadata to be provided by analytics
 * event emitters.
 *
 * @public
 */
type AnalyticsEventAttributes = {
    [attribute in string]: string | boolean | number;
};
/**
 * Represents a tracker with methods that can be called to track events in a
 * configured analytics service.
 *
 * @public
 */
type AnalyticsTracker = {
    captureEvent: (action: string, subject: string, options?: {
        value?: number;
        attributes?: AnalyticsEventAttributes;
    }) => void;
};
/**
 * The Analytics API is used to track user behavior in a Backstage instance.
 *
 * @remarks
 *
 * To instrument your App or Plugin, retrieve an analytics tracker using the
 * useAnalytics() hook. This will return a pre-configured AnalyticsTracker
 * with relevant methods for instrumentation.
 *
 * @public
 */
type AnalyticsApi = {
    /**
     * Primary event handler responsible for compiling and forwarding events to
     * an analytics system.
     */
    captureEvent(event: AnalyticsEvent): void;
};
/**
 * The API reference of {@link AnalyticsApi}.
 *
 * @public
 */
declare const analyticsApiRef: ApiRef<AnalyticsApi>;

/**
 * Gets a pre-configured analytics tracker.
 *
 * @public
 */
declare function useAnalytics(): AnalyticsTracker;

/** @public */
declare function createApiExtension<TConfig extends {}, TInputs extends AnyExtensionInputMap>(options: ({
    api: AnyApiRef;
    factory: (options: {
        config: TConfig;
        inputs: Expand<ResolvedExtensionInputs<TInputs>>;
    }) => AnyApiFactory;
} | {
    factory: AnyApiFactory;
}) & {
    configSchema?: PortableSchema<TConfig>;
    inputs?: TInputs;
}): ExtensionDefinition<TConfig>;
/** @public */
declare namespace createApiExtension {
    const factoryDataRef: ConfigurableExtensionDataRef<AnyApiFactory, {}>;
}

/**
 * Creates an extension that renders a React element at the app root, outside of
 * the app layout. This is useful for example for shared popups and similar.
 *
 * @public
 */
declare function createAppRootElementExtension<TConfig extends {}, TInputs extends AnyExtensionInputMap>(options: {
    namespace?: string;
    name?: string;
    attachTo?: {
        id: string;
        input: string;
    };
    configSchema?: PortableSchema<TConfig>;
    disabled?: boolean;
    inputs?: TInputs;
    element: JSX$1.Element | ((options: {
        inputs: Expand<ResolvedExtensionInputs<TInputs>>;
        config: TConfig;
    }) => JSX$1.Element);
}): ExtensionDefinition<TConfig>;

/**
 * Creates an extension that renders a React wrapper at the app root, enclosing
 * the app layout. This is useful for example for adding global React contexts
 * and similar.
 *
 * @public
 */
declare function createAppRootWrapperExtension<TConfig extends {}, TInputs extends AnyExtensionInputMap>(options: {
    namespace?: string;
    name?: string;
    attachTo?: {
        id: string;
        input: string;
    };
    configSchema?: PortableSchema<TConfig>;
    disabled?: boolean;
    inputs?: TInputs;
    Component: ComponentType<PropsWithChildren<{
        inputs: Expand<ResolvedExtensionInputs<TInputs>>;
        config: TConfig;
    }>>;
}): ExtensionDefinition<TConfig>;
/** @public */
declare namespace createAppRootWrapperExtension {
    const componentDataRef: ConfigurableExtensionDataRef<React.ComponentType<{
        children?: React.ReactNode;
    }>, {}>;
}

/**
 * Creates an extension that replaces the router implementation at the app root.
 * This is useful to be able to for example replace the BrowserRouter with a
 * MemoryRouter in tests, or to add additional props to a BrowserRouter.
 *
 * @public
 */
declare function createRouterExtension<TConfig extends {}, TInputs extends AnyExtensionInputMap>(options: {
    namespace?: string;
    name?: string;
    attachTo?: {
        id: string;
        input: string;
    };
    configSchema?: PortableSchema<TConfig>;
    disabled?: boolean;
    inputs?: TInputs;
    Component: ComponentType<PropsWithChildren<{
        inputs: Expand<ResolvedExtensionInputs<TInputs>>;
        config: TConfig;
    }>>;
}): ExtensionDefinition<TConfig>;
/** @public */
declare namespace createRouterExtension {
    const componentDataRef: ConfigurableExtensionDataRef<React.ComponentType<{
        children?: React.ReactNode;
    }>, {}>;
}

/**
 * Helper for creating extensions for a routable React page component.
 *
 * @public
 */
declare function createPageExtension<TConfig extends {
    path: string;
}, TInputs extends AnyExtensionInputMap>(options: ({
    defaultPath: string;
} | {
    configSchema: PortableSchema<TConfig>;
}) & {
    namespace?: string;
    name?: string;
    attachTo?: {
        id: string;
        input: string;
    };
    disabled?: boolean;
    inputs?: TInputs;
    routeRef?: RouteRef;
    loader: (options: {
        config: TConfig;
        inputs: Expand<ResolvedExtensionInputs<TInputs>>;
    }) => Promise<JSX.Element>;
}): ExtensionDefinition<TConfig>;

/**
 * Helper for creating extensions for a nav item.
 * @public
 */
declare function createNavItemExtension(options: {
    namespace?: string;
    name?: string;
    routeRef: RouteRef<undefined>;
    title: string;
    icon: IconComponent$1;
}): ExtensionDefinition<{
    title: string;
}>;
/** @public */
declare namespace createNavItemExtension {
    const targetDataRef: ConfigurableExtensionDataRef<{
        title: string;
        icon: IconComponent$1;
        routeRef: RouteRef<undefined>;
    }, {}>;
}

/**
 * Helper for creating extensions for a nav logos.
 * @public
 */
declare function createNavLogoExtension(options: {
    name?: string;
    namespace?: string;
    logoIcon: JSX.Element;
    logoFull: JSX.Element;
}): ExtensionDefinition<never>;
/** @public */
declare namespace createNavLogoExtension {
    const logoElementsDataRef: ConfigurableExtensionDataRef<{
        logoIcon?: JSX.Element | undefined;
        logoFull?: JSX.Element | undefined;
    }, {}>;
}

/**
 *
 * @public
 */
declare function createSignInPageExtension<TConfig extends {}, TInputs extends AnyExtensionInputMap>(options: {
    namespace?: string;
    name?: string;
    attachTo?: {
        id: string;
        input: string;
    };
    configSchema?: PortableSchema<TConfig>;
    disabled?: boolean;
    inputs?: TInputs;
    loader: (options: {
        config: TConfig;
        inputs: Expand<ResolvedExtensionInputs<TInputs>>;
    }) => Promise<ComponentType<SignInPageProps>>;
}): ExtensionDefinition<TConfig>;
/** @public */
declare namespace createSignInPageExtension {
    const componentDataRef: ConfigurableExtensionDataRef<React.ComponentType<SignInPageProps>, {}>;
}

/** @public */
declare function createThemeExtension(theme: AppTheme): ExtensionDefinition<never>;
/** @public */
declare namespace createThemeExtension {
    const themeDataRef: ConfigurableExtensionDataRef<AppTheme, {}>;
}

/** @public */
declare function createComponentExtension<TProps extends {}, TConfig extends {}, TInputs extends AnyExtensionInputMap>(options: {
    ref: ComponentRef<TProps>;
    name?: string;
    disabled?: boolean;
    inputs?: TInputs;
    configSchema?: PortableSchema<TConfig>;
    loader: {
        lazy: (values: {
            config: TConfig;
            inputs: Expand<ResolvedExtensionInputs<TInputs>>;
        }) => Promise<ComponentType<TProps>>;
    } | {
        sync: (values: {
            config: TConfig;
            inputs: Expand<ResolvedExtensionInputs<TInputs>>;
        }) => ComponentType<TProps>;
    };
}): ExtensionDefinition<TConfig>;
/** @public */
declare namespace createComponentExtension {
    const componentDataRef: ConfigurableExtensionDataRef<{
        ref: ComponentRef;
        impl: ComponentType;
    }, {}>;
}

/** @public */
declare function createTranslationExtension(options: {
    name?: string;
    resource: TranslationResource | TranslationMessages;
}): ExtensionDefinition<never>;
/** @public */
declare namespace createTranslationExtension {
    const translationDataRef: ConfigurableExtensionDataRef<TranslationResource<string> | TranslationMessages<string, {
        [x: string]: string;
    }, boolean>, {}>;
}

/**
 * IconComponent is the common icon type used throughout Backstage when
 * working with and rendering generic icons, including the app system icons.
 *
 * @remarks
 *
 * The type is based on SvgIcon from Material UI, but both do not what the plugin-api
 * package to have a dependency on Material UI, nor do we want the props to be as broad
 * as the SvgIconProps interface.
 *
 * If you have the need to forward additional props from SvgIconProps, you can
 * open an issue or submit a PR to the main Backstage repo. When doing so please
 * also describe your use-case and reasoning of the addition.
 *
 * @public
 */
type IconComponent = ComponentType<{
    fontSize?: 'large' | 'small' | 'default' | 'inherit';
} | {
    fontSize?: 'medium' | 'large' | 'small' | 'inherit';
}>;

export { AnalyticsApi, AnalyticsContext, AnalyticsContextValue, AnalyticsEvent, AnalyticsEventAttributes, AnalyticsTracker, AnyExtensionDataMap, AnyExtensionInputMap, AnyExternalRoutes, AnyRouteRefParams, AnyRoutes, AppNode, AppNodeEdges, AppNodeInstance, AppNodeSpec, AppTree, AppTreeApi, BackstagePlugin, CommonAnalyticsContext, ComponentRef, ComponentsApi, ConfigurableExtensionDataRef, CoreErrorBoundaryFallbackProps, CoreNotFoundErrorPageProps, CoreProgressProps, CreateExtensionOptions, Extension, ExtensionBoundary, ExtensionBoundaryProps, ExtensionDataRef, ExtensionDataValues, ExtensionDefinition, ExtensionInput, ExtensionOverrides, ExtensionOverridesOptions, ExternalRouteRef, FeatureFlagConfig, FrontendFeature, IconComponent, PluginOptions, PortableSchema, ResolvedExtensionInput, ResolvedExtensionInputs, RouteFunc, RouteRef, SubRouteRef, analyticsApiRef, appTreeApiRef, componentsApiRef, coreComponentRefs, coreExtensionData, createApiExtension, createAppRootElementExtension, createAppRootWrapperExtension, createComponentExtension, createComponentRef, createExtension, createExtensionDataRef, createExtensionInput, createExtensionOverrides, createExternalRouteRef, createNavItemExtension, createNavLogoExtension, createPageExtension, createPlugin, createRouteRef, createRouterExtension, createSchemaFromZod, createSignInPageExtension, createSubRouteRef, createThemeExtension, createTranslationExtension, useAnalytics, useComponentRef, useRouteRef, useRouteRefParams };
