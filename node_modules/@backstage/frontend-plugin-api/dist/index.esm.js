import { createVersionedContext, createVersionedValueMap, getOrCreateGlobalSingleton, useVersionedContext } from '@backstage/version-bridge';
import React, { useContext, useRef, Component, Suspense, useEffect, lazy, useMemo } from 'react';
import { createApiRef, useApi, AnalyticsContext as AnalyticsContext$1, useAnalytics as useAnalytics$1 } from '@backstage/core-plugin-api';
export { SessionState, alertApiRef, appThemeApiRef, atlassianAuthApiRef, bitbucketAuthApiRef, bitbucketServerAuthApiRef, configApiRef, createApiFactory, createApiRef, discoveryApiRef, errorApiRef, featureFlagsApiRef, fetchApiRef, githubAuthApiRef, gitlabAuthApiRef, googleAuthApiRef, identityApiRef, microsoftAuthApiRef, oauthRequestApiRef, oktaAuthApiRef, oneloginAuthApiRef, storageApiRef, useApi, useApiHolder, withApis } from '@backstage/core-plugin-api';
import { z } from 'zod';
import zodToJsonSchema from 'zod-to-json-schema';
import { useLocation, useParams } from 'react-router-dom';
export { createTranslationMessages, createTranslationRef, createTranslationResource, useTranslationRef } from '@backstage/core-plugin-api/alpha';

const AnalyticsReactContext = createVersionedContext("analytics-context");
const useAnalyticsContext = () => {
  const theContext = useContext(AnalyticsReactContext);
  if (theContext === void 0) {
    return {
      pluginId: "root",
      extensionId: "App"
    };
  }
  const theValue = theContext.atVersion(1);
  if (theValue === void 0) {
    throw new Error("No context found for version 1.");
  }
  return theValue;
};
const AnalyticsContext = (options) => {
  const { attributes, children } = options;
  const parentValues = useAnalyticsContext();
  const combinedValue = {
    ...parentValues,
    ...attributes
  };
  const versionedCombinedValue = createVersionedValueMap({ 1: combinedValue });
  return /* @__PURE__ */ React.createElement(AnalyticsReactContext.Provider, { value: versionedCombinedValue }, children);
};

const appTreeApiRef = createApiRef({ id: "core.app-tree" });

const componentsApiRef = createApiRef({
  id: "core.components"
});
function useComponentRef(ref) {
  const componentsApi = useApi(componentsApiRef);
  return componentsApi.getComponent(ref);
}

const analyticsApiRef = createApiRef({
  id: "core.analytics"
});

const globalEvents = getOrCreateGlobalSingleton(
  "core-plugin-api:analytics-tracker-events",
  () => ({
    mostRecentGatheredNavigation: void 0,
    mostRecentRoutableExtensionRender: void 0,
    beforeUnloadRegistered: false
  })
);
const routableExtensionRenderedEvent$1 = "_ROUTABLE-EXTENSION-RENDERED";
class Tracker {
  constructor(analyticsApi, context = {
    pluginId: "root",
    extensionId: "App"
  }) {
    this.analyticsApi = analyticsApi;
    this.context = context;
    if (!globalEvents.beforeUnloadRegistered) {
      addEventListener(
        "beforeunload",
        () => {
          if (globalEvents.mostRecentGatheredNavigation) {
            this.analyticsApi.captureEvent({
              ...globalEvents.mostRecentGatheredNavigation,
              ...globalEvents.mostRecentRoutableExtensionRender
            });
            globalEvents.mostRecentGatheredNavigation = void 0;
            globalEvents.mostRecentRoutableExtensionRender = void 0;
          }
        },
        { once: true, passive: true }
      );
      globalEvents.beforeUnloadRegistered = true;
    }
  }
  setContext(context) {
    this.context = context;
  }
  captureEvent(action, subject, {
    value,
    attributes
  } = {}) {
    const context = this.context;
    if (action === routableExtensionRenderedEvent$1) {
      if (globalEvents.mostRecentGatheredNavigation) {
        globalEvents.mostRecentRoutableExtensionRender = {
          context: {
            ...context,
            extensionId: "App"
          }
        };
      }
      return;
    }
    if (globalEvents.mostRecentGatheredNavigation) {
      try {
        this.analyticsApi.captureEvent({
          ...globalEvents.mostRecentGatheredNavigation,
          ...globalEvents.mostRecentRoutableExtensionRender
        });
      } catch (e) {
        console.warn("Error during analytics event capture. %o", e);
      }
      globalEvents.mostRecentGatheredNavigation = void 0;
      globalEvents.mostRecentRoutableExtensionRender = void 0;
    }
    if (action === "navigate" && context.pluginId === "root") {
      globalEvents.mostRecentGatheredNavigation = {
        action,
        subject,
        value,
        attributes,
        context
      };
      return;
    }
    try {
      this.analyticsApi.captureEvent({
        action,
        subject,
        value,
        attributes,
        context
      });
    } catch (e) {
      console.warn("Error during analytics event capture. %o", e);
    }
  }
}

function useAnalyticsApi() {
  try {
    return useApi(analyticsApiRef);
  } catch {
    return { captureEvent: () => {
    } };
  }
}
function useAnalytics() {
  const trackerRef = useRef(null);
  const context = useAnalyticsContext();
  const analyticsApi = useAnalyticsApi();
  function getTracker() {
    if (trackerRef.current === null) {
      trackerRef.current = new Tracker(analyticsApi);
    }
    return trackerRef.current;
  }
  const tracker = getTracker();
  tracker.setContext(context);
  return tracker;
}

var __defProp$3 = Object.defineProperty;
var __defNormalProp$3 = (obj, key, value) => key in obj ? __defProp$3(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$3 = (obj, key, value) => {
  __defNormalProp$3(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
class ErrorBoundary extends Component {
  constructor() {
    super(...arguments);
    __publicField$3(this, "state", { error: void 0 });
    __publicField$3(this, "handleErrorReset", () => {
      this.setState({ error: void 0 });
    });
  }
  static getDerivedStateFromError(error) {
    return { error };
  }
  render() {
    const { error } = this.state;
    const { plugin, children, Fallback } = this.props;
    if (error) {
      return /* @__PURE__ */ React.createElement(
        Fallback,
        {
          plugin,
          error,
          resetError: this.handleErrorReset
        }
      );
    }
    return children;
  }
}

getOrCreateGlobalSingleton(
  "core-plugin-api:analytics-tracker-events",
  () => ({
    mostRecentGatheredNavigation: void 0,
    mostRecentRoutableExtensionRender: void 0,
    beforeUnloadRegistered: false
  })
);
const routableExtensionRenderedEvent = "_ROUTABLE-EXTENSION-RENDERED";

function createComponentRef(options) {
  const { id } = options;
  return {
    id,
    toString() {
      return `ComponentRef{id=${id}}`;
    }
  };
}

const coreProgressComponentRef = createComponentRef({
  id: "core.components.progress"
});
const coreNotFoundErrorPageComponentRef = createComponentRef({
  id: "core.components.notFoundErrorPage"
});
const coreErrorBoundaryFallbackComponentRef = createComponentRef({
  id: "core.components.errorBoundaryFallback"
});
const coreComponentRefs = {
  progress: coreProgressComponentRef,
  notFoundErrorPage: coreNotFoundErrorPageComponentRef,
  errorBoundaryFallback: coreErrorBoundaryFallbackComponentRef
};

const RouteTracker = (props) => {
  const { disableTracking, children } = props;
  const analytics = useAnalytics$1();
  useEffect(() => {
    if (disableTracking)
      return;
    analytics.captureEvent(routableExtensionRenderedEvent, "");
  }, [analytics, disableTracking]);
  return /* @__PURE__ */ React.createElement(React.Fragment, null, children);
};
function ExtensionBoundary(props) {
  var _a;
  const { node, routable, children } = props;
  const plugin = node.spec.source;
  const Progress = useComponentRef(coreComponentRefs.progress);
  const fallback = useComponentRef(coreComponentRefs.errorBoundaryFallback);
  const attributes = {
    extensionId: node.spec.id,
    pluginId: (_a = node.spec.source) == null ? void 0 : _a.id
  };
  return /* @__PURE__ */ React.createElement(Suspense, { fallback: /* @__PURE__ */ React.createElement(Progress, null) }, /* @__PURE__ */ React.createElement(ErrorBoundary, { plugin, Fallback: fallback }, /* @__PURE__ */ React.createElement(AnalyticsContext$1, { attributes }, /* @__PURE__ */ React.createElement(RouteTracker, { disableTracking: !routable }, children))));
}

function createExtensionDataRef(id) {
  return {
    id,
    $$type: "@backstage/ExtensionDataRef",
    config: {},
    optional() {
      return {
        ...this,
        config: { ...this.config, optional: true }
      };
    },
    toString() {
      const optional = Boolean(this.config.optional);
      return `ExtensionDataRef{id=${id},optional=${optional}}`;
    }
  };
}

const coreExtensionData = {
  reactElement: createExtensionDataRef("core.reactElement"),
  routePath: createExtensionDataRef("core.routing.path"),
  routeRef: createExtensionDataRef("core.routing.ref")
};

function toInternalExtensionDefinition(overrides) {
  const internal = overrides;
  if (internal.$$type !== "@backstage/ExtensionDefinition") {
    throw new Error(
      `Invalid extension definition instance, bad type '${internal.$$type}'`
    );
  }
  if (internal.version !== "v1") {
    throw new Error(
      `Invalid extension definition instance, bad version '${internal.version}'`
    );
  }
  return internal;
}
function createExtension(options) {
  var _a, _b;
  return {
    $$type: "@backstage/ExtensionDefinition",
    version: "v1",
    kind: options.kind,
    namespace: options.namespace,
    name: options.name,
    attachTo: options.attachTo,
    disabled: (_a = options.disabled) != null ? _a : false,
    inputs: (_b = options.inputs) != null ? _b : {},
    output: options.output,
    configSchema: options.configSchema,
    factory({ inputs, ...rest }) {
      return options.factory({
        inputs,
        ...rest
      });
    },
    toString() {
      const parts = [];
      if (options.kind) {
        parts.push(`kind=${options.kind}`);
      }
      if (options.namespace) {
        parts.push(`namespace=${options.namespace}`);
      }
      if (options.name) {
        parts.push(`name=${options.name}`);
      }
      parts.push(`attachTo=${options.attachTo.id}@${options.attachTo.input}`);
      return `ExtensionDefinition{${parts.join(",")}}`;
    }
  };
}

function createExtensionInput(extensionData, config) {
  return {
    $$type: "@backstage/ExtensionInput",
    extensionData,
    config: {
      singleton: Boolean(config == null ? void 0 : config.singleton),
      optional: Boolean(config == null ? void 0 : config.optional)
    }
  };
}

function resolveExtensionDefinition(definition, context) {
  var _a;
  const internalDefinition = toInternalExtensionDefinition(definition);
  const { name, kind, namespace: _, ...rest } = internalDefinition;
  const namespace = (_a = internalDefinition.namespace) != null ? _a : context == null ? void 0 : context.namespace;
  const namePart = name && namespace ? `${namespace}/${name}` : namespace || name;
  if (!namePart) {
    throw new Error(
      `Extension must declare an explicit namespace or name as it could not be resolved from context, kind=${kind} namespace=${namespace} name=${name}`
    );
  }
  const id = kind ? `${kind}:${namePart}` : namePart;
  return {
    ...rest,
    $$type: "@backstage/Extension",
    version: "v1",
    id,
    toString() {
      return `Extension{id=${id}}`;
    }
  };
}

function createPlugin(options) {
  var _a, _b, _c, _d;
  const extensions = ((_a = options.extensions) != null ? _a : []).map(
    (def) => resolveExtensionDefinition(def, { namespace: options.id })
  );
  const extensionIds = extensions.map((e) => e.id);
  if (extensionIds.length !== new Set(extensionIds).size) {
    const duplicates = Array.from(
      new Set(
        extensionIds.filter((id, index) => extensionIds.indexOf(id) !== index)
      )
    );
    throw new Error(
      `Plugin '${options.id}' provided duplicate extensions: ${duplicates.join(
        ", "
      )}`
    );
  }
  return {
    $$type: "@backstage/BackstagePlugin",
    version: "v1",
    id: options.id,
    routes: (_b = options.routes) != null ? _b : {},
    externalRoutes: (_c = options.externalRoutes) != null ? _c : {},
    featureFlags: (_d = options.featureFlags) != null ? _d : [],
    extensions,
    toString() {
      return `Plugin{id=${options.id}}`;
    }
  };
}

function createExtensionOverrides(options) {
  var _a;
  const extensions = options.extensions.map(
    (def) => resolveExtensionDefinition(def)
  );
  const featureFlags = (_a = options.featureFlags) != null ? _a : [];
  return {
    $$type: "@backstage/ExtensionOverrides",
    version: "v1",
    extensions,
    featureFlags,
    toString() {
      const ex = extensions.map(String).join(",");
      const ff = featureFlags.map((f) => f.name).join(",");
      return `ExtensionOverrides{extensions=[${ex}],featureFlags=[${ff}]}`;
    }
  };
}

function createApiExtension(options) {
  const { factory, configSchema, inputs: extensionInputs } = options;
  const apiRef = "api" in options ? options.api : factory.api;
  return createExtension({
    kind: "api",
    // Since ApiRef IDs use a global namespace we use the namespace here in order to override
    // potential plugin IDs and always end up with the format `api:<api-ref-id>`
    namespace: apiRef.id,
    attachTo: { id: "app", input: "apis" },
    inputs: extensionInputs,
    configSchema,
    output: {
      api: createApiExtension.factoryDataRef
    },
    factory({ config, inputs }) {
      if (typeof factory === "function") {
        return { api: factory({ config, inputs }) };
      }
      return { api: factory };
    }
  });
}
((createApiExtension2) => {
  createApiExtension2.factoryDataRef = createExtensionDataRef("core.api.factory");
})(createApiExtension || (createApiExtension = {}));

function createAppRootElementExtension(options) {
  var _a;
  return createExtension({
    kind: "app-root-element",
    namespace: options.namespace,
    name: options.name,
    attachTo: (_a = options.attachTo) != null ? _a : { id: "app/root", input: "elements" },
    configSchema: options.configSchema,
    disabled: options.disabled,
    inputs: options.inputs,
    output: {
      element: coreExtensionData.reactElement
    },
    factory({ inputs, config }) {
      return {
        element: typeof options.element === "function" ? options.element({ inputs, config }) : options.element
      };
    }
  });
}

function createAppRootWrapperExtension(options) {
  var _a;
  return createExtension({
    kind: "app-root-wrapper",
    namespace: options.namespace,
    name: options.name,
    attachTo: (_a = options.attachTo) != null ? _a : { id: "app/root", input: "wrappers" },
    configSchema: options.configSchema,
    disabled: options.disabled,
    inputs: options.inputs,
    output: {
      component: createAppRootWrapperExtension.componentDataRef
    },
    factory({ inputs, config }) {
      const Component = (props) => {
        return /* @__PURE__ */ React.createElement(options.Component, { inputs, config }, props.children);
      };
      return {
        component: Component
      };
    }
  });
}
((createAppRootWrapperExtension2) => {
  createAppRootWrapperExtension2.componentDataRef = createExtensionDataRef(
    "app.root.wrapper"
  );
})(createAppRootWrapperExtension || (createAppRootWrapperExtension = {}));

function createRouterExtension(options) {
  var _a;
  return createExtension({
    kind: "app-router-component",
    namespace: options.namespace,
    name: options.name,
    attachTo: (_a = options.attachTo) != null ? _a : { id: "app/root", input: "router" },
    configSchema: options.configSchema,
    disabled: options.disabled,
    inputs: options.inputs,
    output: {
      component: createRouterExtension.componentDataRef
    },
    factory({ inputs, config }) {
      const Component = (props) => {
        return /* @__PURE__ */ React.createElement(options.Component, { inputs, config }, props.children);
      };
      return {
        component: Component
      };
    }
  });
}
((createRouterExtension2) => {
  createRouterExtension2.componentDataRef = createExtensionDataRef(
    "app.router.wrapper"
  );
})(createRouterExtension || (createRouterExtension = {}));

function createSchemaFromZod(schemaCreator) {
  const schema = schemaCreator(z);
  return {
    // TODO: Types allow z.array etc here but it will break stuff
    parse: (input) => {
      const result = schema.safeParse(input);
      if (result.success) {
        return result.data;
      }
      throw new Error(result.error.issues.map(formatIssue).join("; "));
    },
    // TODO: Verify why we are not compatible with the latest zodToJsonSchema.
    schema: zodToJsonSchema(schema)
  };
}
function formatIssue(issue) {
  if (issue.code === "invalid_union") {
    return formatIssue(issue.unionErrors[0].issues[0]);
  }
  let message = issue.message;
  if (message === "Required") {
    message = `Missing required value`;
  }
  if (issue.path.length) {
    message += ` at '${issue.path.join(".")}'`;
  }
  return message;
}

function createPageExtension(options) {
  var _a;
  const configSchema = "configSchema" in options ? options.configSchema : createSchemaFromZod(
    (z) => z.object({ path: z.string().default(options.defaultPath) })
  );
  return createExtension({
    kind: "page",
    namespace: options.namespace,
    name: options.name,
    attachTo: (_a = options.attachTo) != null ? _a : { id: "app/routes", input: "routes" },
    configSchema,
    inputs: options.inputs,
    disabled: options.disabled,
    output: {
      element: coreExtensionData.reactElement,
      path: coreExtensionData.routePath,
      routeRef: coreExtensionData.routeRef.optional()
    },
    factory({ config, inputs, node }) {
      const ExtensionComponent = lazy(
        () => options.loader({ config, inputs }).then((element) => ({ default: () => element }))
      );
      return {
        path: config.path,
        routeRef: options.routeRef,
        element: /* @__PURE__ */ React.createElement(ExtensionBoundary, { node, routable: true }, /* @__PURE__ */ React.createElement(ExtensionComponent, null))
      };
    }
  });
}

function createNavItemExtension(options) {
  const { routeRef, title, icon, namespace, name } = options;
  return createExtension({
    namespace,
    name,
    kind: "nav-item",
    attachTo: { id: "app/nav", input: "items" },
    configSchema: createSchemaFromZod(
      (z) => z.object({
        title: z.string().default(title)
      })
    ),
    output: {
      navTarget: createNavItemExtension.targetDataRef
    },
    factory: ({ config }) => ({
      navTarget: {
        title: config.title,
        icon,
        routeRef
      }
    })
  });
}
((createNavItemExtension2) => {
  createNavItemExtension2.targetDataRef = createExtensionDataRef("core.nav-item.target");
})(createNavItemExtension || (createNavItemExtension = {}));

function createNavLogoExtension(options) {
  const { logoIcon, logoFull } = options;
  return createExtension({
    kind: "nav-logo",
    name: options == null ? void 0 : options.name,
    namespace: options == null ? void 0 : options.namespace,
    attachTo: { id: "app/nav", input: "logos" },
    output: {
      logos: createNavLogoExtension.logoElementsDataRef
    },
    factory: () => {
      return {
        logos: {
          logoIcon,
          logoFull
        }
      };
    }
  });
}
((createNavLogoExtension2) => {
  createNavLogoExtension2.logoElementsDataRef = createExtensionDataRef("core.nav-logo.logo-elements");
})(createNavLogoExtension || (createNavLogoExtension = {}));

function createSignInPageExtension(options) {
  var _a;
  return createExtension({
    kind: "sign-in-page",
    namespace: options == null ? void 0 : options.namespace,
    name: options == null ? void 0 : options.name,
    attachTo: (_a = options.attachTo) != null ? _a : { id: "app/root", input: "signInPage" },
    configSchema: options.configSchema,
    inputs: options.inputs,
    disabled: options.disabled,
    output: {
      component: createSignInPageExtension.componentDataRef
    },
    factory({ config, inputs, node }) {
      const ExtensionComponent = lazy(
        () => options.loader({ config, inputs }).then((component) => ({ default: component }))
      );
      return {
        component: (props) => /* @__PURE__ */ React.createElement(ExtensionBoundary, { node, routable: true }, /* @__PURE__ */ React.createElement(ExtensionComponent, { ...props }))
      };
    }
  });
}
((createSignInPageExtension2) => {
  createSignInPageExtension2.componentDataRef = createExtensionDataRef("core.sign-in-page.component");
})(createSignInPageExtension || (createSignInPageExtension = {}));

function createThemeExtension(theme) {
  return createExtension({
    kind: "theme",
    namespace: "app",
    name: theme.id,
    attachTo: { id: "app", input: "themes" },
    output: {
      theme: createThemeExtension.themeDataRef
    },
    factory: () => ({ theme })
  });
}
((createThemeExtension2) => {
  createThemeExtension2.themeDataRef = createExtensionDataRef("core.theme.theme");
})(createThemeExtension || (createThemeExtension = {}));

function createComponentExtension(options) {
  return createExtension({
    kind: "component",
    namespace: options.ref.id,
    name: options.name,
    attachTo: { id: "app", input: "components" },
    inputs: options.inputs,
    disabled: options.disabled,
    configSchema: options.configSchema,
    output: {
      component: createComponentExtension.componentDataRef
    },
    factory({ config, inputs, node }) {
      let ExtensionComponent;
      if ("sync" in options.loader) {
        ExtensionComponent = options.loader.sync({ config, inputs });
      } else {
        const lazyLoader = options.loader.lazy;
        ExtensionComponent = lazy(
          () => lazyLoader({ config, inputs }).then((Component) => ({
            default: Component
          }))
        );
      }
      return {
        component: {
          ref: options.ref,
          impl: (props) => /* @__PURE__ */ React.createElement(ExtensionBoundary, { node }, /* @__PURE__ */ React.createElement(ExtensionComponent, { ...props }))
        }
      };
    }
  });
}
((createComponentExtension2) => {
  createComponentExtension2.componentDataRef = createExtensionDataRef("core.component.component");
})(createComponentExtension || (createComponentExtension = {}));

function createTranslationExtension(options) {
  return createExtension({
    kind: "translation",
    namespace: options.resource.id,
    name: options.name,
    attachTo: { id: "app", input: "translations" },
    output: {
      resource: createTranslationExtension.translationDataRef
    },
    factory: () => ({ resource: options.resource })
  });
}
((createTranslationExtension2) => {
  createTranslationExtension2.translationDataRef = createExtensionDataRef("core.translation.translation");
})(createTranslationExtension || (createTranslationExtension = {}));

const MESSAGE_MARKER = "eHgtF5hmbrXyiEvo";
function describeParentCallSite(ErrorConstructor = Error) {
  const { stack } = new ErrorConstructor(MESSAGE_MARKER);
  if (!stack) {
    return "<unknown>";
  }
  const startIndex = stack.includes(MESSAGE_MARKER) ? stack.indexOf("\n") + 1 : 0;
  const secondEntryStart = stack.indexOf("\n", stack.indexOf("\n", startIndex) + 1) + 1;
  const secondEntryEnd = stack.indexOf("\n", secondEntryStart);
  const line = stack.substring(secondEntryStart, secondEntryEnd).trim();
  if (!line) {
    return "unknown";
  }
  if (line.includes("(")) {
    return line.substring(line.indexOf("(") + 1, line.indexOf(")"));
  }
  if (line.includes("@")) {
    return line.substring(line.indexOf("@") + 1);
  }
  return line;
}

var __defProp$2 = Object.defineProperty;
var __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$2 = (obj, key, value) => {
  __defNormalProp$2(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var __accessCheck$1 = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet$1 = (obj, member, getter) => {
  __accessCheck$1(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd$1 = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet$1 = (obj, member, value, setter) => {
  __accessCheck$1(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var _id, _params$1, _creationSite, _name, name_get;
function toInternalRouteRef(resource) {
  const r = resource;
  if (r.$$type !== "@backstage/RouteRef") {
    throw new Error(`Invalid RouteRef, bad type '${r.$$type}'`);
  }
  return r;
}
class RouteRefImpl {
  constructor(params = [], creationSite) {
    this.params = params;
    __privateAdd$1(this, _name);
    __publicField$2(this, "$$type", "@backstage/RouteRef");
    __publicField$2(this, "version", "v1");
    __privateAdd$1(this, _id, void 0);
    __privateAdd$1(this, _params$1, void 0);
    __privateAdd$1(this, _creationSite, void 0);
    __privateSet$1(this, _params$1, params);
    __privateSet$1(this, _creationSite, creationSite);
  }
  getParams() {
    return __privateGet$1(this, _params$1);
  }
  getDescription() {
    if (__privateGet$1(this, _id)) {
      return __privateGet$1(this, _id);
    }
    return `created at '${__privateGet$1(this, _creationSite)}'`;
  }
  setId(id) {
    if (!id) {
      throw new Error(`${__privateGet$1(this, _name, name_get)} id must be a non-empty string`);
    }
    if (__privateGet$1(this, _id)) {
      throw new Error(
        `${__privateGet$1(this, _name, name_get)} was referenced twice as both '${__privateGet$1(this, _id)}' and '${id}'`
      );
    }
    __privateSet$1(this, _id, id);
  }
  toString() {
    return `${__privateGet$1(this, _name, name_get)}{${this.getDescription()}}`;
  }
}
_id = new WeakMap();
_params$1 = new WeakMap();
_creationSite = new WeakMap();
_name = new WeakSet();
name_get = function() {
  return this.$$type.slice("@backstage/".length);
};
function createRouteRef(config) {
  return new RouteRefImpl(
    config == null ? void 0 : config.params,
    describeParentCallSite()
  );
}

var __defProp$1 = Object.defineProperty;
var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$1 = (obj, key, value) => {
  __defNormalProp$1(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var _params, _parent;
const PARAM_PATTERN = /^\w+$/;
class SubRouteRefImpl {
  constructor(path, params, parent) {
    this.path = path;
    __publicField$1(this, "$$type", "@backstage/SubRouteRef");
    __publicField$1(this, "version", "v1");
    __privateAdd(this, _params, void 0);
    __privateAdd(this, _parent, void 0);
    __privateSet(this, _params, params);
    __privateSet(this, _parent, parent);
  }
  getParams() {
    return __privateGet(this, _params);
  }
  getParent() {
    return __privateGet(this, _parent);
  }
  getDescription() {
    const parent = toInternalRouteRef(__privateGet(this, _parent));
    return `at ${this.path} with parent ${parent.getDescription()}`;
  }
  toString() {
    return `SubRouteRef{${this.getDescription()}}`;
  }
}
_params = new WeakMap();
_parent = new WeakMap();
function createSubRouteRef(config) {
  const { path, parent } = config;
  const internalParent = toInternalRouteRef(parent);
  const parentParams = internalParent.getParams();
  const pathParams = path.split("/").filter((p) => p.startsWith(":")).map((p) => p.substring(1));
  const params = [...parentParams, ...pathParams];
  if (parentParams.some((p) => pathParams.includes(p))) {
    throw new Error(
      "SubRouteRef may not have params that overlap with its parent"
    );
  }
  if (!path.startsWith("/")) {
    throw new Error(`SubRouteRef path must start with '/', got '${path}'`);
  }
  if (path.endsWith("/")) {
    throw new Error(`SubRouteRef path must not end with '/', got '${path}'`);
  }
  for (const param of pathParams) {
    if (!PARAM_PATTERN.test(param)) {
      throw new Error(`SubRouteRef path has invalid param, got '${param}'`);
    }
  }
  const subRouteRef = new SubRouteRefImpl(
    path,
    params,
    parent
  );
  return subRouteRef;
}

var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
class ExternalRouteRefImpl extends RouteRefImpl {
  constructor(optional, params = [], creationSite) {
    super(params, creationSite);
    this.optional = optional;
    this.params = params;
    __publicField(this, "$$type", "@backstage/ExternalRouteRef");
  }
}
function createExternalRouteRef(options) {
  return new ExternalRouteRefImpl(
    Boolean(options == null ? void 0 : options.optional),
    options == null ? void 0 : options.params,
    describeParentCallSite()
  );
}

function useRouteRef(routeRef) {
  const { pathname } = useLocation();
  const versionedContext = useVersionedContext(
    "routing-context"
  );
  if (!versionedContext) {
    throw new Error("Routing context is not available");
  }
  const resolver = versionedContext.atVersion(1);
  const routeFunc = useMemo(
    () => resolver && resolver.resolve(routeRef, { pathname }),
    [resolver, routeRef, pathname]
  );
  if (!versionedContext) {
    throw new Error("useRouteRef used outside of routing context");
  }
  if (!resolver) {
    throw new Error("RoutingContext v1 not available");
  }
  const isOptional = "optional" in routeRef && routeRef.optional;
  if (!routeFunc && !isOptional) {
    throw new Error(`No path for ${routeRef}`);
  }
  return routeFunc;
}

function useRouteRefParams(_routeRef) {
  return useParams();
}

export { AnalyticsContext, ExtensionBoundary, analyticsApiRef, appTreeApiRef, componentsApiRef, coreComponentRefs, coreExtensionData, createApiExtension, createAppRootElementExtension, createAppRootWrapperExtension, createComponentExtension, createComponentRef, createExtension, createExtensionDataRef, createExtensionInput, createExtensionOverrides, createExternalRouteRef, createNavItemExtension, createNavLogoExtension, createPageExtension, createPlugin, createRouteRef, createRouterExtension, createSchemaFromZod, createSignInPageExtension, createSubRouteRef, createThemeExtension, createTranslationExtension, useAnalytics, useComponentRef, useRouteRef, useRouteRefParams };
//# sourceMappingURL=index.esm.js.map
