/// <reference types="react" />
import * as _backstage_frontend_plugin_api from '@backstage/frontend-plugin-api';
import { AnyExtensionInputMap, PortableSchema, ResolvedExtensionInputs, RouteRef } from '@backstage/frontend-plugin-api';
import { Entity } from '@backstage/catalog-model';
import { ResourcePermission } from '@backstage/plugin-permission-common';

/**
 * Returns true if the `owner` argument is a direct owner on the `entity` argument.
 *
 * @alpha
 * @remarks
 *
 * Note that this ownership is not the same as using the claims in the auth-resolver, it only will take into account ownership as expressed by direct entity relations.
 * It doesn't know anything about the additional groups that a user might belong to which the claims contain.
 */
declare function isOwnerOf(owner: Entity, entity: Entity): boolean;

/**
 * Utility type to expand type aliases into their equivalent type.
 * @ignore
 */
type Expand<T> = T extends infer O ? {
    [K in keyof O]: O[K];
} : never;

/**
 * A thin wrapper around the
 * {@link @backstage/plugin-permission-react#usePermission} hook which uses the
 * current entity in context to make an authorization request for the given
 * {@link @backstage/plugin-catalog-common#CatalogEntityPermission}.
 *
 * Note: this hook blocks the permission request until the entity has loaded in
 * context. If you have the entityRef and need concurrent requests, use the
 * `usePermission` hook directly.
 * @alpha
 */
declare function useEntityPermission(permission: ResourcePermission<'catalog-entity'>): {
    loading: boolean;
    allowed: boolean;
    error?: Error;
};

/** @alpha */
declare const catalogExtensionData: {
    entityContentTitle: _backstage_frontend_plugin_api.ConfigurableExtensionDataRef<string, {}>;
    entityFilterFunction: _backstage_frontend_plugin_api.ConfigurableExtensionDataRef<(entity: Entity) => boolean, {}>;
    entityFilterExpression: _backstage_frontend_plugin_api.ConfigurableExtensionDataRef<string, {}>;
};
/** @alpha */
declare function createEntityCardExtension<TConfig extends {
    filter?: string;
}, TInputs extends AnyExtensionInputMap>(options: {
    namespace?: string;
    name?: string;
    attachTo?: {
        id: string;
        input: string;
    };
    disabled?: boolean;
    inputs?: TInputs;
    configSchema?: PortableSchema<TConfig>;
    filter?: typeof catalogExtensionData.entityFilterFunction.T | typeof catalogExtensionData.entityFilterExpression.T;
    loader: (options: {
        config: TConfig;
        inputs: Expand<ResolvedExtensionInputs<TInputs>>;
    }) => Promise<JSX.Element>;
}): _backstage_frontend_plugin_api.ExtensionDefinition<TConfig>;
/** @alpha */
declare function createEntityContentExtension<TInputs extends AnyExtensionInputMap>(options: {
    namespace?: string;
    name?: string;
    attachTo?: {
        id: string;
        input: string;
    };
    disabled?: boolean;
    inputs?: TInputs;
    routeRef?: RouteRef;
    defaultPath: string;
    defaultTitle: string;
    filter?: typeof catalogExtensionData.entityFilterFunction.T | typeof catalogExtensionData.entityFilterExpression.T;
    loader: (options: {
        inputs: Expand<ResolvedExtensionInputs<TInputs>>;
    }) => Promise<JSX.Element>;
}): _backstage_frontend_plugin_api.ExtensionDefinition<{
    title: string;
    path: string;
    filter?: string | undefined;
}>;

export { catalogExtensionData, createEntityCardExtension, createEntityContentExtension, isOwnerOf, useEntityPermission };
