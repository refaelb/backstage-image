import { useState, useMemo, useCallback, useEffect, useRef } from 'react';
import { u as useApi, r as errorApiRef } from './esm/StorageApi-c8a5e616.esm.js';
import { createApiRef } from '@backstage/core-plugin-api';
import '@backstage/version-bridge';
import '@backstage/errors';

function createTranslationMessages(options) {
  return {
    $$type: "@backstage/TranslationMessages",
    id: options.ref.id,
    full: Boolean(options.full),
    messages: options.messages
  };
}

function createTranslationResource(options) {
  return {
    $$type: "@backstage/TranslationResource",
    version: "v1",
    id: options.ref.id,
    resources: Object.entries(options.translations).map(
      ([language, loader]) => ({
        language,
        loader: () => loader().then((m) => {
          const value = m.default;
          return {
            messages: (value == null ? void 0 : value.$$type) === "@backstage/TranslationMessages" ? value.messages : value
          };
        })
      })
    )
  };
}

var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var _id, _messages, _resources;
function flattenMessages(nested) {
  const entries = new Array();
  function visit(obj, prefix) {
    for (const [key, value] of Object.entries(obj)) {
      if (typeof value === "string") {
        entries.push([prefix + key, value]);
      } else {
        visit(value, `${prefix}${key}.`);
      }
    }
  }
  visit(nested, "");
  return Object.fromEntries(entries);
}
class TranslationRefImpl {
  constructor(options) {
    __privateAdd(this, _id, void 0);
    __privateAdd(this, _messages, void 0);
    __privateAdd(this, _resources, void 0);
    __publicField(this, "$$type", "@backstage/TranslationRef");
    __publicField(this, "version", "v1");
    __privateSet(this, _id, options.id);
    __privateSet(this, _messages, flattenMessages(
      options.messages
    ));
  }
  get id() {
    return __privateGet(this, _id);
  }
  get T() {
    throw new Error("Not implemented");
  }
  getDefaultMessages() {
    return __privateGet(this, _messages);
  }
  setDefaultResource(resources) {
    __privateSet(this, _resources, resources);
  }
  getDefaultResource() {
    return __privateGet(this, _resources);
  }
  toString() {
    return `TranslationRef{id=${this.id}}`;
  }
}
_id = new WeakMap();
_messages = new WeakMap();
_resources = new WeakMap();
function createTranslationRef(config) {
  const ref = new TranslationRefImpl(config);
  if (config.translations) {
    ref.setDefaultResource(
      createTranslationResource({
        ref,
        translations: config.translations
      })
    );
  }
  return ref;
}

const translationApiRef = createApiRef({
  id: "core.translation"
});

const appLanguageApiRef = createApiRef({
  id: "core.applanguage"
});

const loggedRefs = /* @__PURE__ */ new WeakSet();
const useTranslationRef = (translationRef) => {
  const errorApi = useApi(errorApiRef);
  const translationApi = useApi(translationApiRef);
  const [snapshot, setSnapshot] = useState(
    () => translationApi.getTranslation(translationRef)
  );
  const observable = useMemo(
    () => translationApi.translation$(translationRef),
    [translationApi, translationRef]
  );
  const onError = useCallback(
    (error) => {
      if (!loggedRefs.has(translationRef)) {
        const errMsg = `Failed to load translation resource '${translationRef.id}'; caused by ${error}`;
        console.error(errMsg);
        errorApi.post(new Error(errMsg));
        loggedRefs.add(translationRef);
      }
    },
    [errorApi, translationRef]
  );
  useEffect(() => {
    const subscription = observable.subscribe({
      next(next) {
        if (next.ready) {
          setSnapshot(next);
        }
      },
      error(error) {
        onError(error);
      }
    });
    return () => {
      subscription.unsubscribe();
    };
  }, [observable, onError]);
  const initialRenderRef = useRef(true);
  useEffect(() => {
    if (initialRenderRef.current) {
      initialRenderRef.current = false;
    } else {
      setSnapshot(translationApi.getTranslation(translationRef));
    }
  }, [translationApi, translationRef]);
  if (!snapshot.ready) {
    throw new Promise((resolve) => {
      const subscription = observable.subscribe({
        next(next) {
          if (next.ready) {
            subscription.unsubscribe();
            resolve();
          }
        },
        error(error) {
          subscription.unsubscribe();
          onError(error);
          resolve();
        }
      });
    });
  }
  return { t: snapshot.t };
};

export { appLanguageApiRef, createTranslationMessages, createTranslationRef, createTranslationResource, translationApiRef, useTranslationRef };
//# sourceMappingURL=alpha.esm.js.map
