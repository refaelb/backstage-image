import { BaseResource, BaseResourceOptions } from '@gitbeaker/requester-utils';

interface UserAgentDetailSchema extends Record<string, unknown> {
    user_agent: string;
    ip_address: string;
    akismet_submitted: boolean;
}
type CamelizeString<T extends PropertyKey> = T extends string ? string extends T ? string : T extends `${infer F}_${infer R}` ? `${F}${Capitalize<CamelizeString<R>>}` : T : T;
type Camelize<T> = {
    [K in keyof T as CamelizeString<K>]: T[K];
};
type Never<T> = {
    [P in keyof T]?: never;
};
type Only<T, U> = Required<T> & Never<U>;
type OnlyOrNone<T, U> = Partial<T> & Never<U>;
type OnlyOrNone3<T, U, V> = Partial<T> & Never<U> & Never<V>;
type OnlyOrNone4<T, U, V, W> = Partial<T> & Never<U> & Never<V> & Never<W>;
type Either<T, U> = Only<T, U> | Only<U, T>;
type EitherOrNone<T, U> = OnlyOrNone<T, U> | OnlyOrNone<U, T>;
type EitherOrNone3<T, U, V> = OnlyOrNone3<T, U, V> | OnlyOrNone3<U, T, V> | OnlyOrNone3<V, T, U>;
type EitherOrNone4<T, U, V, W> = OnlyOrNone4<T, U, V, W> | OnlyOrNone4<U, T, V, W> | OnlyOrNone4<V, T, U, W> | OnlyOrNone4<W, T, U, V>;

interface Sudo {
    sudo?: string | number;
}
interface ShowExpanded<E extends boolean = false> {
    showExpanded?: E;
}
type PaginationTypes = 'keyset' | 'offset';
type BaseRequestOptions<E extends boolean = false> = Sudo & ShowExpanded<E> & {
    [Key in string]?: any;
};
interface KeysetPaginationRequestOptions {
    orderBy: string;
    sort: 'asc' | 'dec';
}
interface OffsetPaginationRequestOptions {
    page?: number | string;
    maxPages?: number;
}
interface BasePaginationRequestOptions<P extends PaginationTypes | void> {
    pagination?: P;
    perPage?: number | string;
}
type PaginationRequestSubOptions<P extends PaginationTypes | void> = P extends 'keyset' ? KeysetPaginationRequestOptions : P extends 'offset' ? OffsetPaginationRequestOptions : Record<string, never>;
type PaginationRequestOptions<P extends PaginationTypes | void> = BasePaginationRequestOptions<P> & PaginationRequestSubOptions<P>;
type CamelizedResponse<T, C> = C extends true ? Camelize<T> : T;
interface OffsetPagination {
    total: number;
    next: number | null;
    current: number;
    previous: number | null;
    perPage: number;
    totalPages: number;
}
interface KeysetPagination {
    idAfter: number;
    perPage: number;
    orderBy: string;
    sort: 'asc' | 'dec';
}
interface ExpandedResponse<T> {
    data: T;
    headers: Record<string, string>;
    status: number;
}
type PaginatedResponse<T, P extends PaginationTypes = PaginationTypes> = {
    [U in P]: {
        paginationInfo: P extends 'keyset' ? KeysetPagination : OffsetPagination;
        data: T;
    };
}[P];
type GitlabAPIExpandedResponse<T, E extends boolean | void, P> = E extends true ? P extends PaginationTypes ? PaginatedResponse<T, P> : ExpandedResponse<T> : T;
type GitlabAPISingleResponse<T, C extends boolean | void, E extends boolean | void> = T extends Record<string, unknown> ? GitlabAPIExpandedResponse<CamelizedResponse<T, C>, E, undefined> : GitlabAPIExpandedResponse<T, E, undefined>;
type GitlabAPIMultiResponse<T, C extends boolean | void, E extends boolean | void, P extends PaginationTypes | void> = T extends Record<string, unknown> ? GitlabAPIExpandedResponse<CamelizedResponse<T, C>[], E, P> : GitlabAPIExpandedResponse<T[], E, P>;
type GitlabAPIResponse<T, C extends boolean | void, E extends boolean | void, P extends PaginationTypes | void> = T extends (infer R)[] ? GitlabAPIMultiResponse<R, C, E, P> : GitlabAPISingleResponse<T, C, E>;

interface ProjectRemoteMirrorSchema extends Record<string, unknown> {
    enabled: boolean;
    id: number;
    last_error?: string;
    last_successful_update_at: string;
    last_update_at: string;
    last_update_started_at: string;
    only_protected_branches: boolean;
    keep_divergent_refs: boolean;
    update_status: string;
    url: string;
}
declare class ProjectRemoteMirrors<C extends boolean = false> extends BaseResource<C> {
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(projectId: string | number, options?: Sudo & ShowExpanded<E> & PaginationRequestOptions<P>): Promise<GitlabAPIResponse<ProjectRemoteMirrorSchema[], C, E, P>>;
    createPullMirror<E extends boolean = false>(projectId: string | number, url: string, mirror: boolean, options?: {
        onlyProtectedBranches?: boolean;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<ProjectRemoteMirrorSchema, C, E, void>>;
    createPushMirror<E extends boolean = false>(projectId: string | number, url: string, options?: {
        enabled?: boolean;
        onlyProtectedBranches?: boolean;
        keepDivergentRefs?: boolean;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<ProjectRemoteMirrorSchema, C, E, void>>;
    edit<E extends boolean = false>(projectId: string | number, mirrorId: number, options?: {
        enabled?: boolean;
        onlyProtectedBranches?: boolean;
        keepDivergentRefs?: boolean;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<ProjectRemoteMirrorSchema, C, E, void>>;
    remove<E extends boolean = false>(name: string, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
    show<E extends boolean = false>(projectId: string | number, mirrorId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<ProjectRemoteMirrorSchema, C, E, void>>;
}

interface EventOptions {
    action?: 'created' | 'updated' | 'closed' | 'reopened' | 'pushed' | 'commented' | 'merged' | 'joined' | 'left' | 'destroyed' | 'expired';
    targetType?: 'issue' | 'milestone' | 'merge_request' | 'note' | 'project' | 'snippet' | 'user';
    before?: string;
    after?: string;
    scope?: string;
    sort?: 'asc' | 'desc';
}
interface EventSchema extends Record<string, unknown> {
    id: number;
    title?: string;
    project_id: number;
    action_name: string;
    target_id: number;
    target_type: string;
    author_id: number;
    target_title: string;
    created_at: string;
    author: Omit<UserSchema, 'created_at'>;
    author_username: string;
}
declare class Events<C extends boolean = false> extends BaseResource<C> {
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>({ projectId, userId, ...options }?: EitherOrNone<{
        projectId?: string | number;
    }, {
        userId: string | number;
    }> & PaginationRequestOptions<P> & BaseRequestOptions<E> & EventOptions): Promise<GitlabAPIResponse<EventSchema[], C, E, P>>;
}

type AccessLevel = 0 | 5 | 10 | 20 | 30 | 40 | 50;
interface AccessRequestSchema extends Record<string, unknown> {
    id: number;
    username: string;
    name: string;
    state: string;
    created_at: string;
    requested_at: string;
}
declare class ResourceAccessRequests<C extends boolean = false> extends BaseResource<C> {
    constructor(resourceType: string, options: BaseResourceOptions<C>);
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(resourceId: string | number, options?: PaginationRequestOptions<P> & BaseRequestOptions<E>): Promise<GitlabAPIResponse<AccessRequestSchema[], C, E, P>>;
    request<E extends boolean = false>(resourceId: string | number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<AccessRequestSchema, C, E, void>>;
    approve<E extends boolean = false>(resourceId: string | number, userId: number, options?: {
        accessLevel?: AccessLevel;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<AccessRequestSchema, C, E, void>>;
    deny<E extends boolean = false>(resourceId: string | number, userId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
}

type AccessTokenScopes = 'api' | 'read_api' | 'read_registry' | 'write_registry' | 'read_repository' | 'write_repository';
interface AccessTokenSchema extends Record<string, unknown> {
    user_id: number;
    scopes?: AccessTokenScopes[];
    name: string;
    expires_at: string;
    id: number;
    active: boolean;
    created_at: string;
    revoked: boolean;
    access_level: AccessLevel;
}
declare class ResourceAccessTokens<C extends boolean = false> extends BaseResource<C> {
    constructor(resourceType: string, options: BaseResourceOptions<C>);
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(resourceId: string | number, options?: Sudo & ShowExpanded<E> & PaginationRequestOptions<P>): Promise<GitlabAPIResponse<AccessTokenSchema[], C, E, P>>;
    create<E extends boolean = false>(resourceId: string | number, name: string, scopes: AccessTokenScopes[], options?: {
        accessLevel?: AccessLevel;
        expiresAt?: string;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<AccessTokenSchema, C, E, void>>;
    revoke<E extends boolean = false>(resourceId: string | number, tokenId: string | number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
    show<E extends boolean = false>(resourceId: string | number, tokenId: string | number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<AccessTokenSchema, C, E, void>>;
}

interface AwardEmojiSchema extends Record<string, unknown> {
    id: number;
    name: string;
    user: UserSchema;
    created_at: string;
    updated_at: string;
    awardable_id: number;
    awardable_type: string;
}
declare class ResourceAwardEmojis<C extends boolean = false> extends BaseResource<C> {
    protected resourceType2: string;
    constructor(resourceType1: string, resourceType2: string, options: BaseResourceOptions<C>);
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(resourceId: string | number, resourceIId: number, options?: PaginationRequestOptions<P> & BaseRequestOptions<E>): Promise<GitlabAPIResponse<AwardEmojiSchema[], C, E, P>>;
    award<E extends boolean = false>(resourceId: string | number, resourceIId: number, name: string, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<AwardEmojiSchema, C, E, void>>;
    remove<E extends boolean = false>(resourceId: string | number, resourceIId: number, awardId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
    show<E extends boolean = false>(resourceId: string | number, resourceIId: number, awardId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<AwardEmojiSchema, C, E, void>>;
}

interface BadgeSchema extends Record<string, unknown> {
    name: string;
    id: number;
    link_url: string;
    image_url: string;
    rendered_link_url: string;
    rendered_image_url: string;
    kind: 'project' | 'group';
}
type CondensedBadgeSchema = Omit<BadgeSchema, 'id' | 'name' | 'kind'>;
declare class ResourceBadges<C extends boolean = false> extends BaseResource<C> {
    constructor(resourceType: string, options: BaseResourceOptions<C>);
    add<E extends boolean = false>(resourceId: string | number, linkUrl: string, imageUrl: string, options?: BaseRequestOptions<E>): Promise<GitlabAPIResponse<BadgeSchema, C, E, void>>;
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(resourceId: string | number, options?: PaginationRequestOptions<P> & BaseRequestOptions<E>): Promise<GitlabAPIResponse<BadgeSchema[], C, E, P>>;
    edit<E extends boolean = false>(resourceId: string | number, badgeId: number, options?: BaseRequestOptions<E>): Promise<GitlabAPIResponse<BadgeSchema, C, E, void>>;
    preview<E extends boolean = false>(resourceId: string | number, linkUrl: string, imageUrl: string, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<CondensedBadgeSchema, C, E, void>>;
    remove<E extends boolean = false>(resourceId: string | number, badgeId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
    show<E extends boolean = false>(resourceId: string | number, badgeId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<BadgeSchema, C, E, void>>;
}

interface CustomAttributeSchema extends Record<string, unknown> {
    key: string;
    value: string;
}
declare class ResourceCustomAttributes<C extends boolean = false> extends BaseResource<C> {
    constructor(resourceType: string, options: BaseResourceOptions<C>);
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(resourceId: string | number, options?: PaginationRequestOptions<P> & BaseRequestOptions<E>): Promise<GitlabAPIResponse<CustomAttributeSchema[], C, E, P>>;
    remove<E extends boolean = false>(resourceId: string | number, customAttributeId: string, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
    set<E extends boolean = false>(resourceId: string | number, customAttributeId: string, value: string, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<CustomAttributeSchema, C, E, void>>;
    show<E extends boolean = false>(resourceId: string | number, customAttributeId: string, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<CustomAttributeSchema, C, E, void>>;
}

interface DiscussionNotePositionBaseSchema extends Record<string, unknown> {
    base_sha: string;
    start_sha: string;
    head_sha: string;
    position_type: 'text' | 'image';
    old_path?: string;
    new_path?: string;
}
type DiscussionNotePositionSchema = (DiscussionNotePositionBaseSchema & {
    position_type: 'text';
    new_line?: string;
    old_line?: string;
}) | (DiscussionNotePositionBaseSchema & {
    position_type: 'image';
    width?: string;
    height?: string;
    x?: number;
    y?: number;
});
interface DiscussionNoteSchema extends Record<string, unknown> {
    id: number;
    type?: string;
    body: string;
    attachment?: string;
    author: Omit<UserSchema, 'created_at'>;
    created_at: string;
    updated_at: string;
    system: boolean;
    noteable_id: number;
    noteable_type: string;
    noteable_iid?: number;
    resolvable?: boolean;
}
interface DiscussionSchema extends Record<string, unknown> {
    id: string;
    individual_note: boolean;
    notes?: DiscussionNoteSchema[];
}
declare class ResourceDiscussions<C extends boolean = false> extends BaseResource<C> {
    protected resource2Type: string;
    constructor(resourceType: string, resource2Type: string, options: BaseResourceOptions<C>);
    addNote<E extends boolean = false>(resourceId: string | number, resource2Id: string | number, discussionId: string | number, noteId: number, body: string, options?: BaseRequestOptions<E>): Promise<GitlabAPIResponse<DiscussionNoteSchema, C, E, void>>;
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(resourceId: string | number, resource2Id: string | number, options?: PaginationRequestOptions<P> & BaseRequestOptions<E>): Promise<GitlabAPIResponse<DiscussionSchema[], C, E, P>>;
    create<E extends boolean = false>(resourceId: string | number, resource2Id: string | number, body: string, { position, ...options }?: {
        position?: DiscussionNotePositionSchema;
        commitId?: string;
        createdAt?: string;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<DiscussionSchema, C, E, void>>;
    editNote<E extends boolean = false>(resourceId: string | number, resource2Id: string | number, discussionId: string | number, noteId: number, { body, ...options }?: Sudo & ShowExpanded<E> & {
        body?: string;
        resolved?: boolean;
    }): Promise<GitlabAPIResponse<DiscussionNoteSchema, C, E, void>>;
    removeNote<E extends boolean = false>(resourceId: string | number, resource2Id: string | number, discussionId: string | number, noteId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
    show<E extends boolean = false>(resourceId: string | number, resource2Id: string | number, discussionId: string | number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<DiscussionSchema, C, E, void>>;
}

type MetricType = 'deployment_frequency' | 'lead_time_for_changes';
interface DORA4MetricSchema extends Record<string, unknown> {
    date: string;
    value: number;
}
declare class ResourceDORA4Metrics<C extends boolean = false> extends BaseResource<C> {
    constructor(resourceType: string, options: BaseResourceOptions<C>);
    all<E extends boolean = false>(resourceId: string | number, metric: MetricType, options?: {
        startDate?: string;
        endDate?: string;
        interval?: string;
        environmentTier?: string;
    } & BaseRequestOptions<E>): Promise<GitlabAPIResponse<DORA4MetricSchema[], C, E, void>>;
}

interface HookSchema extends Record<string, unknown> {
    id: number;
    url: string;
    created_at: string;
    push_events: boolean;
    tag_push_events: boolean;
    merge_requests_events: boolean;
    repository_update_events: boolean;
    enable_ssl_verification: boolean;
}
interface ExpandedHookSchema extends HookSchema {
    push_events_branch_filter: string;
    issues_events: boolean;
    confidential_issues_events: boolean;
    note_events: boolean;
    confidential_note_events: boolean;
    job_events: boolean;
    pipeline_events: boolean;
    wiki_page_events: boolean;
    deployment_events: boolean;
    releases_events: boolean;
}
declare class ResourceHooks<C extends boolean = false> extends BaseResource<C> {
    constructor(resourceType: string, options: BaseResourceOptions<C>);
    add<E extends boolean = false>(resourceId: string | number, url: string, options?: BaseRequestOptions<E>): Promise<GitlabAPIResponse<ExpandedHookSchema, C, E, void>>;
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(resourceId: string | number, options?: PaginationRequestOptions<P> & BaseRequestOptions<E>): Promise<GitlabAPIResponse<ExpandedHookSchema[], C, E, P>>;
    edit<E extends boolean = false>(resourceId: string | number, hookId: number, url: string, options?: BaseRequestOptions<E>): Promise<GitlabAPIResponse<ExpandedHookSchema, C, E, void>>;
    remove<E extends boolean = false>(resourceId: string | number, hookId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
    show<E extends boolean = false>(resourceId: string | number, hookId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<ExpandedHookSchema, C, E, void>>;
}

interface InvitationSchema extends Record<string, unknown> {
    id: number;
    invite_email: string;
    created_at: string;
    access_level: number;
    expires_at: string;
    user_name: string;
    created_by_name: string;
}
declare class ResourceInvitations<C extends boolean = false> extends BaseResource<C> {
    constructor(resourceType: string, options: BaseResourceOptions<C>);
    add<E extends boolean = false>(resourceId: string | number, accessLevel: AccessLevel, options?: Either<{
        email: string;
    }, {
        userId: string;
    }> & BaseRequestOptions<E>): Promise<GitlabAPIResponse<InvitationSchema, C, E, void>>;
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(resourceId: string | number, options?: PaginationRequestOptions<P> & BaseRequestOptions<E>): Promise<GitlabAPIResponse<InvitationSchema[], C, E, P>>;
    edit<E extends boolean = false>(resourceId: string | number, email: string, options?: BaseRequestOptions<E>): Promise<GitlabAPIResponse<InvitationSchema, C, E, void>>;
    remove<E extends boolean = false>(resourceId: string | number, email: string, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<InvitationSchema, C, E, void>>;
}

interface CommitAction {
    /** The action to perform */
    action: 'create' | 'delete' | 'move' | 'update' | 'chmod';
    /** Full path to the file. Ex. lib/class.rb */
    filePath: string;
    /** Original full path to the file being moved.Ex.lib / class1.rb */
    previousPath?: string;
    /** File content, required for all except delete. Optional for move */
    content?: string;
    /** text or base64. text is default. */
    encoding?: string;
    /** Last known file commit id. Will be only considered in update, move and delete actions. */
    lastCommitId?: string;
    /** When true/false enables/disables the execute flag on the file. Only considered for chmod action. */
    execute_filemode?: boolean;
}
interface CondensedCommitSchema extends Record<string, unknown> {
    id: string;
    short_id: string;
    message: string;
    title: string;
    author_email: string;
    author_name: string;
    created_at: string;
}
interface CommitSchema extends CondensedCommitSchema {
    parent_ids?: string[];
    message: string;
    authored_date?: string;
    committer_name?: string;
    committer_email?: string;
    committed_date?: string;
    web_url: string;
}
interface CommitExpandedSchema extends CommitSchema {
    last_pipeline: {
        id: number;
        ref: string;
        sha: string;
        status: string;
    };
    stats: {
        additions: number;
        deletions: number;
        total: number;
    };
    status: string;
}
interface GPGSignatureSchema extends Record<string, unknown> {
    signature_type: 'PGP';
    verification_status: 'verified' | 'unverified';
    gpg_key_id: number;
    gpg_key_primary_keyid: string;
    gpg_key_user_name: string;
    gpg_key_user_email: string;
    gpg_key_subkey_id?: number;
    commit_source: string;
}
interface X509SignatureSchema extends Record<string, unknown> {
    signature_type: 'X509';
    verification_status: 'verified' | 'unverified';
    x509_certificate: {
        id: number;
        subject: string;
        subject_key_identifier: string;
        email: string;
        serial_number: string;
        certificate_status: string;
        x509_issuer: {
            id: number;
            subject: string;
            subject_key_identifier: string;
            crl_url: string;
        };
    };
    commit_source: string;
}
interface MissingSignatureSchema extends Record<string, unknown> {
    message: string;
}
type CommitSignatureSchema = GPGSignatureSchema | X509SignatureSchema | MissingSignatureSchema;
interface CommitCommentSchema extends Record<string, unknown> {
    note: string;
    line_type: 'new' | 'old';
    path: string;
    line: number;
    author: Omit<UserSchema, 'created_at'>;
}
interface CommitDiffSchema extends Record<string, unknown> {
    diff: string;
    new_path: string;
    old_path: string;
    a_mode?: string;
    b_mode: string;
    new_file: boolean;
    renamed_file: boolean;
    deleted_file: boolean;
}
interface CommitStatusSchema extends Record<string, unknown> {
    status: string;
    created_at: string;
    started_at?: string;
    name: string;
    allow_failure: boolean;
    author: Omit<UserSchema, 'created_at'>;
    description?: string;
    sha: string;
    target_url: string;
    finished_at?: string;
    id: number;
    ref: string;
}
interface CommitReferenceSchema extends Record<string, unknown> {
    type: 'branch' | 'tag' | 'all';
    name: string;
}
interface CommitDiscussionNoteSchema extends Omit<DiscussionNoteSchema, 'position'> {
    confidential?: boolean;
    commands_changes: Record<string, unknown>;
}
interface CommitDiscussionSchema extends Record<string, unknown> {
    id: string;
    individual_note: boolean;
    notes?: CommitDiscussionNoteSchema[];
}
declare class Commits<C extends boolean = false> extends BaseResource<C> {
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(projectId: string | number, options?: PaginationRequestOptions<P> & BaseRequestOptions<E>): Promise<GitlabAPIResponse<CommitSchema[], C, E, P>>;
    cherryPick<E extends boolean = false>(projectId: string | number, sha: string, branch: string, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<CommitSchema, C, E, void>>;
    allComments<E extends boolean = false, P extends PaginationTypes = 'offset'>(projectId: string | number, sha: string, options?: PaginationRequestOptions<P> & BaseRequestOptions<E>): Promise<GitlabAPIResponse<CommitCommentSchema[], C, E, P>>;
    create<E extends boolean = false>(projectId: string | number, branch: string, message: string, actions?: CommitAction[], options?: BaseRequestOptions<E>): Promise<GitlabAPIResponse<CommitExpandedSchema, C, E, void>>;
    createComment<E extends boolean = false>(projectId: string | number, sha: string, note: string, options?: BaseRequestOptions<E>): Promise<GitlabAPIResponse<CommitCommentSchema, C, E, void>>;
    diff<E extends boolean = false, P extends PaginationTypes = 'offset'>(projectId: string | number, sha: string, options?: PaginationRequestOptions<P> & BaseRequestOptions<E>): Promise<GitlabAPIResponse<CommitDiffSchema[], C, E, P>>;
    allDiscussions<E extends boolean = false, P extends PaginationTypes = 'offset'>(projectId: string | number, sha: string, options?: PaginationRequestOptions<P> & BaseRequestOptions<E>): Promise<GitlabAPIResponse<CommitDiscussionSchema[], C, E, P>>;
    editStatus<E extends boolean = false>(projectId: string | number, sha: string, options?: BaseRequestOptions<E>): Promise<GitlabAPIResponse<CommitStatusSchema, C, E, void>>;
    allReferences<E extends boolean = false, P extends PaginationTypes = 'offset'>(projectId: string | number, sha: string, options?: PaginationRequestOptions<P> & BaseRequestOptions<E>): Promise<GitlabAPIResponse<CommitReferenceSchema[], C, E, P>>;
    revert<E extends boolean = false>(projectId: string | number, sha: string, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<CommitSchema, C, E, void>>;
    show<E extends boolean = false>(projectId: string | number, sha: string, options?: BaseRequestOptions<E>): Promise<GitlabAPIResponse<CommitExpandedSchema, C, E, void>>;
    allStatuses<E extends boolean = false>(projectId: string | number, sha: string, options?: BaseRequestOptions<E>): Promise<GitlabAPIResponse<CommitStatusSchema[], C, E, void>>;
    allMergeRequests<E extends boolean = false>(projectId: string | number, sha: string, options?: BaseRequestOptions<E>): Promise<GitlabAPIResponse<MergeRequestSchema[], C, E, void>>;
    signature<E extends boolean = false>(projectId: string | number, sha: string, options?: BaseRequestOptions<E>): Promise<GitlabAPIResponse<CommitSignatureSchema, C, E, void>>;
}

interface PipelineVariableSchema extends Record<string, unknown> {
    key: string;
    variable_type?: string;
    value: string;
}
declare class PipelineScheduleVariables<C extends boolean = false> extends BaseResource<C> {
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(projectId: string | number, pipelineScheduleId: number, options?: Sudo & ShowExpanded<E> & PaginationRequestOptions<P>): Promise<GitlabAPIResponse<PipelineVariableSchema[], C, E, P>>;
    create<E extends boolean = false>(projectId: string | number, pipelineScheduleId: number, key: string, value: string, options?: {
        variableType?: 'env_var' | 'file';
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<PipelineVariableSchema, C, E, void>>;
    edit<E extends boolean = false>(projectId: string | number, pipelineScheduleId: number, key: string, value: string, options?: {
        variableType?: 'env_var' | 'file';
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<PipelineVariableSchema, C, E, void>>;
    remove<E extends boolean = false>(projectId: string | number, pipelineScheduleId: number, key: string, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
}

type PipelineStatus = 'created' | 'waiting_for_resource' | 'preparing' | 'pending' | 'running' | 'failed' | 'success' | 'canceled' | 'skipped' | 'manual' | 'scheduled';
interface PipelineSchema extends Record<string, unknown> {
    id: number;
    iid: number;
    project_id: number;
    sha: string;
    ref: string;
    status: string;
    source: string;
    created_at: string;
    updated_at: string;
    web_url: string;
}
interface ExpandedPipelineSchema extends PipelineSchema {
    before_sha: string;
    tag: boolean;
    yaml_errors?: unknown;
    user: Omit<UserSchema, 'created_at'>;
    started_at: string;
    finished_at: string;
    committed_at?: string;
    duration: number;
    queued_duration?: unknown;
    coverage?: unknown;
    detailed_status: {
        icon: string;
        text: string;
        label: string;
        group: string;
        tooltip: string;
        has_details: boolean;
        details_path: string;
        illustration?: null;
        favicon: string;
    };
}
interface PipelineTestCaseSchema {
    status: string;
    name: string;
    classname: string;
    execution_time: number;
    system_output?: string;
    stack_trace?: string;
}
interface PipelineTestSuiteSchema {
    name: string;
    total_time: number;
    total_count: number;
    success_count: number;
    failed_count: number;
    skipped_count: number;
    error_count: number;
    test_cases?: PipelineTestCaseSchema[];
}
interface PipelineTestReportSchema extends Record<string, unknown> {
    total_time: number;
    total_count: number;
    success_count: number;
    failed_count: number;
    skipped_count: number;
    error_count: number;
    test_suites?: PipelineTestSuiteSchema[];
}
interface PipelineTestReportSummarySchema extends Record<string, unknown> {
    total: {
        time: number;
        count: number;
        success: number;
        failed: number;
        skipped: number;
        error: number;
        suite_error?: null;
    };
    test_suites?: PipelineTestSuiteSchema[];
}
declare class Pipelines<C extends boolean = false> extends BaseResource<C> {
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(projectId: string | number, options?: PaginationRequestOptions<P> & BaseRequestOptions<E>): Promise<GitlabAPIResponse<PipelineSchema[], C, E, P>>;
    allVariables<E extends boolean = false>(projectId: string | number, pipelineId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<PipelineVariableSchema[], C, E, void>>;
    cancel<E extends boolean = false>(projectId: string | number, pipelineId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<ExpandedPipelineSchema, C, E, void>>;
    create<E extends boolean = false>(projectId: string | number, ref: string, options?: {
        variables?: PipelineVariableSchema[];
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<ExpandedPipelineSchema, C, E, void>>;
    remove<E extends boolean = false>(projectId: string | number, pipelineId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
    retry<E extends boolean = false>(projectId: string | number, pipelineId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<ExpandedPipelineSchema, C, E, void>>;
    show<E extends boolean = false>(projectId: string | number, pipelineId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<ExpandedPipelineSchema, C, E, void>>;
    showTestReport<E extends boolean = false>(projectId: string | number, pipelineId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<PipelineTestReportSchema, C, E, void>>;
    showTestReportSummary<E extends boolean = false>(projectId: string | number, pipelineId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<PipelineTestReportSummarySchema, C, E, void>>;
}

type TodoAction = 'assigned' | 'mentioned' | 'build_failed' | 'marked' | 'approval_required' | 'unmergeable' | 'directly_addressed' | 'merge_train_removed';
type TodoType = 'Issue' | 'MergeRequest' | 'Commit' | 'Epic' | 'DesignManagement::Design' | 'AlertManagement::Alert';
type TodoState = 'pending' | 'done';
interface TodoSchema extends Record<string, unknown> {
    id: number;
    author: Omit<UserSchema, 'created_at'>;
    project: Pick<SimpleProjectSchema, 'id' | 'name' | 'name_with_namespace' | 'path' | 'path_with_namespace'>;
    action_name: TodoAction;
    target_type: TodoType;
    target: Record<string, unknown>;
    target_url: string;
    body: string;
    state: TodoState;
    created_at: string;
    updated_at: string;
}
declare class TodoLists<C extends boolean = false> extends BaseResource<C> {
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(options?: {
        action?: TodoAction;
        authorId?: number;
        projectId?: string | number;
        groupId?: string | number;
        state?: TodoState;
        type?: TodoType;
    } & Sudo & ShowExpanded<E> & PaginationRequestOptions<P>): Promise<GitlabAPIResponse<TodoSchema[], C, E, P>>;
    done<E extends boolean = false>(options: {
        todoId: number;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<TodoSchema, C, E, void>>;
    done<E extends boolean = false>(options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
}

interface AllMergeRequestsOptions {
    state?: 'opened' | 'closed' | 'locked' | 'merged';
    orderBy?: 'created_at' | 'updated_at';
    sort?: 'asc' | 'desc';
    milestone?: 'None' | string;
    view?: string;
    labels?: string | Array<string>;
    withLabelsDetails?: boolean;
    withMergeStatusRecheck?: boolean;
    createdAfter?: string;
    createdBefore?: string;
    updatedBefore?: string;
    updatedAfter?: string;
    scope?: 'created_by_me' | 'assigned_to_me' | 'all';
    authorId?: number;
    authorUsername?: string;
    assigneeId?: number;
    approverIds?: Array<number>;
    approvedByIds?: Array<number>;
    reviewerId?: number | 'Any' | 'None';
    reviewerUsername?: string;
    myReactionEmoji?: string;
    sourceBranch?: string;
    targetBranch?: string;
    search?: string;
    in?: string;
    wip?: string;
    not?: {
        labels?: string | Array<string>;
        milestone?: string;
        authorId?: number;
        authorUsername?: string;
        assigneeId?: number;
        assigneeUsername?: string;
        reviewerId?: number;
        reviewerUsername?: string;
        myReactionEmoji?: string;
    };
    environment?: string;
    deployedBefore?: string;
    deployedAfter?: string;
}
interface AcceptMergeRequestOptions {
    mergeCommitMessage?: string;
    squashCommitMessage?: string;
    squash?: boolean;
    shouldRemoveSourceBranch?: boolean;
    mergeWhenPipelineSucceeds?: boolean;
    sha?: string;
}
interface CreateMergeRequestOptions {
    assigneeId?: number;
    description?: string;
    targetProjectId?: number;
    labels?: string | Array<string>;
    milestoneId?: number;
    removeSourceBranch?: boolean;
    allowCollaboration?: boolean;
    allowMaintainerToPush?: boolean;
    squash?: boolean;
}
interface UpdateMergeRequestOptions {
    targetBranch?: number;
    title?: string;
    assigneeId?: number;
    reviewerId?: number;
    milestoneId?: number;
    labels?: string | Array<string>;
    description?: string;
    stateEvent?: string;
    removeSourceBranch?: boolean;
    squash?: boolean;
    discussionLocked?: boolean;
    allowCollaboration?: boolean;
    allowMaintainerToPush?: boolean;
}
interface DiffRefsSchema {
    base_sha: string;
    head_sha: string;
    start_sha: string;
}
interface MergeRequestChanges {
    old_path: string;
    new_path: string;
    a_mode: string;
    b_mode: string;
    new_file: boolean;
    renamed_file: boolean;
    deleted_file: boolean;
    diff: string;
}
interface ReferenceSchema {
    short: string;
    relative: string;
    full: string;
}
interface TaskCompletionStatusSchema {
    count: number;
    completed_count: number;
}
interface MergeRequestDiffVersionsSchema extends Record<string, unknown> {
    id: number;
    head_commit_sha: string;
    base_commit_sha: string;
    start_commit_sha: string;
    created_at: string;
    merge_request_id: number;
    state: string;
    real_size: string;
}
interface ExpandedMergeRequestDiffVersionsSchema extends Record<string, unknown> {
    id: number;
    head_commit_sha: string;
    base_commit_sha: string;
    start_commit_sha: string;
    created_at: string;
    merge_request_id: number;
    state: string;
    real_size: string;
    commits: CommitSchema[];
    diffs: CommitDiffSchema[];
}
interface MergeRequestRebaseSchema extends Record<string, unknown> {
    rebase_in_progress?: boolean;
    merge_error?: string;
}
interface CondensedMergeRequestSchema extends Record<string, unknown> {
    id: number;
    iid: number;
    project_id: number;
    title: string;
    description: string;
    state: string;
    created_at: string;
    updated_at: string;
    web_url: string;
}
interface MergeRequestSchema extends CondensedMergeRequestSchema {
    merged_by: Omit<UserSchema, 'created_at'>;
    merged_at: string;
    closed_by?: Omit<UserSchema, 'created_at'>;
    closed_at?: Omit<UserSchema, 'created_at'>;
    target_branch: string;
    source_branch: string;
    user_notes_count: number;
    upvotes: number;
    downvotes: number;
    author: Omit<UserSchema, 'created_at'>;
    assignees?: Omit<UserSchema, 'created_at'>[];
    assignee?: Omit<UserSchema, 'created_at'>;
    reviewers?: Omit<UserSchema, 'created_at'>[];
    source_project_id: number;
    target_project_id: number;
    labels?: string[];
    draft: boolean;
    work_in_progress: boolean;
    milestone?: MilestoneSchema;
    merge_when_pipeline_succeeds: boolean;
    merge_status: 'unchecked' | 'checking' | 'can_be_merged' | 'cannot_be_merged' | 'cannot_be_merged_recheck';
    sha: string;
    merge_commit_sha: string;
    squash_commit_sha?: string;
    discussion_locked?: boolean;
    should_remove_source_branch?: boolean;
    force_remove_source_branch: boolean;
    reference: string;
    references: ReferenceSchema;
    time_stats: TimeStatsSchema;
    squash: boolean;
    task_completion_status: TaskCompletionStatusSchema;
    has_conflicts: boolean;
    blocking_discussions_resolved: boolean;
    approvals_before_merge?: unknown;
}
interface ExpandedMergeRequestSchema extends MergeRequestSchema {
    subscribed: boolean;
    changes_count: string;
    latest_build_started_at: string;
    latest_build_finished_at: string;
    first_deployed_to_production_at?: null;
    pipeline: PipelineSchema;
    head_pipeline: ExpandedPipelineSchema;
    diff_refs: DiffRefsSchema;
    merge_error?: null;
    first_contribution: boolean;
    user: {
        can_merge: boolean;
    };
}
interface MergeRequestWithChangesSchema extends ExpandedMergeRequestSchema {
    changes?: MergeRequestChanges[];
    overflow: boolean;
}
interface MergeRequestTodoSchema extends TodoSchema {
    project: SimpleProjectSchema;
    target_type: 'MergeRequest';
    target: ExpandedMergeRequestSchema;
}
declare class MergeRequests<C extends boolean = false> extends BaseResource<C> {
    accept<E extends boolean = false>(projectId: string | number, mergerequestIId: number, options?: AcceptMergeRequestOptions & BaseRequestOptions<E>): Promise<GitlabAPIResponse<ExpandedPipelineSchema, C, E, void>>;
    addSpentTime<E extends boolean = false>(projectId: string | number, mergerequestIId: number, duration: string, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<TimeStatsSchema, C, E, void>>;
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>({ projectId, groupId, ...options }?: AllMergeRequestsOptions & Either<{
        projectId: string | number;
    }, {
        groupId: string | number;
    }> & PaginationRequestOptions<P> & BaseRequestOptions<E>): Promise<GitlabAPIResponse<MergeRequestSchema[], C, E, P>>;
    cancelOnPipelineSuccess<E extends boolean = false>(projectId: string | number, mergerequestIId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<ExpandedMergeRequestSchema, C, E, void>>;
    allChanges<E extends boolean = false>(projectId: string | number, mergerequestIId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<MergeRequestWithChangesSchema[], C, E, void>>;
    allIssuesClosed<E extends boolean = false>(projectId: string | number, mergerequestIId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<IssueSchema[], C, E, void>>;
    allCommits<E extends boolean = false>(projectId: string | number, mergerequestIId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<CommitSchema[], C, E, void>>;
    create<E extends boolean = false>(projectId: string | number, sourceBranch: string, targetBranch: string, title: string, options?: CreateMergeRequestOptions & BaseRequestOptions<E>): Promise<GitlabAPIResponse<ExpandedMergeRequestSchema, C, E, void>>;
    createPipeline<E extends boolean = false>(projectId: string | number, mergerequestIId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<ExpandedPipelineSchema, C, E, void>>;
    createTodo<E extends boolean = false>(projectId: string | number, mergerequestIId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<MergeRequestTodoSchema, C, E, void>>;
    allDiffVersions<E extends boolean = false>(projectId: string | number, mergerequestIId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<MergeRequestDiffVersionsSchema[], C, E, void>>;
    edit<E extends boolean = false>(projectId: string | number, mergerequestIId: number, options?: UpdateMergeRequestOptions & BaseRequestOptions<E>): Promise<GitlabAPIResponse<ExpandedPipelineSchema, C, E, void>>;
    merge<E extends boolean = false>(projectId: string | number, mergerequestIId: number, options?: AcceptMergeRequestOptions & BaseRequestOptions<E>): Promise<GitlabAPIResponse<ExpandedPipelineSchema, C, E, void>>;
    mergeToDefault<E extends boolean = false>(projectId: string | number, mergerequestIId: number, options?: UpdateMergeRequestOptions & BaseRequestOptions<E>): Promise<GitlabAPIResponse<{
        commit_id: string;
    }, C, E, void>>;
    allParticipants<E extends boolean = false>(projectId: string | number, mergerequestIId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<Omit<UserSchema, 'created_at'>[], C, E, void>>;
    allPipelines<E extends boolean = false>(projectId: string | number, mergerequestIId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<Pick<PipelineSchema, 'id' | 'sha' | 'ref' | 'status'>[], C, E, void>>;
    rebase<E extends boolean = false>(projectId: string | number, mergerequestIId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<MergeRequestRebaseSchema, C, E, void>>;
    remove<E extends boolean = false>(projectId: string | number, mergerequestIId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
    resetSpentTime<E extends boolean = false>(projectId: string | number, mergerequestIId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<TimeStatsSchema, C, E, void>>;
    resetTimeEstimate<E extends boolean = false>(projectId: string | number, mergerequestIId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<TimeStatsSchema, C, E, void>>;
    setTimeEstimate<E extends boolean = false>(projectId: string | number, mergerequestIId: number, duration: string, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<TimeStatsSchema, C, E, void>>;
    show<E extends boolean = false>(projectId: string | number, mergerequestIId: number, options?: {
        renderHtml?: boolean;
        includeDivergedCommitsCount?: true;
        includeRebaseInProgress?: boolean;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<ExpandedMergeRequestSchema, C, E, void>>;
    showDiffVersion<E extends boolean = false>(projectId: string | number, mergerequestIId: number, versionId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<ExpandedMergeRequestDiffVersionsSchema, C, E, void>>;
    showTimeStats<E extends boolean = false>(projectId: string | number, mergerequestIId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<TimeStatsSchema, C, E, void>>;
    subscribe<E extends boolean = false>(projectId: string | number, mergerequestIId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<ExpandedMergeRequestSchema, C, E, void>>;
    unsubscribe<E extends boolean = false>(projectId: string | number, mergerequestIId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<ExpandedMergeRequestSchema, C, E, void>>;
}

interface MetricImageSchema extends Record<string, unknown> {
    id: number;
    created_at: string;
    filename: string;
    file_path: string;
    url: string;
    url_text: string;
}
declare class AlertManagement<C extends boolean = false> extends BaseResource<C> {
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(projectId: string | number, alertIId: number, options?: PaginationRequestOptions<P> & BaseRequestOptions<E>): Promise<GitlabAPIResponse<MetricImageSchema[], C, E, P>>;
    edit<E extends boolean = false>(projectId: string | number, alertIId: number, imageId: number, options?: {
        url?: string;
        urlText?: string;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<MetricImageSchema, C, E, void>>;
    remove<E extends boolean = false>(projectId: string | number, alertIId: number, imageId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
    upload<E extends boolean = false>(projectId: string | number, alertIId: number, content: Blob, { filename, url, urlText, ...options }?: {
        url?: string;
        urlText?: string;
        filename?: string;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<MetricImageSchema, C, E, void>>;
}

interface TimeStatsSchema extends Record<string, unknown> {
    time_estimate: number;
    total_time_spent: number;
    human_time_estimate: string;
    human_total_time_spent: string;
}
interface IssueSchema extends Record<string, unknown> {
    state: string;
    description: string;
    health_status?: string;
    weight?: number;
    author: Omit<UserSchema, 'created_at'>;
    milestone: MilestoneSchema;
    project_id: number;
    assignees?: Omit<UserSchema, 'created_at'>[];
    type: string;
    updated_at: string;
    closed_at?: string;
    closed_by?: string;
    id: number;
    title: string;
    created_at: string;
    moved_to_id?: string;
    iid: number;
    labels?: string[];
    upvotes: number;
    downvotes: number;
    merge_requests_count: number;
    user_notes_count: number;
    due_date: string;
    web_url: string;
    references: {
        short: string;
        relative: string;
        full: string;
    };
    time_stats: TimeStatsSchema;
    has_tasks: boolean;
    task_status: string;
    confidential: boolean;
    discussion_locked: boolean;
    _links: {
        self: string;
        notes: string;
        award_emoji: string;
        project: string;
    };
    task_completion_status: {
        count: number;
        completed_count: number;
    };
    subscribed: boolean;
    epic?: {
        id: number;
        iid: number;
        title: string;
        url: string;
        group_id: number;
    };
}
declare class Issues<C extends boolean = false> extends BaseResource<C> {
    addSpentTime<E extends boolean = false>(projectId: string | number, issueIId: number, duration: string, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<TimeStatsSchema, C, E, void>>;
    addTimeEstimate<E extends boolean = false>(projectId: string | number, issueIId: number, duration: string, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<TimeStatsSchema, C, E, void>>;
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>({ projectId, groupId, ...options }?: EitherOrNone<{
        projectId?: string | number;
    }, {
        groupId?: string | number;
    }> & PaginationRequestOptions<P> & BaseRequestOptions<E>): Promise<GitlabAPIResponse<IssueSchema[], C, E, P>>;
    allMetricImages<E extends boolean = false>(projectId: string | number, issueIId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<MetricImageSchema[], C, E, void>>;
    create<E extends boolean = false>(projectId: string | number, options?: BaseRequestOptions<E>): Promise<GitlabAPIResponse<IssueSchema, C, E, void>>;
    createTodo<E extends boolean = false>(projectId: string | number, issueIId: number, options?: BaseRequestOptions<E>): Promise<GitlabAPIResponse<TodoSchema, C, E, void>>;
    clone<E extends boolean = false>(projectId: string | number, issueIId: number, destinationProjectId: string | number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<IssueSchema, C, E, void>>;
    edit<E extends boolean = false>(projectId: string | number, issueIId: number, options?: BaseRequestOptions<E>): Promise<GitlabAPIResponse<IssueSchema, C, E, void>>;
    editMetricImage<E extends boolean = false>(projectId: string | number, issueIId: number, imageId: number, options?: {
        url?: string;
        urlText?: string;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<MetricImageSchema, C, E, void>>;
    move<E extends boolean = false>(projectId: string | number, issueIId: number, destinationProjectId: string | number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<IssueSchema, C, E, void>>;
    allParticipants<E extends boolean = false>(projectId: string | number, issueIId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<Omit<UserSchema, 'created_at'>[], C, E, void>>;
    promote<E extends boolean = false>(projectId: string | number, issueIId: number, body: string, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<IssueSchema, C, E, void>>;
    allRelatedMergeRequests<E extends boolean = false>(projectId: string | number, issueIId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<MergeRequestSchema[], C, E, void>>;
    remove<E extends boolean = false>(projectId: string | number, issueIId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
    removeMetricImage<E extends boolean = false>(projectId: string | number, issueIId: number, imageId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
    reorder<E extends boolean = false>(projectId: string | number, issueIId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
    resetSpentTime<E extends boolean = false>(projectId: string | number, issueIId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<TimeStatsSchema, C, E, void>>;
    resetTimeEstimate<E extends boolean = false>(projectId: string | number, issueIId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<TimeStatsSchema, C, E, void>>;
    show<E extends boolean = false>(issueId: number, { projectId, ...options }?: {
        projectId?: string | number;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<IssueSchema, C, E, void>>;
    subscribe<E extends boolean = false>(projectId: string | number, issueIId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<IssueSchema, C, E, void>>;
    allClosedByMergeRequestst<E extends boolean = false>(projectId: string | number, issueIId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<MergeRequestSchema[], C, E, void>>;
    showTimeStats<E extends boolean = false>(projectId: string | number, issueIId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<TimeStatsSchema, C, E, void>>;
    unsubscribe<E extends boolean = false>(projectId: string | number, issueIId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<IssueSchema, C, E, void>>;
    uploadMetricImage<E extends boolean = false>(projectId: string | number, issueIId: number, content: Blob, { filename, ...options }?: {
        filename?: string;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<MetricImageSchema, C, E, void>>;
    showUserAgentDetails<E extends boolean = false>(projectId: string | number, issueIId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<UserAgentDetailSchema, C, E, void>>;
}

interface MilestoneSchema extends Record<string, unknown> {
    id: number;
    iid: number;
    project_id: number;
    title: string;
    description: string;
    due_date?: string;
    start_date: string;
    state: string;
    updated_at: string;
    created_at: string;
    expired: boolean;
    web_url: string;
}
declare class ResourceMilestones<C extends boolean = false> extends BaseResource<C> {
    constructor(resourceType: string, options: BaseResourceOptions<C>);
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(resourceId: string | number, options?: PaginationRequestOptions<P> & BaseRequestOptions<E>): Promise<GitlabAPIResponse<MilestoneSchema[], C, E, P>>;
    allAssignedIssues<E extends boolean = false>(resourceId: string | number, milestoneId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<IssueSchema[], C, E, void>>;
    allAssignedMergeRequests<E extends boolean = false>(resourceId: string | number, milestoneId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<MergeRequestSchema[], C, E, void>>;
    create<E extends boolean = false>(resourceId: string | number, title: string, options?: {
        description?: string;
        dueDate?: string;
        startDate?: string;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<MilestoneSchema, C, E, void>>;
    edit<E extends boolean = false>(resourceId: string | number, milestoneId: number, options?: {
        title?: string;
        description?: string;
        dueDate?: string;
        startDate?: string;
        startEvent?: 'close' | 'activate';
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<MilestoneSchema, C, E, void>>;
    remove<E extends boolean = false>(resourceId: string | number, milestoneId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
    show<E extends boolean = false>(resourceId: string | number, milestoneId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<MilestoneSchema, C, E, void>>;
    showBurndownChartEvents<E extends boolean = false>(resourceId: string | number, milestoneId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
}

interface LabelSchema extends Record<string, unknown> {
    id: number;
    name: string;
    color: string;
    text_color: string;
    description: string;
    description_html: string;
    open_issues_count: number;
    closed_issues_count: number;
    open_merge_requests_count: number;
    subscribed: boolean;
    priority: number;
    is_project_label: boolean;
}
declare class ResourceLabels<C extends boolean = false> extends BaseResource<C> {
    constructor(resourceType: string, options: BaseResourceOptions<C>);
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(resourceId: string | number, options?: PaginationRequestOptions<P> & BaseRequestOptions<E>): Promise<GitlabAPIResponse<LabelSchema[], C, E, P>>;
    create<E extends boolean = false>(resourceId: string | number, labelName: string, color: string, options?: {
        description?: string;
        priority?: number;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<LabelSchema, C, E, void>>;
    edit<E extends boolean = false>(resourceId: number | string, labelId: number | string, options: Either<{
        newName: string;
    }, {
        color: string;
    }> & {
        description?: string;
        priority?: number;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<LabelSchema, C, E, void>>;
    promote<E extends boolean = false>(resourceId: string | number, labelId: number | string, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<LabelSchema, C, E, void>>;
    remove<E extends boolean = false>(resourceId: string | number, labelId: number | string, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
    show<E extends boolean = false>(resourceId: string | number, labelId: number | string, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<LabelSchema, C, E, void>>;
    subscribe<E extends boolean = false>(resourceId: string | number, labelId: number | string, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<LabelSchema, C, E, void>>;
    unsubscribe<E extends boolean = false>(resourceId: string | number, labelId: number | string, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<LabelSchema, C, E, void>>;
}

interface IssueBoardListSchema extends Record<string, unknown> {
    id: number;
    label: Pick<LabelSchema, 'name' | 'color' | 'description'>;
    position: number;
    max_issue_count: number;
    max_issue_weight: number;
    limit_metric?: string;
}
interface IssueBoardSchema extends Record<string, unknown> {
    id: number;
    name: string;
    milestone: Pick<MilestoneSchema, 'id' | 'title'>;
    lists?: IssueBoardListSchema[];
}
declare class ResourceIssueBoards<C extends boolean = false> extends BaseResource<C> {
    constructor(resourceType: string, options: BaseResourceOptions<C>);
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(resourceId: string | number, options?: PaginationRequestOptions<P> & BaseRequestOptions<E>): Promise<GitlabAPIResponse<IssueBoardSchema[], C, E, P>>;
    create<E extends boolean = false>(resourceId: string | number, name: string, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<IssueBoardSchema, C, E, void>>;
    createList<E extends boolean = false>(resourceId: string | number, boardId: number, options?: EitherOrNone3<{
        labelId?: number;
    }, {
        assigneeId?: number;
    }, {
        milestoneId?: number;
    }> & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<IssueBoardListSchema, C, E, void>>;
    edit<E extends boolean = false>(resourceId: string | number, boardId: number, options?: BaseRequestOptions<E>): Promise<GitlabAPIResponse<IssueBoardSchema, C, E, void>>;
    editList<E extends boolean = false>(resourceId: string | number, boardId: number, listId: number, position: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<IssueBoardListSchema, C, E, void>>;
    lists<E extends boolean = false>(resourceId: string | number, boardId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<IssueBoardListSchema[], C, E, void>>;
    remove<E extends boolean = false>(resourceId: string | number, boardId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
    removeList<E extends boolean = false>(resourceId: string | number, boardId: number, listId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
    show<E extends boolean = false>(resourceId: string | number, boardId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<IssueBoardSchema, C, E, void>>;
    showList<E extends boolean = false>(resourceId: string | number, boardId: number, listId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<IssueBoardListSchema, C, E, void>>;
}

interface IterationSchema extends Record<string, unknown> {
    id: number;
    iid: number;
    group_id: number;
    title: string;
    description: string;
    state: number;
    created_at: string;
    updated_at: string;
    due_date: string;
    start_date: string;
    web_url: string;
}
declare class ResourceIterations<C extends boolean = false> extends BaseResource<C> {
    constructor(resourceType: string, options: BaseResourceOptions<C>);
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(resourceId: string | number, options?: {
        state?: 'opened' | 'upcoming' | 'current' | 'closed' | 'all';
        search?: string;
        includeAncestors?: boolean;
    } & BaseRequestOptions<E> & PaginationRequestOptions<P>): Promise<GitlabAPIResponse<IterationSchema[], C, E, P>>;
}

interface IterationEventSchema extends Record<string, unknown> {
    id: number;
    user: Omit<UserSchema, 'created_at'>;
    created_at: string;
    resource_type: 'Issue';
    resource_id: number;
    iteration: IterationSchema;
    action: 'add' | 'remove';
}
declare class ResourceIterationEvents<C extends boolean = false> extends BaseResource<C> {
    protected resource2Type: string;
    constructor(resourceType: string, resource2Type: string, options: BaseResourceOptions<C>);
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(resourceId: string | number, resource2Id: string | number, options?: Sudo & ShowExpanded<E> & PaginationRequestOptions<P>): Promise<GitlabAPIResponse<IterationEventSchema[], C, E, P>>;
    show<E extends boolean = false>(resourceId: string | number, resource2Id: string | number, iterationEventId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<IterationEventSchema, C, E, void>>;
}

interface LabelEventSchema extends Record<string, unknown> {
    id: number;
    user: Omit<UserSchema, 'created_at'>;
    created_at: string;
    resource_type: 'Issue' | 'Epic' | 'MergeRequest';
    resource_id: number;
    label: LabelSchema;
    action: 'add' | 'remove';
}
declare class ResourceLabelEvents<C extends boolean = false> extends BaseResource<C> {
    protected resource2Type: string;
    constructor(resourceType: string, resource2Type: string, options: BaseResourceOptions<C>);
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(resourceId: string | number, resource2Id: string | number, options?: Sudo & ShowExpanded<E> & PaginationRequestOptions<P>): Promise<GitlabAPIResponse<LabelEventSchema[], C, E, P>>;
    show<E extends boolean = false>(resourceId: string | number, resource2Id: string | number, labelEventId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<LabelEventSchema, C, E, void>>;
}

interface IncludeInherited {
    includeInherited?: boolean;
}
interface CondensedMemberSchema extends Record<string, unknown> {
    id: number;
    username: string;
    name: string;
    state: string;
    avatar_url: string;
    web_url: string;
}
interface SimpleMemberSchema extends CondensedMemberSchema {
    expires_at: string;
    access_level: AccessLevel;
    email: string;
}
interface MemberSchema extends SimpleMemberSchema {
    group_saml_identity: {
        extern_uid: string;
        provider: string;
        saml_provider_id: number;
    };
}
declare class ResourceMembers<C extends boolean = false> extends BaseResource<C> {
    constructor(resourceType: string, options: BaseResourceOptions<C>);
    add<E extends boolean = false>(resourceId: string | number, userId: number, accessLevel: AccessLevel, options?: BaseRequestOptions<E>): Promise<GitlabAPIResponse<MemberSchema, C, E, void>>;
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(resourceId: string | number, { includeInherited, ...options }?: IncludeInherited & PaginationRequestOptions<P> & BaseRequestOptions<E>): Promise<GitlabAPIResponse<MemberSchema[], C, E, P>>;
    edit<E extends boolean = false>(resourceId: string | number, userId: number, accessLevel: AccessLevel, options?: BaseRequestOptions<E>): Promise<GitlabAPIResponse<MemberSchema, C, E, void>>;
    show<E extends boolean = false>(resourceId: string | number, userId: number, { includeInherited, ...options }?: IncludeInherited & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<MemberSchema, C, E, void>>;
    remove<E extends boolean = false>(resourceId: string | number, userId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
}

interface MilestoneEventSchema extends Record<string, unknown> {
    id: number;
    user: Omit<UserSchema, 'created_at'>;
    created_at: string;
    resource_type: 'Issue' | 'MergeRequest';
    resource_id: number;
    milestone: MilestoneSchema;
    action: 'add' | 'remove';
}
declare class ResourceMilestoneEvents<C extends boolean = false> extends BaseResource<C> {
    protected resource2Type: string;
    constructor(resourceType: string, resource2Type: string, options: BaseResourceOptions<C>);
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(resourceId: string | number, resource2Id: string | number, options?: Sudo & ShowExpanded<E> & PaginationRequestOptions<P>): Promise<GitlabAPIResponse<MilestoneEventSchema[], C, E, P>>;
    show<E extends boolean = false>(resourceId: string | number, resource2Id: string | number, milestoneEventId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<MilestoneEventSchema, C, E, void>>;
}

interface NoteSchema extends Record<string, unknown> {
    id: number;
    body: string;
    author: Omit<UserSchema, 'created_at'>;
    created_at: string;
    updated_at: string;
}
declare class ResourceNotes<C extends boolean = false> extends BaseResource<C> {
    protected resource2Type: string;
    constructor(resourceType: string, resource2Type: string, options: BaseResourceOptions<C>);
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(resourceId: string | number, resource2Id: string | number, options?: PaginationRequestOptions<P> & BaseRequestOptions<E>): Promise<GitlabAPIResponse<NoteSchema[], C, E, P>>;
    create<E extends boolean = false>(resourceId: string | number, resource2Id: string | number, body: string, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<NoteSchema, C, E, void>>;
    edit<E extends boolean = false>(resourceId: string | number, resource2Id: string | number, noteId: number, options?: {
        body?: string;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<NoteSchema, C, E, void>>;
    remove<E extends boolean = false>(resourceId: string | number, resource2Id: string | number, noteId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
    show<E extends boolean = false>(resourceId: string | number, resource2Id: string | number, noteId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIExpandedResponse<CamelizedResponse<NoteSchema, C>, E, undefined>>;
}

interface ProtectedEnvironmentAccessLevel {
    access_level: 30 | 40 | 60;
    access_level_description: string;
    user_id?: number;
    group_id?: number;
}
interface ProtectedEnvironmentSchema extends Record<string, unknown> {
    name: string;
    deploy_access_levels?: ProtectedEnvironmentAccessLevel[];
    required_approval_count: number;
}
declare class ResourceProtectedEnvironments<C extends boolean = false> extends BaseResource<C> {
    constructor(resourceType: string, options: BaseResourceOptions<C>);
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(resourceId: string | number, options: {
        search?: string;
    } & Sudo & ShowExpanded<E> & PaginationRequestOptions<P>): Promise<GitlabAPIResponse<ProtectedEnvironmentSchema[], C, E, P>>;
    protect<E extends boolean = false>(resourceId: string | number, name: string, deployAccessLevel: ProtectedEnvironmentAccessLevel[], options?: {
        requiredApprovalCount?: number;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<ProtectedEnvironmentSchema, C, E, void>>;
    edit<E extends boolean = false>(resourceId: string | number, name: string, options?: {
        deploy_access_levels?: ProtectedEnvironmentAccessLevel[];
        required_approval_count?: number;
        approval_rules?: ProtectedEnvironmentAccessLevel[];
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<ProtectedEnvironmentSchema, C, E, void>>;
    show<E extends boolean = false>(resourceId: string | number, name: string, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<ProtectedEnvironmentSchema, C, E, void>>;
    unprotect<E extends boolean = false>(resourceId: string | number, name: string, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
}

interface PushRuleSchema extends Record<string, unknown> {
    id: number;
    commit_message_regex: string;
    commit_message_negative_regex: string;
    branch_name_regex: string;
    deny_delete_tag: boolean;
    created_at: string;
    member_check: boolean;
    prevent_secrets: boolean;
    author_email_regex: string;
    file_name_regex: string;
    max_file_size: number;
}
declare class ResourcePushRules<C extends boolean = false> extends BaseResource<C> {
    constructor(resourceType: string, options: BaseResourceOptions<C>);
    create<E extends boolean = false>(resourceId: string | number, options?: BaseRequestOptions<E>): Promise<GitlabAPIResponse<PushRuleSchema, C, E, void>>;
    edit<E extends boolean = false>(resourceId: string | number, options?: BaseRequestOptions<E>): Promise<GitlabAPIResponse<PushRuleSchema, C, E, void>>;
    remove<E extends boolean = false>(resourceId: string | number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
    show<E extends boolean = false>(resourceId: string | number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<PushRuleSchema, C, E, void>>;
}

interface RepositoryStorageMoveSchema extends Record<string, unknown> {
    id: number;
    created_at: string;
    state: string;
    source_storage_name: string;
    destination_storage_name: string;
}
declare class ResourceRepositoryStorageMoves<C extends boolean = false> extends BaseResource<C> {
    protected resourceType: string;
    protected resourceTypeSingular: string;
    constructor(resourceType: string, options: BaseResourceOptions<C>);
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(options?: PaginationRequestOptions<P> & BaseRequestOptions<E>): Promise<GitlabAPIResponse<RepositoryStorageMoveSchema[], C, E, P>>;
    show<E extends boolean = false, P extends PaginationTypes = 'offset'>(repositoryStorageId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<RepositoryStorageMoveSchema, C, E, P>>;
    schedule<E extends boolean = false, P extends PaginationTypes = 'offset'>(sourceStorageName: string, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<RepositoryStorageMoveSchema, C, E, P>>;
}

interface StateEventSchema extends Record<string, unknown> {
    id: number;
    user: Omit<UserSchema, 'created_at'>;
    created_at: string;
    resource_type: 'Issue';
    resource_id: number;
    action: 'add' | 'remove';
    state: 'opened' | 'closed';
}
declare class ResourceStateEvents<C extends boolean = false> extends BaseResource<C> {
    protected resource2Type: string;
    constructor(resourceType: string, resource2Type: string, options: BaseResourceOptions<C>);
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(resourceId: string | number, resource2Id: string | number, options?: Sudo & ShowExpanded<E> & PaginationRequestOptions<P>): Promise<GitlabAPIResponse<StateEventSchema[], C, E, P>>;
    show<E extends boolean = false>(resourceId: string | number, resource2Id: string | number, stateEventId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<StateEventSchema, C, E, void>>;
}

interface TemplateSchema extends Record<string, unknown> {
    name: string;
    content: string;
}
declare class ResourceTemplates<C extends boolean = false> extends BaseResource<C> {
    constructor(resourceType: string, options: BaseResourceOptions<C>);
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(options?: PaginationRequestOptions<P> & BaseRequestOptions<E>): Promise<GitlabAPIResponse<TemplateSchema[], C, E, P>>;
    show<E extends boolean = false>(key: string | number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<TemplateSchema, C, E, void>>;
}

type VariableType = 'env_var' | 'file';
interface VariableSchema extends Record<string, unknown> {
    variable_type: VariableType;
    value: string;
    protected: boolean;
    masked: boolean;
    key: string;
}
type VariableFilter = Record<'environment_scope', number | string>;
declare class ResourceVariables<C extends boolean> extends BaseResource<C> {
    constructor(resourceType: string, options: BaseResourceOptions<C>);
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(resourceId: string | number, options?: Sudo & ShowExpanded<E> & PaginationRequestOptions<P>): Promise<GitlabAPIResponse<VariableSchema[], C, E, P>>;
    create<E extends boolean = false>(resourceId: string | number, key: string, value: string, options?: {
        variableType?: VariableType;
        protected?: boolean;
        masked?: boolean;
        environmentScope?: string;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<VariableSchema, C, E, void>>;
    edit<E extends boolean = false>(resourceId: string | number, key: string, value: string, options?: {
        variableType?: VariableType;
        protected?: boolean;
        masked?: boolean;
        environmentScope?: string;
        filter: VariableFilter;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<VariableSchema, C, E, void>>;
    show<E extends boolean = false>(resourceId: string | number, key: string, options?: {
        filter?: VariableFilter;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<VariableSchema, C, E, void>>;
    remove<E extends boolean = false>(resourceId: string | number, key: string, options?: {
        filter?: VariableFilter;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
}

interface WeightEventSchema extends Record<string, unknown> {
    id: number;
    user: Omit<UserSchema, 'created_at'>;
    created_at: string;
    issue_id: number;
    weight: number;
}

interface WikiSchema extends Record<string, unknown> {
    content: string;
    format: string;
    slug: string;
    title: string;
    encoding: string;
}
interface WikiAttachmentSchema extends Record<string, unknown> {
    file_name: string;
    file_path: string;
    branch: string;
    link: {
        url: string;
        markdown: string;
    };
}
declare class ResourceWikis<C extends boolean = false> extends BaseResource<C> {
    constructor(resourceType: string, options: BaseResourceOptions<C>);
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(resourceId: string | number, options?: {
        withContent?: boolean;
    } & Sudo & ShowExpanded<E> & PaginationRequestOptions<P>): Promise<GitlabAPIResponse<WikiSchema[], C, E, P>>;
    create<E extends boolean = false>(resourceId: string | number, content: string, title: string, options?: {
        format?: string;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<WikiSchema, C, E, void>>;
    edit<E extends boolean = false>(resourceId: string | number, slug: string, options?: Either<{
        content: string;
    }, {
        title: string;
    }> & {
        format?: string;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<WikiSchema, C, E, void>>;
    remove<E extends boolean = false>(resourceId: string | number, slug: string, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
    show<E extends boolean = false>(resourceId: string | number, slug: string, options?: {
        renderHtml?: boolean;
        version?: string;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<WikiSchema, C, E, void>>;
    uploadAttachment<E extends boolean = false>(resourceId: string | number, content: Blob, { filename, ...options }?: {
        filename?: string;
        branch?: string;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<WikiAttachmentSchema, C, E, void>>;
}

interface PersonalAccessTokenSchema extends Record<string, unknown> {
    id: number;
    name: string;
    revoked: boolean;
    created_at: string;
    scopes?: string[];
    user_id: number;
    last_used_at: string;
    active: boolean;
    expires_at?: string;
}
type PersonalAccessTokenScopes = 'api' | 'read_user' | 'read_api' | 'read_repository' | 'write_repository';
interface AllPersonalAccessTokenOptions extends Record<string, unknown> {
    userId?: number;
    state?: string;
    search?: string;
    revoked?: boolean;
    last_used_before?: string;
    last_used_after?: string;
    created_before?: string;
    created_after?: string;
}
declare class PersonalAccessTokens<C extends boolean = false> extends BaseResource<C> {
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(options?: AllPersonalAccessTokenOptions & Sudo & ShowExpanded<E> & PaginationRequestOptions<P>): Promise<GitlabAPIResponse<PersonalAccessTokenSchema[], C, E, P>>;
    create<E extends boolean = false>(userId: number, name: string, scopes: PersonalAccessTokenScopes, options?: {
        expires_at?: string;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<PersonalAccessTokenSchema, C, E, void>>;
    remove<E extends boolean = false>({ tokenId, ...options }?: {
        tokenId?: string | number;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
    show<E extends boolean = false>({ tokenId, ...options }?: {
        tokenId?: string | number;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<PersonalAccessTokenSchema, C, E, void>>;
}

interface UserSchema extends Record<string, unknown> {
    id: number;
    name: string;
    username: string;
    state: string;
    avatar_url: string;
    web_url: string;
    created_at?: string;
}
interface ExpandedUserSchema extends UserSchema {
    bio?: string;
    location?: string;
    public_email: string;
    skype: string;
    linkedin: string;
    twitter: string;
    website_url: string;
    organization?: string;
    last_sign_in_at: string;
    confirmed_at: string;
    last_activity_on: string;
    email: string;
    theme_id: number;
    color_scheme_id: number;
    projects_limit: number;
    current_sign_in_at?: string;
    can_create_group: boolean;
    can_create_project: boolean;
    two_factor_enabled: boolean;
    external: boolean;
    private_profile?: string;
    current_sign_in_ip: string;
    last_sign_in_ip: string;
    shared_runners_minutes_limit?: number;
    extra_shared_runners_minutes_limit?: number;
    is_auditor?: boolean;
    using_license_seat?: boolean;
    identities?: {
        provider: string;
        extern_uid: string;
        saml_provider_id?: number;
    }[];
    provisioned_by_group_id?: number;
}
interface UserActivitySchema extends Record<string, unknown> {
    username: string;
    last_activity_on: string;
    last_activity_at: string;
}
interface UserStatusSchema extends Record<string, unknown> {
    emoji: string;
    availability: string;
    message: string;
    message_html: string;
    clear_status_at: string;
}
interface UserPreferenceSchema extends Record<string, unknown> {
    id: number;
    user_id: number;
    view_diffs_file_by_file: boolean;
    show_whitespace_in_diffs: boolean;
}
interface UserCountSchema extends Record<string, unknown> {
    merge_requests: number;
    assigned_issues: number;
    assigned_merge_requests: number;
    review_requested_merge_requests: number;
    todos: number;
}
interface UserMembershipSchema extends Record<string, unknown> {
    source_id: number;
    source_name: string;
    source_type: 'Project' | 'Namespace';
    access_level: AccessLevel;
}
declare class Users<C extends boolean = false> extends BaseResource<C> {
    activate<E extends boolean = false>(userId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(options?: PaginationRequestOptions<P> & BaseRequestOptions<E>): Promise<GitlabAPIResponse<(UserSchema | ExpandedUserSchema)[], C, E, P>>;
    allActivities<E extends boolean = false, P extends PaginationTypes = 'offset'>(options?: PaginationRequestOptions<P> & BaseRequestOptions<E>): Promise<GitlabAPIResponse<UserActivitySchema[], C, E, P>>;
    allEvents<E extends boolean = false, P extends PaginationTypes = 'offset'>(userId: number, options?: PaginationRequestOptions<P> & BaseRequestOptions<E> & EventOptions): Promise<GitlabAPIExpandedResponse<CamelizedResponse<EventSchema, C>[], E, void>>;
    allFollowers<E extends boolean = false, P extends PaginationTypes = 'offset'>(userId: number, options?: PaginationRequestOptions<P> & BaseRequestOptions<E>): Promise<GitlabAPIResponse<UserSchema[], C, E, P>>;
    allFollowing<E extends boolean = false, P extends PaginationTypes = 'offset'>(userId: number, options?: PaginationRequestOptions<P> & BaseRequestOptions<E>): Promise<GitlabAPIResponse<UserSchema[], C, E, P>>;
    allMemberships<E extends boolean = false, P extends PaginationTypes = 'offset'>(userId: number, options?: {
        type?: 'Project' | 'Namespace';
    } & PaginationRequestOptions<P> & BaseRequestOptions<E>): Promise<GitlabAPIResponse<UserMembershipSchema[], C, E, P>>;
    allProjects<E extends boolean = false, P extends PaginationTypes = 'offset'>(userId: number, options?: PaginationRequestOptions<P> & BaseRequestOptions<E>): Promise<GitlabAPIResponse<ExpandedProjectSchema[], C, E, P>>;
    allStarredProjects<E extends boolean = false, P extends PaginationTypes = 'keyset'>(userId: number, options?: PaginationRequestOptions<P> & BaseRequestOptions<E>): Promise<GitlabAPIResponse<ExpandedProjectSchema[], C, E, P>>;
    approve<E extends boolean = false>(userId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<{
        message: string;
    }, C, E, void>>;
    ban<E extends boolean = false>(userId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
    block<E extends boolean = false>(userId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
    deactivate<E extends boolean = false>(userId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
    disableTwoFactor<E extends boolean = false>(userId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
    follow<E extends boolean = false>(userId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<UserSchema, C, E, void>>;
    create<E extends boolean = false>(options?: BaseRequestOptions<E>): Promise<GitlabAPIResponse<UserSchema | ExpandedUserSchema, C, E, void>>;
    createPersonalAccessToken<E extends boolean = false>(userId: number, name: string, scopes: string[], options?: {
        expiresAt?: string;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<PersonalAccessTokenSchema, C, E, void>>;
    edit<E extends boolean = false>(userId: number, options?: BaseRequestOptions<E>): Promise<GitlabAPIExpandedResponse<CamelizedResponse<UserSchema, C>, E, undefined>>;
    editStatus<E extends boolean = false>(options?: {
        emoji?: string;
        message?: string;
        clearStatusAfter?: '30_minutes' | '3_hours' | '8_hours' | '1_day' | '3_days' | '7_days' | '30_days';
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<UserStatusSchema, C, E, void>>;
    editCurrentUserPreferences<E extends boolean = false>(viewDiffsFileByFile: boolean, showWhitespaceInDiffs: boolean, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<UserPreferenceSchema, C, E, void>>;
    reject<E extends boolean = false>(userId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<{
        message: string;
    }, C, E, void>>;
    show<E extends boolean = false>(userId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<UserSchema | ExpandedUserSchema, C, E, void>>;
    showCounts<E extends boolean = false>(options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<UserCountSchema, C, E, void>>;
    showCurrentUser<E extends boolean = false>(options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<ExpandedUserSchema, C, E, void>>;
    showCurrentUserPreferences<E extends boolean = false>(options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<UserPreferenceSchema, C, E, void>>;
    showStatus<E extends boolean = false>(options?: {
        iDOrUsername?: string | number;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<UserStatusSchema, C, E, void>>;
    remove<E extends boolean = false>(userId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
    removeAuthenticationIdentity<E extends boolean = false>(userId: number, provider: string, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
    unban<E extends boolean = false>(userId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
    unblock<E extends boolean = false>(userId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
    unfollow<E extends boolean = false>(userId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<UserSchema, C, E, void>>;
}

interface CondensedNamespaceSchema extends Record<string, unknown> {
    id: number;
    name: string;
    path: string;
    kind: string;
    full_path: string;
    parent_id?: number;
    avatar_url: string;
    web_url: string;
}
interface NamespaceSchema extends CondensedNamespaceSchema {
    members_count_with_descendants: number;
    billable_members_count: number;
    plan: string;
    trial_ends_on?: string;
    trial: boolean;
}
declare class Namespaces<C extends boolean = false> extends BaseResource<C> {
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(options?: {
        search?: string;
        ownedOnly?: string;
    } & PaginationRequestOptions<P> & BaseRequestOptions<E>): Promise<GitlabAPIResponse<NamespaceSchema[], C, E, P>>;
    exists<E extends boolean = false>(namespaceId: string | number, options?: {
        parentId?: string;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<NamespaceSchema, C, E, void>>;
    show<E extends boolean = false>(namespaceId: string | number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<NamespaceSchema, C, E, void>>;
}

interface GroupStatisticsSchema {
    storage_size: number;
    repository_size: number;
    wiki_size: number;
    lfs_objects_size: number;
    job_artifacts_size: number;
    pipeline_artifacts_size: number;
    packages_size: number;
    snippets_size: number;
    uploads_size: number;
}
interface CondensedGroupSchema extends Record<string, unknown> {
    id: number;
    web_url: string;
    name: string;
}
interface SimpleGroupSchema extends CondensedGroupSchema {
    avatar_url: string;
    full_name: string;
    full_path: string;
}
interface GroupSchema extends SimpleGroupSchema {
    path: string;
    description: string;
    visibility: string;
    share_with_group_lock: boolean;
    require_two_factor_authentication: boolean;
    two_factor_grace_period: number;
    project_creation_level: string;
    auto_devops_enabled?: boolean;
    subgroup_creation_level: string;
    emails_disabled?: boolean;
    mentions_disabled?: boolean;
    lfs_enabled: boolean;
    default_branch_protection: number;
    request_access_enabled: boolean;
    created_at: string;
    parent_id: number;
    ldap_cn?: string;
    ldap_access?: string;
    marked_for_deletion_on?: string;
    membership_lock?: boolean;
}
interface ExpandedGroupSchema extends GroupSchema {
    runners_token: string;
    file_template_project_id: number;
    shared_with_groups?: ExpandedProjectSchema[];
    projects?: ExpandedProjectSchema[];
    shared_projects?: ExpandedProjectSchema[];
}
declare class Groups<C extends boolean = false> extends BaseResource<C> {
    all<E extends boolean = false, P extends PaginationTypes = 'keyset'>(options?: {
        statistics: true;
    } & PaginationRequestOptions<P> & BaseRequestOptions<E>): Promise<GitlabAPIResponse<(GroupSchema & {
        statistics: GroupStatisticsSchema;
    })[], C, E, P>>;
    allDescendantGroups<E extends boolean = false, P extends PaginationTypes = 'offset'>(groupId: string | number, options: {
        statistics: true;
    } & PaginationRequestOptions<P> & BaseRequestOptions<E>): Promise<GitlabAPIResponse<(GroupSchema & {
        statistics: GroupStatisticsSchema;
    })[], C, E, P>>;
    allProjects<E extends boolean = false, P extends PaginationTypes = 'offset'>(groupId: string | number, options?: {
        simple: true;
        sharedOnly?: boolean;
    } & PaginationRequestOptions<P> & BaseRequestOptions<E>): Promise<GitlabAPIResponse<ExpandedProjectSchema[], C, E, P>>;
    allSharedProjects<E extends boolean = false, P extends PaginationTypes = 'offset'>(groupId: string | number, options?: {
        simple: true;
    } & PaginationRequestOptions<P> & BaseRequestOptions<E>): Promise<GitlabAPIResponse<CondensedProjectSchema[], C, E, P>>;
    allSubgroups<E extends boolean = false, P extends PaginationTypes = 'offset'>(groupId: string | number, options?: {
        statistics: true;
    } & PaginationRequestOptions<P> & BaseRequestOptions<E>): Promise<GitlabAPIResponse<(GroupSchema & {
        statistics: GroupStatisticsSchema;
    })[], C, E, P>>;
    allProvisionedUsers<E extends boolean = false, P extends PaginationTypes = 'offset'>(groupId: string | number, options?: PaginationRequestOptions<P> & BaseRequestOptions<E>): Promise<GitlabAPIResponse<UserSchema[], C, E, P>>;
    allTransferLocations<E extends boolean = false, P extends PaginationTypes = 'offset'>(groupId: string | number, options?: {
        search?: string;
    } & PaginationRequestOptions<P> & BaseRequestOptions<E>): Promise<GitlabAPIResponse<SimpleGroupSchema[], C, E, P>>;
    create<E extends boolean = false>(name: string, path: string, options?: BaseRequestOptions<E>): Promise<GitlabAPIResponse<GroupSchema, C, E, void>>;
    downloadAvatar<E extends boolean = false>(groupId: string | number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<Blob, void, E, void>>;
    edit<E extends boolean = false>(groupId: string | number, options?: BaseRequestOptions<E>): Promise<GitlabAPIResponse<ExpandedGroupSchema, C, E, void>>;
    remove<E extends boolean = false>(groupId: string | number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
    removeAvatar<E extends boolean = false>(groupId: string | number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
    restore<E extends boolean = false>(groupId: string | number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
    search<E extends boolean = false>(nameOrPath: string, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<GroupSchema[], C, E, void>>;
    share<E extends boolean = false>(groupId: string | number, sharedGroupId: string | number, groupAccess: number, options: BaseRequestOptions<E>): Promise<GitlabAPIResponse<ExpandedGroupSchema, C, E, void>>;
    show<E extends boolean = false>(groupId: string | number, options?: BaseRequestOptions<E>): Promise<GitlabAPIResponse<ExpandedGroupSchema, C, E, void>>;
    transfer<E extends boolean = false>(groupId: string | number, options?: BaseRequestOptions<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
    transferProject<E extends boolean = false>(groupId: string | number, projectId: string | number, options?: BaseRequestOptions<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
    unshare<E extends boolean = false>(groupId: string | number, sharedGroupId: string | number, options: BaseRequestOptions<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
    uploadAvatar<E extends boolean = false>(groupId: string | number, content: Blob, { filename, ...options }?: {
        filename?: string;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<{
        avatar_url: string;
    }, C, E, void>>;
}

interface ProjectStarrerSchema extends Record<string, unknown> {
    starred_since: string;
    user: Omit<UserSchema, 'created_at'>;
}
interface ProjectStoragePath extends Record<string, unknown> {
    project_id: string | number;
    disk_path: string;
    created_at: string;
    repository_storage: string;
}
interface ProjectStatisticsSchema {
    commit_count: number;
    storage_size: number;
    repository_size: number;
    wiki_size: number;
    lfs_objects_size: number;
    job_artifacts_size: number;
    pipeline_artifacts_size: number;
    packages_size: number;
    snippets_size: number;
    uploads_size: number;
}
interface CondensedProjectSchema extends Record<string, unknown> {
    id: number;
    web_url: string;
    name: string;
    path: string;
}
interface SimpleProjectSchema extends CondensedProjectSchema {
    description?: null;
    name_with_namespace: string;
    path_with_namespace: string;
    created_at: string;
}
interface ProjectSchema extends SimpleProjectSchema {
    id: number;
    default_branch: string;
    ssh_url_to_repo: string;
    http_url_to_repo: string;
    web_url: string;
    readme_url: string;
    topics?: string[];
    name: string;
    path: string;
    last_activity_at: string;
    forks_count: number;
    avatar_url: string;
    star_count: number;
}
interface ExpandedProjectSchema extends ProjectSchema {
    issues_template?: string;
    merge_requests_template?: string;
    visibility: string;
    owner: Pick<UserSchema, 'id' | 'name' | 'created_at'>;
    issues_enabled: boolean;
    open_issues_count: number;
    merge_requests_enabled: boolean;
    jobs_enabled: boolean;
    wiki_enabled: boolean;
    snippets_enabled: boolean;
    can_create_merge_request_in: boolean;
    resolve_outdated_diff_discussions: boolean;
    container_registry_enabled: boolean;
    container_registry_access_level: string;
    creator_id: number;
    namespace: CondensedNamespaceSchema;
    import_status: string;
    archived: boolean;
    shared_runners_enabled: boolean;
    runners_token: string;
    ci_default_git_depth: number;
    ci_forward_deployment_enabled: boolean;
    public_jobs: boolean;
    shared_with_groups?: string[];
    only_allow_merge_if_pipeline_succeeds: boolean;
    allow_merge_on_skipped_pipeline: boolean;
    restrict_user_defined_variables: boolean;
    only_allow_merge_if_all_discussions_are_resolved: boolean;
    remove_source_branch_after_merge: boolean;
    request_access_enabled: boolean;
    merge_method: string;
    squash_option: string;
    autoclose_referenced_issues: boolean;
    suggestion_commit_message?: string;
    merge_commit_template?: null;
    squash_commit_template?: null;
    marked_for_deletion_on: string;
    approvals_before_merge: number;
    container_registry_image_prefix: string;
    _links: {
        self: string;
        issues: string;
        merge_requests: string;
        repo_branches: string;
        labels: string;
        events: string;
        members: string;
    };
}
interface ProjectFileUploadSchema extends Record<string, unknown> {
    alt: string;
    url: string;
    full_path: string;
    markdown: string;
}
declare class Projects<C extends boolean = false> extends BaseResource<C> {
    all<E extends boolean = false, P extends PaginationTypes = 'keyset'>(options: {
        simple: true;
    } & PaginationRequestOptions<P> & BaseRequestOptions<E>): Promise<GitlabAPIResponse<ProjectSchema[], C, E, P>>;
    all<E extends boolean = false, P extends PaginationTypes = 'keyset'>(options: {
        statistics: true;
    } & PaginationRequestOptions<P> & BaseRequestOptions<E>): Promise<GitlabAPIResponse<(ExpandedProjectSchema & {
        statistics: ProjectStatisticsSchema;
    })[], C, E, P>>;
    all<E extends boolean = false, P extends PaginationTypes = 'keyset'>(options?: PaginationRequestOptions<P> & BaseRequestOptions<E>): Promise<GitlabAPIResponse<ExpandedProjectSchema[], C, E, P>>;
    allTransferLocations<E extends boolean = false, P extends PaginationTypes = 'offset'>(projectId: string | number, options?: {
        search?: string;
    } & PaginationRequestOptions<P> & BaseRequestOptions<E>): Promise<GitlabAPIResponse<SimpleProjectSchema[], C, E, P>>;
    archive<E extends boolean = false>(projectId: string | number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<ExpandedProjectSchema, C, E, void>>;
    create<E extends boolean = false>({ userId, ...options }?: ({
        name: string;
    } | {
        path: string;
    }) & {
        userId?: number;
    } & BaseRequestOptions<E>): Promise<GitlabAPIResponse<ExpandedProjectSchema, C, E, void>>;
    createForkRelationship<E extends boolean = false>(projectId: string | number, forkedFromId: string | number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
    createPullMirror<E extends boolean = false>(projectId: string | number, url: string, mirror: boolean, options?: {
        onlyProtectedBranches?: boolean;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<ProjectRemoteMirrorSchema, C, E, void>>;
    downloadSnapshot<E extends boolean = false>(projectId: string | number, options?: {
        wiki?: boolean;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<Blob, void, E, void>>;
    edit<E extends boolean = false>(projectId: string | number, options?: BaseRequestOptions<E>): Promise<GitlabAPIResponse<ExpandedProjectSchema, C, E, void>>;
    fork<E extends boolean = false>(projectId: string | number, options?: BaseRequestOptions<E>): Promise<GitlabAPIResponse<ExpandedProjectSchema, C, E, void>>;
    housekeeping<E extends boolean = false>(projectId: string | number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
    importProjectMembers<E extends boolean = false>(projectId: string | number, sourceProjectId: string | number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
    remove<E extends boolean = false>(projectId: string | number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
    removeForkRelationship<E extends boolean = false>(projectId: string | number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
    removeAvatar<E extends boolean = false>(projectId: string | number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
    restore<E extends boolean = false>(projectId: string | number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
    search<E extends boolean = false>(projectName: string, options?: {
        sort?: string;
        orderBy?: string;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<ProjectSchema[], C, E, void>>;
    share<E extends boolean = false>(projectId: string | number, groupId: string | number, groupAccess: number, options?: {
        expiresAt?: string;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
    show<E extends boolean = false>(projectId: string | number, options?: {
        license?: boolean;
        statistics?: boolean;
        withCustomAttributes?: boolean;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<ExpandedProjectSchema, C, E, void>>;
    showForks<E extends boolean = false>(projectId: string | number, options: {
        simple: true;
    } & BaseRequestOptions<E>): Promise<GitlabAPIResponse<ProjectSchema[], C, E, void>>;
    showForks<E extends boolean = false>(projectId: string | number, options: {
        statistics: true;
    } & BaseRequestOptions<E>): Promise<GitlabAPIResponse<(ExpandedProjectSchema & {
        statistics: ProjectStatisticsSchema;
    })[], C, E, void>>;
    showGroups<E extends boolean = false>(projectId: string | number, options?: {
        search?: string;
        skipGroups?: number[];
        withShared?: boolean;
        sharedMinAccessLevel?: AccessLevel;
        sharedVisibleOnly?: boolean;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<SimpleGroupSchema[], C, E, void>>;
    showLanguages<E extends boolean = false>(projectId: string | number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<{
        [name: string]: number;
    }, C, E, void>>;
    showStarrers<E extends boolean = false>(projectId: string | number, options?: {
        search?: string;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<ProjectStarrerSchema[], C, E, void>>;
    showStoragePaths<E extends boolean = false>(projectId: string | number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<ProjectStoragePath[], C, E, void>>;
    showUsers<E extends boolean = false>(projectId: string | number, options?: {
        search?: string;
        skipUsers?: number[];
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<Omit<UserSchema, 'created_at'>[], C, E, void>>;
    showPullMirror<E extends boolean = false>(projectId: string | number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<ProjectRemoteMirrorSchema, C, E, void>>;
    star<E extends boolean = false>(projectId: string | number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<ExpandedProjectSchema, C, E, void>>;
    transfer<E extends boolean = false>(projectId: string | number, namespaceId: string | number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIExpandedResponse<CamelizedResponse<ExpandedProjectSchema, C>, E, undefined>>;
    unarchive<E extends boolean = false>(projectId: string | number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<ExpandedProjectSchema, C, E, void>>;
    unshare<E extends boolean = false>(projectId: string | number, groupId: string | number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
    unstar<E extends boolean = false>(projectId: string | number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<ExpandedProjectSchema, C, E, void>>;
    upload<E extends boolean = false>(projectId: string | number, content: Blob, { filename, ...options }?: {
        filename?: string;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<ProjectFileUploadSchema, C, E, void>>;
    uploadAvatar<E extends boolean = false>(projectId: string | number, content: Blob, { filename, ...options }?: {
        filename?: string;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<{
        avatar_url: string;
    }, C, E, void>>;
}

interface ClusterAgentSchema extends Record<string, unknown> {
    id: number;
    name: string;
    config_project: SimpleProjectSchema;
    created_at: string;
    created_by_user_id: number;
}
interface ClusterAgentTokenSchema extends Record<string, unknown> {
    id: number;
    name: string;
    description: string;
    agent_id: number;
    status: string;
    token?: string;
    created_at: string;
    created_by_user_id: number;
}
declare class Agents<C extends boolean = false> extends BaseResource<C> {
    all<E extends boolean = false>(projectId: string | number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<ClusterAgentSchema[], C, E, void>>;
    allTokens<E extends boolean = false>(projectId: string | number, agentId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<ClusterAgentTokenSchema[], C, E, void>>;
    createToken<E extends boolean = false>(projectId: string | number, agentId: number, name: string, options?: {
        description?: string;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<ClusterAgentTokenSchema, C, E, void>>;
    show<E extends boolean = false>(projectId: string | number, agentId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<ClusterAgentSchema, C, E, void>>;
    showToken<E extends boolean = false>(projectId: string | number, agentId: number, tokenId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<ClusterAgentTokenSchema, C, E, void>>;
    register<E extends boolean = false>(projectId: string | number, name: string, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<ClusterAgentSchema, C, E, void>>;
    removeToken<E extends boolean = false>(projectId: string | number, agentId: number, tokenId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
    deregister<E extends boolean = false>(projectId: string | number, agentId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
}

interface ApplicationAppearanceSchema extends Record<string, unknown> {
    title: string;
    description: string;
    logo: string;
    header_logo: string;
    favicon: string;
    new_project_guidelines: string;
    profile_image_guidelines: string;
    header_message: string;
    footer_message: string;
    message_background_color: string;
    message_font_color: string;
    email_header_and_footer_enabled: boolean;
}
declare class ApplicationAppearance<C extends boolean = false> extends BaseResource<C> {
    show<E extends boolean = false>(options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<ApplicationAppearanceSchema, C, E, void>>;
    edit<E extends boolean = false>(options?: BaseRequestOptions<E>): Promise<GitlabAPIResponse<ApplicationAppearanceSchema, C, E, void>>;
}

interface ApplicationPlanLimitSchema extends Record<string, unknown> {
    conan_max_file_size: number;
    generic_packages_max_file_size: number;
    helm_max_file_size: number;
    maven_max_file_size: number;
    npm_max_file_size: number;
    nuget_max_file_size: number;
    pypi_max_file_size: number;
    terraform_module_max_file_size: number;
}
type ApplicationPlanLimitOptions = Partial<Camelize<ApplicationPlanLimitSchema>>;
declare class ApplicationPlanLimits<C extends boolean = false> extends BaseResource<C> {
    show<E extends boolean = false>(options?: {
        planName?: string;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<ApplicationPlanLimitSchema, C, E, void>>;
    edit<E extends boolean = false>(planName: string, options?: ApplicationPlanLimitOptions & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<ApplicationPlanLimitSchema, C, E, void>>;
}

interface ApplicationSchema extends Record<string, unknown> {
    id: number;
    application_id: string;
    application_name: string;
    secret: string;
    callback_url: string;
    confidential: boolean;
}
declare class Applications<C extends boolean = false> extends BaseResource<C> {
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(options?: PaginationRequestOptions<P> & BaseRequestOptions<E>): Promise<GitlabAPIResponse<ApplicationSchema[], C, E, P>>;
    create<E extends boolean = false>(name: string, redirectUri: string, scopes: string, options?: BaseRequestOptions<E>): Promise<GitlabAPIResponse<ApplicationSchema, C, E, void>>;
    remove<E extends boolean = false>(applicationId: number, options?: BaseRequestOptions<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
}

interface ApplicationSettingsSchema extends Record<string, unknown> {
    default_projects_limit: number;
    signup_enabled: boolean;
    id: number;
    default_branch_protection: number;
    restricted_visibility_levels?: string[];
    password_authentication_enabled_for_web: boolean;
    after_sign_out_path?: string;
    max_attachment_size: number;
    max_import_size: number;
    user_oauth_applications: boolean;
    updated_at: string;
    session_expire_delay: number;
    home_page_url?: string;
    default_snippet_visibility: string;
    outbound_local_requests_whitelist?: string[];
    domain_allowlist?: string[];
    domain_denylist_enabled: boolean;
    domain_denylist?: string[];
    created_at: string;
    default_ci_config_path?: string;
    default_project_visibility: string;
    default_group_visibility: string;
    gravatar_enabled: boolean;
    sign_in_text?: string;
    container_expiration_policies_enable_historic_entries: boolean;
    container_registry_token_expire_delay: number;
    repository_storages_weighted: {
        [name: string]: number;
    };
    plantuml_enabled: boolean;
    plantuml_url?: string;
    kroki_enabled: boolean;
    kroki_url?: string;
    terminal_max_session_time: number;
    polling_interval_multiplier: number;
    rsa_key_restriction: number;
    dsa_key_restriction: number;
    ecdsa_key_restriction: number;
    ed25519_key_restriction: number;
    first_day_of_week: number;
    enforce_terms: boolean;
    terms: string;
    performance_bar_allowed_group_id: number;
    user_show_add_ssh_key_message: boolean;
    local_markdown_version: number;
    allow_local_requests_from_hooks_and_services: boolean;
    allow_local_requests_from_web_hooks_and_services: boolean;
    allow_local_requests_from_system_hooks: boolean;
    asset_proxy_enabled: boolean;
    asset_proxy_url: string;
    asset_proxy_whitelist?: string[];
    asset_proxy_allowlist?: string[];
    npm_package_requests_forwarding: boolean;
    snippet_size_limit: number;
    issues_create_limit: number;
    raw_blob_request_limit: number;
    wiki_page_max_content_bytes: number;
    require_admin_approval_after_user_signup: boolean;
    personal_access_token_prefix: string;
    rate_limiting_response_text?: string;
    keep_latest_artifact: boolean;
}
declare class ApplicationSettings<C extends boolean = false> extends BaseResource<C> {
    show<E extends boolean = false>(options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<ApplicationSettingsSchema, C, E, void>>;
    edit<E extends boolean = false>(options?: BaseRequestOptions<E>): Promise<GitlabAPIResponse<ApplicationSettingsSchema, C, E, void>>;
}

interface ApplicationStatisticSchema extends Record<string, unknown> {
    forks: string;
    issues: string;
    merge_requests: string;
    notes: string;
    snippets: string;
    ssh_keys: string;
    milestones: string;
    users: string;
    groups: string;
    projects: string;
    active_users: string;
}
declare class ApplicationStatistics<C extends boolean = false> extends BaseResource<C> {
    show<E extends boolean = false>(options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<ApplicationStatisticSchema, C, E, void>>;
}

interface AuditEventSchema extends Record<string, unknown> {
    id: number;
    author_id: number;
    entity_id: number;
    entity_type: string;
    details: {
        custom_message: string;
        author_name: string;
        target_id: string;
        target_type: string;
        target_details: string;
        ip_address: string;
        entity_path: string;
    };
    created_at: string;
}
declare class AuditEvents<C extends boolean = false> extends BaseResource<C> {
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(options: EitherOrNone<{
        projectId?: string | number;
    }, {
        groupId?: string | number;
    }> & BaseRequestOptions<E> & PaginationRequestOptions<P>): Promise<GitlabAPIResponse<AuditEventSchema[], C, E, P>>;
    show<E extends boolean = false>(auditEventId: number, options?: EitherOrNone<{
        projectId?: string | number;
    }, {
        groupId?: string | number;
    }> & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<AuditEventSchema, C, E, void>>;
}

interface AvatarSchema extends Record<string, unknown> {
    avatar_url: string;
}
declare class Avatar<C extends boolean = false> extends BaseResource<C> {
    show<E extends boolean = false>(email: string, options?: BaseRequestOptions<E>): Promise<GitlabAPIResponse<AvatarSchema, C, E, void>>;
}

interface BroadcastMessageSchema extends Record<string, unknown> {
    message: string;
    starts_at: string;
    ends_at: string;
    color: string;
    font: string;
    id: number;
    active: boolean;
    target_path: string;
    broadcast_type: string;
    dismissable: boolean;
}
type BroadcastMessageOptions = Camelize<Omit<BroadcastMessageSchema, 'id'>>;
declare class BroadcastMessages<C extends boolean = false> extends BaseResource<C> {
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(options?: PaginationRequestOptions<P> & BaseRequestOptions<E>): Promise<GitlabAPIResponse<BroadcastMessageSchema[], C, E, P>>;
    create<E extends boolean = false>(options?: BroadcastMessageOptions & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<BroadcastMessageSchema, C, E, void>>;
    edit<E extends boolean = false>(broadcastMessageId: number, options?: BroadcastMessageOptions & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<BroadcastMessageSchema, C, E, void>>;
    remove<E extends boolean = false>(broadcastMessageId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
    show<E extends boolean = false>(broadcastMessageId: number, options?: BaseRequestOptions<E>): Promise<GitlabAPIResponse<BroadcastMessageSchema, C, E, void>>;
}

interface ComposerV1BaseRepositorySchema extends Record<string, unknown> {
    packages?: string[];
    'metadata-url': string;
    'provider-includes': Record<string, Record<string, string>>;
    'providers-url': string;
}
interface ComposerV2BaseRepositorySchema extends Record<string, unknown> {
    packages?: string[];
    'metadata-url': string;
}
interface ComposerV1PackagesSchema extends Record<string, unknown> {
    providers: {
        [name: string]: {
            sha256: string;
        };
    };
}
interface PackageMetadata {
    name: string;
    type: string;
    license: string;
    version: string;
    dist: {
        type: string;
        url: string;
        reference: string;
        shasum: string;
    };
    source: {
        type: string;
        url: string;
        reference: string;
    };
    uid: number;
}
interface ComposerPackageMetadataSchema extends Record<string, unknown> {
    packages: {
        [name: string]: {
            [version: string]: PackageMetadata;
        };
    };
}
declare class Composer<C extends boolean = false> extends BaseResource<C> {
    create<E extends boolean = false>(projectId: string | number, options?: {
        tag?: string;
        branch?: string;
    } & ShowExpanded<E>): Promise<GitlabAPIResponse<{
        message: string;
    }, C, E, void>>;
    download<E extends boolean = false>(projectId: string | number, packageName: string, sha: string, options?: ShowExpanded<E>): Promise<GitlabAPIResponse<Blob, void, E, void>>;
    showMetadata<E extends boolean = false>(groupId: string | number, packageName: string, options?: {
        sha?: string;
    } & ShowExpanded<E>): Promise<GitlabAPIResponse<ComposerPackageMetadataSchema, C, E, void>>;
    showPackages<E extends boolean = false>(groupId: string | number, sha: string, options?: ShowExpanded<E>): Promise<GitlabAPIResponse<ComposerV1PackagesSchema, C, E, void>>;
    showBaseRepository<E extends boolean = false>(groupId: string | number, options?: {
        composerVersion: '1';
    } & ShowExpanded<E>): Promise<GitlabAPIResponse<ComposerV1BaseRepositorySchema, C, E, void>>;
    showBaseRepository<E extends boolean = false>(groupId: string | number, options?: {
        composerVersion: '2';
    } & ShowExpanded<E>): Promise<GitlabAPIResponse<ComposerV2BaseRepositorySchema, C, E, void>>;
}

interface PackageSnapshotSchema extends Record<string, unknown> {
    'conan_package.tgz': string;
    'conanfile.py': string;
    'conanmanifest.txt': string;
}
interface RecipeSnapshotSchema extends Record<string, unknown> {
    'conan_sources.tgz': string;
    'conanfile.py': string;
    'conanmanifest.txt': string;
}
declare class Conan<C extends boolean = false> extends BaseResource<C> {
    authenticate<E extends boolean = false>(options?: {
        projectId?: string | number;
    } & ShowExpanded<E>): Promise<GitlabAPIResponse<string, C, E, void>>;
    checkCredentials<E extends boolean = false>(options?: {
        projectId?: string | number;
    } & ShowExpanded<E>): Promise<GitlabAPIResponse<string, C, E, void>>;
    downloadPackageFile<E extends boolean = false>(packageName: string, packageVersion: string, packageUsername: string, packageChannel: string, conanPackageReference: string, recipeRevision: string, packageRevision: string, filename: string, options?: {
        projectId?: string | number;
    } & ShowExpanded<E>): Promise<GitlabAPIResponse<Blob, void, E, void>>;
    downloadRecipeFile<E extends boolean = false>(packageName: string, packageVersion: string, packageUsername: string, packageChannel: string, recipeRevision: string, filename: string, options?: {
        projectId?: string | number;
    } & ShowExpanded<E>): Promise<GitlabAPIResponse<Blob, void, E, void>>;
    showPackageUploadUrls<E extends boolean = false>(packageName: string, packageVersion: string, packageUsername: string, packageChannel: string, conanPackageReference: string, options?: {
        projectId?: string | number;
    } & ShowExpanded<E>): Promise<GitlabAPIResponse<PackageSnapshotSchema, C, E, void>>;
    showPackageDownloadUrls<E extends boolean = false>(packageName: string, packageVersion: string, packageUsername: string, packageChannel: string, conanPackageReference: string, options?: {
        projectId?: string | number;
    } & ShowExpanded<E>): Promise<GitlabAPIResponse<PackageSnapshotSchema, C, E, void>>;
    showPackageManifest<E extends boolean = false>(packageName: string, packageVersion: string, packageUsername: string, packageChannel: string, conanPackageReference: string, options?: {
        projectId?: string | number;
    } & ShowExpanded<E>): Promise<GitlabAPIResponse<PackageSnapshotSchema, C, E, void>>;
    showPackageSnapshot<E extends boolean = false>(packageName: string, packageVersion: string, packageUsername: string, packageChannel: string, conanPackageReference: string, options?: {
        projectId?: string | number;
    } & ShowExpanded<E>): Promise<GitlabAPIResponse<PackageSnapshotSchema, C, E, void>>;
    ping<E extends boolean = false>(options?: {
        projectId?: string | number;
    } & ShowExpanded<E>): Promise<GitlabAPIResponse<string, C, E, void>>;
    recipeUploadUrls<E extends boolean = false>(packageName: string, packageVersion: string, packageUsername: string, packageChannel: string, options?: {
        projectId?: string | number;
    } & ShowExpanded<E>): Promise<GitlabAPIResponse<RecipeSnapshotSchema, C, E, void>>;
    showRecipeDownloadUrls<E extends boolean = false>(packageName: string, packageVersion: string, packageUsername: string, packageChannel: string, options?: {
        projectId?: string | number;
    } & ShowExpanded<E>): Promise<GitlabAPIResponse<RecipeSnapshotSchema, C, E, void>>;
    showRecipeManifest<E extends boolean = false>(packageName: string, packageVersion: string, packageUsername: string, packageChannel: string, options?: {
        projectId?: string | number;
    } & ShowExpanded<E>): Promise<GitlabAPIResponse<RecipeSnapshotSchema, C, E, void>>;
    showRecipeSnapshot<E extends boolean = false>(packageName: string, packageVersion: string, packageUsername: string, packageChannel: string, options?: {
        projectId?: string | number;
    } & ShowExpanded<E>): Promise<GitlabAPIResponse<RecipeSnapshotSchema, C, E, void>>;
    removePackageFile<E extends boolean = false>(packageName: string, packageVersion: string, packageUsername: string, packageChannel: string, options?: {
        projectId?: string | number;
    } & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
    search<E extends boolean = false>(options?: {
        projectId?: string | number;
    } & ShowExpanded<E>): Promise<GitlabAPIResponse<{
        results: string[];
    }, C, E, void>>;
    uploadPackageFile<E extends boolean = false>(content: Blob, packageName: string, packageVersion: string, packageUsername: string, packageChannel: string, conanPackageReference: string, recipeRevision: string, packageRevision: string, filename: string, options?: {
        projectId?: string | number;
    } & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
    uploadRecipeFile<E extends boolean = false>(content: Blob, packageName: string, packageVersion: string, packageUsername: string, packageChannel: string, recipeRevision: string, filename: string, options?: {
        projectId?: string | number;
    } & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
}

interface DashboardAnnotationSchema extends Record<string, unknown> {
    id: number;
    starting_at: string;
    ending_at?: null;
    dashboard_path: string;
    description: string;
    environment_id: number;
    cluster_id?: null;
}
declare class DashboardAnnotations<C extends boolean = false> extends BaseResource<C> {
    create<E extends boolean = false>(dashboardPath: string, startingAt: string, description: string, { environmentId, clusterId, ...options }: Either<{
        environmentId: number;
    }, {
        clusterId: number;
    }> & {
        endingAt?: string;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<DashboardAnnotationSchema, C, E, void>>;
}

declare class Debian<C extends boolean = false> extends BaseResource<C> {
    downloadBinaryFileIndex<E extends boolean = false>(distribution: string, component: string, architecture: string, { projectId, groupId, ...options }: Either<{
        projectId: string | number;
    }, {
        groupId: string | number;
    }> & ShowExpanded<E>): Promise<GitlabAPIResponse<Blob, void, E, void>>;
    downloadDistributionReleaseFile<E extends boolean = false>(distribution: string, { projectId, groupId, ...options }: Either<{
        projectId: string | number;
    }, {
        groupId: string | number;
    }> & ShowExpanded<E>): Promise<GitlabAPIResponse<Blob, void, E, void>>;
    downloadSignedDistributionReleaseFile<E extends boolean = false>(distribution: string, { projectId, groupId, ...options }: Either<{
        projectId: string | number;
    }, {
        groupId: string | number;
    }> & ShowExpanded<E>): Promise<GitlabAPIResponse<Blob, void, E, void>>;
    downloadReleaseFileSignature<E extends boolean = false>(distribution: string, { projectId, groupId, ...options }: Either<{
        projectId: string | number;
    }, {
        groupId: string | number;
    }> & ShowExpanded<E>): Promise<GitlabAPIResponse<Blob, void, E, void>>;
    downloadPackageFile<E extends boolean = false>(projectId: string | number, distribution: string, letter: string, packageName: string, packageVersion: string, filename: string, options?: ShowExpanded<E>): Promise<GitlabAPIResponse<Blob, void, E, void>>;
    uploadPackageFile<E extends boolean = false>(projectId: string | number, content: Blob, filename: string, options?: ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
}

declare class DependencyProxy<C extends boolean = false> extends BaseResource<C> {
    remove<E extends boolean = false>(groupId: string | number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
}

interface DeployKeySchema extends Record<string, unknown> {
    id: number;
    title: string;
    key: string;
    can_push?: boolean;
    created_at: string;
}
type CondensedDeployKeySchema = Omit<DeployKeySchema, 'can_push'>;
interface ExpandedDeployKeySchema extends CondensedDeployKeySchema {
    fingerprint: string;
    projects_with_write_access?: SimpleProjectSchema[];
}
declare class DeployKeys<C extends boolean = false> extends BaseResource<C> {
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>({ projectId, ...options }?: {
        projectId?: string | number;
    } & PaginationRequestOptions<P> & BaseRequestOptions<E>): Promise<GitlabAPIResponse<ExpandedDeployKeySchema[], C, E, P>>;
    create<E extends boolean = false>(projectId: string | number, title: string, key: string, options?: {
        canPush?: boolean;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<DeployKeySchema, C, E, void>>;
    edit<E extends boolean = false>(projectId: string | number, keyId: number, options?: BaseRequestOptions<E>): Promise<GitlabAPIResponse<DeployKeySchema, C, E, void>>;
    enable<E extends boolean = false>(projectId: string | number, keyId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<CondensedDeployKeySchema, C, E, void>>;
    remove<E extends boolean = false>(projectId: string | number, keyId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
    show<E extends boolean = false>(projectId: string | number, keyId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<DeployKeySchema, C, E, void>>;
}

type DeployTokenScope = 'read_repository' | 'read_registry' | 'write_registry' | 'read_package_registry' | 'write_package_registry';
interface DeployTokenSchema extends Record<string, unknown> {
    id: number;
    name: string;
    username: string;
    expires_at: string;
    revoked: boolean;
    expired: boolean;
    scopes?: DeployTokenScope[];
}
declare class DeployTokens<C extends boolean = false> extends BaseResource<C> {
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>({ projectId, groupId, ...options }?: EitherOrNone<{
        projectId: string | number;
    }, {
        groupId: string | number;
    }> & PaginationRequestOptions<P> & BaseRequestOptions<E>): Promise<GitlabAPIResponse<DeployTokenSchema[], C, E, P>>;
    create<E extends boolean = false>(name: string, scopes: string[], { projectId, groupId, ...options }?: Either<{
        projectId: string | number;
    }, {
        groupId: string | number;
    }> & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<DeployTokenSchema, C, E, void>>;
    remove<E extends boolean = false>(tokenId: number, { projectId, groupId, ...options }?: Either<{
        projectId: string | number;
    }, {
        groupId: string | number;
    }> & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
}

declare class ResourceNoteAwardEmojis<C extends boolean = false> extends BaseResource<C> {
    protected resourceType: string;
    constructor(resourceType: string, options: BaseResourceOptions<C>);
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(projectId: string | number, resourceIId: number, noteId: number, options?: PaginationRequestOptions<P> & BaseRequestOptions<E>): Promise<GitlabAPIResponse<AwardEmojiSchema[], C, E, P>>;
    award<E extends boolean = false>(projectId: string | number, resourceIId: number, noteId: number, name: string, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<AwardEmojiSchema, C, E, void>>;
    remove<E extends boolean = false>(projectId: string | number, resourceIId: number, noteId: number, awardId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
    show<E extends boolean = false>(projectId: string | number, resourceIId: number, noteId: number, awardId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<AwardEmojiSchema, C, E, void>>;
}

declare class DockerfileTemplates<C extends boolean = false> extends ResourceTemplates<C> {
    constructor(options: BaseResourceOptions<C>);
}

interface ExperimentGateSchema {
    key: string;
    value: boolean | number;
}
interface ExperimentSchema extends Record<string, unknown> {
    key: string;
    definition: {
        name: string;
        introduced_by_url: string;
        rollout_issue_url: string;
        milestone: string;
        type: string;
        group: string;
        default_enabled: boolean;
    };
    current_status: {
        state: string;
        gates?: ExperimentGateSchema[];
    };
}
declare class Experiments<C extends boolean = false> extends BaseResource<C> {
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(options?: PaginationRequestOptions<P> & BaseRequestOptions<E>): Promise<GitlabAPIResponse<ExperimentSchema[], C, E, P>>;
}

interface GeoNodeSchema extends Record<string, unknown> {
    id: number;
    name: string;
    url: string;
    internal_url: string;
    primary: boolean;
    enabled: boolean;
    current: boolean;
    files_max_capacity: number;
    repos_max_capacity: number;
    verification_max_capacity: number;
    selective_sync_type: string;
    selective_sync_shards?: string[];
    selective_sync_namespace_ids?: number[];
    minimum_reverification_interval: number;
    container_repositories_max_capacity: number;
    sync_object_storage: boolean;
    clone_protocol: string;
    web_edit_url: string;
    web_geo_projects_url: string;
    _links: {
        self: string;
        status: string;
        repair: string;
    };
}
interface GeoNodeFailureSchema extends Record<string, unknown> {
    project_id: number;
    last_repository_synced_at: string;
    last_repository_successful_sync_at: string;
    last_wiki_synced_at: string;
    last_wiki_successful_sync_at: string;
    repository_retry_count?: number;
    wiki_retry_count: number;
    last_repository_sync_failure?: string;
    last_wiki_sync_failure: string;
    last_repository_verification_failure: string;
    last_wiki_verification_failure: string;
    repository_verification_checksum_sha: string;
    wiki_verification_checksum_sha: string;
    repository_checksum_mismatch: boolean;
    wiki_checksum_mismatch: boolean;
}
interface GeoNodeStatusSchema extends Record<string, unknown> {
    geo_node_id: number;
    healthy: boolean;
    health: string;
    health_status: string;
    missing_oauth_application: boolean;
    attachments_count: number;
    attachments_synced_count?: number;
    attachments_failed_count?: number;
    attachments_synced_missing_on_primary_count: number;
    attachments_synced_in_percentage: string;
    db_replication_lag_seconds?: number;
    lfs_objects_count: number;
    lfs_objects_synced_count?: number;
    lfs_objects_failed_count?: number;
    lfs_objects_synced_missing_on_primary_count: number;
    lfs_objects_synced_in_percentage: string;
    job_artifacts_count: number;
    job_artifacts_synced_count?: number;
    job_artifacts_failed_count?: number;
    job_artifacts_synced_missing_on_primary_count: number;
    job_artifacts_synced_in_percentage: string;
    container_repositories_count: number;
    container_repositories_synced_count?: number;
    container_repositories_failed_count?: number;
    container_repositories_synced_in_percentage: string;
    design_repositories_count: number;
    design_repositories_synced_count?: number;
    design_repositories_failed_count?: number;
    design_repositories_synced_in_percentage: string;
    projects_count: number;
    repositories_count: number;
    repositories_failed_count?: number;
    repositories_synced_count?: number;
    repositories_synced_in_percentage: string;
    wikis_count: number;
    wikis_failed_count?: number;
    wikis_synced_count?: number;
    wikis_synced_in_percentage: string;
    replication_slots_count: number;
    replication_slots_used_count: number;
    replication_slots_used_in_percentage: string;
    replication_slots_max_retained_wal_bytes: number;
    repositories_checked_count: number;
    repositories_checked_failed_count: number;
    repositories_checked_in_percentage: string;
    repositories_checksummed_count: number;
    repositories_checksum_failed_count: number;
    repositories_checksummed_in_percentage: string;
    wikis_checksummed_count: number;
    wikis_checksum_failed_count: number;
    wikis_checksummed_in_percentage: string;
    repositories_verified_count: number;
    repositories_verification_failed_count: number;
    repositories_verified_in_percentage: string;
    repositories_checksum_mismatch_count: number;
    wikis_verified_count: number;
    wikis_verification_failed_count: number;
    wikis_verified_in_percentage: string;
    wikis_checksum_mismatch_count: number;
    repositories_retrying_verification_count: number;
    wikis_retrying_verification_count: number;
    last_event_id: number;
    last_event_timestamp: number;
    cursor_last_event_id?: number;
    cursor_last_event_timestamp: number;
    last_successful_status_check_timestamp: number;
    version: string;
    revision: string;
    package_files_count: number;
    package_files_checksummed_count: number;
    package_files_checksum_failed_count: number;
    package_files_registry_count: number;
    package_files_synced_count: number;
    package_files_failed_count: number;
    snippet_repositories_count: number;
    snippet_repositories_checksummed_count: number;
    snippet_repositories_checksum_failed_count: number;
    snippet_repositories_registry_count: number;
    snippet_repositories_synced_count: number;
    snippet_repositories_failed_count: number;
    group_wiki_repositories_checksummed_count: number;
    group_wiki_repositories_checksum_failed_count: number;
    group_wiki_repositories_registry_count: number;
    group_wiki_repositories_synced_count: number;
    group_wiki_repositories_failed_count: number;
}
declare class GeoNodes<C extends boolean = false> extends BaseResource<C> {
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(options?: PaginationRequestOptions<P> & BaseRequestOptions<E>): Promise<GitlabAPIResponse<GeoNodeSchema[], C, E, P>>;
    allStatuses<E extends boolean = false, P extends PaginationTypes = 'offset'>(options?: PaginationRequestOptions<P> & BaseRequestOptions<E>): Promise<GitlabAPIResponse<GeoNodeStatusSchema[], C, E, P>>;
    allFailures<E extends boolean = false, P extends PaginationTypes = 'offset'>(options?: PaginationRequestOptions<P> & BaseRequestOptions<E>): Promise<GitlabAPIResponse<GeoNodeFailureSchema[], C, E, P>>;
    create<E extends boolean = false>(name: string, options?: BaseRequestOptions<E>): Promise<GitlabAPIResponse<GeoNodeSchema, C, E, void>>;
    edit<E extends boolean = false>(geonodeId: number, name: string, url: string, options?: BaseRequestOptions<E>): Promise<GitlabAPIResponse<GeoNodeSchema, C, E, void>>;
    repair<E extends boolean = false>(geonodeId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<GeoNodeSchema, C, E, void>>;
    remove<E extends boolean = false>(geonodeId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
    show<E extends boolean = false>(geonodeId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<GeoNodeSchema, C, E, void>>;
    showStatus<E extends boolean = false>(geonodeId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<GeoNodeStatusSchema, C, E, void>>;
}

declare class GitignoreTemplates<C extends boolean = false> extends ResourceTemplates<C> {
    constructor(options: BaseResourceOptions<C>);
}

declare class GitLabCIYMLTemplates<C extends boolean = false> extends ResourceTemplates<C> {
    constructor(options: BaseResourceOptions<C>);
}

interface RepositoryImportStatusSchema extends Record<string, unknown> {
    id: number;
    name: string;
    full_path: string;
    full_name: string;
}
declare class Import<C extends boolean = false> extends BaseResource<C> {
    importGithubRepository<E extends boolean = false>(personalAccessToken: string, repositoryId: number, targetNamespace: string, options?: BaseRequestOptions<E>): Promise<GitlabAPIResponse<RepositoryImportStatusSchema, C, E, void>>;
    cancelGithubRepositoryImport<E extends boolean = false>(projectId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<RepositoryImportStatusSchema, C, E, void>>;
    importBitbucketServerRepository<E extends boolean = false>(bitbucketServerUrl: string, bitbucketServerUsername: string, personalAccessToken: string, bitbucketServerProject: string, bitbucketServerRepository: string, options?: BaseRequestOptions<E>): Promise<GitlabAPIResponse<RepositoryImportStatusSchema, C, E, void>>;
}

interface CICDVariableSchema extends Record<string, unknown> {
    key: string;
    variable_type: string;
    value: string;
    protected: boolean;
    masked: boolean;
}
declare class InstanceLevelCICDVariables<C extends boolean = false> extends BaseResource<C> {
    all<E extends boolean = false>(options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<CICDVariableSchema[], C, E, void>>;
    create<E extends boolean = false>(key: string, value: string, options?: BaseRequestOptions<E>): Promise<GitlabAPIResponse<CICDVariableSchema, C, E, void>>;
    edit<E extends boolean = false>(keyId: string, value: string, options?: BaseRequestOptions<E>): Promise<GitlabAPIResponse<CICDVariableSchema, C, E, void>>;
    show<E extends boolean = false>(keyId: string, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<CICDVariableSchema, C, E, void>>;
    remove<E extends boolean = false>(keyId: string, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
}

interface KeySchema extends Record<string, unknown> {
    id: number;
    title: string;
    key: string;
    created_at: string;
    expires_at: string;
    user: ExpandedUserSchema;
}
declare class Keys<C extends boolean = false> extends BaseResource<C> {
    show<E extends boolean = false>({ keyId, fingerprint, ...options }: Either<{
        keyId: number;
    }, {
        fingerprint: string;
    }> & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<KeySchema, C, E, void>>;
}

interface LicenseSchema extends Record<string, unknown> {
    id: number;
    plan: string;
    created_at: string;
    starts_at: string;
    expires_at: string;
    historical_max: number;
    maximum_user_count: number;
    expired: boolean;
    overage: number;
    user_limit: number;
    active_users: number;
    licensee: {
        Name: string;
    };
    add_ons: {
        GitLab_FileLocks: number;
        GitLab_Auditor_User: number;
    };
}
declare class License<C extends boolean = false> extends BaseResource<C> {
    add<E extends boolean = false>(license: string, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<LicenseSchema, C, E, void>>;
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(options?: Sudo & ShowExpanded<E> & PaginationRequestOptions<P>): Promise<GitlabAPIResponse<LicenseSchema[], C, E, P>>;
    show<E extends boolean = false>(options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<LicenseSchema, C, E, void>>;
    remove<E extends boolean = false>(licenceId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<LicenseSchema, C, E, void>>;
}

interface LicenseTemplateSchema extends Record<string, unknown> {
    key: string;
    name: string;
    nickname?: string;
    featured: boolean;
    html_url: string;
    source_url: string;
    description: string;
    conditions?: string[];
    permissions?: string[];
    limitations?: string[];
    content: string;
}
interface LicenseTemplates<C extends boolean = false> extends ResourceTemplates<C> {
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(options?: PaginationRequestOptions<P> & BaseRequestOptions<E>): Promise<GitlabAPIResponse<LicenseTemplateSchema[], C, E, P>>;
    show<E extends boolean = false>(key: string | number, options?: Sudo): Promise<GitlabAPIResponse<LicenseTemplateSchema, C, E, void>>;
}
declare class LicenseTemplates<C extends boolean = false> extends ResourceTemplates<C> {
    constructor(options: BaseResourceOptions<C>);
}

interface LintSchema extends Record<string, unknown> {
    status: string;
    errors?: string[];
    warnings?: string[];
    merged_yaml?: string;
}
interface ContextualLintSchema extends Omit<LintSchema, 'status'> {
    valid: boolean;
}
declare class Lint<C extends boolean = false> extends BaseResource<C> {
    check<E extends boolean = false>(projectId: string | number, options: BaseRequestOptions<E>): Promise<GitlabAPIResponse<ContextualLintSchema, C, E, void>>;
    lint<E extends boolean = false>(content: string, options?: BaseRequestOptions<E>): Promise<GitlabAPIResponse<LintSchema, C, E, void>>;
    lint<E extends boolean = false>(content: string, options?: {
        projectId: string | number;
    } & BaseRequestOptions<E>): Promise<GitlabAPIResponse<ContextualLintSchema, C, E, void>>;
}

interface ManagedLicenseSchema extends Record<string, unknown> {
    id: number;
    name: string;
    approval_status: 'approved' | 'blacklisted';
}
declare class ManagedLicenses<C extends boolean = false> extends BaseResource<C> {
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(projectId: string | number, options?: Sudo & ShowExpanded<E> & PaginationRequestOptions<P>): Promise<GitlabAPIResponse<ManagedLicenseSchema[], C, E, P>>;
    create<E extends boolean = false>(projectId: string | number, name: string, approvalStatus: 'approved' | 'blacklisted', options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<ManagedLicenseSchema[], C, E, void>>;
    edit<E extends boolean = false>(projectId: string | number, managedLicenceId: number, approvalStatus: 'approved' | 'blacklisted', options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<ManagedLicenseSchema, C, E, void>>;
    show<E extends boolean = false>(projectId: string | number, managedLicenceId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<ManagedLicenseSchema, C, E, void>>;
    remove<E extends boolean = false>(projectId: string | number, managedLicenceId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
}

interface MarkdownSchema extends Record<string, unknown> {
    html: string;
}
declare class Markdown<C extends boolean = false> extends BaseResource<C> {
    render<E extends boolean = false>(text: string, options?: {
        gfm?: string;
        project?: string | number;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<MarkdownSchema, C, E, void>>;
}

declare class Maven<C extends boolean = false> extends BaseResource<C> {
    downloadPackageFile<E extends boolean = false>(path: string, filename: string, { projectId, groupId, ...options }: EitherOrNone<{
        projectId: string | number;
    }, {
        groupId: string | number;
    }> & ShowExpanded<E>): Promise<GitlabAPIResponse<Blob, void, E, void>>;
    uploadPackageFile<E extends boolean = false>(projectId: string | number, content: Blob, path: string, filename: string, options?: ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
}

interface MetadataSchema extends Record<string, unknown> {
    version: string;
    revision: string;
    kas: {
        enabled: boolean;
        externalUrl: string;
        version: string;
    };
    enterprise: boolean;
}
declare class Metadata<C extends boolean = false> extends BaseResource<C> {
    show<E extends boolean = false>(options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<MetadataSchema, C, E, void>>;
}

interface MigrationEntityOptions {
    sourceFullPath: string;
    sourceType: string;
    destinationName: string;
    destinationNamespace: string;
    destinationNamespacePace?: string;
}
interface MigrationEntityFailure {
    pipeline_class: string;
    pipeline_step: string;
    exception_class: string;
    correlation_id_value: string;
    created_at: string;
}
interface MigrationEntitySchema extends Record<string, unknown> {
    id: number;
    bulk_import_id: number;
    status: string;
    source_full_path: string;
    destination_name: string;
    destination_namespace: string;
    parent_id?: number;
    namespace_id: number;
    project_id?: string | number;
    created_at: string;
    updated_at: string;
    failures?: MigrationEntityFailure[];
}
interface MigrationStatusSchema extends Record<string, unknown> {
    id: number;
    status: string;
    source_type: string;
    created_at: string;
    updated_at: string;
}
declare class Migrations<C extends boolean = false> extends BaseResource<C> {
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(options?: {
        status?: 'created' | 'started' | 'finished' | 'finished';
    } & PaginationRequestOptions<P> & BaseRequestOptions<E>): Promise<GitlabAPIResponse<MigrationStatusSchema[], C, E, P>>;
    create<E extends boolean = false>(configuration: {
        url: string;
        access_token: string;
    }, entities: MigrationEntityOptions[], options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<MigrationStatusSchema, C, E, void>>;
    allEntities<E extends boolean = false>({ bulkImportId, ...options }?: {
        status?: 'created' | 'started' | 'finished' | 'finished';
        bulkImportId?: number;
    } & PaginationRequestOptions<'offset'> & BaseRequestOptions<E>): Promise<GitlabAPIResponse<MigrationEntitySchema[], C, E, 'offset'>>;
    show<E extends boolean = false>(bulkImportId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<MigrationStatusSchema, C, E, void>>;
    showEntity<E extends boolean = false>(bulkImportId: number, entitityId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<MigrationEntitySchema, C, E, void>>;
}

type NotificationSettingLevel = 'disabled' | 'participating' | 'watch' | 'global' | 'mention' | 'custom';
type CustomSettingLevelEmailEvents = 'new_note' | 'new_issue' | 'reopen_issue' | 'close_issue' | 'reassign_issue' | 'issue_due' | 'new_merge_request' | 'push_to_merge_request' | 'reopen_merge_request' | 'close_merge_request' | 'reassign_merge_request' | 'merge_merge_request' | 'failed_pipeline' | 'fixed_pipeline' | 'success_pipeline' | 'moved_project' | 'merge_when_pipeline_succeeds' | 'new_epic ';
interface NotificationSettingSchema extends Record<string, unknown> {
    level: NotificationSettingLevel;
    notification_email: string;
}
declare class NotificationSettings<C extends boolean = false> extends BaseResource<C> {
    edit<E extends boolean = false>({ groupId, projectId, ...options }?: EitherOrNone<{
        projectId: string | number;
    }, {
        groupId: string | number;
    }> & BaseRequestOptions<E>): Promise<GitlabAPIResponse<NotificationSettingSchema, C, E, void>>;
    show<E extends boolean = false>({ groupId, projectId, ...options }?: EitherOrNone<{
        projectId: string | number;
    }, {
        groupId: string | number;
    }> & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<NotificationSettingSchema, C, E, void>>;
}

interface NPMVersionSchema {
    name: string;
    version: string;
    dist: {
        shasum: string;
        tarball: string;
    };
}
interface NPMPackageMetadataSchema extends Record<string, unknown> {
    name: string;
    versions: {
        [version: string]: NPMVersionSchema;
    };
    'dist-tags': {
        [tag: string]: string;
    };
}
declare class NPM<C extends boolean = false> extends BaseResource<C> {
    downloadPackageFile<E extends boolean = false>(projectId: string | number, packageName: string, filename: string, options?: ShowExpanded<E>): Promise<GitlabAPIResponse<Blob, void, E, void>>;
    removeDistTag<E extends boolean = false>(packageName: string, tag: string, options?: {
        projectId?: string | number;
    } & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
    setDistTag<E extends boolean = false>(packageName: string, tag: string, options?: {
        projectId?: string | number;
    } & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
    showDistTags<E extends boolean = false>(packageName: string, options?: {
        projectId?: string | number;
    } & ShowExpanded<E>): Promise<GitlabAPIResponse<Record<string, string>, C, E, void>>;
    showMetadata<E extends boolean = false>(packageName: string, options?: {
        projectId?: string | number;
    } & ShowExpanded<E>): Promise<GitlabAPIResponse<NPMPackageMetadataSchema, C, E, void>>;
    uploadPackageFile<E extends boolean = false>(projectId: string | number, packageName: string, versions: string, options?: ShowExpanded<E>): Promise<GitlabAPIResponse<Record<string, unknown>, C, E, void>>;
}

interface NuGetPackageIndexSchema extends Record<string, unknown> {
    versions: string[];
}
interface NuGetResourceSchema extends Record<string, unknown> {
    '@id': string;
    '@type': string;
    comment: string;
}
interface NuGetServiceIndexSchema extends Record<string, unknown> {
    version: string;
    resources: NuGetResourceSchema[];
}
interface NuGetServiceMetadataVersionSchema extends Record<string, unknown> {
    '@id': string;
    packageContent: string;
    catalogEntry: {
        '@id': string;
        authors: string;
        dependencyGroups: unknown[];
        id: string;
        version: string;
        tags: string;
        packageContent: string;
        summary: string;
    };
}
interface NuGetServiceMetadataItemSchema extends Record<string, unknown> {
    '@id': string;
    lower: string;
    upper: string;
    count: number;
    items: NuGetServiceMetadataVersionSchema;
}
interface NuGetServiceMetadataSchema extends Record<string, unknown> {
    count: number;
    items: NuGetServiceMetadataItemSchema[];
    resources: NuGetResourceSchema[];
}
interface NuGetSearchResultSchema extends Record<string, unknown> {
    '@type': string;
    authors: string;
    id: string;
    title: string;
    version: string;
    verified: boolean;
    summary: string;
    totalDownloads: number;
    versions: {
        '@id': string;
        version: string;
        download: number;
    }[];
}
interface NuGetSearchResultsSchema extends Record<string, unknown> {
    totalHits: number;
    data: NuGetSearchResultSchema[];
}
declare class NuGet<C extends boolean = false> extends BaseResource<C> {
    downloadPackageFile<E extends boolean = false>(projectId: string | number, packageName: string, packageVersion: string, filename: string, options?: ShowExpanded<E>): Promise<GitlabAPIResponse<Blob, void, E, void>>;
    search<E extends boolean = false>(q: string, { projectId, groupId, ...options }: Either<{
        projectId: string | number;
    }, {
        groupId: string | number;
    }> & {
        skip?: number;
        take?: number;
        prerelease?: boolean;
    } & ShowExpanded<E>): Promise<GitlabAPIResponse<NuGetSearchResultsSchema, C, E, void>>;
    showMetadata<E extends boolean = false>(packageName: string, { projectId, groupId, ...options }: Either<{
        projectId: string | number;
    }, {
        groupId: string | number;
    }> & ShowExpanded<E>): Promise<GitlabAPIResponse<NuGetServiceMetadataSchema, C, E, void>>;
    showPackageIndex<E extends boolean = false>(projectId: string | number, packageName: string, options?: ShowExpanded<E>): Promise<GitlabAPIResponse<NuGetPackageIndexSchema, C, E, void>>;
    showServiceIndex<E extends boolean = false>({ projectId, groupId, ...options }: Either<{
        projectId: string | number;
    }, {
        groupId: string | number;
    }> & ShowExpanded<E>): Promise<GitlabAPIResponse<NuGetServiceIndexSchema, C, E, void>>;
    showVersionMetadata<E extends boolean = false>(packageName: string, packageVersion: string, { projectId, groupId, ...options }: Either<{
        projectId: string | number;
    }, {
        groupId: string | number;
    }> & ShowExpanded<E>): Promise<GitlabAPIResponse<NuGetServiceMetadataVersionSchema, C, E, void>>;
    uploadPackageFile<E extends boolean = false>(projectId: string | number, packageName: string, packageVersion: string, content: Blob, filename: string, options?: ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
    uploadSymbolPackage<E extends boolean = false>(projectId: string | number, packageName: string, packageVersion: string, content: Blob, filename: string, options?: ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
}

declare class PyPI<C extends boolean = false> extends BaseResource<C> {
    downloadPackageFile<E extends boolean = false>(sha: string, fileIdentifier: string, { projectId, groupId, ...options }: Either<{
        projectId: string | number;
    }, {
        groupId: string | number;
    }> & ShowExpanded<E>): Promise<GitlabAPIResponse<Blob, void, E, void>>;
    showPackageDescriptor<E extends boolean = false>(packageName: string, { projectId, groupId, ...options }: Either<{
        projectId: string | number;
    }, {
        groupId: string | number;
    }> & ShowExpanded<E>): Promise<GitlabAPIResponse<string, C, E, void>>;
    uploadPackageFile<E extends boolean = false>(projectId: string | number, content: Blob, filename: string, options?: ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
}

type SnippetVisibility = 'private' | 'public' | 'internal';
interface SimpleSnippetSchema extends Record<string, unknown> {
    id: number;
    title: string;
    file_name: string;
    description?: string;
    author: Omit<UserSchema, 'created_at'>;
    updated_at: string;
    created_at: string;
    project_id?: string | number;
    web_url: string;
}
interface SnippetSchema extends SimpleSnippetSchema {
    visibility: SnippetVisibility;
    raw_url: string;
}
interface ExpandedSnippetSchema extends SnippetSchema {
    expires_at?: string;
    ssh_url_to_repo: string;
    http_url_to_repo: string;
    files?: {
        path: string;
        raw_url: string;
    }[];
}
declare class Snippets<C extends boolean = false> extends BaseResource<C> {
    all<E extends boolean = false>({ public: ppublic, ...options }?: {
        public?: boolean;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<SnippetSchema[], C, E, void>>;
    create<E extends boolean = false>(title: string, options?: BaseRequestOptions<E>): Promise<GitlabAPIExpandedResponse<CamelizedResponse<ExpandedSnippetSchema, C>, E, undefined>>;
    edit<E extends boolean = false>(snippetId: number, options?: BaseRequestOptions<E>): Promise<GitlabAPIExpandedResponse<CamelizedResponse<ExpandedSnippetSchema, C>, E, undefined>>;
    remove<E extends boolean = false>(snippetId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIExpandedResponse<void, E, undefined>>;
    show<E extends boolean = false>(snippetId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<SnippetSchema, C, E, void>>;
    showContent<E extends boolean = false>(snippetId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<string, C, E, void>>;
    showRepositoryFileContent<E extends boolean = false>(snippetId: number, ref: string, filePath: string, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<string, C, E, void>>;
    showUserAgentDetails<E extends boolean = false>(snippetId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIExpandedResponse<CamelizedResponse<UserAgentDetailSchema, C>, E, undefined>>;
}

interface BlobSchema extends Record<string, unknown> {
    id: number;
    basename: string;
    data: string;
    path: string;
    filename: string;
    ref: string;
    startline: number;
    project_id: number;
}
type SearchScopes = 'projects' | 'issues' | 'merge_requests' | 'milestones' | 'snippet_titles' | 'wiki_blobs' | 'commits' | 'blobs' | 'notes' | 'users';
declare class Search<C extends boolean = false> extends BaseResource<C> {
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(scope: 'users', search: string, options?: EitherOrNone<{
        projectId: string | number;
    }, {
        groupId: string | number;
    }> & BaseRequestOptions<E> & PaginationRequestOptions<P>): Promise<GitlabAPIResponse<UserSchema[], C, E, void>>;
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(scope: 'notes', search: string, options?: EitherOrNone<{
        projectId: string | number;
    }, {
        groupId: string | number;
    }> & BaseRequestOptions<E> & PaginationRequestOptions<P>): Promise<GitlabAPIResponse<NoteSchema[], C, E, P>>;
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(scope: 'blobs', search: string, options?: EitherOrNone<{
        projectId: string | number;
    }, {
        groupId: string | number;
    }> & BaseRequestOptions<E> & PaginationRequestOptions<P>): Promise<GitlabAPIResponse<BlobSchema[], C, E, P>>;
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(scope: 'commits', search: string, options?: EitherOrNone<{
        projectId: string | number;
    }, {
        groupId: string | number;
    }> & BaseRequestOptions<E> & PaginationRequestOptions<P>): Promise<GitlabAPIResponse<CommitSchema[], C, E, P>>;
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(scope: 'wiki_blobs', search: string, options?: EitherOrNone<{
        projectId: string | number;
    }, {
        groupId: string | number;
    }> & BaseRequestOptions<E> & PaginationRequestOptions<P>): Promise<GitlabAPIResponse<BlobSchema[], C, E, P>>;
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(scope: 'snippet_titles', search: string, options?: EitherOrNone<{
        projectId: string | number;
    }, {
        groupId: string | number;
    }> & BaseRequestOptions<E> & PaginationRequestOptions<P>): Promise<GitlabAPIResponse<SimpleSnippetSchema[], C, E, P>>;
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(scope: 'milestones', search: string, options?: EitherOrNone<{
        projectId: string | number;
    }, {
        groupId: string | number;
    }> & BaseRequestOptions<E> & PaginationRequestOptions<P>): Promise<GitlabAPIResponse<MilestoneSchema[], C, E, P>>;
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(scope: 'merge_requests', search: string, options?: EitherOrNone<{
        projectId: string | number;
    }, {
        groupId: string | number;
    }> & BaseRequestOptions<E> & PaginationRequestOptions<P>): Promise<GitlabAPIResponse<MergeRequestSchema[], C, E, P>>;
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(scope: 'issues', search: string, options?: EitherOrNone<{
        projectId: string | number;
    }, {
        groupId: string | number;
    }> & BaseRequestOptions<E> & PaginationRequestOptions<P>): Promise<GitlabAPIResponse<IssueSchema[], C, E, P>>;
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(scope: 'projects', search: string, options?: EitherOrNone<{
        projectId: string | number;
    }, {
        groupId: string | number;
    }> & BaseRequestOptions<E> & PaginationRequestOptions<P>): Promise<GitlabAPIResponse<ProjectSchema[], C, E, P>>;
}

declare class ServiceData<C extends boolean = false> extends BaseResource<C> {
    showMetricDefinitions<E extends boolean = false>(options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<string, C, E, void>>;
    showServicePingSQLQueries<E extends boolean = false>(options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<Record<string, unknown>, C, E, void>>;
    showUsageDataNonSQLMetrics<E extends boolean = false>(options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<Record<string, unknown>, C, E, void>>;
}

interface ProcessMetricSchema {
    hostname: string;
    pid: number;
    tag: string;
    started_at: string;
    queues?: string[];
    labels?: string[];
    concurrency: number;
    busy: number;
}
interface SidekickProcessMetricsSchema extends Record<string, unknown> {
    processes?: ProcessMetricSchema[];
}
interface SidekickQueueMetricsSchema extends Record<string, unknown> {
    queues: {
        default: {
            backlog: number;
            latency: number;
        };
    };
}
interface SidekickJobStatsSchema extends Record<string, unknown> {
    jobs: {
        processed: number;
        failed: number;
        enqueued: number;
        dead: number;
    };
}
type SidekickCompoundMetricsSchema = SidekickJobStatsSchema & SidekickQueueMetricsSchema & SidekickProcessMetricsSchema;
declare class SidekiqMetrics<C extends boolean = false> extends BaseResource<C> {
    queueMetrics<E extends boolean = false>(): Promise<GitlabAPIResponse<SidekickQueueMetricsSchema, C, E, void>>;
    processMetrics<E extends boolean = false>(): Promise<GitlabAPIResponse<SidekickProcessMetricsSchema, C, E, void>>;
    jobStats<E extends boolean = false>(): Promise<GitlabAPIResponse<SidekickJobStatsSchema, C, E, void>>;
    compoundMetrics<E extends boolean = false>(): Promise<GitlabAPIResponse<SidekickCompoundMetricsSchema, C, E, void>>;
}

interface SidekiqQueueStatus extends Record<string, unknown> {
    completed: boolean;
    deleted_jobs: number;
    queue_size: number;
}
declare class SidekiqQueues<C extends boolean = false> extends BaseResource<C> {
    remove<E extends boolean = false>(queueName: string, options?: BaseRequestOptions<E>): Promise<GitlabAPIResponse<SidekiqQueueStatus, C, E, void>>;
}

interface SnippetRepositoryStorageMoveSchema extends RepositoryStorageMoveSchema {
    snippet: Pick<SnippetSchema, 'id' | 'title' | 'description' | 'visibility' | 'updated_at' | 'created_at' | 'created_at' | 'web_url' | 'raw_url' | 'ssh_url_to_repo' | 'http_url_to_repo'>;
}
interface SnippetRepositoryStorageMoves<C extends boolean = false> extends ResourceRepositoryStorageMoves<C> {
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(options?: {
        snippetId?: string | number;
    } & PaginationRequestOptions<P> & BaseRequestOptions<E>): Promise<GitlabAPIResponse<SnippetRepositoryStorageMoveSchema[], C, E, P>>;
    show<E extends boolean = false, P extends PaginationTypes = 'offset'>(repositoryStorageId: number, options?: {
        snippetId?: string | number;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<SnippetRepositoryStorageMoveSchema, C, E, P>>;
    schedule<E extends boolean = false, P extends PaginationTypes = 'offset'>(sourceStorageName: string, options?: {
        snippetId?: string | number;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<SnippetRepositoryStorageMoveSchema, C, E, P>>;
}
declare class SnippetRepositoryStorageMoves<C extends boolean = false> extends ResourceRepositoryStorageMoves<C> {
    constructor(options: BaseResourceOptions<C>);
}

interface SuggestionSchema extends Record<string, unknown> {
    id: number;
    from_line: number;
    to_line: number;
    appliable: boolean;
    applied: boolean;
    from_content: string;
    to_content: string;
}
declare class Suggestions<C extends boolean = false> extends BaseResource<C> {
    edit<E extends boolean = false>(suggestionId: number, options?: {
        commitMessage?: string;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<SuggestionSchema, C, E, void>>;
}

interface SystemHookTestResponse extends Record<string, unknown> {
    project_id: number;
    owner_email: string;
    owner_name: string;
    name: string;
    path: string;
    event_name: string;
}
declare class SystemHooks<C extends boolean = false> extends BaseResource<C> {
    add<E extends boolean = false>(url: string, options?: BaseRequestOptions<E>): Promise<GitlabAPIResponse<HookSchema, C, E, void>>;
    all<E extends boolean = false>(options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<HookSchema[], C, E, void>>;
    create<E extends boolean = false>(url: string, options?: BaseRequestOptions<E>): Promise<GitlabAPIResponse<HookSchema, C, E, void>>;
    test<E extends boolean = false>(hookId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<SystemHookTestResponse, C, E, void>>;
    remove<E extends boolean = false>(hookId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
    show<E extends boolean = false>(hookId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<HookSchema, C, E, void>>;
}

interface TopicSchema extends Record<string, unknown> {
    id: number;
    name: string;
    description: string;
    total_projects_count: number;
    avatar_url: string;
}
declare class Topics<C extends boolean = false> extends BaseResource<C> {
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(options?: {
        search?: string;
    } & PaginationRequestOptions<P> & BaseRequestOptions<E>): Promise<GitlabAPIResponse<TopicSchema[], C, E, P>>;
    create<E extends boolean = false>(name: string, { avatar, ...options }?: {
        avatar?: {
            content: Blob;
            filename: string;
        };
        description?: string;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<TopicSchema, C, E, void>>;
    edit<E extends boolean = false>(topicId: number, { avatar, ...options }?: {
        name?: string;
        avatar?: {
            content: Blob;
            filename: string;
        };
        description?: string;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<TopicSchema, C, E, void>>;
    merge<E extends boolean = false>(sourceTopicId: number, targetTopicId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<TopicSchema, C, E, void>>;
    remove<E extends boolean = false>(topicId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
    show<E extends boolean = false>(topicId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<TopicSchema, C, E, void>>;
}

interface VersionSchema extends Record<string, unknown> {
    version: string;
    revision: string;
}
declare class Version<C extends boolean = false> extends BaseResource<C> {
    show<E extends boolean = false>(options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<VersionSchema, C, E, void>>;
}

interface VulnerabilitySchema extends Record<string, unknown> {
    id: number;
    title: string;
    description?: string;
    state: string;
    severity: string;
    confidence: string;
    report_type: string;
    project: SimpleProjectSchema;
    author_id: number;
    updated_by_id?: number;
    last_edited_by_id?: number;
    closed_by_id?: number;
    start_date?: string;
    due_date?: string;
    created_at: string;
    updated_at: string;
    last_edited_at?: string;
    closed_at?: string;
}
declare class Vulnerabilities<C extends boolean = false> extends BaseResource<C> {
    confirm<E extends boolean = false>(vulnerabilityId: string | number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<VulnerabilitySchema, C, E, void>>;
    dismiss<E extends boolean = false>(vulnerabilityId: string | number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<VulnerabilitySchema, C, E, void>>;
    revert<E extends boolean = false>(vulnerabilityId: string | number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<VulnerabilitySchema, C, E, void>>;
    resolve<E extends boolean = false>(vulnerabilityId: string | number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<VulnerabilitySchema, C, E, void>>;
    show<E extends boolean = false>(vulnerabilityId: string | number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<VulnerabilitySchema, C, E, void>>;
}

interface BranchSchema extends Record<string, unknown> {
    name: string;
    merged: boolean;
    protected: boolean;
    default: boolean;
    developers_can_push: boolean;
    developers_can_merge: boolean;
    can_push: boolean;
    web_url: string;
    commit: Omit<CommitSchema, 'web_url' | 'created_at'>;
}
declare class Branches<C extends boolean = false> extends BaseResource<C> {
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(projectId: string | number, options?: PaginationRequestOptions<P> & BaseRequestOptions<E>): Promise<GitlabAPIResponse<BranchSchema[], C, E, P>>;
    create<E extends boolean = false>(projectId: string | number, branchName: string, ref: string, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<BranchSchema, C, E, void>>;
    remove<E extends boolean = false>(projectId: string | number, branchName: string, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
    removeMerged<E extends boolean = false>(projectId: string | number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
    show<E extends boolean = false>(projectId: string | number, branchName: string, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<BranchSchema, C, E, void>>;
}

interface CommitDiscussions<C extends boolean = false> extends ResourceDiscussions<C> {
    addNote<E extends boolean = false>(projectId: string | number, commitId: number, discussionId: string, noteId: number, body: string, options?: BaseRequestOptions<E>): Promise<GitlabAPIResponse<DiscussionNoteSchema, C, E, void>>;
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(projectId: string | number, commitId: number, options?: PaginationRequestOptions<P> & BaseRequestOptions<E>): Promise<GitlabAPIResponse<DiscussionSchema[], C, E, P>>;
    create<E extends boolean = false>(projectId: string | number, commitId: number, body: string, options: {
        position?: DiscussionNotePositionSchema;
    } & BaseRequestOptions<E>): Promise<GitlabAPIResponse<DiscussionSchema, C, E, void>>;
    editNote<E extends boolean = false>(projectId: string | number, commitId: number, discussionId: string, noteId: number, options?: BaseRequestOptions<E> & {
        body?: string;
    }): Promise<GitlabAPIResponse<DiscussionNoteSchema, C, E, void>>;
    removeNote<E extends boolean = false>(projectId: string | number, commitId: number, discussionId: string, noteId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
    show<E extends boolean = false>(projectId: string | number, commitId: number, discussionId: string, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<DiscussionSchema, C, E, void>>;
}
declare class CommitDiscussions<C extends boolean = false> extends ResourceDiscussions<C> {
    constructor(options: BaseResourceOptions<C>);
}

interface RegistryRepositoryTagSchema extends Record<string, unknown> {
    name: string;
    path: string;
    location: string;
    revision: string;
    short_revision: string;
    digest: string;
    created_at: string;
    total_size: number;
}
type CondensedRegistryRepositoryTagSchema = Pick<RegistryRepositoryTagSchema, 'name' | 'path' | 'location'>;
interface RegistryRepositorySchema extends Record<string, unknown> {
    id: number;
    name: string;
    path: string;
    project_id: number;
    location: string;
    created_at: string;
    cleanup_policy_started_at: string;
    tags_count?: number;
    tags?: Pick<RegistryRepositoryTagSchema, 'name' | 'path' | 'location'>[];
}
type CondensedRegistryRepositorySchema = Omit<RegistryRepositorySchema, 'tags' | 'tags_count'>;
declare class ContainerRegistry<C extends boolean = false> extends BaseResource<C> {
    allRepositories<E extends boolean = false, P extends PaginationTypes = 'offset'>({ groupId, projectId, ...options }: Either<{
        projectId: string | number;
    }, {
        groupId: string | number;
    }> & PaginationRequestOptions<P> & BaseRequestOptions<E>): Promise<GitlabAPIResponse<CondensedRegistryRepositorySchema[], C, E, P>>;
    allTags<E extends boolean = false, P extends PaginationTypes = 'offset'>(projectId: string | number, repositoryId: number, options?: PaginationRequestOptions<P> & BaseRequestOptions<E>): Promise<GitlabAPIResponse<CondensedRegistryRepositoryTagSchema[], C, E, P>>;
    editRegistryVisibility<E extends boolean = false>(projectId: string | number, options?: {
        containerRegistryAccessLevel: 'enabled' | 'private' | 'disabled';
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIExpandedResponse<CamelizedResponse<CondensedRegistryRepositorySchema, C>, E, undefined>>;
    removeRepository<E extends boolean = false>(projectId: string | number, repositoryId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
    removeTag<E extends boolean = false>(projectId: string | number, repositoryId: number, tagName: string, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
    removeTags<E extends boolean = false>(projectId: string | number, repositoryId: number, nameRegexDelete: string, options?: Sudo & {
        nameRegexKeep: string;
        keepN: string;
        olderThan: string;
    } & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
    showRepository<E extends boolean = false>(repositoryId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<RegistryRepositorySchema, C, E, void>>;
    showTag<E extends boolean = false>(projectId: string | number, repositoryId: number, tagName: string, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<RegistryRepositoryTagSchema, C, E, void>>;
}

type JobScope = 'created' | 'pending' | 'running' | 'failed' | 'success' | 'canceled' | 'skipped' | 'manual';
interface ArtifactSchema extends Record<string, unknown> {
    file_type: string;
    size: number;
    filename: string;
    file_format?: string;
}
interface CondensedJobSchema extends Record<string, unknown> {
    id: number;
    name: string;
    stage: string;
    project_id: string | number;
    project_name: string;
}
interface JobSchema extends Record<string, unknown> {
    id: number;
    name: string;
    stage: string;
    status: string;
    ref: string;
    tag: boolean;
    coverage?: string;
    allow_failure: boolean;
    created_at: string;
    started_at?: string;
    finished_at?: string;
    erased_at?: string;
    duration?: number;
    user: ExpandedUserSchema;
    commit: CondensedCommitSchema;
    pipeline: PipelineSchema;
    web_url: string;
    artifacts: ArtifactSchema[];
    queued_duration: number;
    artifacts_file: {
        filename: string;
        size: number;
    };
    runner: RunnerSchema;
    artifacts_expire_at?: string;
    tag_list?: string[];
}
interface BridgeSchema extends Record<string, unknown> {
    commit: CondensedCommitSchema;
    coverage?: string;
    allow_failure: boolean;
    created_at: string;
    started_at: string;
    finished_at: string;
    erased_at?: string;
    duration: number;
    queued_duration: number;
    id: number;
    name: string;
    pipeline: Omit<PipelineSchema & {
        project_id: number;
    }, 'user'>;
    ref: string;
    stage: string;
    status: string;
    tag: boolean;
    web_url: string;
    user: ExpandedUserSchema;
    downstream_pipeline: Omit<PipelineSchema, 'user'>;
}
interface AllowedAgentSchema extends Record<string, unknown> {
    id: number;
    config_project: Omit<SimpleProjectSchema, 'web_url'>;
}
interface JobKubernetesAgentsSchema extends Record<string, unknown> {
    allowed_agents: AllowedAgentSchema[];
    job: CondensedJobSchema;
    pipeline: PipelineSchema;
    project: Omit<SimpleProjectSchema, 'web_url'>;
    user: UserSchema;
}
interface JobVariableAttributeOption extends Record<string, unknown> {
    key: string;
    value: string;
}
declare class Jobs<C extends boolean = false> extends BaseResource<C> {
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(projectId: string | number, { pipelineId, ...options }?: {
        pipelineId?: number;
        scope?: JobScope;
        includeRetried?: boolean;
    } & Sudo & ShowExpanded<E> & PaginationRequestOptions<P>): Promise<GitlabAPIResponse<JobSchema[], C, E, P>>;
    allPipelineBridges<E extends boolean = false>(projectId: string | number, pipelineId: number, options?: {
        scope?: JobScope;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<BridgeSchema[], C, E, void>>;
    cancel<E extends boolean = false>(projectId: string | number, jobId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<JobSchema, C, E, void>>;
    downloadTraceFile<E extends boolean = false>(projectId: string | number, jobId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<Blob, void, E, void>>;
    erase<E extends boolean = false>(projectId: string | number, jobId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<JobSchema, C, E, void>>;
    play<E extends boolean = false>(projectId: string | number, jobId: number, options?: {
        jobVariablesAttributes: JobVariableAttributeOption[];
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<JobSchema, C, E, void>>;
    retry<E extends boolean = false>(projectId: string | number, jobId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<JobSchema, C, E, void>>;
    show<E extends boolean = false>(projectId: string | number, jobId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<JobSchema, C, E, void>>;
    showConnectedJob<E extends boolean = false>(options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<JobSchema, C, E, void>>;
    showConnectedJobK8Agents<E extends boolean = false>(options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<JobKubernetesAgentsSchema, C, E, void>>;
}

interface RunnerToken extends Record<string, unknown> {
    id: number;
    token: string;
    token_expires_at: string;
}
interface RunnerSchema extends Record<string, unknown> {
    id: number;
    paused: boolean;
    description: string;
    ip_address: string;
    is_shared: boolean;
    runner_type: 'instance_type' | 'group_type' | 'project_type';
    name: string;
    online: boolean;
    status: 'online' | 'offline';
}
interface ExpandedRunnerSchema extends RunnerSchema {
    architecture?: string;
    description: string;
    contacted_at: string;
    platform?: string;
    projects?: Pick<SimpleProjectSchema, 'id' | 'name' | 'name_with_namespace' | 'path' | 'path_with_namespace'>;
    revision?: string;
    tag_list?: string[];
    version?: string;
    access_level: string;
    maximum_timeout?: number;
}
declare class Runners<C extends boolean = false> extends BaseResource<C> {
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>({ projectId, groupId, owned, ...options }?: EitherOrNone3<{
        projectId?: string | number;
    }, {
        owned?: boolean;
    }, {
        groupId?: string | number;
    }> & BaseRequestOptions<E> & PaginationRequestOptions<P>): Promise<GitlabAPIResponse<RunnerSchema[], C, E, P>>;
    create<E extends boolean = false>(token: string, options?: BaseRequestOptions<E>): Promise<GitlabAPIResponse<RunnerToken, C, E, void>>;
    edit<E extends boolean = false>(runnerId: number, options?: BaseRequestOptions<E>): Promise<GitlabAPIResponse<ExpandedRunnerSchema, C, E, void>>;
    enable<E extends boolean = false>(projectId: string | number, runnerId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<RunnerSchema, C, E, void>>;
    disable<E extends boolean = false>(projectId: string | number, runnerId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
    allJobs<E extends boolean = false>(runnerId: number, options?: Sudo & ShowExpanded<E> & {
        status?: string;
        orderBy?: string;
        sort?: string;
    }): Promise<GitlabAPIResponse<JobSchema[], C, E, void>>;
    register<E extends boolean = false>(token: string, options?: BaseRequestOptions<E>): Promise<GitlabAPIResponse<RunnerToken, C, E, void>>;
    remove<E extends boolean = false>({ runnerId, token, ...options }: Either<{
        runnerId: number;
    }, {
        token: string;
    }> & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
    resetRegistrationToken<E extends boolean = false>({ projectId, groupId, runnerId, token, ...options }?: EitherOrNone4<{
        projectId: string | number;
    }, {
        groupId: string | number;
    }, {
        runnerId: string;
    }, {
        token: string;
    }> & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
    show<E extends boolean = false>(runnerId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<ExpandedRunnerSchema, C, E, void>>;
    verify<E extends boolean = false>(options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
}

interface EnvironmentSchema extends Record<string, unknown> {
    id: number;
    name: string;
    slug: string;
    external_url: string;
    state: string;
    created_at: string;
    updated_at: string;
    last_deployment: DeploymentSchema;
    deployable: DeployableSchema;
}
type CondensedEnvironmentSchema = Omit<EnvironmentSchema, 'last_deployment' | 'deployable'>;
type ReviewAppSchema = Omit<CondensedEnvironmentSchema, 'state'>;
declare class Environments<C extends boolean = false> extends BaseResource<C> {
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(projectId: string | number, options?: PaginationRequestOptions<P> & BaseRequestOptions<E>): Promise<GitlabAPIResponse<CondensedEnvironmentSchema[], C, E, P>>;
    create<E extends boolean = false>(projectId: string | number, name: string, options?: {
        externalUrl?: string;
    } & BaseRequestOptions<E>): Promise<GitlabAPIResponse<CondensedEnvironmentSchema, C, E, void>>;
    edit<E extends boolean = false>(projectId: string | number, environmentId: number, options?: {
        externalUrl?: string;
    } & BaseRequestOptions<E>): Promise<GitlabAPIResponse<CondensedEnvironmentSchema, C, E, void>>;
    remove<E extends boolean = false>(projectId: string | number, environmentId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
    removeReviewApps<E extends boolean = false>(projectId: string | number, options?: {
        before?: string;
        limit?: number;
        dryRun?: boolean;
    } & BaseRequestOptions<E>): Promise<GitlabAPIResponse<{
        scheduled_entries: ReviewAppSchema[];
        unprocessable_entries: ReviewAppSchema[];
    }, C, E, void>>;
    show<E extends boolean = false>(projectId: string | number, environmentId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<CondensedEnvironmentSchema, C, E, void>>;
    stop<E extends boolean = false>(projectId: string | number, environmentId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<CondensedEnvironmentSchema, C, E, void>>;
}

type DeploymentStatus = 'created' | 'running' | 'success' | 'failed' | 'canceled';
interface DeployableSchema extends Record<string, unknown> {
    id: number;
    ref: string;
    name: string;
    runner?: RunnerSchema;
    stage?: string;
    started_at?: string;
    status?: DeploymentStatus;
    tag: boolean;
    commit?: CommitSchema;
    coverage?: string;
    created_at?: string;
    finished_at?: string;
    user?: UserSchema;
    pipeline?: PipelineSchema;
}
interface DeploymentStatusSchema extends Record<string, unknown> {
    user: UserSchema;
    status: 'approved' | 'rejected';
}
interface DeploymentSchema extends Record<string, unknown> {
    id: number;
    iid: number;
    ref: string;
    sha: string;
    created_at: string;
    updated_at: string;
    status: DeploymentStatus;
    user: UserSchema;
    deployable: DeployableSchema;
    environment: EnvironmentSchema;
}
interface AllDeploymentsOptions {
    orderBy?: 'id' | 'iid' | 'created_at' | 'updated_at' | 'ref';
    sort?: 'asc' | 'desc';
    updatedAfter?: string;
    updatedBefore?: string;
    environment?: string;
    status?: 'created' | 'running' | 'success' | 'failed' | 'canceled' | 'blocked';
}
declare class Deployments<C extends boolean = false> extends BaseResource<C> {
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(projectId: string | number, options?: AllDeploymentsOptions & PaginationRequestOptions<P> & BaseRequestOptions<E>): Promise<GitlabAPIResponse<DeploymentSchema[], C, E, P>>;
    allMergeRequests<E extends boolean = false, P extends PaginationTypes = 'offset'>(projectId: string | number, deploymentId: number, options?: PaginationRequestOptions<P> & BaseRequestOptions<E>): Promise<GitlabAPIResponse<MergeRequestSchema[], C, E, P>>;
    create<E extends boolean = false>(projectId: string | number, environment: string, sha: string, ref: string, tag: string, options?: {
        status?: DeploymentStatus;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<DeploymentSchema, C, E, void>>;
    edit<E extends boolean = false>(projectId: string | number, deploymentId: number, options?: {
        status?: DeploymentStatus;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<DeploymentSchema, C, E, void>>;
    setApproval<E extends boolean = false>(projectId: string | number, deploymentId: number, options?: {
        status?: 'approved' | 'rejected';
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<DeploymentStatusSchema, C, E, void>>;
    show<E extends boolean = false>(projectId: string | number, deploymentId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<DeploymentSchema, C, E, void>>;
}

interface ErrorTrackingClientKeySchema extends Record<string, unknown> {
    id: number;
    active: boolean;
    public_key: string;
    sentry_dsn: string;
}
declare class ErrorTrackingClientKeys<C extends boolean = false> extends BaseResource<C> {
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(projectId: string | number, options?: PaginationRequestOptions<P> & BaseRequestOptions<E>): Promise<GitlabAPIResponse<ErrorTrackingClientKeySchema[], C, E, P>>;
    create<E extends boolean = false>(projectId: string | number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<ErrorTrackingClientKeySchema, C, E, void>>;
    remove<E extends boolean = false>(projectId: string | number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
}

interface ErrorTrackingSettingsSchema extends Record<string, unknown> {
    active: boolean;
    project_name: string;
    sentry_external_url: string;
    api_url: string;
    integrated: boolean;
}
declare class ErrorTrackingSettings<C extends boolean = false> extends BaseResource<C> {
    show<E extends boolean = false>(projectId: string | number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<ErrorTrackingSettingsSchema, C, E, void>>;
    edit<E extends boolean = false>(projectId: string | number, active: boolean, { integrated, ...options }?: BaseRequestOptions<E>): Promise<GitlabAPIResponse<ErrorTrackingSettingsSchema, C, E, void>>;
}

interface BaseExternalStatusCheckSchema extends Record<string, unknown> {
    id: number;
    name: string;
    external_url: string;
    status: string;
}
type MergeRequestExternalStatusCheckSchema = BaseExternalStatusCheckSchema;
interface ExternalStatusCheckProtectedBranchesSchema {
    id: number;
    project_id: number;
    name: string;
    created_at: string;
    updated_at: string;
    code_owner_approval_required: boolean;
}
interface ProjectExternalStatusCheckSchema extends BaseExternalStatusCheckSchema {
    project_id: number;
    protected_branches?: ExternalStatusCheckProtectedBranchesSchema[];
}
declare class ExternalStatusChecks<C extends boolean = false> extends BaseResource<C> {
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(projectId: string | number, options: {
        mergerequestIId: number;
    } & PaginationRequestOptions<P> & BaseRequestOptions<E>): Promise<GitlabAPIResponse<MergeRequestExternalStatusCheckSchema[], C, E, P>>;
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(projectId: string | number, options?: PaginationRequestOptions<P> & BaseRequestOptions<E>): Promise<GitlabAPIResponse<ProjectExternalStatusCheckSchema[], C, E, P>>;
    create<E extends boolean = false>(projectId: string | number, name: string, externalUrl: string, options?: {
        protectedBrancheIds: number[];
    } & BaseRequestOptions<E>): Promise<GitlabAPIResponse<ProjectExternalStatusCheckSchema, C, E, void>>;
    edit<E extends boolean = false>(projectId: string | number, externalStatusCheckId: number, options?: {
        protectedBrancheIds?: number[];
        externalUrl?: string;
        name?: string;
    } & BaseRequestOptions<E>): Promise<GitlabAPIResponse<ProjectExternalStatusCheckSchema, C, E, void>>;
    remove<E extends boolean = false>(projectId: string | number, externalStatusCheckId: number, options?: {
        protectedBrancheIds?: number[];
    } & BaseRequestOptions<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
    set<E extends boolean = false>(projectId: string | number, mergerequestIId: number, sha: string, externalCheckStatusId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<ProjectExternalStatusCheckSchema, C, E, void>>;
    show<E extends boolean = false>(projectId: string | number, mergerequestIId: number, sha: string, externalCheckStatusId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<ProjectExternalStatusCheckSchema, C, E, void>>;
}

interface FeatureFlagStrategyScope {
    id: number;
    environment_scope: string;
}
interface FeatureFlagStrategy {
    id: number;
    name: string;
    parameters: {
        user_ids: string;
    };
    scopes?: FeatureFlagStrategyScope[];
}
interface FeatureFlagSchema extends Record<string, unknown> {
    name: string;
    description: string;
    active: boolean;
    version: string;
    created_at: string;
    updated_at: string;
    scopes?: string[];
    strategies?: FeatureFlagStrategy[];
}
declare class FeatureFlags<C extends boolean = false> extends BaseResource<C> {
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(projectId: string | number, options?: {
        scopes?: 'enabled' | 'disabled';
    } & PaginationRequestOptions<P> & BaseRequestOptions<E>): Promise<GitlabAPIResponse<FeatureFlagSchema[], C, E, P>>;
    create<E extends boolean = false>(projectId: string | number, flagName: string, version: string, options?: BaseRequestOptions<E>): Promise<GitlabAPIResponse<FeatureFlagSchema, C, E, void>>;
    edit<E extends boolean = false>(projectId: string | number, featureFlagName: string, options?: BaseRequestOptions<E>): Promise<GitlabAPIResponse<FeatureFlagSchema, C, E, void>>;
    remove<E extends boolean = false>(projectId: string | number, flagName: string, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
    show<E extends boolean = false>(projectId: string | number, flagName: string, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<FeatureFlagSchema, C, E, void>>;
}

interface FeatureFlagUserListSchema extends Record<string, unknown> {
    name: string;
    user_xids: string;
    id: number;
    iid: number;
    project_id: string | number;
    created_at: string;
    updated_at: string;
}
declare class FeatureFlagUserLists<C extends boolean = false> extends BaseResource<C> {
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(projectId: string | number, options?: {
        scopes?: 'enabled' | 'disabled';
    } & PaginationRequestOptions<P> & BaseRequestOptions<E>): Promise<GitlabAPIResponse<FeatureFlagUserListSchema[], C, E, P>>;
    create<E extends boolean = false>(projectId: string | number, name: string, userXIds: string, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<FeatureFlagUserListSchema, C, E, void>>;
    edit<E extends boolean = false>(projectId: string | number, featureFlagUserListIId: string, options?: {
        name?: string;
        userXIds?: string;
    } & BaseRequestOptions<E>): Promise<GitlabAPIResponse<FeatureFlagUserListSchema, C, E, void>>;
    remove<E extends boolean = false>(projectId: string | number, featureFlagUserListIId: string, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
    show<E extends boolean = false>(projectId: string | number, featureFlagUserListIId: string, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<FeatureFlagUserListSchema, C, E, void>>;
}

interface FreezePeriodSchema extends Record<string, unknown> {
    id: number;
    freeze_start: string;
    freeze_end: string;
    cron_timezone: string;
    created_at: string;
    updated_at: string;
}
declare class FreezePeriods<C extends boolean = false> extends BaseResource<C> {
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(projectId: string | number, options?: PaginationRequestOptions<P> & BaseRequestOptions<E>): Promise<GitlabAPIResponse<FreezePeriodSchema[], C, E, P>>;
    show<E extends boolean = false>(projectId: string | number, freezePeriodId: string | number, options?: BaseRequestOptions<E>): Promise<GitlabAPIResponse<FreezePeriodSchema, C, E, void>>;
    create<E extends boolean = false>(projectId: string | number, freezeStart: string, freezeEnd: string, options?: {
        cronTimezone?: string;
    } & BaseRequestOptions<E>): Promise<GitlabAPIResponse<FreezePeriodSchema, C, E, void>>;
    edit<E extends boolean = false>(projectId: string | number, freezePeriodId: string | number, options?: {
        freezeStart?: string;
        freezeEnd?: string;
        cronTimezone?: string;
    } & BaseRequestOptions<E>): Promise<GitlabAPIResponse<FreezePeriodSchema, C, E, void>>;
    remove<E extends boolean = false>(projectId: string | number, freezePeriodId: string | number, options?: BaseRequestOptions<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
}

declare class GitlabPages<C extends boolean = false> extends BaseResource<C> {
    remove<E extends boolean = false>(projectId: string | number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
}

interface GoProxyModuleVersionSchema extends Record<string, unknown> {
    Version: string;
    Time: string;
}
declare class GoProxy<C extends boolean = false> extends BaseResource<C> {
    all<E extends boolean = false>(projectId: string | number, moduleName: string, options?: BaseRequestOptions<E>): Promise<GitlabAPIResponse<string, C, E, void>>;
    showVersionMetadata<E extends boolean = false>(projectId: string | number, moduleName: string, moduleVersion: string, options?: BaseRequestOptions<E>): Promise<GitlabAPIResponse<GoProxyModuleVersionSchema, C, E, void>>;
    downloadModuleFile<E extends boolean = false>(projectId: string | number, moduleName: string, moduleVersion: string, options?: BaseRequestOptions<E>): Promise<GitlabAPIResponse<string, C, E, void>>;
    downloadModuleSource<E extends boolean = false>(projectId: string | number, moduleName: string, moduleVersion: string, options?: BaseRequestOptions<E>): Promise<GitlabAPIResponse<Blob, void, E, void>>;
}

declare class Helm<C extends boolean = false> extends BaseResource<C> {
    downloadChartIndex<E extends boolean = false>(projectId: string | number, channel: string, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<Blob, void, E, void>>;
    downloadChart<E extends boolean = false>(projectId: string | number, channel: string, filename: string, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<Blob, void, E, void>>;
    import<E extends boolean = false>(projectId: string | number, content: Blob, channel: string, { filename, parentId, ...options }?: {
        parentId?: number;
        filename?: string;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
}

type SupportedIntegration = 'asana' | 'assembla' | 'bamboo' | 'bugzilla' | 'buildkite' | 'campfire' | 'custom-issue-tracker' | 'drone-ci' | 'emails-on-push' | 'external-wiki' | 'flowdock' | 'hangouts_chat' | 'hipchat' | 'irker' | 'jira' | 'kubernetes' | 'slack-slash-commands' | 'slack' | 'packagist' | 'pipelines-email' | 'pivotaltracker' | 'prometheus' | 'pushover' | 'redmine' | 'microsoft-teams' | 'mattermost' | 'mattermost-slash-commands' | 'teamcity' | 'jenkins' | 'jenkins-deprecated' | 'mock-ci' | 'youtrack';
interface IntegrationSchema extends Record<string, unknown> {
    id: number;
    title: string;
    slug: string;
    created_at: string;
    updated_at: string;
    active: boolean;
    commit_events: boolean;
    push_events: boolean;
    issues_events: boolean;
    confidential_issues_events: boolean;
    merge_requests_events: boolean;
    tag_push_events: boolean;
    note_events: boolean;
    confidential_note_events: boolean;
    pipeline_events: boolean;
    wiki_page_events: boolean;
    job_events: boolean;
    comment_on_event_enabled: boolean;
}
declare class Integrations<C extends boolean = false> extends BaseResource<C> {
    all<E extends boolean = false>(projectId: string | number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<IntegrationSchema[], C, E, void>>;
    edit<E extends boolean = false>(projectId: string | number, integrationName: SupportedIntegration, options?: BaseRequestOptions<E>): Promise<GitlabAPIResponse<IntegrationSchema, C, E, void>>;
    disable<E extends boolean = false>(projectId: string | number, integrationName: SupportedIntegration, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
    show<E extends boolean = false>(projectId: string | number, integrationName: SupportedIntegration, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<IntegrationSchema, C, E, void>>;
}

interface IssueAwardEmojis<C extends boolean = false> extends ResourceAwardEmojis<C> {
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(projectId: string | number, issueIId: number, options?: PaginationRequestOptions<P> & BaseRequestOptions<E>): Promise<GitlabAPIResponse<AwardEmojiSchema[], C, E, P>>;
    award<E extends boolean = false>(projectId: string | number, issueIId: number, name: string, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<AwardEmojiSchema, C, E, void>>;
    remove<E extends boolean = false>(projectId: string | number, issueIId: number, awardId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
    show<E extends boolean = false>(projectId: string | number, issueIId: number, awardId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<AwardEmojiSchema, C, E, void>>;
}
declare class IssueAwardEmojis<C extends boolean = false> extends ResourceAwardEmojis<C> {
    constructor(options: BaseResourceOptions<C>);
}

interface IssueDiscussions<C extends boolean = false> extends ResourceDiscussions<C> {
    addNote<E extends boolean = false>(projectId: string | number, issueIId: number, discussionId: string, noteId: number, body: string, options?: BaseRequestOptions<E>): Promise<GitlabAPIResponse<DiscussionNoteSchema, C, E, void>>;
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(projectId: string | number, issueIId: number, options?: PaginationRequestOptions<P> & BaseRequestOptions<E>): Promise<GitlabAPIResponse<DiscussionSchema[], C, E, P>>;
    create<E extends boolean = false>(projectId: string | number, issueIId: number, body: string, options?: BaseRequestOptions<E>): Promise<GitlabAPIResponse<DiscussionSchema, C, E, void>>;
    editNote<E extends boolean = false>(projectId: string | number, issueIId: number, discussionId: string, noteId: number, options: BaseRequestOptions<E> & {
        body: string;
    }): Promise<GitlabAPIResponse<DiscussionNoteSchema, C, E, void>>;
    removeNote<E extends boolean = false>(projectId: string | number, issueIId: number, discussionId: string, noteId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
    show<E extends boolean = false>(projectId: string | number, issueIId: number, discussionId: string, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<DiscussionSchema, C, E, void>>;
}
declare class IssueDiscussions<C extends boolean = false> extends ResourceDiscussions<C> {
    constructor(options: BaseResourceOptions<C>);
}

interface IssueIterationEvents<C extends boolean = false> {
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(projectId: string | number, issueIId: number, options?: Sudo & ShowExpanded<E> & PaginationRequestOptions<P>): Promise<GitlabAPIResponse<IterationEventSchema[], C, E, P>>;
    show<E extends boolean = false>(projectId: string | number, issueIId: number, iterationEventId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<IterationEventSchema, C, E, void>>;
}
declare class IssueIterationEvents<C extends boolean = false> extends ResourceIterationEvents<C> {
    constructor(options: BaseResourceOptions<C>);
}

interface IssueLabelEvents<C extends boolean = false> {
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(projectId: string | number, issueIId: number, options?: Sudo & ShowExpanded<E> & PaginationRequestOptions<P>): Promise<GitlabAPIResponse<LabelEventSchema[], C, E, P>>;
    show<E extends boolean = false>(projectId: string | number, issueIId: number, labelEventId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<LabelEventSchema, C, E, void>>;
}
declare class IssueLabelEvents<C extends boolean = false> extends ResourceLabelEvents<C> {
    constructor(options: BaseResourceOptions<C>);
}

interface IssueLinkSchema extends Record<string, unknown> {
    id: number;
    iid: number;
    project_id: number;
    issue_link_id: number;
    state: string;
    description: string;
    weight?: number;
    author: Omit<UserSchema, 'created_at'>;
    milestone: MilestoneSchema;
    assignees?: Omit<UserSchema, 'created_at'>[];
    title: string;
    labels?: string[];
    user_notes_count: number;
    due_date: string;
    web_url: string;
    confidential: boolean;
    updated_at: string;
    link_created_at: string;
    link_updated_at: string;
    link_type: 'relates_to' | 'blocks' | 'is_blocked_by';
}
interface ExpandedIssueLinkSchema extends Record<string, unknown> {
    source_issue: Omit<IssueLinkSchema, 'link_type' | 'link_created_at' | 'link_updated_at' | 'issue_link_id'>;
    target_issue: Omit<IssueLinkSchema, 'link_type' | 'link_created_at' | 'link_updated_at' | 'issue_link_id'>;
    link_type: 'relates_to' | 'blocks' | 'is_blocked_by';
}
declare class IssueLinks<C extends boolean = false> extends BaseResource<C> {
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(projectId: string | number, issueIId: number, options?: Sudo & ShowExpanded<E> & PaginationRequestOptions<P>): Promise<GitlabAPIResponse<IssueLinkSchema[], C, E, P>>;
    create<E extends boolean = false>(projectId: string | number, issueIId: number, targetProjectId: string | number, targetIssueIId: number, options?: {
        linkType?: string;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<ExpandedIssueLinkSchema, C, E, void>>;
    remove<E extends boolean = false>(projectId: string | number, issueIId: number, issueLinkId: number, options?: {
        linkType?: string;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<ExpandedIssueLinkSchema, C, E, void>>;
}

interface IssueMilestoneEvents<C extends boolean = false> {
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(projectId: string | number, issueIId: number, options?: Sudo & ShowExpanded<E> & PaginationRequestOptions<P>): Promise<GitlabAPIResponse<MilestoneEventSchema[], C, E, P>>;
    show<E extends boolean = false>(projectId: string | number, issueIId: number, milestoneEventId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<MilestoneEventSchema, C, E, void>>;
}
declare class IssueMilestoneEvents<C extends boolean = false> extends ResourceMilestoneEvents<C> {
    constructor(options: BaseResourceOptions<C>);
}

interface IssueNoteAwardEmojis<C extends boolean = false> extends ResourceNoteAwardEmojis<C> {
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(projectId: string | number, issueIId: number, noteId: number, options?: PaginationRequestOptions<P> & BaseRequestOptions<E>): Promise<GitlabAPIResponse<AwardEmojiSchema[], C, E, P>>;
    award<E extends boolean = false>(projectId: string | number, issueIId: number, noteId: number, name: string, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<AwardEmojiSchema, C, E, void>>;
    remove<E extends boolean = false>(projectId: string | number, issueIId: number, noteId: number, awardId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
    show<E extends boolean = false>(projectId: string | number, issueIId: number, noteId: number, awardId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<AwardEmojiSchema, C, E, void>>;
}
declare class IssueNoteAwardEmojis<C extends boolean = false> extends ResourceNoteAwardEmojis<C> {
    constructor(options: BaseResourceOptions<C>);
}

interface IssueNoteSchema extends NoteSchema {
    confidential: boolean;
    attachment?: string;
    system: boolean;
    noteable_id: number;
    noteable_type: string;
    noteable_iid: number;
    resolvable: boolean;
}
interface IssueNotes<C extends boolean = false> extends ResourceNotes<C> {
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(projectId: string | number, issueIId: number, options?: PaginationRequestOptions<P> & BaseRequestOptions<E>): Promise<GitlabAPIResponse<IssueNoteSchema[], C, E, P>>;
    create<E extends boolean = false>(projectId: string | number, issueIId: number, body: string, options?: {
        created_at?: string;
        confidential?: boolean;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<IssueNoteSchema, C, E, void>>;
    edit<E extends boolean = false>(projectId: string | number, issueIId: number, noteId: number, options: {
        body?: string;
        confidential?: boolean;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<IssueNoteSchema, C, E, void>>;
    remove<E extends boolean = false>(projectId: string | number, issueIId: number, noteId: number, options?: Sudo): Promise<GitlabAPIResponse<void, C, E, void>>;
    show<E extends boolean = false>(projectId: string | number, issueIId: number, noteId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<IssueNoteSchema, C, E, void>>;
}
declare class IssueNotes<C extends boolean = false> extends ResourceNotes<C> {
    constructor(options: BaseResourceOptions<C>);
}

interface StatisticsSchema extends Record<string, unknown> {
    statistics: {
        counts: {
            all: number;
            closed: number;
            opened: number;
        };
    };
}
declare class IssuesStatistics<C extends boolean = false> extends BaseResource<C> {
    all<E extends boolean = false>({ projectId, groupId, ...options }?: EitherOrNone<{
        projectId: string | number;
    }, {
        groupId: string | number;
    }> & BaseRequestOptions<E>): Promise<GitlabAPIResponse<StatisticsSchema, C, E, void>>;
}

interface IssueStateEvents<C extends boolean = false> {
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(projectId: string | number, issueIId: number, options?: Sudo & ShowExpanded<E> & PaginationRequestOptions<P>): Promise<GitlabAPIResponse<StateEventSchema[], C, E, P>>;
    show<E extends boolean = false>(projectId: string | number, issueIId: number, stateEventId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<StateEventSchema, C, E, void>>;
}
declare class IssueStateEvents<C extends boolean = false> extends ResourceStateEvents<C> {
    constructor(options: BaseResourceOptions<C>);
}

interface IssueWeightEvents<C extends boolean = false> {
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(projectId: string | number, issueIId: number, options?: Sudo & ShowExpanded<E> & PaginationRequestOptions<P>): Promise<GitlabAPIResponse<StateEventSchema[], C, E, P>>;
    show<E extends boolean = false>(projectId: string | number, issueIId: number, weightEventId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<StateEventSchema, C, E, void>>;
}
declare class IssueWeightEvents<C extends boolean = false> extends ResourceStateEvents<C> {
    constructor(options: BaseResourceOptions<C>);
}

declare class JobArtifacts<C extends boolean = false> extends BaseResource<C> {
    download<E extends boolean = false>(projectId: string | number, { jobId, jobToken, artifactPath, ref, job, ...options }?: ({
        jobId: number;
        artifactPath?: undefined;
        job?: undefined;
        ref?: undefined;
    } | {
        jobId: number;
        artifactPath: string;
        job?: undefined;
        ref?: undefined;
    } | {
        ref: string;
        job: string;
        jobId?: undefined;
        artifactPath?: undefined;
    } | {
        ref: string;
        job: string;
        artifactPath: string;
        jobId?: undefined;
    }) & {
        jobToken?: string;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<Blob, void, E, void>>;
    downloadArchive<E extends boolean = false>(projectId: string | number, ref: string, job: string, { jobToken, ...options }?: {
        jobToken?: string;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<Blob, void, E, void>>;
    keep<E extends boolean = false>(projectId: string | number, jobId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<JobSchema, C, E, void>>;
    remove<E extends boolean = false>(projectId: string | number, { jobId, ...options }?: {
        jobId?: number;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
}

interface ProtectedBranchAccessLevel {
    access_level: 0 | 30 | 40 | 60;
    access_level_description: string;
    user_id?: number;
    group_id?: number;
}
interface ProtectedBranchSchema extends Record<string, unknown> {
    id: number;
    name: string;
    push_access_levels?: ProtectedBranchAccessLevel[];
    merge_access_levels?: ProtectedBranchAccessLevel[];
    unprotect_access_levels?: ProtectedBranchAccessLevel[];
    allow_force_push: boolean;
    code_owner_approval_required: boolean;
}
declare class ProtectedBranches<C extends boolean = false> extends BaseResource<C> {
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(projectId: string | number, options?: {
        search?: string;
    } & Sudo & ShowExpanded<E> & PaginationRequestOptions<P>): Promise<GitlabAPIResponse<ProtectedBranchSchema[], C, E, P>>;
    edit<E extends boolean = false>(projectId: string | number, branchName: string, options?: {
        codeOwnerApprovalRequired?: boolean;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<ProtectedBranchSchema, C, E, void>>;
    protect<E extends boolean = false>(projectId: string | number, branchName: string, options?: BaseRequestOptions<E>): Promise<GitlabAPIResponse<ProtectedBranchSchema, C, E, void>>;
    show<E extends boolean = false>(projectId: string | number, branchName: string, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<ProtectedBranchSchema, C, E, void>>;
    unprotect<E extends boolean = false>(projectId: string | number, branchName: string, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
}

interface ProjectLevelMergeRequestApprovalSchema extends Record<string, unknown> {
    approvals_before_merge: number;
    reset_approvals_on_push: boolean;
    disable_overriding_approvers_per_merge_request: boolean;
    merge_requests_author_approval: boolean;
    merge_requests_disable_committers_approval: boolean;
    require_password_to_approve: boolean;
}
interface ApprovedByEntity {
    user: Omit<UserSchema, 'created_at'>;
}
interface MergeRequestLevelMergeRequestApprovalSchema extends Record<string, unknown> {
    id: number;
    iid: number;
    project_id: number;
    title: string;
    description: string;
    state: string;
    created_at: string;
    updated_at: string;
    merge_status: string;
    approvals_required: number;
    approvals_left: number;
    approved_by?: ApprovedByEntity[];
}
type ApprovalRulesRequestOptions = {
    userIds?: number[];
    groupIds?: number[];
    protectedBranchIds?: number[];
};
interface ApprovalRuleSchema extends Record<string, unknown> {
    id: number;
    name: string;
    rule_type: string;
    eligible_approvers?: Omit<UserSchema, 'created_at'>[];
    approvals_required: number;
    users?: Omit<UserSchema, 'created_at'>[];
    groups?: GroupSchema[];
    contains_hidden_groups: boolean;
    overridden: boolean;
}
interface ProjectLevelApprovalRuleSchema extends ApprovalRuleSchema {
    protected_branches?: ProtectedBranchSchema[];
}
interface MergeRequestLevelApprovalRuleSchema extends ApprovalRuleSchema {
    source_rule?: string;
}
interface ApprovalStateSchema extends Record<string, unknown> {
    approval_rules_overwritten: boolean;
    rules: ({
        approved: boolean;
    } & MergeRequestLevelApprovalRuleSchema)[];
}
declare class MergeRequestApprovals<C extends boolean = false> extends BaseResource<C> {
    allApprovalRules<E extends boolean = false>(projectId: string | number, options: {
        mergerequestIId: number;
    } & BaseRequestOptions<E>): Promise<GitlabAPIResponse<MergeRequestLevelApprovalRuleSchema[], C, E, void>>;
    allApprovalRules<E extends boolean = false>(projectId: string | number, options?: BaseRequestOptions<E>): Promise<GitlabAPIResponse<ProjectLevelApprovalRuleSchema[], C, E, void>>;
    approve<E extends boolean = false>(projectId: string | number, mergerequestIId: number, options?: {
        sha?: string;
        approval_password?: string;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIExpandedResponse<CamelizedResponse<MergeRequestLevelMergeRequestApprovalSchema, C>, E, undefined>>;
    createApprovalRule<E extends boolean = false>(projectId: string | number, name: string, approvalsRequired: number, options: {
        mergerequestIId: number;
    } & ApprovalRulesRequestOptions & BaseRequestOptions<E>): Promise<GitlabAPIResponse<MergeRequestLevelApprovalRuleSchema, C, E, void>>;
    createApprovalRule<E extends boolean = false>(projectId: string | number, name: string, approvalsRequired: number, options?: ApprovalRulesRequestOptions & BaseRequestOptions<E>): Promise<GitlabAPIResponse<ProjectLevelApprovalRuleSchema, C, E, void>>;
    editApprovalRule<E extends boolean = false>(projectId: string | number, approvalRuleId: number, name: string, approvalsRequired: number, options: {
        mergerequestIId: number;
    } & ApprovalRulesRequestOptions & BaseRequestOptions<E>): Promise<GitlabAPIResponse<MergeRequestLevelApprovalRuleSchema, C, E, void>>;
    editApprovalRule<E extends boolean = false>(projectId: string | number, approvalRuleId: number, name: string, approvalsRequired: number, options?: ApprovalRulesRequestOptions & BaseRequestOptions<E>): Promise<GitlabAPIResponse<ProjectLevelApprovalRuleSchema, C, E, void>>;
    editConfiguration<E extends boolean = false>(projectId: string | number, options?: BaseRequestOptions<E>): Promise<GitlabAPIResponse<ProjectLevelMergeRequestApprovalSchema, C, E, void>>;
    removeApprovalRule<E extends boolean = false>(projectId: string | number, approvalRuleId: number, { mergerequestIId, ...options }?: {
        mergerequestIId?: number;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
    showApprovalRule<E extends boolean = false>(projectId: string | number, approvalRuleId: number, options: BaseRequestOptions<E>): Promise<GitlabAPIResponse<ProjectLevelApprovalRuleSchema, C, E, void>>;
    showApprovalState<E extends boolean = false>(projectId: string | number, mergerequestIId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<ApprovalStateSchema, C, E, void>>;
    showConfiguration<E extends boolean = false>(projectId: string | number, options: {
        mergerequestIId: number;
    } & BaseRequestOptions<E>): Promise<GitlabAPIResponse<MergeRequestLevelMergeRequestApprovalSchema, C, E, void>>;
    showConfiguration<E extends boolean = false>(projectId: string | number, options?: BaseRequestOptions<E>): Promise<GitlabAPIResponse<ProjectLevelMergeRequestApprovalSchema, C, E, void>>;
    unapprove<E extends boolean = false>(projectId: string | number, mergerequestIId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
}

interface MergeRequestAwardEmojis<C extends boolean = false> extends ResourceAwardEmojis<C> {
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(projectId: string | number, mergerequestIId: number, options?: PaginationRequestOptions<P> & BaseRequestOptions<E>): Promise<GitlabAPIResponse<AwardEmojiSchema[], C, E, P>>;
    award<E extends boolean = false>(projectId: string | number, mergerequestIId: number, name: string, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<AwardEmojiSchema, C, E, void>>;
    remove<E extends boolean = false>(projectId: string | number, mergerequestIId: number, awardId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
    show<E extends boolean = false>(projectId: string | number, mergerequestIId: number, awardId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<AwardEmojiSchema, C, E, void>>;
}
declare class MergeRequestAwardEmojis<C extends boolean = false> extends ResourceAwardEmojis<C> {
    constructor(options: BaseResourceOptions<C>);
}

interface MergeRequestContextCommitSchema extends Record<string, unknown> {
    id: string;
    short_id: string;
    created_at: string;
    parent_ids?: null;
    title: string;
    message: string;
    author_name: string;
    author_email: string;
    authored_date: string;
    committer_name: string;
    committer_email: string;
    committed_date: string;
}
declare class MergeRequestContextCommits<C extends boolean = false> extends BaseResource<C> {
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(projectId: string | number, mergerequestIId: number, options?: Sudo & ShowExpanded<E> & PaginationRequestOptions<P>): Promise<GitlabAPIResponse<MergeRequestContextCommitSchema[], C, E, P>>;
    create<E extends boolean = false>(projectId: string | number, commits: string[], { mergerequestIId, ...options }?: {
        mergerequestIId?: number;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
    remove<E extends boolean = false>(projectId: string | number, mergerequestIId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
}

interface MergeRequestDiscussionNoteSchema extends DiscussionNoteSchema {
    resolved_by: string;
    resolved_at: string;
    position?: DiscussionNotePositionSchema;
}
type DiscussionNotePositionOptions = DiscussionNotePositionSchema & {
    line_range?: {
        start?: {
            line_code: string;
            type: 'new' | 'old';
        };
        end?: {
            line_code: string;
            type: 'new' | 'old';
        };
    };
};
interface MergeRequestDiscussions<C extends boolean = false> extends ResourceDiscussions<C> {
    addNote<E extends boolean = false>(projectId: string | number, mergerequestId: string | number, discussionId: string, noteId: number, body: string, options?: BaseRequestOptions<E>): Promise<GitlabAPIResponse<MergeRequestDiscussionNoteSchema, C, E, void>>;
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(projectId: string | number, mergerequestId: string | number, options?: PaginationRequestOptions<P> & BaseRequestOptions<E>): Promise<GitlabAPIResponse<DiscussionSchema[], C, E, P>>;
    create<E extends boolean = false>(projectId: string | number, mergerequestId: string | number, body: string, options?: {
        position?: DiscussionNotePositionOptions;
    } & BaseRequestOptions<E>): Promise<GitlabAPIResponse<DiscussionSchema, C, E, void>>;
    editNote<E extends boolean = false>(projectId: string | number, mergerequestId: string | number, discussionId: string, noteId: number, options: BaseRequestOptions<E> & {
        body: string;
    }): Promise<GitlabAPIResponse<MergeRequestDiscussionNoteSchema, C, E, void>>;
    removeNote<E extends boolean = false>(projectId: string | number, mergerequestId: string | number, discussionId: string, noteId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
    resolve<E extends boolean = false>(projectId: string | number, mergerequestId: string | number, discussionId: string, resolve: boolean, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<DiscussionSchema, C, E, void>>;
    show<E extends boolean = false>(projectId: string | number, mergerequestId: string | number, discussionId: string, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<DiscussionSchema, C, E, void>>;
}
declare class MergeRequestDiscussions<C extends boolean = false> extends ResourceDiscussions<C> {
    constructor(options: BaseResourceOptions<C>);
}

interface MergeRequestLabelEvents<C extends boolean = false> {
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(projectId: string | number, mergerequestIId: number, options?: Sudo & ShowExpanded<E> & PaginationRequestOptions<P>): Promise<GitlabAPIResponse<LabelEventSchema[], C, E, P>>;
    show<E extends boolean = false>(projectId: string | number, mergerequestIId: number, labelEventId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<LabelEventSchema, C, E, void>>;
}
declare class MergeRequestLabelEvents<C extends boolean = false> extends ResourceLabelEvents<C> {
    constructor(options: BaseResourceOptions<C>);
}

interface MergeRequestMilestoneEvents<C extends boolean = false> {
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(projectId: string | number, mergerequestIId: number, options?: Sudo & ShowExpanded<E> & PaginationRequestOptions<P>): Promise<GitlabAPIResponse<MilestoneEventSchema[], C, E, P>>;
    show<E extends boolean = false>(projectId: string | number, mergerequestIId: number, milestoneEventId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<MilestoneEventSchema, C, E, void>>;
}
declare class MergeRequestMilestoneEvents<C extends boolean = false> extends ResourceMilestoneEvents<C> {
    constructor(options: BaseResourceOptions<C>);
}

interface MergeRequestNoteSchema extends NoteSchema {
    confidential: boolean;
    attachment?: string;
    system: boolean;
    noteable_id: number;
    noteable_type: string;
    noteable_iid: number;
    resolvable: boolean;
}
interface MergeRequestNotes<C extends boolean = false> extends ResourceNotes<C> {
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(projectId: string | number, mergerequestIId: number, options?: PaginationRequestOptions<P> & BaseRequestOptions<E>): Promise<GitlabAPIResponse<MergeRequestNoteSchema[], C, E, P>>;
    create<E extends boolean = false>(projectId: string | number, mergerequestIId: number, body: string, options?: {
        created_at?: string;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<MergeRequestNoteSchema, C, E, void>>;
    edit<E extends boolean = false>(projectId: string | number, mergerequestIId: number, noteId: number, options: {
        body: string;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<MergeRequestNoteSchema, C, E, void>>;
    remove<E extends boolean = false>(projectId: string | number, mergerequestIId: number, noteId: number, options?: Sudo): Promise<GitlabAPIResponse<void, C, E, void>>;
    show<E extends boolean = false>(projectId: string | number, mergerequestIId: number, noteId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<MergeRequestNoteSchema, C, E, void>>;
}
declare class MergeRequestNotes<C extends boolean = false> extends ResourceNotes<C> {
    constructor(options: BaseResourceOptions<C>);
}

interface MergeTrainSchema extends Record<string, unknown> {
    id: number;
    merge_request: CondensedMergeRequestSchema;
    user: Omit<UserSchema, 'created_at'>;
    pipeline: PipelineSchema;
    created_at: string;
    updated_at: string;
    target_branch: string;
    status: string;
    merged_at: string;
    duration: number;
}
declare class MergeTrains<C extends boolean = false> extends BaseResource<C> {
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(projectId: string | number, options: {
        targetBranch?: string;
        scope?: 'active' | 'complete';
        sort?: 'asc' | 'desc';
    } & PaginationRequestOptions<P> & BaseRequestOptions<E>): Promise<GitlabAPIResponse<MergeTrainSchema[], C, E, P>>;
    showStatus<E extends boolean = false>(projectId: string | number, mergeRequestIId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<MergeTrainSchema, C, E, void>>;
}

interface PackageRegistrySchema extends Record<string, unknown> {
    id: number;
    package_id: number;
    created_at: string;
    updated_at: string;
    size: number;
    file_store: number;
    file_md5?: string;
    file_sha1?: string;
    file_name: string;
    file: {
        url: string;
    };
    file_sha256: string;
    verification_retry_at?: string;
    verified_at?: string;
    verification_failure?: string;
    verification_retry_count?: string;
    verification_checksum?: string;
    verification_state: number;
    verification_started_at?: string;
    new_file_path?: string;
}
declare class PackageRegistry<C extends boolean = false> extends BaseResource<C> {
    publish<E extends boolean = false>(projectId: string | number, packageName: string, packageVersion: string, filename: string, content: Blob, options: {
        select: 'package_file';
        contentType?: string;
        status?: 'default' | 'hidden';
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<PackageRegistrySchema, C, E, void>>;
    publish<E extends boolean = false>(projectId: string | number, packageName: string, packageVersion: string, filename: string, content: Blob, options?: {
        contentType?: string;
        status?: 'default' | 'hidden';
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<{
        message: string;
    }, C, E, void>>;
    download<E extends boolean = false>(projectId: string | number, packageName: string, packageVersion: string, filename: string, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIExpandedResponse<CamelizedResponse<{
        message: string;
    }, C>, E, undefined>>;
}

interface PackageSchema extends Record<string, unknown> {
    id: number;
    name: string;
    version: string;
    package_type: string;
    created_at: string;
}
interface ExpandedPackageSchema extends PackageSchema {
    _links: Record<string, string>;
    pipelines: PipelineSchema[];
    versions: Omit<ExpandedPackageSchema, '_links'>;
}
interface PackageFileSchema extends Record<string, unknown> {
    id: number;
    package_id: number;
    created_at: string;
    file_name: string;
    size: number;
    file_md5: string;
    file_sha1: string;
    pipelines?: PipelineSchema[];
}
declare class Packages<C extends boolean = false> extends BaseResource<C> {
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>({ projectId, groupId, ...options }?: Either<{
        projectId: string | number;
    }, {
        groupId: string | number;
    }> & Sudo & ShowExpanded<E> & PaginationRequestOptions<P>): Promise<GitlabAPIResponse<PackageSchema[], C, E, P>>;
    remove<E extends boolean = false>(projectId: string | number, packageId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
    removeFile<E extends boolean = false>(projectId: string | number, packageId: number, projectFileId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
    show<E extends boolean = false>(projectId: string | number, packageId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<ExpandedPackageSchema, C, E, void>>;
    allFiles<E extends boolean = false>(projectId: string | number, packageId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<PackageFileSchema[], C, E, void>>;
}

interface PagesDomainSchema extends Record<string, unknown> {
    domain: string;
    url: string;
    project_id: number;
    auto_ssl_enabled?: boolean;
    certificate?: {
        expired: boolean;
        expiration: string;
        certificate: string;
        certificate_text: string;
    };
}
declare class PagesDomains<C extends boolean = false> extends BaseResource<C> {
    all<E extends boolean = false>({ projectId, ...options }?: {
        projectId?: string | number;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<PagesDomainSchema[], C, E, void>>;
    create<E extends boolean = false>(projectId: string | number, domain: string, options?: {
        autoSslEnabled?: string;
        certificate?: string;
        key?: string;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<PagesDomainSchema, C, E, void>>;
    edit<E extends boolean = false>(projectId: string | number, domain: string, options?: {
        autoSslEnabled?: string;
        certificate?: string;
        key?: string;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<PagesDomainSchema, C, E, void>>;
    show<E extends boolean = false>(projectId: string | number, domain: string, options?: {
        autoSslEnabled?: string;
        certificate?: string;
        key?: string;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<PagesDomainSchema, C, E, void>>;
    remove<E extends boolean = false>(projectId: string | number, domain: string, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
}

interface CondensedPipelineScheduleSchema extends Record<string, unknown> {
    id: number;
    description: string;
    ref: string;
    cron: string;
    cron_timezone: string;
    next_run_at: string;
    active: boolean;
    created_at: string;
    updated_at: string;
    owner: Omit<UserSchema, 'created_at'>;
}
interface PipelineScheduleSchema extends CondensedPipelineScheduleSchema {
    last_pipeline: Pick<PipelineSchema, 'id' | 'sha' | 'ref' | 'status'>;
}
interface ExpandedPipelineScheduleSchema extends PipelineScheduleSchema {
    last_pipeline: Pick<PipelineSchema, 'id' | 'sha' | 'ref' | 'status'>;
    variables: PipelineVariableSchema[];
}
declare class PipelineSchedules<C extends boolean = false> extends BaseResource<C> {
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(projectId: string | number, options?: {
        scope?: 'active' | 'inactive';
    } & Sudo & ShowExpanded<E> & PaginationRequestOptions<P>): Promise<GitlabAPIResponse<CondensedPipelineScheduleSchema[], C, E, P>>;
    allTriggeredPipelines<E extends boolean = false>(projectId: string | number, pipelineScheduleId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<PipelineSchema[], C, E, void>>;
    create<E extends boolean = false>(projectId: string | number, description: string, ref: string, cron: string, options?: {
        cronTimezone?: string;
        active?: boolean;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<PipelineScheduleSchema, C, E, void>>;
    edit<E extends boolean = false>(projectId: string | number, pipelineScheduleId: number, options?: {
        description?: string;
        ref?: string;
        cron?: string;
        cronTimezone?: string;
        active?: boolean;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<PipelineScheduleSchema, C, E, void>>;
    remove<E extends boolean = false>(projectId: string | number, pipelineScheduleId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<PipelineScheduleSchema, C, E, void>>;
    run<E extends boolean = false>(projectId: string | number, pipelineScheduleId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<{
        message: string;
    }, C, E, void>>;
    show<E extends boolean = false>(projectId: string | number, pipelineScheduleId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<ExpandedPipelineScheduleSchema, C, E, void>>;
    takeOwnership<E extends boolean = false>(projectId: string | number, pipelineScheduleId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<PipelineScheduleSchema, C, E, void>>;
}

interface PipelineTriggerTokenSchema extends Record<string, unknown> {
    id: number;
    description: string;
    created_at: string;
    last_used?: null;
    token: string;
    updated_at: string;
    owner?: null;
}
declare class PipelineTriggerTokens<C extends boolean = false> extends BaseResource<C> {
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(projectId: string | number, options?: Sudo & ShowExpanded<E> & PaginationRequestOptions<P>): Promise<GitlabAPIResponse<PipelineTriggerTokenSchema[], C, E, P>>;
    create<E extends boolean = false>(projectId: string | number, description: string, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<PipelineTriggerTokenSchema, C, E, void>>;
    edit<E extends boolean = false>(projectId: string | number, triggerId: number, options?: {
        description?: string;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<PipelineTriggerTokenSchema, C, E, void>>;
    remove<E extends boolean = false>(projectId: string | number, pipelineId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
    show<E extends boolean = false>(projectId: string | number, triggerId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<PipelineTriggerTokenSchema, C, E, void>>;
    trigger<E extends boolean = false>(projectId: string | number, ref: string, token: string, options?: {
        variables?: Record<string, unknown>;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<ExpandedPipelineSchema, C, E, void>>;
}

declare class ProductAnalytics<C extends boolean = false> extends BaseResource<C> {
    load<E extends boolean = false>(projectId: string | number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
    dryRun<E extends boolean = false>(projectId: string | number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
    showMetadata<E extends boolean = false>(projectId: string | number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
}

interface ProjectAccessRequests<C extends boolean = false> extends ResourceAccessRequests<C> {
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(projectId: string | number, options?: PaginationRequestOptions<P> & BaseRequestOptions<E>): Promise<GitlabAPIResponse<AccessRequestSchema[], C, E, P>>;
    request<E extends boolean = false>(projectId: string | number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<AccessRequestSchema, C, E, void>>;
    approve<E extends boolean = false>(projectId: string | number, userId: number, options?: {
        accessLevel?: AccessLevel;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<AccessRequestSchema, C, E, void>>;
    deny<E extends boolean = false>(groupId: string | number, userId: number): Promise<GitlabAPIResponse<void, C, E, void>>;
}
declare class ProjectAccessRequests<C extends boolean = false> extends ResourceAccessRequests<C> {
    constructor(options: BaseResourceOptions<C>);
}

interface ProjectAccessTokens<C extends boolean = false> extends ResourceAccessTokens<C> {
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(projectId: string | number, options?: Sudo & ShowExpanded<E> & PaginationRequestOptions<P>): Promise<GitlabAPIResponse<AccessTokenSchema[], C, E, P>>;
    create<E extends boolean = false>(projectId: string | number, name: string, scopes: AccessTokenScopes[], options?: {
        accessLevel?: AccessLevel;
        expiresAt?: string;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<AccessTokenSchema, C, E, void>>;
    revoke<E extends boolean = false>(projectId: string | number, tokenId: string | number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
    show<E extends boolean = false>(projectId: string | number, tokenId: string | number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<AccessTokenSchema, C, E, void>>;
}
declare class ProjectAccessTokens<C extends boolean = false> extends ResourceAccessTokens<C> {
    constructor(options: BaseResourceOptions<C>);
}

interface ProjectAliasSchema extends Record<string, unknown> {
    id: number;
    project_id: string | number;
    name: string;
}
declare class ProjectAliases<C extends boolean = false> extends BaseResource<C> {
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(options?: Sudo & ShowExpanded<E> & PaginationRequestOptions<P>): Promise<GitlabAPIResponse<ProjectAliasSchema[], C, E, P>>;
    create<E extends boolean = false>(projectId: string | number, name: string, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<ProjectAliasSchema, C, E, void>>;
    edit<E extends boolean = false>(name: string, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<ProjectAliasSchema, C, E, void>>;
    remove<E extends boolean = false>(name: string, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
}

interface ProjectBadgeSchema extends BadgeSchema {
    kind: 'project';
}
type ProjectBadgePreviewSchema = Omit<ProjectBadgeSchema, 'id' | 'name' | 'kind'>;
interface ProjectBadges<C extends boolean = false> extends ResourceBadges<C> {
    add<E extends boolean = false>(groupId: string | number, linkUrl: string, imageUrl: string, options?: BaseRequestOptions<E>): Promise<GitlabAPIResponse<ProjectBadgeSchema, C, E, void>>;
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(groupId: string | number, options?: PaginationRequestOptions<P> & BaseRequestOptions<E>): Promise<GitlabAPIResponse<ProjectBadgeSchema[], C, E, P>>;
    edit<E extends boolean = false>(groupId: string | number, badgeId: number, options?: BaseRequestOptions<E>): Promise<GitlabAPIResponse<ProjectBadgeSchema, C, E, void>>;
    preview<E extends boolean = false>(groupId: string | number, linkUrl: string, imageUrl: string, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<ProjectBadgePreviewSchema, C, E, void>>;
    remove<E extends boolean = false>(groupId: string | number, badgeId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
    show<E extends boolean = false>(groupId: string | number, badgeId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<ProjectBadgeSchema, C, E, void>>;
}
declare class ProjectBadges<C extends boolean = false> extends ResourceBadges<C> {
    constructor(options: BaseResourceOptions<C>);
}

interface ProjectCustomAttributes<C extends boolean = false> extends ResourceCustomAttributes<C> {
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(projectId: string | number, options?: PaginationRequestOptions<P> & BaseRequestOptions<E>): Promise<GitlabAPIResponse<CustomAttributeSchema[], C, E, P>>;
    set<E extends boolean = false>(projectId: string | number, customAttributeId: string, value: string, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<CustomAttributeSchema, C, E, void>>;
    remove<E extends boolean = false>(projectId: string | number, customAttributeId: string, options?: Sudo): Promise<GitlabAPIResponse<void, C, E, void>>;
    show<E extends boolean = false>(projectId: string | number, customAttributeId: string, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<CustomAttributeSchema, C, E, void>>;
}
declare class ProjectCustomAttributes<C extends boolean> extends ResourceCustomAttributes<C> {
    constructor(options: BaseResourceOptions<C>);
}

declare class ProjectDORA4Metrics<C extends boolean = false> extends ResourceDORA4Metrics<C> {
    constructor(options: BaseResourceOptions<C>);
}

interface ProjectHookSchema extends ExpandedHookSchema {
    projectId: number;
}
interface ProjectHooks<C extends boolean = false> {
    add<E extends boolean = false>(projectId: string | number, url: string, options?: BaseRequestOptions<E>): Promise<GitlabAPIResponse<ProjectHookSchema, C, E, void>>;
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(projectId: string | number, options?: PaginationRequestOptions<P> & BaseRequestOptions<E>): Promise<GitlabAPIResponse<ProjectHookSchema[], C, E, P>>;
    edit<E extends boolean = false>(projectId: string | number, hookId: number, url: string, options?: BaseRequestOptions<E>): Promise<GitlabAPIResponse<ProjectHookSchema, C, E, void>>;
    remove<E extends boolean = false>(projectId: string | number, hookId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
    show<E extends boolean = false>(projectId: string | number, hookId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<ProjectHookSchema, C, E, void>>;
}
declare class ProjectHooks<C extends boolean = false> extends ResourceHooks<C> {
    constructor(options: BaseResourceOptions<C>);
}

interface ExportStatusSchema$1 extends Record<string, unknown> {
    id: number;
    description: string;
    name: string;
    name_with_namespace: string;
    path: string;
    path_with_namespace: string;
    created_at: string;
    export_status: string;
    _links: {
        api_url: string;
        web_url: string;
    };
}
interface FailedRelationSchema {
    id: number;
    created_at: string;
    exception_class: string;
    exception_message: string;
    source: string;
    relation_name: string;
}
interface ImportStatusSchema extends Record<string, unknown> {
    id: number;
    description: string;
    name: string;
    name_with_namespace: string;
    path: string;
    path_with_namespace: string;
    created_at: string;
    import_status: string;
    correlation_id: string;
    failed_relations?: FailedRelationSchema[];
}
declare class ProjectImportExport<C extends boolean = false> extends BaseResource<C> {
    download<E extends boolean = false>(projectId: string | number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<Blob, void, E, void>>;
    import<E extends boolean = false>(content: Blob, name: string, path: string, { filename, parentId, ...options }?: {
        parentId?: number;
        filename?: string;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
    showExportStatus(projectId: string | number, options?: Sudo): Promise<CamelizedResponse<ExportStatusSchema$1, C>>;
    showImportStatus(projectId: string | number, options?: Sudo): Promise<CamelizedResponse<ImportStatusSchema, C>>;
    scheduleExport<E extends boolean = false>(projectId: string | number, options?: BaseRequestOptions<E>): Promise<GitlabAPIResponse<{
        message: string;
    }, C, E, void>>;
}

interface ProjectInvitations<C extends boolean = false> {
    add<E extends boolean = false>(projectId: string | number, accessLevel: AccessLevel, options: Either<{
        email: string;
    }, {
        userId: string;
    }> & BaseRequestOptions<E>): Promise<GitlabAPIResponse<InvitationSchema, C, E, void>>;
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(projectId: string | number, options?: PaginationRequestOptions<P> & BaseRequestOptions<E>): Promise<GitlabAPIResponse<InvitationSchema[], C, E, P>>;
    edit<E extends boolean = false>(projectId: string | number, email: string, options?: BaseRequestOptions<E>): Promise<GitlabAPIResponse<InvitationSchema, C, E, void>>;
    remove<E extends boolean = false>(projectId: string | number, email: string, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<InvitationSchema, C, E, void>>;
}
declare class ProjectInvitations<C extends boolean = false> extends ResourceInvitations<C> {
    constructor(options: BaseResourceOptions<C>);
}

interface ProjectIssueBoardSchema extends IssueBoardSchema {
    project: SimpleProjectSchema;
}
interface ProjectIssueBoards<C extends boolean = false> extends ResourceIssueBoards<C> {
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(projectId: string | number, options?: PaginationRequestOptions<P> & BaseRequestOptions<E>): Promise<GitlabAPIResponse<ProjectIssueBoardSchema[], C, E, P>>;
    create<E extends boolean = false>(projectId: string | number, name: string, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<ProjectIssueBoardSchema, C, E, void>>;
    createList<E extends boolean = false>(projectId: string | number, boardId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<IssueBoardListSchema, C, E, void>>;
    edit<E extends boolean = false>(projectId: string | number, boardId: number, options?: BaseRequestOptions<E>): Promise<GitlabAPIResponse<ProjectIssueBoardSchema, C, E, void>>;
    editList<E extends boolean = false>(projectId: string | number, boardId: number, listId: number, position: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<IssueBoardListSchema, C, E, void>>;
    alllists<E extends boolean = false>(projectId: string | number, boardId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<IssueBoardListSchema[], C, E, void>>;
    remove<E extends boolean = false>(projectId: string | number, boardId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
    removeList<E extends boolean = false>(projectId: string | number, boardId: number, listId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
    show<E extends boolean = false>(projectId: string | number, boardId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<ProjectIssueBoardSchema, C, E, void>>;
    showList<E extends boolean = false>(projectId: string | number, boardId: number, listId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<IssueBoardListSchema, C, E, void>>;
}
declare class ProjectIssueBoards<C extends boolean = false> extends ResourceIssueBoards<C> {
    constructor(options: BaseResourceOptions<C>);
}

interface ProjectIterations<C extends boolean = false> {
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(projectId: string | number, options?: {
        state?: 'opened' | 'upcoming' | 'current' | 'closed' | 'all';
        search?: string;
        includeAncestors?: boolean;
    } & BaseRequestOptions<E> & PaginationRequestOptions<P>): Promise<GitlabAPIResponse<IterationSchema[], C, E, P>>;
}
declare class ProjectIterations<C extends boolean = false> extends ResourceIterations<C> {
    constructor(options: BaseResourceOptions<C>);
}

interface ProjectLabels<C extends boolean = false> extends ResourceLabels<C> {
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(projectId: string | number, options?: PaginationRequestOptions<P> & BaseRequestOptions<E>): Promise<GitlabAPIResponse<LabelSchema[], C, E, P>>;
    create<E extends boolean = false>(projectId: string | number, labelName: string, color: string, options?: {
        description?: string;
        priority?: number;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<LabelSchema, C, E, void>>;
    edit<E extends boolean = false>(projectId: string | number, labelId: number | string, options: Either<{
        newName: string;
    }, {
        color: string;
    }> & {
        description?: string;
        priority?: number;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<LabelSchema, C, E, void>>;
    promote<E extends boolean = false>(projectId: string | number, labelId: number | string, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<LabelSchema, C, E, void>>;
    remove<E extends boolean = false>(projectId: string | number, labelId: number | string, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
    show<E extends boolean = false>(projectId: string | number, labelId: number | string, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<LabelSchema, C, E, void>>;
    subscribe<E extends boolean = false>(projectId: string | number, labelId: number | string, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<LabelSchema, C, E, void>>;
    unsubscribe<E extends boolean = false>(projectId: string | number, labelId: number | string, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<LabelSchema, C, E, void>>;
}
declare class ProjectLabels<C extends boolean = false> extends ResourceLabels<C> {
    constructor(options: BaseResourceOptions<C>);
}

interface ProjectMembers<C extends boolean = false> extends ResourceMembers<C> {
    add<E extends boolean = false>(projectId: string | number, userId: number, accessLevel: AccessLevel, options?: BaseRequestOptions<E>): Promise<GitlabAPIResponse<MemberSchema, C, E, void>>;
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(projectId: string | number, options: IncludeInherited & PaginationRequestOptions<P> & BaseRequestOptions<E>): Promise<GitlabAPIResponse<MemberSchema[], C, E, P>>;
    edit<E extends boolean = false>(projectId: string | number, userId: number, accessLevel: AccessLevel, options?: BaseRequestOptions<E>): Promise<GitlabAPIResponse<MemberSchema, C, E, void>>;
    show<E extends boolean = false>(projectId: string | number, userId: number, options?: IncludeInherited & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<MemberSchema, C, E, void>>;
    remove<E extends boolean = false>(projectId: string | number, userId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
}
declare class ProjectMembers<C extends boolean = false> extends ResourceMembers<C> {
    constructor(options: BaseResourceOptions<C>);
}

interface ProjectMilestones<C extends boolean = false> extends ResourceMilestones<C> {
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(projectId: string | number, options?: PaginationRequestOptions<P> & BaseRequestOptions<E>): Promise<GitlabAPIResponse<MilestoneSchema[], C, E, P>>;
    allAssignedIssues<E extends boolean = false>(projectId: string | number, milestoneId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<IssueSchema[], C, E, void>>;
    allAssignedMergeRequests<E extends boolean = false>(projectId: string | number, milestoneId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<MergeRequestSchema[], C, E, void>>;
    create<E extends boolean = false>(projectId: string | number, title: string, options?: {
        description?: string;
        dueDate?: string;
        startDate?: string;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<MilestoneSchema, C, E, void>>;
    edit<E extends boolean = false>(projectId: string | number, milestoneId: number, options?: {
        title?: string;
        description?: string;
        dueDate?: string;
        startDate?: string;
        startEvent?: 'close' | 'activate';
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<MilestoneSchema, C, E, void>>;
    remove<E extends boolean = false>(projectId: string | number, milestoneId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
    show<E extends boolean = false>(projectId: string | number, milestoneId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<MilestoneSchema, C, E, void>>;
    showBurndownChartEvents<E extends boolean = false>(projectId: string | number, milestoneId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
}
declare class ProjectMilestones<C extends boolean = false> extends ResourceMilestones<C> {
    constructor(options: BaseResourceOptions<C>);
    promote<E extends boolean = false>(projectId: string | number, milestoneId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
}

interface ProjectProtectedEnvironments<C extends boolean = false> {
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(projectId: string | number, options: {
        search?: string;
    } & Sudo & ShowExpanded<E> & PaginationRequestOptions<P>): Promise<GitlabAPIResponse<ProtectedEnvironmentSchema[], C, E, P>>;
    edit<E extends boolean = false>(projectId: string | number, name: string, options?: {
        deploy_access_levels?: ProtectedEnvironmentAccessLevel[];
        required_approval_count?: number;
        approval_rules?: ProtectedEnvironmentAccessLevel[];
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<ProtectedEnvironmentSchema, C, E, void>>;
    protect<E extends boolean = false>(projectId: string | number, name: string, deployAccessLevel: ProtectedEnvironmentAccessLevel[], options?: {
        requiredApprovalCount?: number;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<ProtectedEnvironmentSchema, C, E, void>>;
    show<E extends boolean = false>(projectId: string | number, name: string, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<ProtectedEnvironmentSchema, C, E, void>>;
    unprotect<E extends boolean = false>(projectId: string | number, name: string, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
}
declare class ProjectProtectedEnvironments<C extends boolean = false> extends ResourceProtectedEnvironments<C> {
    constructor(options: BaseResourceOptions<C>);
}

interface ProjectPushRules<C extends boolean = false> extends ResourcePushRules<C> {
    create<E extends boolean = false>(projectId: string | number, options?: BaseRequestOptions<E>): Promise<GitlabAPIResponse<PushRuleSchema, C, E, void>>;
    edit<E extends boolean = false>(projectId: string | number, options?: BaseRequestOptions<E>): Promise<GitlabAPIResponse<PushRuleSchema, C, E, void>>;
    remove<E extends boolean = false>(projectId: string | number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
    show<E extends boolean = false>(projectId: string | number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<PushRuleSchema, C, E, void>>;
}
declare class ProjectPushRules<C extends boolean = false> extends ResourcePushRules<C> {
    constructor(options: BaseResourceOptions<C>);
}

interface ExportStatusSchema extends Record<string, unknown> {
    id: number;
    description: string;
    name: string;
    name_with_namespace: string;
    path: string;
    path_with_namespace: string;
    created_at: string;
    export_status: string;
    _links: {
        api_url: string;
        web_url: string;
    };
}
declare class ProjectRelationsExport<C extends boolean = false> extends BaseResource<C> {
    download<E extends boolean = false>(projectId: string | number, relation: string, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<Blob, void, E, void>>;
    showExportStatus(projectId: string | number, options?: Sudo): Promise<CamelizedResponse<ExportStatusSchema, C>>;
    scheduleExport<E extends boolean = false>(projectId: string | number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<{
        message: string;
    }, C, E, void>>;
}

interface ReleaseEvidence {
    sha: string;
    filepath: string;
    collected_at: string;
}
interface ReleaseAssetSource {
    format: string;
    url: string;
}
interface ReleaseAssetLink {
    id: number;
    name: string;
    url: string;
    external: boolean;
    link_type: string;
}
interface ReleaseSchema extends Record<string, unknown> {
    tag_name: string;
    description: string;
    name: string;
    description_html: string;
    created_at: string;
    released_at: string;
    user: Omit<UserSchema, 'created_at'>;
    commit: CommitSchema;
    milestones?: MilestoneSchema[];
    commit_path: string;
    tag_path: string;
    assets: {
        count: number;
        sources?: ReleaseAssetSource[];
        links?: ReleaseAssetLink[];
        evidence_file_path: string;
    };
    evidences?: ReleaseEvidence[];
}
declare class ProjectReleases<C extends boolean = false> extends BaseResource<C> {
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(projectId: string | number, options?: PaginationRequestOptions<P> & BaseRequestOptions<E>): Promise<GitlabAPIResponse<ReleaseSchema[], C, E, P>>;
    create<E extends boolean = false>(projectId: string | number, options?: BaseRequestOptions<E>): Promise<GitlabAPIResponse<ReleaseSchema, C, E, void>>;
    createEvidence<E extends boolean = false>(projectId: string | number, tagName: string, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<number, C, E, void>>;
    edit<E extends boolean = false>(projectId: string | number, tagName: string, options?: BaseRequestOptions<E>): Promise<GitlabAPIResponse<ReleaseSchema, C, E, void>>;
    download<E extends boolean = false>(projectId: string | number, tagName: string, filepath: string, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<Blob, C, E, void>>;
    downloadLatest<E extends boolean = false>(projectId: string | number, filepath: string, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<Blob, C, E, void>>;
    remove<E extends boolean = false>(projectId: string | number, tagName: string, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
    show<E extends boolean = false>(projectId: string | number, tagName: string, options?: {
        includeHtmlDescription?: boolean;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<ReleaseSchema, C, E, void>>;
    showLatest<E extends boolean = false>(projectId: string | number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<ReleaseSchema, C, E, void>>;
    showLatestEvidence<E extends boolean = false>(projectId: string | number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<ReleaseSchema, C, E, void>>;
}

interface ProjectRepositoryStorageMoveSchema extends RepositoryStorageMoveSchema {
    project: SimpleProjectSchema;
}
interface ProjectRepositoryStorageMoves<C extends boolean = false> extends ResourceRepositoryStorageMoves<C> {
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(options?: {
        projectId?: string | number;
    } & PaginationRequestOptions<P> & BaseRequestOptions<E>): Promise<GitlabAPIResponse<ProjectRepositoryStorageMoveSchema[], C, E, P>>;
    show<E extends boolean = false, P extends PaginationTypes = 'offset'>(repositoryStorageId: number, options?: {
        projectId?: string | number;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<ProjectRepositoryStorageMoveSchema, C, E, P>>;
    schedule<E extends boolean = false, P extends PaginationTypes = 'offset'>(sourceStorageName: string, options?: {
        projectId?: string | number;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<ProjectRepositoryStorageMoveSchema, C, E, P>>;
}
declare class ProjectRepositoryStorageMoves<C extends boolean = false> extends ResourceRepositoryStorageMoves<C> {
    constructor(options: BaseResourceOptions<C>);
}

interface ProjectSnippetAwardEmojis<C extends boolean = false> extends ResourceAwardEmojis<C> {
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(projectId: string | number, snippetId: number, options?: PaginationRequestOptions<P> & BaseRequestOptions<E>): Promise<GitlabAPIResponse<AwardEmojiSchema[], C, E, P>>;
    award<E extends boolean = false>(projectId: string | number, snippetId: number, name: string, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<AwardEmojiSchema, C, E, void>>;
    remove<E extends boolean = false>(projectId: string | number, snippetId: number, awardId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
    show<E extends boolean = false>(projectId: string | number, snippetId: number, awardId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<AwardEmojiSchema, C, E, void>>;
}
declare class ProjectSnippetAwardEmojis<C extends boolean = false> extends ResourceAwardEmojis<C> {
    constructor(options: BaseResourceOptions<C>);
}

interface ProjectSnippetDiscussions<C extends boolean = false> extends ResourceDiscussions<C> {
    addNote<E extends boolean = false>(projectId: string | number, snippetId: string | number, discussionId: string, noteId: number, body: string, options?: BaseRequestOptions<E>): Promise<GitlabAPIResponse<DiscussionNoteSchema, C, E, void>>;
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(projectId: string | number, issueId: string | number, options?: PaginationRequestOptions<P> & BaseRequestOptions<E>): Promise<GitlabAPIResponse<DiscussionSchema[], C, E, P>>;
    create<E extends boolean = false>(projectId: string | number, snippetId: string | number, body: string, options?: BaseRequestOptions<E>): Promise<GitlabAPIResponse<DiscussionSchema, C, E, void>>;
    editNote<E extends boolean = false>(projectId: string | number, snippetId: string | number, discussionId: string, noteId: number, options: BaseRequestOptions<E> & {
        body: string;
    }): Promise<GitlabAPIResponse<DiscussionNoteSchema, C, E, void>>;
    removeNote<E extends boolean = false>(projectId: string | number, snippetId: string | number, discussionId: string, noteId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
    show<E extends boolean = false>(projectId: string | number, snippetId: string | number, discussionId: string, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<DiscussionSchema, C, E, void>>;
}
declare class ProjectSnippetDiscussions<C extends boolean = false> extends ResourceDiscussions<C> {
    constructor(options: BaseResourceOptions<C>);
}

interface SnippetNoteSchema extends NoteSchema {
    confidential: boolean;
    file_name: string;
    expires_at: string;
}
interface ProjectSnippetNotes<C extends boolean = false> extends ResourceNotes<C> {
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(projectId: string | number, snippedId: number, options?: PaginationRequestOptions<P> & BaseRequestOptions<E>): Promise<GitlabAPIResponse<SnippetNoteSchema[], C, E, P>>;
    create<E extends boolean = false>(projectId: string | number, snippedId: number, body: string, options?: {
        created_at?: string;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<SnippetNoteSchema, C, E, void>>;
    edit<E extends boolean = false>(projectId: string | number, snippedId: number, noteId: number, options: {
        body: string;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<SnippetNoteSchema, C, E, void>>;
    remove<E extends boolean = false>(projectId: string | number, snippedId: number, noteId: number, options?: Sudo): Promise<GitlabAPIResponse<void, C, E, void>>;
    show<E extends boolean = false>(projectId: string | number, snippedId: number, noteId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<SnippetNoteSchema, C, E, void>>;
}
declare class ProjectSnippetNotes<C extends boolean = false> extends ResourceNotes<C> {
    constructor(options: BaseResourceOptions<C>);
}

declare class ProjectSnippets<C extends boolean = false> extends BaseResource<C> {
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(projectId: string | number, options?: Sudo & ShowExpanded<E> & PaginationRequestOptions<P>): Promise<GitlabAPIResponse<SnippetSchema[], C, E, P>>;
    create<E extends boolean = false>(projectId: string | number, title: string, options?: BaseRequestOptions<E>): Promise<GitlabAPIExpandedResponse<CamelizedResponse<ExpandedSnippetSchema, C>, E, undefined>>;
    edit<E extends boolean = false>(projectId: string | number, snippetId: number, options?: BaseRequestOptions<E>): Promise<GitlabAPIExpandedResponse<CamelizedResponse<ExpandedSnippetSchema, C>, E, undefined>>;
    remove<E extends boolean = false>(projectId: string | number, snippetId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIExpandedResponse<void, E, undefined>>;
    show<E extends boolean = false>(projectId: string | number, snippetId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<SnippetSchema, C, E, void>>;
    showContent<E extends boolean = false>(projectId: string | number, snippetId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<string, C, E, void>>;
    showRepositoryFileContent<E extends boolean = false>(projectId: string | number, snippetId: number, ref: string, filePath: string, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<string, C, E, void>>;
    showUserAgentDetails<E extends boolean = false>(projectId: string | number, snippetId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIExpandedResponse<CamelizedResponse<UserAgentDetailSchema, C>, E, undefined>>;
}

interface ProjectStatisticSchema extends Record<string, unknown> {
    fetches: {
        total: number;
        days: {
            count: number;
            date: string;
        }[];
    };
}
declare class ProjectStatistics<C extends boolean = false> extends BaseResource<C> {
    show<E extends boolean = false>(projectId: string | number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<ProjectStatisticSchema, C, E, void>>;
}

type ProjectTemplateType = 'dockerfiles' | 'gitignores' | 'gitlab_ci_ymls' | 'licenses' | 'issues' | 'merge_requests';
interface ProjectTemplateSchema extends Record<string, unknown> {
    name: string;
    content: string;
}
declare class ProjectTemplates<C extends boolean = false> extends BaseResource<C> {
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(projectId: string | number, type: ProjectTemplateType, options?: PaginationRequestOptions<P> & BaseRequestOptions<E>): Promise<GitlabAPIResponse<ProjectTemplateSchema[], C, E, P>>;
    show<E extends boolean = false>(projectId: string | number, type: ProjectTemplateType, name: string, options?: {
        project?: string;
        fullname?: string;
        sourceTemplateProjectId?: number;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<ProjectTemplateSchema, C, E, void>>;
}

interface ProjectVariableSchema extends VariableSchema {
    environment_scope: string;
}
interface ProjectVariables<C extends boolean = false> extends ResourceVariables<C> {
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(projectId: string | number, options?: Sudo & ShowExpanded<E> & PaginationRequestOptions<P>): Promise<GitlabAPIResponse<ProjectVariableSchema[], C, E, P>>;
    create<E extends boolean = false>(projectId: string | number, key: string, value: string, options?: {
        variableType?: VariableType;
        protected?: boolean;
        masked?: boolean;
        environmentScope?: string;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<ProjectVariableSchema, C, E, void>>;
    edit<E extends boolean = false>(projectId: string | number, key: string, value: string, options?: {
        variableType?: VariableType;
        protected?: boolean;
        masked?: boolean;
        environmentScope?: string;
        filter: VariableFilter;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<ProjectVariableSchema, C, E, void>>;
    show<E extends boolean = false>(projectId: string | number, key: string, options?: {
        filter?: VariableFilter;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<ProjectVariableSchema, C, E, void>>;
    remove<E extends boolean = false>(projectId: string | number, key: string, options?: {
        filter?: VariableFilter;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
}
declare class ProjectVariables<C extends boolean = false> extends ResourceVariables<C> {
    constructor(options: BaseResourceOptions<C>);
}

interface ProjectVulnerabilitySchema extends Record<string, unknown> {
    author_id: number;
    confidence: string;
    created_at: string;
    description?: string;
    dismissed_at?: string;
    dismissed_by_id?: number;
    due_date?: string;
    finding: {
        confidence: string;
        created_at: string;
        id: number;
        location_fingerprint: string;
        metadata_version: string;
        name: string;
        primary_identifier_id: number;
        project_fingerprint: string;
        project_id: number;
        raw_metadata: string;
        report_type: string;
        scanner_id: number;
        severity: string;
        updated_at: string;
        uuid: string;
        vulnerability_id: number;
    };
    id: number;
    last_edited_at?: string;
    last_edited_by_id?: number;
    project: SimpleProjectSchema;
    project_default_branch: string;
    report_type: string;
    resolved_at?: string;
    resolved_by_id?: number;
    resolved_on_default_branch: boolean;
    severity: string;
    start_date?: string;
    state: string;
    title: string;
    updated_at: string;
    updated_by_id?: number;
}
declare class ProjectVulnerabilities<C extends boolean = false> extends BaseResource<C> {
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(projectId: string | number, options?: PaginationRequestOptions<P> & BaseRequestOptions<E>): Promise<GitlabAPIResponse<ProjectVulnerabilitySchema[], C, E, P>>;
    create<E extends boolean = false>(projectId: string | number, findingId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<ProjectVulnerabilitySchema, C, E, void>>;
}

interface ProjectWikis<C extends boolean = false> extends ResourceWikis<C> {
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(projectId: string | number, options?: {
        withContent?: boolean;
    } & Sudo & ShowExpanded<E> & PaginationRequestOptions<P>): Promise<GitlabAPIResponse<WikiSchema[], C, E, P>>;
    create<E extends boolean = false>(projectId: string | number, content: string, title: string, options?: {
        format?: string;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<WikiSchema, C, E, void>>;
    edit<E extends boolean = false>(projectId: string | number, slug: string, options?: Either<{
        content: string;
    }, {
        title: string;
    }> & {
        format?: string;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<WikiSchema, C, E, void>>;
    remove<E extends boolean = false>(projectId: string | number, slug: string, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
    show<E extends boolean = false>(projectId: string | number, slug: string, options?: {
        renderHtml?: boolean;
        version?: string;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<WikiSchema, C, E, void>>;
    uploadAttachment<E extends boolean = false>(projectId: string | number, content: Blob, options?: {
        filename?: string;
        branch?: string;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<WikiAttachmentSchema, C, E, void>>;
}
declare class ProjectWikis<C extends boolean = false> extends ResourceWikis<C> {
    constructor(options: BaseResourceOptions<C>);
}

interface ProtectedTagAccessLevel {
    access_level: 0 | 30 | 40 | 60;
    access_level_description: string;
}
interface ProtectedTagSchema extends Record<string, unknown> {
    name: string;
    create_access_levels?: ProtectedTagAccessLevel[];
}
declare class ProtectedTags<C extends boolean = false> extends BaseResource<C> {
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(projectId: string | number, options?: PaginationRequestOptions<P> & BaseRequestOptions<E>): Promise<GitlabAPIResponse<ProtectedTagSchema[], C, E, P>>;
    protect<E extends boolean = false>(projectId: string | number, tagName: string, options?: {
        createAccessLevel?: string;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<ProtectedTagSchema, C, E, void>>;
    show<E extends boolean = false>(projectId: string | number, tagName: string, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<ProtectedTagSchema, C, E, void>>;
    unprotect<E extends boolean = false>(projectId: string | number, tagName: string, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
}

interface ReleaseLinkSchema extends Record<string, unknown> {
    id: number;
    name: string;
    url: string;
    external: boolean;
    link_type: string;
}
declare class ReleaseLinks<C extends boolean = false> extends BaseResource<C> {
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(projectId: string | number, tagName: string, options?: Sudo & ShowExpanded<E> & PaginationRequestOptions<P>): Promise<GitlabAPIResponse<ReleaseLinkSchema[], C, E, P>>;
    create<E extends boolean = false>(projectId: string | number, tagName: string, name: string, url: string, options?: Sudo & {
        filePath?: string;
        linkType?: string;
    }): Promise<GitlabAPIResponse<ReleaseLinkSchema, C, E, void>>;
    edit<E extends boolean = false>(projectId: string | number, tagName: string, linkId: number, options?: Sudo & ShowExpanded<E> & {
        name?: string;
        url?: string;
        filePath?: string;
        linkType?: string;
    }): Promise<GitlabAPIResponse<ReleaseLinkSchema, C, E, void>>;
    remove<E extends boolean = false>(projectId: string | number, tagName: string, linkId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
    show<E extends boolean = false>(projectId: string | number, tagName: string, linkId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIExpandedResponse<CamelizedResponse<ReleaseLinkSchema, C>, E, undefined>>;
}

type ArchiveType = 'tar.gz' | 'tar.bz2' | 'tbz' | 'tbz2' | 'tb2' | 'bz2' | 'tar' | 'zip';
interface RepositoryChangelogSchema extends Record<string, unknown> {
    notes: string;
}
interface RepositoryCompareSchema extends Record<string, unknown> {
    commit: Omit<CondensedCommitSchema, 'message'>;
    commits?: Omit<CondensedCommitSchema, 'message'>[];
    diffs?: CommitDiffSchema[];
    compare_timeout: boolean;
    compare_same_ref: boolean;
}
interface RepositoryContributorSchema extends Record<string, unknown> {
    name: string;
    email: string;
    commits: number;
    additions: number;
    deletions: number;
}
interface RepositoryTreeSchema extends Record<string, unknown> {
    id: string;
    name: string;
    type: string;
    path: string;
    mode: string;
}
interface RepositoryBlobSchema extends Record<string, unknown> {
    size: number;
    encoding: string;
    content: string;
    sha: string;
}
declare class Repositories<C extends boolean = false> extends BaseResource<C> {
    compare<E extends boolean = false>(projectId: string | number, from: string, to: string, options?: {
        fromProjectId?: string | number;
        straight?: string;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<RepositoryCompareSchema, C, E, void>>;
    allContributors<E extends boolean = false>(projectId: string | number, options?: {
        orderBy?: string;
        sort?: string;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<RepositoryContributorSchema[], C, E, void>>;
    editChangelog<E extends boolean = false>(projectId: string | number, version: string, options?: BaseRequestOptions<E>): Promise<GitlabAPIResponse<RepositoryChangelogSchema, C, E, void>>;
    mergeBase<E extends boolean = false>(projectId: string | number, refs: string[], options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<CommitSchema, C, E, void>>;
    showArchive<E extends boolean = false>(projectId: string | number, options: {
        fileType?: ArchiveType;
        sha?: string;
        path?: string;
        asStream: true;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<ReadableStream, void, E, void>>;
    showArchive<E extends boolean = false>(projectId: string | number, options?: {
        fileType?: ArchiveType;
        sha?: string;
        path?: string;
        asStream?: boolean;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<Blob, void, E, void>>;
    showBlob<E extends boolean = false>(projectId: string | number, sha: string, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<RepositoryBlobSchema, void, E, void>>;
    showBlobRaw<E extends boolean = false>(projectId: string | number, sha: string, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<Blob, void, E, void>>;
    showChangelog<E extends boolean = false>(projectId: string | number, version: string, options?: BaseRequestOptions<E>): Promise<GitlabAPIResponse<RepositoryChangelogSchema, C, E, void>>;
    allRepositoryTrees<E extends boolean = false>(projectId: string | number, options?: PaginationRequestOptions<'keyset'> & BaseRequestOptions<E>): Promise<GitlabAPIResponse<RepositoryTreeSchema[], C, E, 'keyset'>>;
}

interface RepositoryFileExpandedSchema extends Record<string, unknown> {
    file_name: string;
    file_path: string;
    size: number;
    encoding: string;
    content: string;
    content_sha256: string;
    ref: string;
    blob_id: string;
    commit_id: string;
    last_commit_id: string;
}
interface RepositoryFileBlameSchema extends Record<string, unknown> {
    commit: CommitSchema;
    lines?: string[];
}
interface RepositoryFileSchema extends Record<string, unknown> {
    file_path: string;
    branch: string;
}
declare class RepositoryFiles<C extends boolean = false> extends BaseResource<C> {
    create<E extends boolean = false>(projectId: string | number, filePath: string, branch: string, content: Blob, commitMessage: string, options?: BaseRequestOptions<E>): Promise<GitlabAPIResponse<RepositoryFileSchema, C, E, void>>;
    edit<E extends boolean = false>(projectId: string | number, filePath: string, branch: string, content: Blob, commitMessage: string, options?: BaseRequestOptions<E>): Promise<GitlabAPIResponse<RepositoryFileSchema, C, E, void>>;
    remove<E extends boolean = false>(projectId: string | number, filePath: string, branch: string, commitMessage: string, options?: BaseRequestOptions<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
    show<E extends boolean = false>(projectId: string | number, filePath: string, ref: string, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<RepositoryFileExpandedSchema, C, E, void>>;
    allFileBlames<E extends boolean = false>(projectId: string | number, filePath: string, ref: string, options?: {
        range?: {
            start: number;
            end: number;
        };
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<RepositoryFileBlameSchema[], C, E, void>>;
    showRaw<E extends boolean = false>(projectId: string | number, filePath: string, ref: string, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<string, C, E, void>>;
}

interface RepositorySubmoduleSchema extends CommitSchema {
    status?: string;
}
declare class RepositorySubmodules<C extends boolean = false> extends BaseResource<C> {
    edit<E extends boolean = false>(projectId: string | number, submodule: string, branch: string, commitSha: string, options?: BaseRequestOptions<E>): Promise<GitlabAPIResponse<RepositorySubmoduleSchema, C, E, void>>;
}

interface ResourceGroupSchema extends Record<string, unknown> {
    id: number;
    key: string;
    process_mode: string;
    created_at: string;
    updated_at: string;
}
declare class ResourceGroups<C extends boolean = false> extends BaseResource<C> {
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(projectId: string | number, options?: Sudo & ShowExpanded<E> & PaginationRequestOptions<P>): Promise<GitlabAPIResponse<ResourceGroupSchema[], C, E, P>>;
    create<E extends boolean = false>(projectId: string | number, title: string, options?: BaseRequestOptions<E>): Promise<GitlabAPIExpandedResponse<CamelizedResponse<ResourceGroupSchema, C>, E, undefined>>;
    edit<E extends boolean = false>(projectId: string | number, key: string, options?: {
        processMode?: string;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIExpandedResponse<CamelizedResponse<ResourceGroupSchema, C>, E, undefined>>;
    show<E extends boolean = false>(projectId: string | number, key: string, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<ResourceGroupSchema, C, E, void>>;
    allUpcomingJobs<E extends boolean = false>(projectId: string | number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<JobSchema[], C, E, void>>;
}

interface SecureFileSchema extends Record<string, unknown> {
    id: number;
    name: string;
    checksum: string;
    checksum_algorithm: string;
    created_at: string;
    expires_at: string;
    metadata: {
        id: string;
        issuer: {
            C: string;
            O: string;
            CN: string;
            OU: string;
        };
        subject: {
            C: string;
            O: string;
            CN: string;
            OU: string;
            UID: string;
        };
        expires_at: string;
    };
}
declare class SecureFiles<C extends boolean = false> extends BaseResource<C> {
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(projectId: string | number, options?: PaginationRequestOptions<P> & BaseRequestOptions<E>): Promise<GitlabAPIResponse<SecureFileSchema[], C, E, P>>;
    create<E extends boolean = false>(projectId: string | number, content: Blob, name: string, path: string, { filename, parentId, ...options }?: {
        parentId?: number;
        filename?: string;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<SecureFileSchema, C, E, void>>;
    download<E extends boolean = false>(projectId: string | number, secureFileId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<Blob, void, E, void>>;
    remove<E extends boolean = false>(projectId: string | number, secureFileId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
    show<E extends boolean = false>(projectId: string | number, secureFileId: string, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<SecureFileSchema, C, E, void>>;
}

interface TagSchema extends Record<string, unknown> {
    commit: CommitSchema;
    release: Pick<ReleaseSchema, 'tag_name' | 'description'>;
    name: string;
    target: string;
    message?: string;
    protected: boolean;
}
interface TagSignatureSchema extends Record<string, unknown> {
    signature_type: string;
    verification_status: string;
    x509_certificate: {
        id: number;
        subject: string;
        subject_key_identifier: string;
        email: string;
        serial_number: number;
        certificate_status: string;
        x509_issuer: {
            id: number;
            subject: string;
            subject_key_identifier: string;
            crl_url: string;
        };
    };
}
declare class Tags<C extends boolean = false> extends BaseResource<C> {
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(projectId: string | number, options?: {
        orderBy?: 'name' | 'updated';
        sort?: 'asc' | 'desc';
        search?: string;
    } & Sudo & ShowExpanded<E> & PaginationRequestOptions<P>): Promise<GitlabAPIResponse<TagSchema[], C, E, P>>;
    create<E extends boolean = false>(projectId: string | number, tagName: string, ref: string, options?: {
        message?: string;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<TagSchema, C, E, void>>;
    remove<E extends boolean = false>(projectId: string | number, tagName: string, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
    show<E extends boolean = false>(projectId: string | number, tagName: string, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<TagSchema, C, E, void>>;
    showSignature<E extends boolean = false>(projectId: string | number, tagName: string, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<TagSignatureSchema | {
        message: string;
    }, C, E, void>>;
}

interface StarredDashboardSchema extends Record<string, unknown> {
    id: number;
    dashboard_path: string;
    user_id: number;
    project_id: number;
}
declare class UserStarredMetricsDashboard<C extends boolean = false> extends BaseResource<C> {
    create<E extends boolean = false>(projectId: string | number, dashboardPath: string, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<StarredDashboardSchema, C, E, void>>;
    remove<E extends boolean = false>(projectId: string | number, options?: {
        dashboard_path?: string;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<{
        deleted_rows: number;
    }, C, E, void>>;
}

declare class VisualReviewDiscussions<C extends boolean = false> extends BaseResource<C> {
    create<E extends boolean = false>(projectId: string | number, mergerequestIId: number, body: string, options?: {
        position?: DiscussionNotePositionSchema;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<DiscussionSchema, C, E, void>>;
}

interface VulnerabilityFindingSchema extends Record<string, unknown> {
    id: number;
    title: string;
    description?: string;
    state: string;
    severity: string;
    confidence: string;
    report_type: string;
    project: SimpleProjectSchema;
    author_id: number;
    updated_by_id?: number;
    last_edited_by_id?: number;
    closed_by_id?: number;
    start_date?: string;
    due_date?: string;
    created_at: string;
    updated_at: string;
    last_edited_at?: string;
    closed_at?: string;
}
declare class VulnerabilityFindings<C extends boolean = false> extends BaseResource<C> {
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(projectId: string | number, options?: PaginationRequestOptions<P> & BaseRequestOptions<E>): Promise<GitlabAPIResponse<VulnerabilityFindingSchema, C, E, P>>;
}

interface EpicAwardEmojis<C extends boolean = false> extends ResourceAwardEmojis<C> {
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(epicId: string | number, issueIId: number, options?: PaginationRequestOptions<P> & BaseRequestOptions<E>): Promise<GitlabAPIResponse<AwardEmojiSchema[], C, E, P>>;
    award<E extends boolean = false>(epicId: string | number, issueIId: number, name: string, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<AwardEmojiSchema, C, E, void>>;
    remove<E extends boolean = false>(epicId: string | number, issueIId: number, awardId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
    show<E extends boolean = false>(epicId: string | number, issueIId: number, awardId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<AwardEmojiSchema, C, E, void>>;
}
declare class EpicAwardEmojis<C extends boolean = false> extends ResourceAwardEmojis<C> {
    constructor(options: BaseResourceOptions<C>);
}

interface EpicDiscussions<C extends boolean = false> extends ResourceDiscussions<C> {
    addNote<E extends boolean = false>(groupId: string | number, epicId: number, discussionId: string, noteId: number, body: string, options?: BaseRequestOptions<E>): Promise<GitlabAPIResponse<DiscussionNoteSchema, C, E, void>>;
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(groupId: string | number, epicId: number, options?: PaginationRequestOptions<P> & BaseRequestOptions<E>): Promise<GitlabAPIResponse<DiscussionSchema[], C, E, P>>;
    create<E extends boolean = false>(groupId: string | number, epicId: number, body: string, options?: BaseRequestOptions<E>): Promise<GitlabAPIResponse<DiscussionSchema, C, E, void>>;
    editNote<E extends boolean = false>(groupId: string | number, epicId: number, discussionId: string, noteId: number, options: BaseRequestOptions<E> & {
        body: string;
    }): Promise<GitlabAPIResponse<DiscussionNoteSchema, C, E, void>>;
    removeNote<E extends boolean = false>(groupId: string | number, epicId: number, discussionId: string, noteId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
    show<E extends boolean = false>(groupId: string | number, epicId: number, discussionId: string, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<DiscussionSchema, C, E, void>>;
}
declare class EpicDiscussions<C extends boolean = false> extends ResourceDiscussions<C> {
    constructor(options: BaseResourceOptions<C>);
}

interface EpicIssueSchema extends Omit<IssueSchema, 'references' | 'task_completion_status'> {
    epic_issue_id: number;
}
interface ExpandedEpicIssueSchema extends EpicIssueSchema {
    subscribed: boolean;
    relative_position: number;
}
declare class EpicIssues<C extends boolean = false> extends BaseResource<C> {
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(groupId: string | number, epicIId: number, options?: PaginationRequestOptions<P> & BaseRequestOptions<E>): Promise<GitlabAPIResponse<EpicIssueSchema[], C, E, P>>;
    assign<E extends boolean = false>(groupId: string | number, epicIId: number, epicIssueId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<EpicIssueSchema, C, E, void>>;
    edit<E extends boolean = false>(groupId: string | number, epicIId: number, epicIssueId: number, options?: BaseRequestOptions<E>): Promise<GitlabAPIResponse<ExpandedEpicIssueSchema, C, E, void>>;
    remove<E extends boolean = false>(groupId: string | number, epicIId: number, epicIssueId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
}

interface EpicLabelEvents<C extends boolean = false> {
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(groupId: string | number, epidId: number, options?: BaseRequestOptions<E> & PaginationRequestOptions<P>): Promise<GitlabAPIResponse<LabelEventSchema[], C, E, P>>;
    show<E extends boolean = false>(groupId: string | number, epidId: number, labelEventId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<LabelEventSchema, C, E, void>>;
}
declare class EpicLabelEvents<C extends boolean = false> extends ResourceLabelEvents<C> {
    constructor(options: BaseResourceOptions<C>);
}

interface CondensedEpicLinkSchema extends Record<string, unknown> {
    id: number;
    iid: number;
    group_id: number;
    parent_id: number;
    title: string;
    has_children: boolean;
    has_issues: boolean;
    reference: string;
    url: string;
    relation_url: string;
}
interface EpicLinkSchema extends Record<string, unknown> {
    id: number;
    iid: number;
    group_id: number;
    parent_id: number;
    title: string;
    description: string;
    author: UserSchema;
    start_date?: string;
    start_date_is_fixed: boolean;
    start_date_fixed?: string;
    start_date_from_inherited_source?: string;
    due_date: string;
    due_date_is_fixed: boolean;
    due_date_fixed?: string;
    due_date_from_inherited_source: string;
    created_at: string;
    updated_at: string;
    labels?: string[];
}
declare class EpicLinks<C extends boolean = false> extends BaseResource<C> {
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(groupId: string | number, epicIId: number, options?: BaseRequestOptions<E> & PaginationRequestOptions<P>): Promise<GitlabAPIResponse<EpicLinkSchema[], C, E, P>>;
    assign<E extends boolean = false>(groupId: string | number, epicIId: number, childEpicId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<EpicLinkSchema, C, E, void>>;
    create<E extends boolean = false>(groupId: string | number, epicIId: number, title: string, options?: {
        confidential?: boolean;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<CondensedEpicLinkSchema, C, E, void>>;
    reorder<E extends boolean = false>(groupId: string | number, epicIId: number, childEpicId: number, options?: {
        moveBeforeId?: number;
        moveAfterId?: number;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<EpicLinkSchema, C, E, void>>;
    unassign<E extends boolean = false>(groupId: string | number, epicIId: number, childEpicId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<EpicLinkSchema, C, E, void>>;
}

interface EpicNoteSchema extends NoteSchema {
    confidential: boolean;
    file_name: string;
    expires_at: string;
}
interface EpicNotes<C extends boolean = false> extends ResourceNotes<C> {
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(groupId: string | number, epicId: number, options?: PaginationRequestOptions<P> & BaseRequestOptions<E>): Promise<GitlabAPIResponse<EpicNoteSchema[], C, E, P>>;
    create<E extends boolean = false>(groupId: string | number, epicId: number, body: string, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<EpicNoteSchema, C, E, void>>;
    edit<E extends boolean = false>(groupId: string | number, epicId: number, noteId: number, options: {
        body: string;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<EpicNoteSchema, C, E, void>>;
    remove<E extends boolean = false>(groupId: string | number, epicId: number, noteId: number, options?: Sudo): Promise<GitlabAPIResponse<void, C, E, void>>;
    show<E extends boolean = false>(groupId: string | number, epicId: number, noteId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<EpicNoteSchema, C, E, void>>;
}
declare class EpicNotes<C extends boolean = false> extends ResourceNotes<C> {
    constructor(options: BaseResourceOptions<C>);
}

interface EpicSchema extends Record<string, unknown> {
    id: number;
    iid: number;
    group_id: number;
    parent_id: number;
    parent_iid: number;
    title: string;
    description: string;
    state: string;
    confidential: string;
    web_url: string;
    references: {
        short: string;
        relative: string;
        full: string;
    };
    author: Omit<UserSchema, 'created_at'>;
    start_date?: string;
    start_date_is_fixed: boolean;
    start_date_fixed?: string;
    start_date_from_inherited_source?: string;
    due_date: string;
    due_date_is_fixed: boolean;
    due_date_fixed?: string;
    due_date_from_inherited_source: string;
    created_at: string;
    updated_at: string;
    closed_at: string;
    labels?: string[];
    upvotes: number;
    downvotes: number;
    _links: {
        self: string;
        epic_issues: string;
        group: string;
    };
}
interface EpicTodoSchema extends TodoSchema {
    group: Pick<GroupSchema, 'id' | 'name' | 'path' | 'kind' | 'full_path' | 'parent_id'>;
    target_type: 'Epic';
    target: EpicSchema;
}
declare class Epics<C extends boolean = false> extends BaseResource<C> {
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(groupId: string | number, options?: PaginationRequestOptions<P> & BaseRequestOptions<E>): Promise<GitlabAPIResponse<EpicSchema[], C, E, P>>;
    create<E extends boolean = false>(groupId: string | number, title: string, options?: BaseRequestOptions<E>): Promise<GitlabAPIResponse<EpicSchema, C, E, void>>;
    createTodo<E extends boolean = false>(groupId: string | number, epicIId: number, options?: BaseRequestOptions<E>): Promise<GitlabAPIResponse<EpicTodoSchema, C, E, void>>;
    edit<E extends boolean = false>(groupId: string | number, epicIId: number, options?: BaseRequestOptions<E>): Promise<GitlabAPIResponse<Omit<EpicSchema, '_links'>, C, E, void>>;
    remove<E extends boolean = false>(groupId: string | number, epicIId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
    show<E extends boolean = false>(groupId: string | number, epicIId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<EpicSchema, C, E, void>>;
}

interface GroupAccessRequests<C extends boolean = false> extends ResourceAccessRequests<C> {
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(groupId: string | number, options?: PaginationRequestOptions<P> & BaseRequestOptions<E>): Promise<GitlabAPIResponse<AccessRequestSchema[], C, E, P>>;
    request<E extends boolean = false>(groupId: string | number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<AccessRequestSchema, C, E, void>>;
    approve<E extends boolean = false>(groupId: string | number, userId: number, options?: {
        accessLevel?: AccessLevel;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<AccessRequestSchema, C, E, void>>;
    deny<E extends boolean = false>(groupId: string | number, userId: number): Promise<GitlabAPIResponse<void, C, E, void>>;
}
declare class GroupAccessRequests<C extends boolean = false> extends ResourceAccessRequests<C> {
    constructor(options: BaseResourceOptions<C>);
}

interface GroupAccessTokens<C extends boolean = false> extends ResourceAccessTokens<C> {
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(groupId: string | number, options?: BaseRequestOptions<E> & PaginationRequestOptions<P>): Promise<GitlabAPIResponse<AccessTokenSchema[], C, E, P>>;
    create<E extends boolean = false>(groupId: string | number, name: string, scopes: AccessTokenScopes[], options?: {
        accessLevel?: AccessLevel;
        expiresAt?: string;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<AccessTokenSchema, C, E, void>>;
    revoke<E extends boolean = false>(groupId: string | number, tokenId: string | number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
    show<E extends boolean = false>(groupId: string | number, tokenId: string | number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<AccessTokenSchema, C, E, void>>;
}
declare class GroupAccessTokens<C extends boolean = false> extends ResourceAccessTokens<C> {
    constructor(options: BaseResourceOptions<C>);
}

interface GroupAnalyticsIssuesCountSchema extends Record<string, unknown> {
    issues_count: number;
}
interface GroupAnalyticsMRsCountSchema extends Record<string, unknown> {
    merge_requests_count: number;
}
interface GroupAnalyticsNewMembersCountSchema extends Record<string, unknown> {
    new_members_count: number;
}
declare class GroupActivityAnalytics<C extends boolean = false> extends BaseResource<C> {
    showIssuesCount<E extends boolean = false>(groupPath: string, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<GroupAnalyticsIssuesCountSchema, C, E, void>>;
    showMergeRequestsCount<E extends boolean = false>(groupPath: string, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<GroupAnalyticsMRsCountSchema, C, E, void>>;
    showNewMembersCount<E extends boolean = false>(groupPath: string, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<GroupAnalyticsNewMembersCountSchema, C, E, void>>;
}

interface GroupBadgeSchema extends BadgeSchema {
    kind: 'group';
}
type GroupBadgePreviewSchema = Omit<GroupBadgeSchema, 'id' | 'name' | 'kind'>;
interface GroupBadges<C extends boolean = false> extends ResourceBadges<C> {
    add<E extends boolean = false>(groupId: string | number, linkUrl: string, imageUrl: string, options?: BaseRequestOptions<E>): Promise<GitlabAPIResponse<GroupBadgeSchema, C, E, void>>;
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(groupId: string | number, options?: PaginationRequestOptions<P> & BaseRequestOptions<E>): Promise<GitlabAPIResponse<GroupBadgeSchema[], C, E, P>>;
    edit<E extends boolean = false>(groupId: string | number, badgeId: number, options?: BaseRequestOptions<E>): Promise<GitlabAPIResponse<GroupBadgeSchema, C, E, void>>;
    preview<E extends boolean = false>(groupId: string | number, linkUrl: string, imageUrl: string, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<GroupBadgePreviewSchema, C, E, void>>;
    remove<E extends boolean = false>(groupId: string | number, badgeId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
    show<E extends boolean = false>(groupId: string | number, badgeId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<GroupBadgeSchema, C, E, void>>;
}
declare class GroupBadges<C extends boolean = false> extends ResourceBadges<C> {
    constructor(options: BaseResourceOptions<C>);
}

interface GroupCustomAttributes<C extends boolean = false> extends ResourceCustomAttributes<C> {
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(groupId: string | number, options?: PaginationRequestOptions<P> & BaseRequestOptions<E>): Promise<GitlabAPIResponse<CustomAttributeSchema[], C, E, P>>;
    set<E extends boolean = false>(groupId: string | number, customAttributeId: string, value: string, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<CustomAttributeSchema, C, E, void>>;
    remove<E extends boolean = false>(groupId: string | number, customAttributeId: string, options?: Sudo): Promise<GitlabAPIResponse<void, C, E, void>>;
    show<E extends boolean = false>(groupId: string | number, customAttributeId: string, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<CustomAttributeSchema, C, E, void>>;
}
declare class GroupCustomAttributes<C extends boolean = false> extends ResourceCustomAttributes<C> {
    constructor(options: BaseResourceOptions<C>);
}

declare class GroupDORA4Metrics<C extends boolean = false> extends ResourceDORA4Metrics<C> {
    constructor(options: BaseResourceOptions<C>);
}

interface GroupHookSchema extends ExpandedHookSchema {
    groupId: number;
}
interface GroupHooks<C extends boolean = false> {
    add<E extends boolean = false>(groupId: string | number, url: string, options?: BaseRequestOptions<E>): Promise<GitlabAPIResponse<GroupHookSchema, C, E, void>>;
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(groupId: string | number, options?: PaginationRequestOptions<P> & BaseRequestOptions<E>): Promise<GitlabAPIResponse<GroupHookSchema[], C, E, P>>;
    edit<E extends boolean = false>(groupId: string | number, hookId: number, url: string, options?: BaseRequestOptions<E>): Promise<GitlabAPIResponse<GroupHookSchema, C, E, void>>;
    remove<E extends boolean = false>(groupId: string | number, hookId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
    show<E extends boolean = false>(groupId: string | number, hookId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<GroupHookSchema, C, E, void>>;
}
declare class GroupHooks<C extends boolean = false> extends ResourceHooks<C> {
    constructor(options: BaseResourceOptions<C>);
}

declare class GroupImportExports<C extends boolean = false> extends BaseResource<C> {
    download<E extends boolean = false>(groupId: string | number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<Blob, void, E, void>>;
    import<E extends boolean = false>(content: Blob, name: string, path: string, { filename, parentId, ...options }?: {
        parentId?: number;
        filename?: string;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
    scheduleExport<E extends boolean = false>(groupId: string | number, options?: BaseRequestOptions<E>): Promise<GitlabAPIResponse<{
        message: string;
    }, C, E, void>>;
}

interface GroupInvitations<C extends boolean = false> {
    add<E extends boolean = false>(groupId: string | number, accessLevel: AccessLevel, options: Either<{
        email: string;
    }, {
        userId: string;
    }> & BaseRequestOptions<E>): Promise<GitlabAPIResponse<InvitationSchema, C, E, void>>;
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(groupId: string | number, options?: PaginationRequestOptions<P> & BaseRequestOptions<E>): Promise<GitlabAPIResponse<InvitationSchema[], C, E, P>>;
    edit<E extends boolean = false>(groupId: string | number, email: string, options?: BaseRequestOptions<E>): Promise<GitlabAPIResponse<InvitationSchema, C, E, void>>;
    remove<E extends boolean = false>(groupId: string | number, email: string, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<InvitationSchema, C, E, void>>;
}
declare class GroupInvitations<C extends boolean = false> extends ResourceInvitations<C> {
    constructor(options: BaseResourceOptions<C>);
}

interface GrouptIssueBoardSchema extends IssueBoardSchema {
    group: CondensedGroupSchema;
}
interface GroupIssueBoards<C extends boolean = false> extends ResourceIssueBoards<C> {
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(groupId: string | number, options?: PaginationRequestOptions<P> & BaseRequestOptions<E>): Promise<GitlabAPIResponse<GrouptIssueBoardSchema[], C, E, P>>;
    create<E extends boolean = false>(groupId: string | number, name: string, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<GrouptIssueBoardSchema, C, E, void>>;
    createList<E extends boolean = false>(groupId: string | number, boardId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<IssueBoardListSchema, C, E, void>>;
    edit<E extends boolean = false>(groupId: string | number, boardId: number, options?: BaseRequestOptions<E>): Promise<GitlabAPIResponse<GrouptIssueBoardSchema, C, E, void>>;
    editList<E extends boolean = false>(groupId: string | number, boardId: number, listId: number, position: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<IssueBoardListSchema, C, E, void>>;
    allLists<E extends boolean = false>(groupId: string | number, boardId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<IssueBoardListSchema[], C, E, void>>;
    remove<E extends boolean = false>(groupId: string | number, boardId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
    removeList<E extends boolean = false>(groupId: string | number, boardId: number, listId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
    show<E extends boolean = false>(groupId: string | number, boardId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<GrouptIssueBoardSchema, C, E, void>>;
    showList<E extends boolean = false>(groupId: string | number, boardId: number, listId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<IssueBoardListSchema, C, E, void>>;
}
declare class GroupIssueBoards<C extends boolean = false> extends ResourceIssueBoards<C> {
    constructor(options: BaseResourceOptions<C>);
}

interface GroupIterations<C extends boolean = false> {
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(groupId: string | number, options?: {
        state?: 'opened' | 'upcoming' | 'current' | 'closed' | 'all';
        search?: string;
        includeAncestors?: boolean;
    } & BaseRequestOptions<E> & PaginationRequestOptions<P>): Promise<GitlabAPIResponse<IterationSchema[], C, E, P>>;
}
declare class GroupIterations<C extends boolean = false> extends ResourceIterations<C> {
    constructor(options: BaseResourceOptions<C>);
}

interface GroupLabels<C extends boolean = false> extends ResourceLabels<C> {
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(groupId: string | number, options?: PaginationRequestOptions<P> & BaseRequestOptions<E>): Promise<GitlabAPIResponse<LabelSchema[], C, E, P>>;
    create<E extends boolean = false>(groupId: string | number, labelName: string, color: string, options?: {
        description?: string;
        priority?: number;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<LabelSchema, C, E, void>>;
    edit<E extends boolean = false>(groupId: string | number, labelId: number | string, options: Either<{
        newName: string;
    }, {
        color: string;
    }> & {
        description?: string;
        priority?: number;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<LabelSchema, C, E, void>>;
    promote<E extends boolean = false>(groupId: string | number, labelId: number | string, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<LabelSchema, C, E, void>>;
    remove<E extends boolean = false>(groupId: string | number, labelId: number | string, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
    show<E extends boolean = false>(projectId: string | number, labelId: number | string, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<LabelSchema, C, E, void>>;
    subscribe<E extends boolean = false>(groupId: string | number, labelId: number | string, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<LabelSchema, C, E, void>>;
    unsubscribe<E extends boolean = false>(groupId: string | number, labelId: number | string, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<LabelSchema, C, E, void>>;
}
declare class GroupLabels<C extends boolean = false> extends ResourceLabels<C> {
    constructor(options: BaseResourceOptions<C>);
}

declare class GroupLDAPLinks<C extends boolean = false> extends BaseResource<C> {
    add<E extends boolean = false>(groupId: string | number, groupAccess: number, provider: string, options?: BaseRequestOptions<E>): Promise<GitlabAPIResponse<string, C, E, void>>;
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(groupId: string | number, options: PaginationRequestOptions<P> & BaseRequestOptions<E>): Promise<GitlabAPIResponse<string[], C, E, P>>;
    remove<E extends boolean = false>(groupId: string | number, provider: string, options?: BaseRequestOptions<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
    sync(groupId: string | number, options?: Sudo & ShowExpanded): Promise<string | number | void | ReadableStream<any> | Blob | string[] | CamelizedResponse<Record<string, unknown>, C> | CamelizedResponse<Record<string, unknown>, C>[]>;
}

interface BillableGroupMemberSchema extends CondensedMemberSchema {
    last_activity_on: string;
    membership_type: string;
    removable: boolean;
    created_at: string;
}
interface BillableGroupMemberMembershipSchema extends Record<string, unknown> {
    id: number;
    source_id: number;
    source_full_name: string;
    source_members_url: string;
    created_at: string;
    expires_at: string;
    access_level: {
        string_value: string;
        integer_value: AccessLevel;
    };
}
interface OverrodeGroupMemberSchema extends SimpleMemberSchema {
    override: boolean;
}
interface GroupMembers<C extends boolean = false> extends ResourceMembers<C> {
    add<E extends boolean = false>(projectId: string | number, userId: number, accessLevel: AccessLevel, options?: BaseRequestOptions<E>): Promise<GitlabAPIResponse<MemberSchema, C, E, void>>;
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(projectId: string | number, options?: IncludeInherited & PaginationRequestOptions<P> & BaseRequestOptions<E>): Promise<GitlabAPIResponse<MemberSchema[], C, E, P>>;
    edit<E extends boolean = false>(projectId: string | number, userId: number, accessLevel: AccessLevel, options?: BaseRequestOptions<E>): Promise<GitlabAPIResponse<MemberSchema, C, E, void>>;
    show<E extends boolean = false>(projectId: string | number, userId: number, options?: IncludeInherited & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<MemberSchema, C, E, void>>;
    remove<E extends boolean = false>(projectId: string | number, userId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
}
declare class GroupMembers<C extends boolean = false> extends ResourceMembers<C> {
    constructor(options: BaseResourceOptions<C>);
    allBillable<E extends boolean = false, P extends PaginationTypes = 'offset'>(groupId: string | number, options: PaginationRequestOptions<P> & BaseRequestOptions<E>): Promise<GitlabAPIResponse<BillableGroupMemberSchema[], C, E, P>>;
    approve<E extends boolean = false>(groupId: string | number, userId: number, options: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<MemberSchema, C, E, void>>;
    approveAll<E extends boolean = false>(groupId: string | number, options: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<MemberSchema[], C, E, void>>;
    removeBillable<E extends boolean = false>(groupId: string | number, userId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
    removeOverrideFlag<E extends boolean = false>(groupId: string | number, userId: number, options: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<OverrodeGroupMemberSchema, C, E, void>>;
    setOverrideFlag<E extends boolean = false>(groupId: string | number, userId: number, options: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<OverrodeGroupMemberSchema, C, E, void>>;
    allBillableMemberships<E extends boolean = false>(groupId: string | number, userId: number, options: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<BillableGroupMemberMembershipSchema[], C, E, void>>;
}

interface GroupMilestones<C extends boolean = false> extends ResourceMilestones<C> {
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(groupId: string | number, options?: PaginationRequestOptions<P> & BaseRequestOptions<E>): Promise<GitlabAPIResponse<MilestoneSchema[], C, E, P>>;
    allAssignedIssues<E extends boolean = false>(groupId: string | number, milestoneId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<IssueSchema[], C, E, void>>;
    allAssignedMergeRequests<E extends boolean = false>(groupId: string | number, milestoneId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<MergeRequestSchema[], C, E, void>>;
    create<E extends boolean = false>(groupId: string | number, title: string, options?: {
        description?: string;
        dueDate?: string;
        startDate?: string;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<MilestoneSchema, C, E, void>>;
    edit<E extends boolean = false>(groupId: string | number, milestoneId: number, options?: {
        title?: string;
        description?: string;
        dueDate?: string;
        startDate?: string;
        startEvent?: 'close' | 'activate';
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<MilestoneSchema, C, E, void>>;
    remove<E extends boolean = false>(groupId: string | number, milestoneId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
    show<E extends boolean = false>(groupId: string | number, milestoneId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<MilestoneSchema, C, E, void>>;
    showBurndownChartEvents<E extends boolean = false>(groupId: string | number, milestoneId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
}
declare class GroupMilestones<C extends boolean = false> extends ResourceMilestones<C> {
    constructor(options: BaseResourceOptions<C>);
}

interface GroupProtectedEnvironments<C extends boolean = false> {
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(groupId: string | number, options: {
        search?: string;
    } & Sudo & ShowExpanded<E> & PaginationRequestOptions<P>): Promise<GitlabAPIResponse<ProtectedEnvironmentSchema[], C, E, P>>;
    edit<E extends boolean = false>(groupId: string | number, name: string, options?: {
        deploy_access_levels?: ProtectedEnvironmentAccessLevel[];
        required_approval_count?: number;
        approval_rules?: ProtectedEnvironmentAccessLevel[];
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<ProtectedEnvironmentSchema, C, E, void>>;
    protect<E extends boolean = false>(groupId: string | number, name: string, deployAccessLevel: ProtectedEnvironmentAccessLevel[], options?: {
        requiredApprovalCount?: number;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<ProtectedEnvironmentSchema, C, E, void>>;
    show<E extends boolean = false>(groupId: string | number, name: string, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<ProtectedEnvironmentSchema, C, E, void>>;
    unprotect<E extends boolean = false>(groupId: string | number, name: string, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
}
declare class GroupProtectedEnvironments<C extends boolean = false> extends ResourceProtectedEnvironments<C> {
    constructor(options: BaseResourceOptions<C>);
}

interface GroupPushRules<C extends boolean = false> extends ResourcePushRules<C> {
    create<E extends boolean = false>(groupId: string | number, options?: BaseRequestOptions<E>): Promise<GitlabAPIResponse<PushRuleSchema, C, E, void>>;
    edit<E extends boolean = false>(groupId: string | number, options?: BaseRequestOptions<E>): Promise<GitlabAPIResponse<PushRuleSchema, C, E, void>>;
    remove<E extends boolean = false>(groupId: string | number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
    show<E extends boolean = false>(groupId: string | number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<PushRuleSchema, C, E, void>>;
}
declare class GroupPushRules<C extends boolean = false> extends ResourcePushRules<C> {
    constructor(options: BaseResourceOptions<C>);
}

interface GroupRelationExportStatusSchema extends Record<string, unknown> {
    relation: string;
    status: number;
    error?: string;
    updated_at: string;
}
declare class GroupRelationExports<C extends boolean = false> extends BaseResource<C> {
    download<E extends boolean = false>(groupId: string | number, relation: string, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<Blob, void, E, void>>;
    exportStatus<E extends boolean = false>(groupId: string | number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<GroupRelationExportStatusSchema[], C, E, void>>;
    scheduleExport<E extends boolean = false>(groupId: string | number, options?: BaseRequestOptions<E>): Promise<GitlabAPIResponse<{
        message: string;
    }, C, E, void>>;
}

declare class GroupReleases<C extends boolean = false> extends BaseResource<C> {
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(groupId: string | number, options?: PaginationRequestOptions<P> & BaseRequestOptions<E>): Promise<GitlabAPIResponse<ReleaseSchema[], C, E, P>>;
}

interface GroupRepositoryStorageMoveSchema extends RepositoryStorageMoveSchema {
    group: Pick<GroupSchema, 'id' | 'web_url' | 'name'>;
}
interface GroupRepositoryStorageMoves<C extends boolean = false> extends ResourceRepositoryStorageMoves<C> {
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(options?: {
        groupId?: string | number;
    } & PaginationRequestOptions<P> & BaseRequestOptions<E>): Promise<GitlabAPIResponse<GroupRepositoryStorageMoveSchema[], C, E, P>>;
    show<E extends boolean = false, P extends PaginationTypes = 'offset'>(repositoryStorageId: number, options?: {
        groupId?: string | number;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<GroupRepositoryStorageMoveSchema, C, E, P>>;
    schedule<E extends boolean = false, P extends PaginationTypes = 'offset'>(sourceStorageName: string, options?: {
        groupId?: string | number;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<GroupRepositoryStorageMoveSchema, C, E, P>>;
}
declare class GroupRepositoryStorageMoves<C extends boolean = false> extends ResourceRepositoryStorageMoves<C> {
    constructor(options: BaseResourceOptions<C>);
}

interface IdentitySchema extends Record<string, unknown> {
    extern_uid: string;
    user_id: number;
}
declare class GroupSAMLIdentities<C extends boolean = false> extends BaseResource<C> {
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(groupId: string | number, options: PaginationRequestOptions<P> & BaseRequestOptions<E>): Promise<GitlabAPIResponse<IdentitySchema[], C, E, P>>;
    edit<E extends boolean = false>(groupId: string | number, identityId: string, options: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
}

declare class GroupSCIMIdentities<C extends boolean = false> extends BaseResource<C> {
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(groupId: string | number, options: PaginationRequestOptions<P> & BaseRequestOptions<E>): Promise<GitlabAPIResponse<IdentitySchema[], C, E, P>>;
    edit<E extends boolean = false>(groupId: string | number, identityId: string, options: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
}

interface GroupVariables<C extends boolean = false> extends ResourceVariables<C> {
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(projectId: string | number, options?: Sudo & ShowExpanded<E> & PaginationRequestOptions<P>): Promise<GitlabAPIResponse<VariableSchema[], C, E, P>>;
    create<E extends boolean = false>(projectId: string | number, key: string, value: string, options?: {
        variableType?: VariableType;
        protected?: boolean;
        masked?: boolean;
        environmentScope?: string;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<VariableSchema, C, E, void>>;
    edit<E extends boolean = false>(projectId: string | number, key: string, value: string, options?: {
        variableType?: VariableType;
        protected?: boolean;
        masked?: boolean;
        environmentScope?: string;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<VariableSchema, C, E, void>>;
    show<E extends boolean = false>(projectId: string | number, key: string, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<VariableSchema, C, E, void>>;
    remove<E extends boolean = false>(projectId: string | number, key: string, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
}
declare class GroupVariables<C extends boolean = false> extends ResourceVariables<C> {
    constructor(options: BaseResourceOptions<C>);
}

interface GroupWikis<C extends boolean = false> extends ResourceWikis<C> {
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(groupId: string | number, options?: {
        withContent?: boolean;
    } & Sudo & ShowExpanded<E> & PaginationRequestOptions<P>): Promise<GitlabAPIResponse<WikiSchema[], C, E, P>>;
    create<E extends boolean = false>(groupId: string | number, content: string, title: string, options?: {
        format?: string;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<WikiSchema, C, E, void>>;
    edit<E extends boolean = false>(groupId: string | number, slug: string, options?: Either<{
        content: string;
    }, {
        title: string;
    }> & {
        format?: string;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<WikiSchema, C, E, void>>;
    remove<E extends boolean = false>(groupId: string | number, slug: string, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
    show<E extends boolean = false>(groupId: string | number, slug: string, options?: {
        renderHtml?: boolean;
        version?: string;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<WikiSchema, C, E, void>>;
    uploadAttachment<E extends boolean = false>(groupId: string | number, content: Blob, options?: {
        filename?: string;
        branch?: string;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<WikiAttachmentSchema, C, E, void>>;
}
declare class GroupWikis<C extends boolean = false> extends ResourceWikis<C> {
    constructor(options: BaseResourceOptions<C>);
}

interface RelatedEpicSchema extends EpicSchema {
    related_epic_link_id: number;
}
interface RelatedEpicLinkSchema extends Record<string, unknown> {
    source_epic: RelatedEpicSchema;
    target_epic: RelatedEpicSchema;
}
type RelatedEpicLinkType = 'relates_to' | 'blocks' | 'is_blocked_by';
declare class LinkedEpics<C extends boolean = false> extends BaseResource<C> {
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(groupId: string | number, epicIId: number, options?: Sudo & ShowExpanded<E> & PaginationRequestOptions<P>): Promise<GitlabAPIResponse<RelatedEpicSchema[], C, E, P>>;
    create<E extends boolean = false>(groupId: string | number, epicIId: number, targetEpicIId: string | number, targetGroupId: string | number, options?: {
        link_type?: RelatedEpicLinkType;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<RelatedEpicLinkSchema, C, E, void>>;
    remove<E extends boolean = false>(groupId: string | number, epicIId: number, relatedEpicLinkId: string | number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<RelatedEpicLinkSchema, C, E, void>>;
}

interface UserCustomAttributes<C extends boolean = false> extends ResourceCustomAttributes<C> {
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(userId: string | number, options?: PaginationRequestOptions<P> & BaseRequestOptions<E>): Promise<GitlabAPIResponse<CustomAttributeSchema[], C, E, P>>;
    set<E extends boolean = false>(userId: string | number, customAttributeId: string, value: string, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<CustomAttributeSchema, C, E, void>>;
    remove<E extends boolean = false>(userId: string | number, customAttributeId: string, options?: Sudo): Promise<GitlabAPIResponse<void, C, E, void>>;
    show<E extends boolean = false>(userId: string | number, customAttributeId: string, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<CustomAttributeSchema, C, E, void>>;
}
declare class UserCustomAttributes<C extends boolean = false> extends ResourceCustomAttributes<C> {
    constructor(options: BaseResourceOptions<C>);
}

interface UserEmailSchema extends Record<string, unknown> {
    id: number;
    email: string;
    confirmed_at: string;
}
declare class UserEmails<C extends boolean = false> extends BaseResource<C> {
    add<E extends boolean = false>(email: string, options?: {
        userId?: number;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<UserEmailSchema, C, E, void>>;
    all<E extends boolean = false>({ userId, ...options }?: {
        userId?: number;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<UserEmailSchema[], C, E, void>>;
    create<E extends boolean = false>(email: string, { userId, ...options }?: {
        userId?: number;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<UserEmailSchema, C, E, void>>;
    show<E extends boolean = false>(emailId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<UserEmailSchema, C, E, void>>;
    remove<E extends boolean = false>(emailId: number, { userId, ...options }?: {
        userId?: number;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
}

interface UserGPGKeySchema extends Record<string, unknown> {
    id: number;
    key: string;
    created_at: string;
}
declare class UserGPGKeys<C extends boolean = false> extends BaseResource<C> {
    add<E extends boolean = false>(key: string, options?: {
        userId?: number;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<UserGPGKeySchema, C, E, void>>;
    all<E extends boolean = false>({ userId, ...options }?: {
        userId?: number;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<UserGPGKeySchema[], C, E, void>>;
    create<E extends boolean = false>(key: string, { userId, ...options }?: {
        userId?: number;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<UserGPGKeySchema, C, E, void>>;
    show<E extends boolean = false>(keyId: number, { userId, ...options }?: {
        userId?: number;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<UserGPGKeySchema, C, E, void>>;
    remove<E extends boolean = false>(keyId: number, { userId, ...options }?: {
        userId?: number;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
}

type ImpersonationTokenScope = 'api' | 'read_user';
type ImpersonationTokenState = 'all' | 'active' | 'inactive';
interface UserImpersonationTokenSchema extends Record<string, unknown> {
    active: boolean;
    user_id: number;
    scopes?: string[];
    revoked: boolean;
    name: string;
    id: number;
    created_at: string;
    impersonation: boolean;
    expires_at: string;
}
declare class UserImpersonationTokens<C extends boolean = false> extends BaseResource<C> {
    all<E extends boolean = false, P extends PaginationTypes = 'offset'>(userId: number, options?: {
        state?: ImpersonationTokenState;
    } & PaginationRequestOptions<P> & BaseRequestOptions<E>): Promise<GitlabAPIResponse<UserImpersonationTokenSchema[], C, E, P>>;
    create<E extends boolean = false>(userId: number, name: string, scopes: ImpersonationTokenScope[], options?: {
        expiresAt?: string;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<UserImpersonationTokenSchema, C, E, void>>;
    show<E extends boolean = false>(userId: number, tokenId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<UserImpersonationTokenSchema, C, E, void>>;
    remove<E extends boolean = false>(userId: number, tokenId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIExpandedResponse<void, E, undefined>>;
    revoke<E extends boolean = false>(userId: number, tokenId: number, options?: Sudo & ShowExpanded<E>): Promise<GitlabAPIExpandedResponse<void, E, undefined>>;
}

interface UserSSHKeySchema extends Record<string, unknown> {
    id: number;
    key: string;
    title: string;
    created_at: string;
}
declare class UserSSHKeys<C extends boolean = false> extends BaseResource<C> {
    add<E extends boolean = false>(title: string, key: string, options?: {
        userId?: number;
        expiresAt?: string;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<UserSSHKeySchema, C, E, void>>;
    all<E extends boolean = false>({ userId, ...options }?: {
        userId?: number;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<UserSSHKeySchema[], C, E, void>>;
    create<E extends boolean = false>(title: string, key: string, { userId, ...options }?: {
        userId?: number;
        expiresAt?: string;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<UserSSHKeySchema, C, E, void>>;
    show<E extends boolean = false>(keyId: number, { userId, ...options }?: {
        userId?: number;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<UserSSHKeySchema, C, E, void>>;
    remove<E extends boolean = false>(keyId: number, { userId, ...options }?: {
        userId?: number;
    } & Sudo & ShowExpanded<E>): Promise<GitlabAPIResponse<void, C, E, void>>;
}

interface Gitlab<C extends boolean = false> extends BaseResource<C> {
    Agents: Agents<C>;
    AlertManagement: AlertManagement<C>;
    ApplicationAppearance: ApplicationAppearance<C>;
    ApplicationPlanLimits: ApplicationPlanLimits<C>;
    Applications: Applications<C>;
    ApplicationSettings: ApplicationSettings<C>;
    ApplicationStatistics: ApplicationStatistics<C>;
    AuditEvents: AuditEvents<C>;
    Avatar: Avatar<C>;
    BroadcastMessages: BroadcastMessages<C>;
    Composer: Composer<C>;
    Conan: Conan<C>;
    DashboardAnnotations: DashboardAnnotations<C>;
    Debian: Debian<C>;
    DependencyProxy: DependencyProxy<C>;
    DeployKeys: DeployKeys<C>;
    DeployTokens: DeployTokens<C>;
    DockerfileTemplates: DockerfileTemplates<C>;
    Events: Events<C>;
    Experiments: Experiments<C>;
    GeoNodes: GeoNodes<C>;
    GitignoreTemplates: GitignoreTemplates<C>;
    GitLabCIYMLTemplates: GitLabCIYMLTemplates<C>;
    Import: Import<C>;
    InstanceLevelCICDVariables: InstanceLevelCICDVariables<C>;
    Keys: Keys<C>;
    License: License<C>;
    LicenseTemplates: LicenseTemplates<C>;
    Lint: Lint<C>;
    ManagedLicenses: ManagedLicenses<C>;
    Markdown: Markdown<C>;
    Maven: Maven<C>;
    Metadata: Metadata<C>;
    Migrations: Migrations<C>;
    Namespaces: Namespaces<C>;
    NotificationSettings: NotificationSettings<C>;
    NPM: NPM<C>;
    NuGet: NuGet<C>;
    PersonalAccessTokens: PersonalAccessTokens<C>;
    PyPI: PyPI<C>;
    Search: Search<C>;
    ServiceData: ServiceData<C>;
    SidekiqMetrics: SidekiqMetrics<C>;
    SidekiqQueues: SidekiqQueues<C>;
    SnippetRepositoryStorageMoves: SnippetRepositoryStorageMoves<C>;
    Snippets: Snippets<C>;
    Suggestions: Suggestions<C>;
    SystemHooks: SystemHooks<C>;
    TodoLists: TodoLists<C>;
    Topics: Topics<C>;
    Version: Version<C>;
    Vulnerabilities: Vulnerabilities<C>;
    Branches: Branches<C>;
    CommitDiscussions: CommitDiscussions<C>;
    Commits: Commits<C>;
    ContainerRegistry: ContainerRegistry<C>;
    Deployments: Deployments<C>;
    Environments: Environments<C>;
    ErrorTrackingClientKeys: ErrorTrackingClientKeys<C>;
    ErrorTrackingSettings: ErrorTrackingSettings<C>;
    ExternalStatusChecks: ExternalStatusChecks<C>;
    FeatureFlags: FeatureFlags<C>;
    FeatureFlagUserLists: FeatureFlagUserLists<C>;
    FreezePeriods: FreezePeriods<C>;
    GitlabPages: GitlabPages<C>;
    GoProxy: GoProxy<C>;
    Helm: Helm<C>;
    Integrations: Integrations<C>;
    IssueAwardEmojis: IssueAwardEmojis<C>;
    IssueDiscussions: IssueDiscussions<C>;
    IssueIterationEvents: IssueIterationEvents<C>;
    IssueLabelEvents: IssueLabelEvents<C>;
    IssueLinks: IssueLinks<C>;
    IssueMilestoneEvents: IssueMilestoneEvents<C>;
    IssueNoteAwardEmojis: IssueNoteAwardEmojis<C>;
    IssueNotes: IssueNotes<C>;
    Issues: Issues<C>;
    IssuesStatistics: IssuesStatistics<C>;
    IssueStateEvents: IssueStateEvents<C>;
    IssueWeightEvents: IssueWeightEvents<C>;
    JobArtifacts: JobArtifacts<C>;
    Jobs: Jobs<C>;
    MergeRequestApprovals: MergeRequestApprovals<C>;
    MergeRequestAwardEmojis: MergeRequestAwardEmojis<C>;
    MergeRequestContextCommits: MergeRequestContextCommits<C>;
    MergeRequestDiscussions: MergeRequestDiscussions<C>;
    MergeRequestLabelEvents: MergeRequestLabelEvents<C>;
    MergeRequestMilestoneEvents: MergeRequestMilestoneEvents<C>;
    MergeRequestNotes: MergeRequestNotes<C>;
    MergeRequests: MergeRequests<C>;
    MergeTrains: MergeTrains<C>;
    PackageRegistry: PackageRegistry<C>;
    Packages: Packages<C>;
    PagesDomains: PagesDomains<C>;
    Pipelines: Pipelines<C>;
    PipelineSchedules: PipelineSchedules<C>;
    PipelineScheduleVariables: PipelineScheduleVariables<C>;
    PipelineTriggerTokens: PipelineTriggerTokens<C>;
    ProductAnalytics: ProductAnalytics<C>;
    ProjectAccessRequests: ProjectAccessRequests<C>;
    ProjectAccessTokens: ProjectAccessTokens<C>;
    ProjectAliases: ProjectAliases<C>;
    ProjectBadges: ProjectBadges<C>;
    ProjectCustomAttributes: ProjectCustomAttributes<C>;
    ProjectDORA4Metrics: ProjectDORA4Metrics<C>;
    ProjectHooks: ProjectHooks<C>;
    ProjectImportExport: ProjectImportExport<C>;
    ProjectInvitations: ProjectInvitations<C>;
    ProjectIssueBoards: ProjectIssueBoards<C>;
    ProjectIterations: ProjectIterations<C>;
    ProjectLabels: ProjectLabels<C>;
    ProjectMembers: ProjectMembers<C>;
    ProjectMilestones: ProjectMilestones<C>;
    ProjectProtectedEnvironments: ProjectProtectedEnvironments<C>;
    ProjectPushRules: ProjectPushRules<C>;
    ProjectRelationsExport: ProjectRelationsExport<C>;
    ProjectReleases: ProjectReleases<C>;
    ProjectRemoteMirrors: ProjectRemoteMirrors<C>;
    ProjectRepositoryStorageMoves: ProjectRepositoryStorageMoves<C>;
    Projects: Projects<C>;
    ProjectSnippetAwardEmojis: ProjectSnippetAwardEmojis<C>;
    ProjectSnippetDiscussions: ProjectSnippetDiscussions<C>;
    ProjectSnippetNotes: ProjectSnippetNotes<C>;
    ProjectSnippets: ProjectSnippets<C>;
    ProjectStatistics: ProjectStatistics<C>;
    ProjectTemplates: ProjectTemplates<C>;
    ProjectVariables: ProjectVariables<C>;
    ProjectVulnerabilities: ProjectVulnerabilities<C>;
    ProjectWikis: ProjectWikis<C>;
    ProtectedBranches: ProtectedBranches<C>;
    ProtectedTags: ProtectedTags<C>;
    ReleaseLinks: ReleaseLinks<C>;
    Repositories: Repositories<C>;
    RepositoryFiles: RepositoryFiles<C>;
    RepositorySubmodules: RepositorySubmodules<C>;
    ResourceGroups: ResourceGroups<C>;
    Runners: Runners<C>;
    SecureFiles: SecureFiles<C>;
    Tags: Tags<C>;
    UserStarredMetricsDashboard: UserStarredMetricsDashboard<C>;
    VisualReviewDiscussions: VisualReviewDiscussions<C>;
    VulnerabilityFindings: VulnerabilityFindings<C>;
    EpicAwardEmojis: EpicAwardEmojis<C>;
    EpicDiscussions: EpicDiscussions<C>;
    EpicIssues: EpicIssues<C>;
    EpicLabelEvents: EpicLabelEvents<C>;
    EpicLinks: EpicLinks<C>;
    EpicNotes: EpicNotes<C>;
    Epics: Epics<C>;
    GroupAccessRequests: GroupAccessRequests<C>;
    GroupAccessTokens: GroupAccessTokens<C>;
    GroupActivityAnalytics: GroupActivityAnalytics<C>;
    GroupBadges: GroupBadges<C>;
    GroupCustomAttributes: GroupCustomAttributes<C>;
    GroupDORA4Metrics: GroupDORA4Metrics<C>;
    GroupHooks: GroupHooks<C>;
    GroupImportExports: GroupImportExports<C>;
    GroupInvitations: GroupInvitations<C>;
    GroupIssueBoards: GroupIssueBoards<C>;
    GroupIterations: GroupIterations<C>;
    GroupLabels: GroupLabels<C>;
    GroupLDAPLinks: GroupLDAPLinks<C>;
    GroupMembers: GroupMembers<C>;
    GroupMilestones: GroupMilestones<C>;
    GroupProtectedEnvironments: GroupProtectedEnvironments<C>;
    GroupPushRules: GroupPushRules<C>;
    GroupRelationExports: GroupRelationExports<C>;
    GroupReleases: GroupReleases<C>;
    GroupRepositoryStorageMoves: GroupRepositoryStorageMoves<C>;
    Groups: Groups<C>;
    GroupSAMLIdentities: GroupSAMLIdentities<C>;
    GroupSCIMIdentities: GroupSCIMIdentities<C>;
    GroupVariables: GroupVariables<C>;
    GroupWikis: GroupWikis<C>;
    LinkedEpics: LinkedEpics<C>;
    UserCustomAttributes: UserCustomAttributes<C>;
    UserEmails: UserEmails<C>;
    UserGPGKeys: UserGPGKeys<C>;
    UserImpersonationTokens: UserImpersonationTokens<C>;
    Users: Users<C>;
    UserSSHKeys: UserSSHKeys<C>;
}
declare class Gitlab<C extends boolean = false> extends BaseResource<C> {
    constructor(options: BaseResourceOptions<C>);
}

type index_Agents<C extends boolean = false> = Agents<C>;
declare const index_Agents: typeof Agents;
type index_AlertManagement<C extends boolean = false> = AlertManagement<C>;
declare const index_AlertManagement: typeof AlertManagement;
type index_ApplicationAppearance<C extends boolean = false> = ApplicationAppearance<C>;
declare const index_ApplicationAppearance: typeof ApplicationAppearance;
type index_ApplicationPlanLimits<C extends boolean = false> = ApplicationPlanLimits<C>;
declare const index_ApplicationPlanLimits: typeof ApplicationPlanLimits;
type index_ApplicationSettings<C extends boolean = false> = ApplicationSettings<C>;
declare const index_ApplicationSettings: typeof ApplicationSettings;
type index_ApplicationStatistics<C extends boolean = false> = ApplicationStatistics<C>;
declare const index_ApplicationStatistics: typeof ApplicationStatistics;
type index_Applications<C extends boolean = false> = Applications<C>;
declare const index_Applications: typeof Applications;
type index_AuditEvents<C extends boolean = false> = AuditEvents<C>;
declare const index_AuditEvents: typeof AuditEvents;
type index_Avatar<C extends boolean = false> = Avatar<C>;
declare const index_Avatar: typeof Avatar;
type index_Branches<C extends boolean = false> = Branches<C>;
declare const index_Branches: typeof Branches;
type index_BroadcastMessages<C extends boolean = false> = BroadcastMessages<C>;
declare const index_BroadcastMessages: typeof BroadcastMessages;
type index_CommitDiscussions<C extends boolean = false> = CommitDiscussions<C>;
declare const index_CommitDiscussions: typeof CommitDiscussions;
type index_Commits<C extends boolean = false> = Commits<C>;
declare const index_Commits: typeof Commits;
type index_Composer<C extends boolean = false> = Composer<C>;
declare const index_Composer: typeof Composer;
type index_Conan<C extends boolean = false> = Conan<C>;
declare const index_Conan: typeof Conan;
type index_ContainerRegistry<C extends boolean = false> = ContainerRegistry<C>;
declare const index_ContainerRegistry: typeof ContainerRegistry;
type index_DashboardAnnotations<C extends boolean = false> = DashboardAnnotations<C>;
declare const index_DashboardAnnotations: typeof DashboardAnnotations;
type index_Debian<C extends boolean = false> = Debian<C>;
declare const index_Debian: typeof Debian;
type index_DependencyProxy<C extends boolean = false> = DependencyProxy<C>;
declare const index_DependencyProxy: typeof DependencyProxy;
type index_DeployKeys<C extends boolean = false> = DeployKeys<C>;
declare const index_DeployKeys: typeof DeployKeys;
type index_DeployTokens<C extends boolean = false> = DeployTokens<C>;
declare const index_DeployTokens: typeof DeployTokens;
type index_Deployments<C extends boolean = false> = Deployments<C>;
declare const index_Deployments: typeof Deployments;
type index_DockerfileTemplates<C extends boolean = false> = DockerfileTemplates<C>;
declare const index_DockerfileTemplates: typeof DockerfileTemplates;
type index_Environments<C extends boolean = false> = Environments<C>;
declare const index_Environments: typeof Environments;
type index_EpicAwardEmojis<C extends boolean = false> = EpicAwardEmojis<C>;
declare const index_EpicAwardEmojis: typeof EpicAwardEmojis;
type index_EpicDiscussions<C extends boolean = false> = EpicDiscussions<C>;
declare const index_EpicDiscussions: typeof EpicDiscussions;
type index_EpicIssues<C extends boolean = false> = EpicIssues<C>;
declare const index_EpicIssues: typeof EpicIssues;
type index_EpicLabelEvents<C extends boolean = false> = EpicLabelEvents<C>;
declare const index_EpicLabelEvents: typeof EpicLabelEvents;
type index_EpicLinks<C extends boolean = false> = EpicLinks<C>;
declare const index_EpicLinks: typeof EpicLinks;
type index_EpicNotes<C extends boolean = false> = EpicNotes<C>;
declare const index_EpicNotes: typeof EpicNotes;
type index_Epics<C extends boolean = false> = Epics<C>;
declare const index_Epics: typeof Epics;
type index_ErrorTrackingClientKeys<C extends boolean = false> = ErrorTrackingClientKeys<C>;
declare const index_ErrorTrackingClientKeys: typeof ErrorTrackingClientKeys;
type index_ErrorTrackingSettings<C extends boolean = false> = ErrorTrackingSettings<C>;
declare const index_ErrorTrackingSettings: typeof ErrorTrackingSettings;
type index_Events<C extends boolean = false> = Events<C>;
declare const index_Events: typeof Events;
type index_Experiments<C extends boolean = false> = Experiments<C>;
declare const index_Experiments: typeof Experiments;
type index_ExternalStatusChecks<C extends boolean = false> = ExternalStatusChecks<C>;
declare const index_ExternalStatusChecks: typeof ExternalStatusChecks;
type index_FeatureFlagUserLists<C extends boolean = false> = FeatureFlagUserLists<C>;
declare const index_FeatureFlagUserLists: typeof FeatureFlagUserLists;
type index_FeatureFlags<C extends boolean = false> = FeatureFlags<C>;
declare const index_FeatureFlags: typeof FeatureFlags;
type index_FreezePeriods<C extends boolean = false> = FreezePeriods<C>;
declare const index_FreezePeriods: typeof FreezePeriods;
type index_GeoNodes<C extends boolean = false> = GeoNodes<C>;
declare const index_GeoNodes: typeof GeoNodes;
type index_GitLabCIYMLTemplates<C extends boolean = false> = GitLabCIYMLTemplates<C>;
declare const index_GitLabCIYMLTemplates: typeof GitLabCIYMLTemplates;
type index_GitignoreTemplates<C extends boolean = false> = GitignoreTemplates<C>;
declare const index_GitignoreTemplates: typeof GitignoreTemplates;
type index_Gitlab<C extends boolean = false> = Gitlab<C>;
declare const index_Gitlab: typeof Gitlab;
type index_GitlabPages<C extends boolean = false> = GitlabPages<C>;
declare const index_GitlabPages: typeof GitlabPages;
type index_GoProxy<C extends boolean = false> = GoProxy<C>;
declare const index_GoProxy: typeof GoProxy;
type index_GroupAccessRequests<C extends boolean = false> = GroupAccessRequests<C>;
declare const index_GroupAccessRequests: typeof GroupAccessRequests;
type index_GroupAccessTokens<C extends boolean = false> = GroupAccessTokens<C>;
declare const index_GroupAccessTokens: typeof GroupAccessTokens;
type index_GroupActivityAnalytics<C extends boolean = false> = GroupActivityAnalytics<C>;
declare const index_GroupActivityAnalytics: typeof GroupActivityAnalytics;
type index_GroupBadges<C extends boolean = false> = GroupBadges<C>;
declare const index_GroupBadges: typeof GroupBadges;
type index_GroupCustomAttributes<C extends boolean = false> = GroupCustomAttributes<C>;
declare const index_GroupCustomAttributes: typeof GroupCustomAttributes;
type index_GroupDORA4Metrics<C extends boolean = false> = GroupDORA4Metrics<C>;
declare const index_GroupDORA4Metrics: typeof GroupDORA4Metrics;
type index_GroupHooks<C extends boolean = false> = GroupHooks<C>;
declare const index_GroupHooks: typeof GroupHooks;
type index_GroupImportExports<C extends boolean = false> = GroupImportExports<C>;
declare const index_GroupImportExports: typeof GroupImportExports;
type index_GroupInvitations<C extends boolean = false> = GroupInvitations<C>;
declare const index_GroupInvitations: typeof GroupInvitations;
type index_GroupIssueBoards<C extends boolean = false> = GroupIssueBoards<C>;
declare const index_GroupIssueBoards: typeof GroupIssueBoards;
type index_GroupIterations<C extends boolean = false> = GroupIterations<C>;
declare const index_GroupIterations: typeof GroupIterations;
type index_GroupLDAPLinks<C extends boolean = false> = GroupLDAPLinks<C>;
declare const index_GroupLDAPLinks: typeof GroupLDAPLinks;
type index_GroupLabels<C extends boolean = false> = GroupLabels<C>;
declare const index_GroupLabels: typeof GroupLabels;
type index_GroupMembers<C extends boolean = false> = GroupMembers<C>;
declare const index_GroupMembers: typeof GroupMembers;
type index_GroupMilestones<C extends boolean = false> = GroupMilestones<C>;
declare const index_GroupMilestones: typeof GroupMilestones;
type index_GroupProtectedEnvironments<C extends boolean = false> = GroupProtectedEnvironments<C>;
declare const index_GroupProtectedEnvironments: typeof GroupProtectedEnvironments;
type index_GroupPushRules<C extends boolean = false> = GroupPushRules<C>;
declare const index_GroupPushRules: typeof GroupPushRules;
type index_GroupRelationExports<C extends boolean = false> = GroupRelationExports<C>;
declare const index_GroupRelationExports: typeof GroupRelationExports;
type index_GroupReleases<C extends boolean = false> = GroupReleases<C>;
declare const index_GroupReleases: typeof GroupReleases;
type index_GroupRepositoryStorageMoves<C extends boolean = false> = GroupRepositoryStorageMoves<C>;
declare const index_GroupRepositoryStorageMoves: typeof GroupRepositoryStorageMoves;
type index_GroupSAMLIdentities<C extends boolean = false> = GroupSAMLIdentities<C>;
declare const index_GroupSAMLIdentities: typeof GroupSAMLIdentities;
type index_GroupSCIMIdentities<C extends boolean = false> = GroupSCIMIdentities<C>;
declare const index_GroupSCIMIdentities: typeof GroupSCIMIdentities;
type index_GroupVariables<C extends boolean = false> = GroupVariables<C>;
declare const index_GroupVariables: typeof GroupVariables;
type index_GroupWikis<C extends boolean = false> = GroupWikis<C>;
declare const index_GroupWikis: typeof GroupWikis;
type index_Groups<C extends boolean = false> = Groups<C>;
declare const index_Groups: typeof Groups;
type index_Helm<C extends boolean = false> = Helm<C>;
declare const index_Helm: typeof Helm;
type index_Import<C extends boolean = false> = Import<C>;
declare const index_Import: typeof Import;
type index_InstanceLevelCICDVariables<C extends boolean = false> = InstanceLevelCICDVariables<C>;
declare const index_InstanceLevelCICDVariables: typeof InstanceLevelCICDVariables;
type index_Integrations<C extends boolean = false> = Integrations<C>;
declare const index_Integrations: typeof Integrations;
type index_IssueAwardEmojis<C extends boolean = false> = IssueAwardEmojis<C>;
declare const index_IssueAwardEmojis: typeof IssueAwardEmojis;
type index_IssueDiscussions<C extends boolean = false> = IssueDiscussions<C>;
declare const index_IssueDiscussions: typeof IssueDiscussions;
type index_IssueIterationEvents<C extends boolean = false> = IssueIterationEvents<C>;
declare const index_IssueIterationEvents: typeof IssueIterationEvents;
type index_IssueLabelEvents<C extends boolean = false> = IssueLabelEvents<C>;
declare const index_IssueLabelEvents: typeof IssueLabelEvents;
type index_IssueLinks<C extends boolean = false> = IssueLinks<C>;
declare const index_IssueLinks: typeof IssueLinks;
type index_IssueMilestoneEvents<C extends boolean = false> = IssueMilestoneEvents<C>;
declare const index_IssueMilestoneEvents: typeof IssueMilestoneEvents;
type index_IssueNoteAwardEmojis<C extends boolean = false> = IssueNoteAwardEmojis<C>;
declare const index_IssueNoteAwardEmojis: typeof IssueNoteAwardEmojis;
type index_IssueNotes<C extends boolean = false> = IssueNotes<C>;
declare const index_IssueNotes: typeof IssueNotes;
type index_IssueStateEvents<C extends boolean = false> = IssueStateEvents<C>;
declare const index_IssueStateEvents: typeof IssueStateEvents;
type index_IssueWeightEvents<C extends boolean = false> = IssueWeightEvents<C>;
declare const index_IssueWeightEvents: typeof IssueWeightEvents;
type index_Issues<C extends boolean = false> = Issues<C>;
declare const index_Issues: typeof Issues;
type index_IssuesStatistics<C extends boolean = false> = IssuesStatistics<C>;
declare const index_IssuesStatistics: typeof IssuesStatistics;
type index_JobArtifacts<C extends boolean = false> = JobArtifacts<C>;
declare const index_JobArtifacts: typeof JobArtifacts;
type index_Jobs<C extends boolean = false> = Jobs<C>;
declare const index_Jobs: typeof Jobs;
type index_Keys<C extends boolean = false> = Keys<C>;
declare const index_Keys: typeof Keys;
type index_License<C extends boolean = false> = License<C>;
declare const index_License: typeof License;
type index_LicenseTemplates<C extends boolean = false> = LicenseTemplates<C>;
declare const index_LicenseTemplates: typeof LicenseTemplates;
type index_LinkedEpics<C extends boolean = false> = LinkedEpics<C>;
declare const index_LinkedEpics: typeof LinkedEpics;
type index_Lint<C extends boolean = false> = Lint<C>;
declare const index_Lint: typeof Lint;
type index_ManagedLicenses<C extends boolean = false> = ManagedLicenses<C>;
declare const index_ManagedLicenses: typeof ManagedLicenses;
type index_Markdown<C extends boolean = false> = Markdown<C>;
declare const index_Markdown: typeof Markdown;
type index_Maven<C extends boolean = false> = Maven<C>;
declare const index_Maven: typeof Maven;
type index_MergeRequestApprovals<C extends boolean = false> = MergeRequestApprovals<C>;
declare const index_MergeRequestApprovals: typeof MergeRequestApprovals;
type index_MergeRequestAwardEmojis<C extends boolean = false> = MergeRequestAwardEmojis<C>;
declare const index_MergeRequestAwardEmojis: typeof MergeRequestAwardEmojis;
type index_MergeRequestContextCommits<C extends boolean = false> = MergeRequestContextCommits<C>;
declare const index_MergeRequestContextCommits: typeof MergeRequestContextCommits;
type index_MergeRequestDiscussions<C extends boolean = false> = MergeRequestDiscussions<C>;
declare const index_MergeRequestDiscussions: typeof MergeRequestDiscussions;
type index_MergeRequestLabelEvents<C extends boolean = false> = MergeRequestLabelEvents<C>;
declare const index_MergeRequestLabelEvents: typeof MergeRequestLabelEvents;
type index_MergeRequestMilestoneEvents<C extends boolean = false> = MergeRequestMilestoneEvents<C>;
declare const index_MergeRequestMilestoneEvents: typeof MergeRequestMilestoneEvents;
type index_MergeRequestNotes<C extends boolean = false> = MergeRequestNotes<C>;
declare const index_MergeRequestNotes: typeof MergeRequestNotes;
type index_MergeRequests<C extends boolean = false> = MergeRequests<C>;
declare const index_MergeRequests: typeof MergeRequests;
type index_MergeTrains<C extends boolean = false> = MergeTrains<C>;
declare const index_MergeTrains: typeof MergeTrains;
type index_Metadata<C extends boolean = false> = Metadata<C>;
declare const index_Metadata: typeof Metadata;
type index_Migrations<C extends boolean = false> = Migrations<C>;
declare const index_Migrations: typeof Migrations;
type index_NPM<C extends boolean = false> = NPM<C>;
declare const index_NPM: typeof NPM;
type index_Namespaces<C extends boolean = false> = Namespaces<C>;
declare const index_Namespaces: typeof Namespaces;
type index_NotificationSettings<C extends boolean = false> = NotificationSettings<C>;
declare const index_NotificationSettings: typeof NotificationSettings;
type index_NuGet<C extends boolean = false> = NuGet<C>;
declare const index_NuGet: typeof NuGet;
type index_PackageRegistry<C extends boolean = false> = PackageRegistry<C>;
declare const index_PackageRegistry: typeof PackageRegistry;
type index_Packages<C extends boolean = false> = Packages<C>;
declare const index_Packages: typeof Packages;
type index_PagesDomains<C extends boolean = false> = PagesDomains<C>;
declare const index_PagesDomains: typeof PagesDomains;
type index_PersonalAccessTokens<C extends boolean = false> = PersonalAccessTokens<C>;
declare const index_PersonalAccessTokens: typeof PersonalAccessTokens;
type index_PipelineScheduleVariables<C extends boolean = false> = PipelineScheduleVariables<C>;
declare const index_PipelineScheduleVariables: typeof PipelineScheduleVariables;
type index_PipelineSchedules<C extends boolean = false> = PipelineSchedules<C>;
declare const index_PipelineSchedules: typeof PipelineSchedules;
type index_PipelineTriggerTokens<C extends boolean = false> = PipelineTriggerTokens<C>;
declare const index_PipelineTriggerTokens: typeof PipelineTriggerTokens;
type index_Pipelines<C extends boolean = false> = Pipelines<C>;
declare const index_Pipelines: typeof Pipelines;
type index_ProductAnalytics<C extends boolean = false> = ProductAnalytics<C>;
declare const index_ProductAnalytics: typeof ProductAnalytics;
type index_ProjectAccessRequests<C extends boolean = false> = ProjectAccessRequests<C>;
declare const index_ProjectAccessRequests: typeof ProjectAccessRequests;
type index_ProjectAccessTokens<C extends boolean = false> = ProjectAccessTokens<C>;
declare const index_ProjectAccessTokens: typeof ProjectAccessTokens;
type index_ProjectAliases<C extends boolean = false> = ProjectAliases<C>;
declare const index_ProjectAliases: typeof ProjectAliases;
type index_ProjectBadges<C extends boolean = false> = ProjectBadges<C>;
declare const index_ProjectBadges: typeof ProjectBadges;
type index_ProjectCustomAttributes<C extends boolean> = ProjectCustomAttributes<C>;
declare const index_ProjectCustomAttributes: typeof ProjectCustomAttributes;
type index_ProjectDORA4Metrics<C extends boolean = false> = ProjectDORA4Metrics<C>;
declare const index_ProjectDORA4Metrics: typeof ProjectDORA4Metrics;
type index_ProjectHooks<C extends boolean = false> = ProjectHooks<C>;
declare const index_ProjectHooks: typeof ProjectHooks;
type index_ProjectImportExport<C extends boolean = false> = ProjectImportExport<C>;
declare const index_ProjectImportExport: typeof ProjectImportExport;
type index_ProjectInvitations<C extends boolean = false> = ProjectInvitations<C>;
declare const index_ProjectInvitations: typeof ProjectInvitations;
type index_ProjectIssueBoards<C extends boolean = false> = ProjectIssueBoards<C>;
declare const index_ProjectIssueBoards: typeof ProjectIssueBoards;
type index_ProjectIterations<C extends boolean = false> = ProjectIterations<C>;
declare const index_ProjectIterations: typeof ProjectIterations;
type index_ProjectLabels<C extends boolean = false> = ProjectLabels<C>;
declare const index_ProjectLabels: typeof ProjectLabels;
type index_ProjectMembers<C extends boolean = false> = ProjectMembers<C>;
declare const index_ProjectMembers: typeof ProjectMembers;
type index_ProjectMilestones<C extends boolean = false> = ProjectMilestones<C>;
declare const index_ProjectMilestones: typeof ProjectMilestones;
type index_ProjectProtectedEnvironments<C extends boolean = false> = ProjectProtectedEnvironments<C>;
declare const index_ProjectProtectedEnvironments: typeof ProjectProtectedEnvironments;
type index_ProjectPushRules<C extends boolean = false> = ProjectPushRules<C>;
declare const index_ProjectPushRules: typeof ProjectPushRules;
type index_ProjectRelationsExport<C extends boolean = false> = ProjectRelationsExport<C>;
declare const index_ProjectRelationsExport: typeof ProjectRelationsExport;
type index_ProjectReleases<C extends boolean = false> = ProjectReleases<C>;
declare const index_ProjectReleases: typeof ProjectReleases;
type index_ProjectRemoteMirrors<C extends boolean = false> = ProjectRemoteMirrors<C>;
declare const index_ProjectRemoteMirrors: typeof ProjectRemoteMirrors;
type index_ProjectRepositoryStorageMoves<C extends boolean = false> = ProjectRepositoryStorageMoves<C>;
declare const index_ProjectRepositoryStorageMoves: typeof ProjectRepositoryStorageMoves;
type index_ProjectSnippetAwardEmojis<C extends boolean = false> = ProjectSnippetAwardEmojis<C>;
declare const index_ProjectSnippetAwardEmojis: typeof ProjectSnippetAwardEmojis;
type index_ProjectSnippetDiscussions<C extends boolean = false> = ProjectSnippetDiscussions<C>;
declare const index_ProjectSnippetDiscussions: typeof ProjectSnippetDiscussions;
type index_ProjectSnippetNotes<C extends boolean = false> = ProjectSnippetNotes<C>;
declare const index_ProjectSnippetNotes: typeof ProjectSnippetNotes;
type index_ProjectSnippets<C extends boolean = false> = ProjectSnippets<C>;
declare const index_ProjectSnippets: typeof ProjectSnippets;
type index_ProjectStatistics<C extends boolean = false> = ProjectStatistics<C>;
declare const index_ProjectStatistics: typeof ProjectStatistics;
type index_ProjectTemplates<C extends boolean = false> = ProjectTemplates<C>;
declare const index_ProjectTemplates: typeof ProjectTemplates;
type index_ProjectVariables<C extends boolean = false> = ProjectVariables<C>;
declare const index_ProjectVariables: typeof ProjectVariables;
type index_ProjectVulnerabilities<C extends boolean = false> = ProjectVulnerabilities<C>;
declare const index_ProjectVulnerabilities: typeof ProjectVulnerabilities;
type index_ProjectWikis<C extends boolean = false> = ProjectWikis<C>;
declare const index_ProjectWikis: typeof ProjectWikis;
type index_Projects<C extends boolean = false> = Projects<C>;
declare const index_Projects: typeof Projects;
type index_ProtectedBranches<C extends boolean = false> = ProtectedBranches<C>;
declare const index_ProtectedBranches: typeof ProtectedBranches;
type index_ProtectedTags<C extends boolean = false> = ProtectedTags<C>;
declare const index_ProtectedTags: typeof ProtectedTags;
type index_PyPI<C extends boolean = false> = PyPI<C>;
declare const index_PyPI: typeof PyPI;
type index_ReleaseLinks<C extends boolean = false> = ReleaseLinks<C>;
declare const index_ReleaseLinks: typeof ReleaseLinks;
type index_Repositories<C extends boolean = false> = Repositories<C>;
declare const index_Repositories: typeof Repositories;
type index_RepositoryFiles<C extends boolean = false> = RepositoryFiles<C>;
declare const index_RepositoryFiles: typeof RepositoryFiles;
type index_RepositorySubmodules<C extends boolean = false> = RepositorySubmodules<C>;
declare const index_RepositorySubmodules: typeof RepositorySubmodules;
type index_ResourceGroups<C extends boolean = false> = ResourceGroups<C>;
declare const index_ResourceGroups: typeof ResourceGroups;
type index_Runners<C extends boolean = false> = Runners<C>;
declare const index_Runners: typeof Runners;
type index_Search<C extends boolean = false> = Search<C>;
declare const index_Search: typeof Search;
type index_SecureFiles<C extends boolean = false> = SecureFiles<C>;
declare const index_SecureFiles: typeof SecureFiles;
type index_ServiceData<C extends boolean = false> = ServiceData<C>;
declare const index_ServiceData: typeof ServiceData;
type index_SidekiqMetrics<C extends boolean = false> = SidekiqMetrics<C>;
declare const index_SidekiqMetrics: typeof SidekiqMetrics;
type index_SidekiqQueues<C extends boolean = false> = SidekiqQueues<C>;
declare const index_SidekiqQueues: typeof SidekiqQueues;
type index_SnippetRepositoryStorageMoves<C extends boolean = false> = SnippetRepositoryStorageMoves<C>;
declare const index_SnippetRepositoryStorageMoves: typeof SnippetRepositoryStorageMoves;
type index_Snippets<C extends boolean = false> = Snippets<C>;
declare const index_Snippets: typeof Snippets;
type index_Suggestions<C extends boolean = false> = Suggestions<C>;
declare const index_Suggestions: typeof Suggestions;
type index_SystemHooks<C extends boolean = false> = SystemHooks<C>;
declare const index_SystemHooks: typeof SystemHooks;
type index_Tags<C extends boolean = false> = Tags<C>;
declare const index_Tags: typeof Tags;
type index_TodoLists<C extends boolean = false> = TodoLists<C>;
declare const index_TodoLists: typeof TodoLists;
type index_Topics<C extends boolean = false> = Topics<C>;
declare const index_Topics: typeof Topics;
type index_UserCustomAttributes<C extends boolean = false> = UserCustomAttributes<C>;
declare const index_UserCustomAttributes: typeof UserCustomAttributes;
type index_UserEmails<C extends boolean = false> = UserEmails<C>;
declare const index_UserEmails: typeof UserEmails;
type index_UserGPGKeys<C extends boolean = false> = UserGPGKeys<C>;
declare const index_UserGPGKeys: typeof UserGPGKeys;
type index_UserImpersonationTokens<C extends boolean = false> = UserImpersonationTokens<C>;
declare const index_UserImpersonationTokens: typeof UserImpersonationTokens;
type index_UserSSHKeys<C extends boolean = false> = UserSSHKeys<C>;
declare const index_UserSSHKeys: typeof UserSSHKeys;
type index_UserStarredMetricsDashboard<C extends boolean = false> = UserStarredMetricsDashboard<C>;
declare const index_UserStarredMetricsDashboard: typeof UserStarredMetricsDashboard;
type index_Users<C extends boolean = false> = Users<C>;
declare const index_Users: typeof Users;
type index_Version<C extends boolean = false> = Version<C>;
declare const index_Version: typeof Version;
type index_VisualReviewDiscussions<C extends boolean = false> = VisualReviewDiscussions<C>;
declare const index_VisualReviewDiscussions: typeof VisualReviewDiscussions;
type index_Vulnerabilities<C extends boolean = false> = Vulnerabilities<C>;
declare const index_Vulnerabilities: typeof Vulnerabilities;
type index_VulnerabilityFindings<C extends boolean = false> = VulnerabilityFindings<C>;
declare const index_VulnerabilityFindings: typeof VulnerabilityFindings;
declare namespace index {
  export {
    index_Agents as Agents,
    index_AlertManagement as AlertManagement,
    index_ApplicationAppearance as ApplicationAppearance,
    index_ApplicationPlanLimits as ApplicationPlanLimits,
    index_ApplicationSettings as ApplicationSettings,
    index_ApplicationStatistics as ApplicationStatistics,
    index_Applications as Applications,
    index_AuditEvents as AuditEvents,
    index_Avatar as Avatar,
    index_Branches as Branches,
    index_BroadcastMessages as BroadcastMessages,
    index_CommitDiscussions as CommitDiscussions,
    index_Commits as Commits,
    index_Composer as Composer,
    index_Conan as Conan,
    index_ContainerRegistry as ContainerRegistry,
    index_DashboardAnnotations as DashboardAnnotations,
    index_Debian as Debian,
    index_DependencyProxy as DependencyProxy,
    index_DeployKeys as DeployKeys,
    index_DeployTokens as DeployTokens,
    index_Deployments as Deployments,
    index_DockerfileTemplates as DockerfileTemplates,
    index_Environments as Environments,
    index_EpicAwardEmojis as EpicAwardEmojis,
    index_EpicDiscussions as EpicDiscussions,
    index_EpicIssues as EpicIssues,
    index_EpicLabelEvents as EpicLabelEvents,
    index_EpicLinks as EpicLinks,
    index_EpicNotes as EpicNotes,
    index_Epics as Epics,
    index_ErrorTrackingClientKeys as ErrorTrackingClientKeys,
    index_ErrorTrackingSettings as ErrorTrackingSettings,
    index_Events as Events,
    index_Experiments as Experiments,
    index_ExternalStatusChecks as ExternalStatusChecks,
    index_FeatureFlagUserLists as FeatureFlagUserLists,
    index_FeatureFlags as FeatureFlags,
    index_FreezePeriods as FreezePeriods,
    index_GeoNodes as GeoNodes,
    index_GitLabCIYMLTemplates as GitLabCIYMLTemplates,
    index_GitignoreTemplates as GitignoreTemplates,
    index_Gitlab as Gitlab,
    index_GitlabPages as GitlabPages,
    index_GoProxy as GoProxy,
    index_GroupAccessRequests as GroupAccessRequests,
    index_GroupAccessTokens as GroupAccessTokens,
    index_GroupActivityAnalytics as GroupActivityAnalytics,
    index_GroupBadges as GroupBadges,
    index_GroupCustomAttributes as GroupCustomAttributes,
    index_GroupDORA4Metrics as GroupDORA4Metrics,
    index_GroupHooks as GroupHooks,
    index_GroupImportExports as GroupImportExports,
    index_GroupInvitations as GroupInvitations,
    index_GroupIssueBoards as GroupIssueBoards,
    index_GroupIterations as GroupIterations,
    index_GroupLDAPLinks as GroupLDAPLinks,
    index_GroupLabels as GroupLabels,
    index_GroupMembers as GroupMembers,
    index_GroupMilestones as GroupMilestones,
    index_GroupProtectedEnvironments as GroupProtectedEnvironments,
    index_GroupPushRules as GroupPushRules,
    index_GroupRelationExports as GroupRelationExports,
    index_GroupReleases as GroupReleases,
    index_GroupRepositoryStorageMoves as GroupRepositoryStorageMoves,
    index_GroupSAMLIdentities as GroupSAMLIdentities,
    index_GroupSCIMIdentities as GroupSCIMIdentities,
    index_GroupVariables as GroupVariables,
    index_GroupWikis as GroupWikis,
    index_Groups as Groups,
    index_Helm as Helm,
    index_Import as Import,
    index_InstanceLevelCICDVariables as InstanceLevelCICDVariables,
    index_Integrations as Integrations,
    index_IssueAwardEmojis as IssueAwardEmojis,
    index_IssueDiscussions as IssueDiscussions,
    index_IssueIterationEvents as IssueIterationEvents,
    index_IssueLabelEvents as IssueLabelEvents,
    index_IssueLinks as IssueLinks,
    index_IssueMilestoneEvents as IssueMilestoneEvents,
    index_IssueNoteAwardEmojis as IssueNoteAwardEmojis,
    index_IssueNotes as IssueNotes,
    index_IssueStateEvents as IssueStateEvents,
    index_IssueWeightEvents as IssueWeightEvents,
    index_Issues as Issues,
    index_IssuesStatistics as IssuesStatistics,
    index_JobArtifacts as JobArtifacts,
    index_Jobs as Jobs,
    index_Keys as Keys,
    index_License as License,
    index_LicenseTemplates as LicenseTemplates,
    index_LinkedEpics as LinkedEpics,
    index_Lint as Lint,
    index_ManagedLicenses as ManagedLicenses,
    index_Markdown as Markdown,
    index_Maven as Maven,
    index_MergeRequestApprovals as MergeRequestApprovals,
    index_MergeRequestAwardEmojis as MergeRequestAwardEmojis,
    index_MergeRequestContextCommits as MergeRequestContextCommits,
    index_MergeRequestDiscussions as MergeRequestDiscussions,
    index_MergeRequestLabelEvents as MergeRequestLabelEvents,
    index_MergeRequestMilestoneEvents as MergeRequestMilestoneEvents,
    index_MergeRequestNotes as MergeRequestNotes,
    index_MergeRequests as MergeRequests,
    index_MergeTrains as MergeTrains,
    index_Metadata as Metadata,
    index_Migrations as Migrations,
    index_NPM as NPM,
    index_Namespaces as Namespaces,
    index_NotificationSettings as NotificationSettings,
    index_NuGet as NuGet,
    index_PackageRegistry as PackageRegistry,
    index_Packages as Packages,
    index_PagesDomains as PagesDomains,
    index_PersonalAccessTokens as PersonalAccessTokens,
    index_PipelineScheduleVariables as PipelineScheduleVariables,
    index_PipelineSchedules as PipelineSchedules,
    index_PipelineTriggerTokens as PipelineTriggerTokens,
    index_Pipelines as Pipelines,
    index_ProductAnalytics as ProductAnalytics,
    index_ProjectAccessRequests as ProjectAccessRequests,
    index_ProjectAccessTokens as ProjectAccessTokens,
    index_ProjectAliases as ProjectAliases,
    index_ProjectBadges as ProjectBadges,
    index_ProjectCustomAttributes as ProjectCustomAttributes,
    index_ProjectDORA4Metrics as ProjectDORA4Metrics,
    index_ProjectHooks as ProjectHooks,
    index_ProjectImportExport as ProjectImportExport,
    index_ProjectInvitations as ProjectInvitations,
    index_ProjectIssueBoards as ProjectIssueBoards,
    index_ProjectIterations as ProjectIterations,
    index_ProjectLabels as ProjectLabels,
    index_ProjectMembers as ProjectMembers,
    index_ProjectMilestones as ProjectMilestones,
    index_ProjectProtectedEnvironments as ProjectProtectedEnvironments,
    index_ProjectPushRules as ProjectPushRules,
    index_ProjectRelationsExport as ProjectRelationsExport,
    index_ProjectReleases as ProjectReleases,
    index_ProjectRemoteMirrors as ProjectRemoteMirrors,
    index_ProjectRepositoryStorageMoves as ProjectRepositoryStorageMoves,
    index_ProjectSnippetAwardEmojis as ProjectSnippetAwardEmojis,
    index_ProjectSnippetDiscussions as ProjectSnippetDiscussions,
    index_ProjectSnippetNotes as ProjectSnippetNotes,
    index_ProjectSnippets as ProjectSnippets,
    index_ProjectStatistics as ProjectStatistics,
    index_ProjectTemplates as ProjectTemplates,
    index_ProjectVariables as ProjectVariables,
    index_ProjectVulnerabilities as ProjectVulnerabilities,
    index_ProjectWikis as ProjectWikis,
    index_Projects as Projects,
    index_ProtectedBranches as ProtectedBranches,
    index_ProtectedTags as ProtectedTags,
    index_PyPI as PyPI,
    index_ReleaseLinks as ReleaseLinks,
    index_Repositories as Repositories,
    index_RepositoryFiles as RepositoryFiles,
    index_RepositorySubmodules as RepositorySubmodules,
    index_ResourceGroups as ResourceGroups,
    index_Runners as Runners,
    index_Search as Search,
    index_SecureFiles as SecureFiles,
    index_ServiceData as ServiceData,
    index_SidekiqMetrics as SidekiqMetrics,
    index_SidekiqQueues as SidekiqQueues,
    index_SnippetRepositoryStorageMoves as SnippetRepositoryStorageMoves,
    index_Snippets as Snippets,
    index_Suggestions as Suggestions,
    index_SystemHooks as SystemHooks,
    index_Tags as Tags,
    index_TodoLists as TodoLists,
    index_Topics as Topics,
    index_UserCustomAttributes as UserCustomAttributes,
    index_UserEmails as UserEmails,
    index_UserGPGKeys as UserGPGKeys,
    index_UserImpersonationTokens as UserImpersonationTokens,
    index_UserSSHKeys as UserSSHKeys,
    index_UserStarredMetricsDashboard as UserStarredMetricsDashboard,
    index_Users as Users,
    index_Version as Version,
    index_VisualReviewDiscussions as VisualReviewDiscussions,
    index_Vulnerabilities as Vulnerabilities,
    index_VulnerabilityFindings as VulnerabilityFindings,
  };
}

interface SAMLGroupSchema extends Record<string, unknown> {
    name: string;
    access_level: number;
}

type types_AcceptMergeRequestOptions = AcceptMergeRequestOptions;
type types_AccessLevel = AccessLevel;
type types_AccessRequestSchema = AccessRequestSchema;
type types_AccessTokenSchema = AccessTokenSchema;
type types_AccessTokenScopes = AccessTokenScopes;
type types_AllMergeRequestsOptions = AllMergeRequestsOptions;
type types_AllowedAgentSchema = AllowedAgentSchema;
type types_ApplicationAppearanceSchema = ApplicationAppearanceSchema;
type types_ApplicationPlanLimitOptions = ApplicationPlanLimitOptions;
type types_ApplicationPlanLimitSchema = ApplicationPlanLimitSchema;
type types_ApplicationSchema = ApplicationSchema;
type types_ApplicationSettingsSchema = ApplicationSettingsSchema;
type types_ApplicationStatisticSchema = ApplicationStatisticSchema;
type types_ApprovalRuleSchema = ApprovalRuleSchema;
type types_ApprovalRulesRequestOptions = ApprovalRulesRequestOptions;
type types_ApprovalStateSchema = ApprovalStateSchema;
type types_ApprovedByEntity = ApprovedByEntity;
type types_ArchiveType = ArchiveType;
type types_ArtifactSchema = ArtifactSchema;
type types_AuditEventSchema = AuditEventSchema;
type types_AvatarSchema = AvatarSchema;
type types_AwardEmojiSchema = AwardEmojiSchema;
type types_BadgeSchema = BadgeSchema;
type types_BaseExternalStatusCheckSchema = BaseExternalStatusCheckSchema;
type types_BasePaginationRequestOptions<P extends PaginationTypes | void> = BasePaginationRequestOptions<P>;
type types_BaseRequestOptions<E extends boolean = false> = BaseRequestOptions<E>;
type types_BillableGroupMemberMembershipSchema = BillableGroupMemberMembershipSchema;
type types_BillableGroupMemberSchema = BillableGroupMemberSchema;
type types_BlobSchema = BlobSchema;
type types_BranchSchema = BranchSchema;
type types_BridgeSchema = BridgeSchema;
type types_BroadcastMessageOptions = BroadcastMessageOptions;
type types_BroadcastMessageSchema = BroadcastMessageSchema;
type types_CICDVariableSchema = CICDVariableSchema;
type types_CamelizedResponse<T, C> = CamelizedResponse<T, C>;
type types_ClusterAgentSchema = ClusterAgentSchema;
type types_ClusterAgentTokenSchema = ClusterAgentTokenSchema;
type types_CommitAction = CommitAction;
type types_CommitCommentSchema = CommitCommentSchema;
type types_CommitDiffSchema = CommitDiffSchema;
type types_CommitDiscussionNoteSchema = CommitDiscussionNoteSchema;
type types_CommitDiscussionSchema = CommitDiscussionSchema;
type types_CommitExpandedSchema = CommitExpandedSchema;
type types_CommitReferenceSchema = CommitReferenceSchema;
type types_CommitSchema = CommitSchema;
type types_CommitSignatureSchema = CommitSignatureSchema;
type types_CommitStatusSchema = CommitStatusSchema;
type types_ComposerPackageMetadataSchema = ComposerPackageMetadataSchema;
type types_ComposerV1BaseRepositorySchema = ComposerV1BaseRepositorySchema;
type types_ComposerV1PackagesSchema = ComposerV1PackagesSchema;
type types_ComposerV2BaseRepositorySchema = ComposerV2BaseRepositorySchema;
type types_CondensedCommitSchema = CondensedCommitSchema;
type types_CondensedEnvironmentSchema = CondensedEnvironmentSchema;
type types_CondensedEpicLinkSchema = CondensedEpicLinkSchema;
type types_CondensedGroupSchema = CondensedGroupSchema;
type types_CondensedJobSchema = CondensedJobSchema;
type types_CondensedMemberSchema = CondensedMemberSchema;
type types_CondensedMergeRequestSchema = CondensedMergeRequestSchema;
type types_CondensedNamespaceSchema = CondensedNamespaceSchema;
type types_CondensedPipelineScheduleSchema = CondensedPipelineScheduleSchema;
type types_CondensedProjectSchema = CondensedProjectSchema;
type types_CondensedRegistryRepositorySchema = CondensedRegistryRepositorySchema;
type types_CondensedRegistryRepositoryTagSchema = CondensedRegistryRepositoryTagSchema;
type types_ContextualLintSchema = ContextualLintSchema;
type types_CreateMergeRequestOptions = CreateMergeRequestOptions;
type types_CustomAttributeSchema = CustomAttributeSchema;
type types_CustomSettingLevelEmailEvents = CustomSettingLevelEmailEvents;
type types_DORA4MetricSchema = DORA4MetricSchema;
type types_DashboardAnnotationSchema = DashboardAnnotationSchema;
type types_DeployKeys<C extends boolean = false> = DeployKeys<C>;
declare const types_DeployKeys: typeof DeployKeys;
type types_DeployTokenSchema = DeployTokenSchema;
type types_DeployTokenScope = DeployTokenScope;
type types_DeployableSchema = DeployableSchema;
type types_DeploymentSchema = DeploymentSchema;
type types_DeploymentStatus = DeploymentStatus;
type types_DeploymentStatusSchema = DeploymentStatusSchema;
type types_DiffRefsSchema = DiffRefsSchema;
type types_DiscussionNotePositionBaseSchema = DiscussionNotePositionBaseSchema;
type types_DiscussionNotePositionOptions = DiscussionNotePositionOptions;
type types_DiscussionNotePositionSchema = DiscussionNotePositionSchema;
type types_DiscussionNoteSchema = DiscussionNoteSchema;
type types_DiscussionSchema = DiscussionSchema;
type types_EnvironmentSchema = EnvironmentSchema;
type types_EpicIssueSchema = EpicIssueSchema;
type types_EpicLinkSchema = EpicLinkSchema;
type types_EpicNoteSchema = EpicNoteSchema;
type types_EpicSchema = EpicSchema;
type types_EpicTodoSchema = EpicTodoSchema;
type types_ErrorTrackingClientKeySchema = ErrorTrackingClientKeySchema;
type types_ErrorTrackingSettingsSchema = ErrorTrackingSettingsSchema;
type types_EventOptions = EventOptions;
type types_EventSchema = EventSchema;
type types_ExpandedEpicIssueSchema = ExpandedEpicIssueSchema;
type types_ExpandedGroupSchema = ExpandedGroupSchema;
type types_ExpandedHookSchema = ExpandedHookSchema;
type types_ExpandedIssueLinkSchema = ExpandedIssueLinkSchema;
type types_ExpandedMergeRequestDiffVersionsSchema = ExpandedMergeRequestDiffVersionsSchema;
type types_ExpandedMergeRequestSchema = ExpandedMergeRequestSchema;
type types_ExpandedPackageSchema = ExpandedPackageSchema;
type types_ExpandedPipelineScheduleSchema = ExpandedPipelineScheduleSchema;
type types_ExpandedPipelineSchema = ExpandedPipelineSchema;
type types_ExpandedProjectSchema = ExpandedProjectSchema;
type types_ExpandedResponse<T> = ExpandedResponse<T>;
type types_ExpandedRunnerSchema = ExpandedRunnerSchema;
type types_ExpandedSnippetSchema = ExpandedSnippetSchema;
type types_ExpandedUserSchema = ExpandedUserSchema;
type types_ExperimentGateSchema = ExperimentGateSchema;
type types_ExperimentSchema = ExperimentSchema;
type types_ExternalStatusCheckProtectedBranchesSchema = ExternalStatusCheckProtectedBranchesSchema;
type types_FailedRelationSchema = FailedRelationSchema;
type types_FeatureFlagSchema = FeatureFlagSchema;
type types_FeatureFlagStrategy = FeatureFlagStrategy;
type types_FeatureFlagStrategyScope = FeatureFlagStrategyScope;
type types_FeatureFlagUserListSchema = FeatureFlagUserListSchema;
type types_FreezePeriodSchema = FreezePeriodSchema;
type types_GPGSignatureSchema = GPGSignatureSchema;
type types_GeoNodeFailureSchema = GeoNodeFailureSchema;
type types_GeoNodeSchema = GeoNodeSchema;
type types_GeoNodeStatusSchema = GeoNodeStatusSchema;
type types_Gitlab<C extends boolean = false> = Gitlab<C>;
declare const types_Gitlab: typeof Gitlab;
type types_GoProxyModuleVersionSchema = GoProxyModuleVersionSchema;
type types_GroupAnalyticsIssuesCountSchema = GroupAnalyticsIssuesCountSchema;
type types_GroupAnalyticsMRsCountSchema = GroupAnalyticsMRsCountSchema;
type types_GroupAnalyticsNewMembersCountSchema = GroupAnalyticsNewMembersCountSchema;
type types_GroupBadgePreviewSchema = GroupBadgePreviewSchema;
type types_GroupBadgeSchema = GroupBadgeSchema;
type types_GroupHookSchema = GroupHookSchema;
type types_GroupRelationExportStatusSchema = GroupRelationExportStatusSchema;
type types_GroupRepositoryStorageMoveSchema = GroupRepositoryStorageMoveSchema;
type types_GroupSchema = GroupSchema;
type types_GroupStatisticsSchema = GroupStatisticsSchema;
type types_GrouptIssueBoardSchema = GrouptIssueBoardSchema;
type types_HookSchema = HookSchema;
type types_IdentitySchema = IdentitySchema;
type types_ImpersonationTokenScope = ImpersonationTokenScope;
type types_ImpersonationTokenState = ImpersonationTokenState;
type types_ImportStatusSchema = ImportStatusSchema;
type types_IncludeInherited = IncludeInherited;
type types_IntegrationSchema = IntegrationSchema;
type types_InvitationSchema = InvitationSchema;
type types_IssueBoardListSchema = IssueBoardListSchema;
type types_IssueBoardSchema = IssueBoardSchema;
type types_IssueLinkSchema = IssueLinkSchema;
type types_IssueNoteSchema = IssueNoteSchema;
type types_IssueSchema = IssueSchema;
type types_IterationEventSchema = IterationEventSchema;
type types_IterationSchema = IterationSchema;
type types_JobKubernetesAgentsSchema = JobKubernetesAgentsSchema;
type types_JobSchema = JobSchema;
type types_JobScope = JobScope;
type types_KeySchema = KeySchema;
type types_LabelEventSchema = LabelEventSchema;
type types_LabelSchema = LabelSchema;
type types_LicenseSchema = LicenseSchema;
type types_LicenseTemplateSchema = LicenseTemplateSchema;
type types_LintSchema = LintSchema;
type types_ManagedLicenseSchema = ManagedLicenseSchema;
type types_MarkdownSchema = MarkdownSchema;
type types_MemberSchema = MemberSchema;
type types_MergeRequestChanges = MergeRequestChanges;
type types_MergeRequestContextCommitSchema = MergeRequestContextCommitSchema;
type types_MergeRequestDiffVersionsSchema = MergeRequestDiffVersionsSchema;
type types_MergeRequestDiscussionNoteSchema = MergeRequestDiscussionNoteSchema;
type types_MergeRequestExternalStatusCheckSchema = MergeRequestExternalStatusCheckSchema;
type types_MergeRequestLevelApprovalRuleSchema = MergeRequestLevelApprovalRuleSchema;
type types_MergeRequestLevelMergeRequestApprovalSchema = MergeRequestLevelMergeRequestApprovalSchema;
type types_MergeRequestNoteSchema = MergeRequestNoteSchema;
type types_MergeRequestRebaseSchema = MergeRequestRebaseSchema;
type types_MergeRequestSchema = MergeRequestSchema;
type types_MergeRequestTodoSchema = MergeRequestTodoSchema;
type types_MergeRequestWithChangesSchema = MergeRequestWithChangesSchema;
type types_MergeTrainSchema = MergeTrainSchema;
type types_MetadataSchema = MetadataSchema;
type types_MetricImageSchema = MetricImageSchema;
type types_MetricType = MetricType;
type types_MigrationEntityFailure = MigrationEntityFailure;
type types_MigrationEntityOptions = MigrationEntityOptions;
type types_MigrationEntitySchema = MigrationEntitySchema;
type types_MigrationStatusSchema = MigrationStatusSchema;
type types_MilestoneEventSchema = MilestoneEventSchema;
type types_MilestoneSchema = MilestoneSchema;
type types_MissingSignatureSchema = MissingSignatureSchema;
type types_NPMPackageMetadataSchema = NPMPackageMetadataSchema;
type types_NPMVersionSchema = NPMVersionSchema;
type types_NamespaceSchema = NamespaceSchema;
type types_NoteSchema = NoteSchema;
type types_NotificationSettingLevel = NotificationSettingLevel;
type types_NotificationSettingSchema = NotificationSettingSchema;
type types_NuGetPackageIndexSchema = NuGetPackageIndexSchema;
type types_NuGetResourceSchema = NuGetResourceSchema;
type types_NuGetSearchResultSchema = NuGetSearchResultSchema;
type types_NuGetSearchResultsSchema = NuGetSearchResultsSchema;
type types_NuGetServiceIndexSchema = NuGetServiceIndexSchema;
type types_NuGetServiceMetadataItemSchema = NuGetServiceMetadataItemSchema;
type types_NuGetServiceMetadataSchema = NuGetServiceMetadataSchema;
type types_NuGetServiceMetadataVersionSchema = NuGetServiceMetadataVersionSchema;
type types_OffsetPaginationRequestOptions = OffsetPaginationRequestOptions;
type types_OverrodeGroupMemberSchema = OverrodeGroupMemberSchema;
type types_PackageFileSchema = PackageFileSchema;
type types_PackageMetadata = PackageMetadata;
type types_PackageRegistrySchema = PackageRegistrySchema;
type types_PackageSchema = PackageSchema;
type types_PackageSnapshotSchema = PackageSnapshotSchema;
type types_PagesDomainSchema = PagesDomainSchema;
type types_PaginatedResponse<T, P extends PaginationTypes = PaginationTypes> = PaginatedResponse<T, P>;
type types_PaginationRequestOptions<P extends PaginationTypes | void> = PaginationRequestOptions<P>;
type types_PaginationTypes = PaginationTypes;
type types_PersonalAccessTokenSchema = PersonalAccessTokenSchema;
type types_PersonalAccessTokenScopes = PersonalAccessTokenScopes;
type types_PipelineScheduleSchema = PipelineScheduleSchema;
type types_PipelineSchema = PipelineSchema;
type types_PipelineStatus = PipelineStatus;
type types_PipelineTestCaseSchema = PipelineTestCaseSchema;
type types_PipelineTestReportSchema = PipelineTestReportSchema;
type types_PipelineTestReportSummarySchema = PipelineTestReportSummarySchema;
type types_PipelineTestSuiteSchema = PipelineTestSuiteSchema;
type types_PipelineTriggerTokenSchema = PipelineTriggerTokenSchema;
type types_PipelineVariableSchema = PipelineVariableSchema;
type types_ProcessMetricSchema = ProcessMetricSchema;
type types_ProjectAliasSchema = ProjectAliasSchema;
type types_ProjectBadgePreviewSchema = ProjectBadgePreviewSchema;
type types_ProjectBadgeSchema = ProjectBadgeSchema;
type types_ProjectExternalStatusCheckSchema = ProjectExternalStatusCheckSchema;
type types_ProjectFileUploadSchema = ProjectFileUploadSchema;
type types_ProjectHookSchema = ProjectHookSchema;
type types_ProjectIssueBoardSchema = ProjectIssueBoardSchema;
type types_ProjectLevelApprovalRuleSchema = ProjectLevelApprovalRuleSchema;
type types_ProjectLevelMergeRequestApprovalSchema = ProjectLevelMergeRequestApprovalSchema;
type types_ProjectRemoteMirrorSchema = ProjectRemoteMirrorSchema;
type types_ProjectRepositoryStorageMoveSchema = ProjectRepositoryStorageMoveSchema;
type types_ProjectSchema = ProjectSchema;
type types_ProjectStarrerSchema = ProjectStarrerSchema;
type types_ProjectStatisticSchema = ProjectStatisticSchema;
type types_ProjectStatisticsSchema = ProjectStatisticsSchema;
type types_ProjectStoragePath = ProjectStoragePath;
type types_ProjectTemplateSchema = ProjectTemplateSchema;
type types_ProjectTemplateType = ProjectTemplateType;
type types_ProjectVariableSchema = ProjectVariableSchema;
type types_ProjectVulnerabilitySchema = ProjectVulnerabilitySchema;
type types_ProtectedBranchAccessLevel = ProtectedBranchAccessLevel;
type types_ProtectedBranchSchema = ProtectedBranchSchema;
type types_ProtectedEnvironmentAccessLevel = ProtectedEnvironmentAccessLevel;
type types_ProtectedEnvironmentSchema = ProtectedEnvironmentSchema;
type types_ProtectedTagAccessLevel = ProtectedTagAccessLevel;
type types_ProtectedTagSchema = ProtectedTagSchema;
type types_PushRuleSchema = PushRuleSchema;
type types_RecipeSnapshotSchema = RecipeSnapshotSchema;
type types_ReferenceSchema = ReferenceSchema;
type types_RegistryRepositorySchema = RegistryRepositorySchema;
type types_RegistryRepositoryTagSchema = RegistryRepositoryTagSchema;
type types_RelatedEpicLinkSchema = RelatedEpicLinkSchema;
type types_RelatedEpicSchema = RelatedEpicSchema;
type types_ReleaseAssetLink = ReleaseAssetLink;
type types_ReleaseAssetSource = ReleaseAssetSource;
type types_ReleaseEvidence = ReleaseEvidence;
type types_ReleaseLinkSchema = ReleaseLinkSchema;
type types_ReleaseSchema = ReleaseSchema;
type types_RepositoryChangelogSchema = RepositoryChangelogSchema;
type types_RepositoryCompareSchema = RepositoryCompareSchema;
type types_RepositoryContributorSchema = RepositoryContributorSchema;
type types_RepositoryFileBlameSchema = RepositoryFileBlameSchema;
type types_RepositoryFileExpandedSchema = RepositoryFileExpandedSchema;
type types_RepositoryFileSchema = RepositoryFileSchema;
type types_RepositoryImportStatusSchema = RepositoryImportStatusSchema;
type types_RepositoryStorageMoveSchema = RepositoryStorageMoveSchema;
type types_RepositorySubmoduleSchema = RepositorySubmoduleSchema;
type types_RepositoryTreeSchema = RepositoryTreeSchema;
type types_ResourceGroupSchema = ResourceGroupSchema;
type types_ReviewAppSchema = ReviewAppSchema;
type types_RunnerSchema = RunnerSchema;
type types_RunnerToken = RunnerToken;
type types_SAMLGroupSchema = SAMLGroupSchema;
type types_SearchScopes = SearchScopes;
type types_SecureFileSchema = SecureFileSchema;
type types_ShowExpanded<E extends boolean = false> = ShowExpanded<E>;
type types_SidekickCompoundMetricsSchema = SidekickCompoundMetricsSchema;
type types_SidekickJobStatsSchema = SidekickJobStatsSchema;
type types_SidekickProcessMetricsSchema = SidekickProcessMetricsSchema;
type types_SidekickQueueMetricsSchema = SidekickQueueMetricsSchema;
type types_SidekiqQueueStatus = SidekiqQueueStatus;
type types_SimpleGroupSchema = SimpleGroupSchema;
type types_SimpleMemberSchema = SimpleMemberSchema;
type types_SimpleProjectSchema = SimpleProjectSchema;
type types_SimpleSnippetSchema = SimpleSnippetSchema;
type types_SnippetNoteSchema = SnippetNoteSchema;
type types_SnippetRepositoryStorageMoveSchema = SnippetRepositoryStorageMoveSchema;
type types_SnippetSchema = SnippetSchema;
type types_SnippetVisibility = SnippetVisibility;
type types_StarredDashboardSchema = StarredDashboardSchema;
type types_StateEventSchema = StateEventSchema;
type types_StatisticsSchema = StatisticsSchema;
type types_Sudo = Sudo;
type types_SuggestionSchema = SuggestionSchema;
type types_SupportedIntegration = SupportedIntegration;
type types_SystemHookTestResponse = SystemHookTestResponse;
type types_TagSchema = TagSchema;
type types_TaskCompletionStatusSchema = TaskCompletionStatusSchema;
type types_TemplateSchema = TemplateSchema;
type types_TimeStatsSchema = TimeStatsSchema;
type types_TodoAction = TodoAction;
type types_TodoSchema = TodoSchema;
type types_TodoState = TodoState;
type types_TodoType = TodoType;
type types_TopicSchema = TopicSchema;
type types_UpdateMergeRequestOptions = UpdateMergeRequestOptions;
type types_UserActivitySchema = UserActivitySchema;
type types_UserCountSchema = UserCountSchema;
type types_UserEmailSchema = UserEmailSchema;
type types_UserGPGKeySchema = UserGPGKeySchema;
type types_UserImpersonationTokenSchema = UserImpersonationTokenSchema;
type types_UserMembershipSchema = UserMembershipSchema;
type types_UserPreferenceSchema = UserPreferenceSchema;
type types_UserSSHKeySchema = UserSSHKeySchema;
type types_UserSchema = UserSchema;
type types_UserStatusSchema = UserStatusSchema;
type types_VariableFilter = VariableFilter;
type types_VariableSchema = VariableSchema;
type types_VariableType = VariableType;
type types_VersionSchema = VersionSchema;
type types_VulnerabilityFindingSchema = VulnerabilityFindingSchema;
type types_VulnerabilitySchema = VulnerabilitySchema;
type types_WeightEventSchema = WeightEventSchema;
type types_WikiAttachmentSchema = WikiAttachmentSchema;
type types_WikiSchema = WikiSchema;
type types_X509SignatureSchema = X509SignatureSchema;
declare namespace types {
  export {
    types_AcceptMergeRequestOptions as AcceptMergeRequestOptions,
    types_AccessLevel as AccessLevel,
    types_AccessRequestSchema as AccessRequestSchema,
    types_AccessTokenSchema as AccessTokenSchema,
    types_AccessTokenScopes as AccessTokenScopes,
    types_AllMergeRequestsOptions as AllMergeRequestsOptions,
    types_AllowedAgentSchema as AllowedAgentSchema,
    types_ApplicationAppearanceSchema as ApplicationAppearanceSchema,
    types_ApplicationPlanLimitOptions as ApplicationPlanLimitOptions,
    types_ApplicationPlanLimitSchema as ApplicationPlanLimitSchema,
    types_ApplicationSchema as ApplicationSchema,
    types_ApplicationSettingsSchema as ApplicationSettingsSchema,
    types_ApplicationStatisticSchema as ApplicationStatisticSchema,
    types_ApprovalRuleSchema as ApprovalRuleSchema,
    types_ApprovalRulesRequestOptions as ApprovalRulesRequestOptions,
    types_ApprovalStateSchema as ApprovalStateSchema,
    types_ApprovedByEntity as ApprovedByEntity,
    types_ArchiveType as ArchiveType,
    types_ArtifactSchema as ArtifactSchema,
    types_AuditEventSchema as AuditEventSchema,
    types_AvatarSchema as AvatarSchema,
    types_AwardEmojiSchema as AwardEmojiSchema,
    types_BadgeSchema as BadgeSchema,
    types_BaseExternalStatusCheckSchema as BaseExternalStatusCheckSchema,
    types_BasePaginationRequestOptions as BasePaginationRequestOptions,
    types_BaseRequestOptions as BaseRequestOptions,
    types_BillableGroupMemberMembershipSchema as BillableGroupMemberMembershipSchema,
    types_BillableGroupMemberSchema as BillableGroupMemberSchema,
    types_BlobSchema as BlobSchema,
    types_BranchSchema as BranchSchema,
    types_BridgeSchema as BridgeSchema,
    types_BroadcastMessageOptions as BroadcastMessageOptions,
    types_BroadcastMessageSchema as BroadcastMessageSchema,
    types_CICDVariableSchema as CICDVariableSchema,
    types_CamelizedResponse as CamelizedResponse,
    types_ClusterAgentSchema as ClusterAgentSchema,
    types_ClusterAgentTokenSchema as ClusterAgentTokenSchema,
    types_CommitAction as CommitAction,
    types_CommitCommentSchema as CommitCommentSchema,
    types_CommitDiffSchema as CommitDiffSchema,
    types_CommitDiscussionNoteSchema as CommitDiscussionNoteSchema,
    types_CommitDiscussionSchema as CommitDiscussionSchema,
    types_CommitExpandedSchema as CommitExpandedSchema,
    types_CommitReferenceSchema as CommitReferenceSchema,
    types_CommitSchema as CommitSchema,
    types_CommitSignatureSchema as CommitSignatureSchema,
    types_CommitStatusSchema as CommitStatusSchema,
    types_ComposerPackageMetadataSchema as ComposerPackageMetadataSchema,
    types_ComposerV1BaseRepositorySchema as ComposerV1BaseRepositorySchema,
    types_ComposerV1PackagesSchema as ComposerV1PackagesSchema,
    types_ComposerV2BaseRepositorySchema as ComposerV2BaseRepositorySchema,
    types_CondensedCommitSchema as CondensedCommitSchema,
    types_CondensedEnvironmentSchema as CondensedEnvironmentSchema,
    types_CondensedEpicLinkSchema as CondensedEpicLinkSchema,
    types_CondensedGroupSchema as CondensedGroupSchema,
    types_CondensedJobSchema as CondensedJobSchema,
    types_CondensedMemberSchema as CondensedMemberSchema,
    types_CondensedMergeRequestSchema as CondensedMergeRequestSchema,
    types_CondensedNamespaceSchema as CondensedNamespaceSchema,
    types_CondensedPipelineScheduleSchema as CondensedPipelineScheduleSchema,
    types_CondensedProjectSchema as CondensedProjectSchema,
    types_CondensedRegistryRepositorySchema as CondensedRegistryRepositorySchema,
    types_CondensedRegistryRepositoryTagSchema as CondensedRegistryRepositoryTagSchema,
    types_ContextualLintSchema as ContextualLintSchema,
    types_CreateMergeRequestOptions as CreateMergeRequestOptions,
    types_CustomAttributeSchema as CustomAttributeSchema,
    types_CustomSettingLevelEmailEvents as CustomSettingLevelEmailEvents,
    types_DORA4MetricSchema as DORA4MetricSchema,
    types_DashboardAnnotationSchema as DashboardAnnotationSchema,
    types_DeployKeys as DeployKeys,
    types_DeployTokenSchema as DeployTokenSchema,
    types_DeployTokenScope as DeployTokenScope,
    types_DeployableSchema as DeployableSchema,
    types_DeploymentSchema as DeploymentSchema,
    types_DeploymentStatus as DeploymentStatus,
    types_DeploymentStatusSchema as DeploymentStatusSchema,
    types_DiffRefsSchema as DiffRefsSchema,
    types_DiscussionNotePositionBaseSchema as DiscussionNotePositionBaseSchema,
    types_DiscussionNotePositionOptions as DiscussionNotePositionOptions,
    types_DiscussionNotePositionSchema as DiscussionNotePositionSchema,
    types_DiscussionNoteSchema as DiscussionNoteSchema,
    types_DiscussionSchema as DiscussionSchema,
    types_EnvironmentSchema as EnvironmentSchema,
    types_EpicIssueSchema as EpicIssueSchema,
    types_EpicLinkSchema as EpicLinkSchema,
    types_EpicNoteSchema as EpicNoteSchema,
    types_EpicSchema as EpicSchema,
    types_EpicTodoSchema as EpicTodoSchema,
    types_ErrorTrackingClientKeySchema as ErrorTrackingClientKeySchema,
    types_ErrorTrackingSettingsSchema as ErrorTrackingSettingsSchema,
    types_EventOptions as EventOptions,
    types_EventSchema as EventSchema,
    types_ExpandedEpicIssueSchema as ExpandedEpicIssueSchema,
    types_ExpandedGroupSchema as ExpandedGroupSchema,
    types_ExpandedHookSchema as ExpandedHookSchema,
    types_ExpandedIssueLinkSchema as ExpandedIssueLinkSchema,
    types_ExpandedMergeRequestDiffVersionsSchema as ExpandedMergeRequestDiffVersionsSchema,
    types_ExpandedMergeRequestSchema as ExpandedMergeRequestSchema,
    types_ExpandedPackageSchema as ExpandedPackageSchema,
    types_ExpandedPipelineScheduleSchema as ExpandedPipelineScheduleSchema,
    types_ExpandedPipelineSchema as ExpandedPipelineSchema,
    types_ExpandedProjectSchema as ExpandedProjectSchema,
    types_ExpandedResponse as ExpandedResponse,
    types_ExpandedRunnerSchema as ExpandedRunnerSchema,
    types_ExpandedSnippetSchema as ExpandedSnippetSchema,
    types_ExpandedUserSchema as ExpandedUserSchema,
    types_ExperimentGateSchema as ExperimentGateSchema,
    types_ExperimentSchema as ExperimentSchema,
    ExportStatusSchema$1 as ExportStatusSchema,
    types_ExternalStatusCheckProtectedBranchesSchema as ExternalStatusCheckProtectedBranchesSchema,
    types_FailedRelationSchema as FailedRelationSchema,
    types_FeatureFlagSchema as FeatureFlagSchema,
    types_FeatureFlagStrategy as FeatureFlagStrategy,
    types_FeatureFlagStrategyScope as FeatureFlagStrategyScope,
    types_FeatureFlagUserListSchema as FeatureFlagUserListSchema,
    types_FreezePeriodSchema as FreezePeriodSchema,
    types_GPGSignatureSchema as GPGSignatureSchema,
    types_GeoNodeFailureSchema as GeoNodeFailureSchema,
    types_GeoNodeSchema as GeoNodeSchema,
    types_GeoNodeStatusSchema as GeoNodeStatusSchema,
    types_Gitlab as Gitlab,
    types_GoProxyModuleVersionSchema as GoProxyModuleVersionSchema,
    types_GroupAnalyticsIssuesCountSchema as GroupAnalyticsIssuesCountSchema,
    types_GroupAnalyticsMRsCountSchema as GroupAnalyticsMRsCountSchema,
    types_GroupAnalyticsNewMembersCountSchema as GroupAnalyticsNewMembersCountSchema,
    types_GroupBadgePreviewSchema as GroupBadgePreviewSchema,
    types_GroupBadgeSchema as GroupBadgeSchema,
    types_GroupHookSchema as GroupHookSchema,
    types_GroupRelationExportStatusSchema as GroupRelationExportStatusSchema,
    types_GroupRepositoryStorageMoveSchema as GroupRepositoryStorageMoveSchema,
    types_GroupSchema as GroupSchema,
    types_GroupStatisticsSchema as GroupStatisticsSchema,
    types_GrouptIssueBoardSchema as GrouptIssueBoardSchema,
    types_HookSchema as HookSchema,
    types_IdentitySchema as IdentitySchema,
    types_ImpersonationTokenScope as ImpersonationTokenScope,
    types_ImpersonationTokenState as ImpersonationTokenState,
    types_ImportStatusSchema as ImportStatusSchema,
    types_IncludeInherited as IncludeInherited,
    types_IntegrationSchema as IntegrationSchema,
    types_InvitationSchema as InvitationSchema,
    types_IssueBoardListSchema as IssueBoardListSchema,
    types_IssueBoardSchema as IssueBoardSchema,
    types_IssueLinkSchema as IssueLinkSchema,
    types_IssueNoteSchema as IssueNoteSchema,
    types_IssueSchema as IssueSchema,
    types_IterationEventSchema as IterationEventSchema,
    types_IterationSchema as IterationSchema,
    types_JobKubernetesAgentsSchema as JobKubernetesAgentsSchema,
    types_JobSchema as JobSchema,
    types_JobScope as JobScope,
    types_KeySchema as KeySchema,
    types_LabelEventSchema as LabelEventSchema,
    types_LabelSchema as LabelSchema,
    types_LicenseSchema as LicenseSchema,
    types_LicenseTemplateSchema as LicenseTemplateSchema,
    types_LintSchema as LintSchema,
    types_ManagedLicenseSchema as ManagedLicenseSchema,
    types_MarkdownSchema as MarkdownSchema,
    types_MemberSchema as MemberSchema,
    types_MergeRequestChanges as MergeRequestChanges,
    types_MergeRequestContextCommitSchema as MergeRequestContextCommitSchema,
    types_MergeRequestDiffVersionsSchema as MergeRequestDiffVersionsSchema,
    types_MergeRequestDiscussionNoteSchema as MergeRequestDiscussionNoteSchema,
    types_MergeRequestExternalStatusCheckSchema as MergeRequestExternalStatusCheckSchema,
    types_MergeRequestLevelApprovalRuleSchema as MergeRequestLevelApprovalRuleSchema,
    types_MergeRequestLevelMergeRequestApprovalSchema as MergeRequestLevelMergeRequestApprovalSchema,
    types_MergeRequestNoteSchema as MergeRequestNoteSchema,
    types_MergeRequestRebaseSchema as MergeRequestRebaseSchema,
    types_MergeRequestSchema as MergeRequestSchema,
    types_MergeRequestTodoSchema as MergeRequestTodoSchema,
    types_MergeRequestWithChangesSchema as MergeRequestWithChangesSchema,
    types_MergeTrainSchema as MergeTrainSchema,
    types_MetadataSchema as MetadataSchema,
    types_MetricImageSchema as MetricImageSchema,
    types_MetricType as MetricType,
    types_MigrationEntityFailure as MigrationEntityFailure,
    types_MigrationEntityOptions as MigrationEntityOptions,
    types_MigrationEntitySchema as MigrationEntitySchema,
    types_MigrationStatusSchema as MigrationStatusSchema,
    types_MilestoneEventSchema as MilestoneEventSchema,
    types_MilestoneSchema as MilestoneSchema,
    types_MissingSignatureSchema as MissingSignatureSchema,
    types_NPMPackageMetadataSchema as NPMPackageMetadataSchema,
    types_NPMVersionSchema as NPMVersionSchema,
    types_NamespaceSchema as NamespaceSchema,
    types_NoteSchema as NoteSchema,
    types_NotificationSettingLevel as NotificationSettingLevel,
    types_NotificationSettingSchema as NotificationSettingSchema,
    types_NuGetPackageIndexSchema as NuGetPackageIndexSchema,
    types_NuGetResourceSchema as NuGetResourceSchema,
    types_NuGetSearchResultSchema as NuGetSearchResultSchema,
    types_NuGetSearchResultsSchema as NuGetSearchResultsSchema,
    types_NuGetServiceIndexSchema as NuGetServiceIndexSchema,
    types_NuGetServiceMetadataItemSchema as NuGetServiceMetadataItemSchema,
    types_NuGetServiceMetadataSchema as NuGetServiceMetadataSchema,
    types_NuGetServiceMetadataVersionSchema as NuGetServiceMetadataVersionSchema,
    types_OffsetPaginationRequestOptions as OffsetPaginationRequestOptions,
    types_OverrodeGroupMemberSchema as OverrodeGroupMemberSchema,
    types_PackageFileSchema as PackageFileSchema,
    types_PackageMetadata as PackageMetadata,
    types_PackageRegistrySchema as PackageRegistrySchema,
    types_PackageSchema as PackageSchema,
    types_PackageSnapshotSchema as PackageSnapshotSchema,
    types_PagesDomainSchema as PagesDomainSchema,
    types_PaginatedResponse as PaginatedResponse,
    types_PaginationRequestOptions as PaginationRequestOptions,
    types_PaginationTypes as PaginationTypes,
    types_PersonalAccessTokenSchema as PersonalAccessTokenSchema,
    types_PersonalAccessTokenScopes as PersonalAccessTokenScopes,
    types_PipelineScheduleSchema as PipelineScheduleSchema,
    types_PipelineSchema as PipelineSchema,
    types_PipelineStatus as PipelineStatus,
    types_PipelineTestCaseSchema as PipelineTestCaseSchema,
    types_PipelineTestReportSchema as PipelineTestReportSchema,
    types_PipelineTestReportSummarySchema as PipelineTestReportSummarySchema,
    types_PipelineTestSuiteSchema as PipelineTestSuiteSchema,
    types_PipelineTriggerTokenSchema as PipelineTriggerTokenSchema,
    types_PipelineVariableSchema as PipelineVariableSchema,
    types_ProcessMetricSchema as ProcessMetricSchema,
    types_ProjectAliasSchema as ProjectAliasSchema,
    types_ProjectBadgePreviewSchema as ProjectBadgePreviewSchema,
    types_ProjectBadgeSchema as ProjectBadgeSchema,
    types_ProjectExternalStatusCheckSchema as ProjectExternalStatusCheckSchema,
    types_ProjectFileUploadSchema as ProjectFileUploadSchema,
    types_ProjectHookSchema as ProjectHookSchema,
    types_ProjectIssueBoardSchema as ProjectIssueBoardSchema,
    types_ProjectLevelApprovalRuleSchema as ProjectLevelApprovalRuleSchema,
    types_ProjectLevelMergeRequestApprovalSchema as ProjectLevelMergeRequestApprovalSchema,
    types_ProjectRemoteMirrorSchema as ProjectRemoteMirrorSchema,
    types_ProjectRepositoryStorageMoveSchema as ProjectRepositoryStorageMoveSchema,
    types_ProjectSchema as ProjectSchema,
    types_ProjectStarrerSchema as ProjectStarrerSchema,
    types_ProjectStatisticSchema as ProjectStatisticSchema,
    types_ProjectStatisticsSchema as ProjectStatisticsSchema,
    types_ProjectStoragePath as ProjectStoragePath,
    types_ProjectTemplateSchema as ProjectTemplateSchema,
    types_ProjectTemplateType as ProjectTemplateType,
    types_ProjectVariableSchema as ProjectVariableSchema,
    types_ProjectVulnerabilitySchema as ProjectVulnerabilitySchema,
    types_ProtectedBranchAccessLevel as ProtectedBranchAccessLevel,
    types_ProtectedBranchSchema as ProtectedBranchSchema,
    types_ProtectedEnvironmentAccessLevel as ProtectedEnvironmentAccessLevel,
    types_ProtectedEnvironmentSchema as ProtectedEnvironmentSchema,
    types_ProtectedTagAccessLevel as ProtectedTagAccessLevel,
    types_ProtectedTagSchema as ProtectedTagSchema,
    types_PushRuleSchema as PushRuleSchema,
    types_RecipeSnapshotSchema as RecipeSnapshotSchema,
    types_ReferenceSchema as ReferenceSchema,
    types_RegistryRepositorySchema as RegistryRepositorySchema,
    types_RegistryRepositoryTagSchema as RegistryRepositoryTagSchema,
    types_RelatedEpicLinkSchema as RelatedEpicLinkSchema,
    types_RelatedEpicSchema as RelatedEpicSchema,
    types_ReleaseAssetLink as ReleaseAssetLink,
    types_ReleaseAssetSource as ReleaseAssetSource,
    types_ReleaseEvidence as ReleaseEvidence,
    types_ReleaseLinkSchema as ReleaseLinkSchema,
    types_ReleaseSchema as ReleaseSchema,
    types_RepositoryChangelogSchema as RepositoryChangelogSchema,
    types_RepositoryCompareSchema as RepositoryCompareSchema,
    types_RepositoryContributorSchema as RepositoryContributorSchema,
    types_RepositoryFileBlameSchema as RepositoryFileBlameSchema,
    types_RepositoryFileExpandedSchema as RepositoryFileExpandedSchema,
    types_RepositoryFileSchema as RepositoryFileSchema,
    types_RepositoryImportStatusSchema as RepositoryImportStatusSchema,
    types_RepositoryStorageMoveSchema as RepositoryStorageMoveSchema,
    types_RepositorySubmoduleSchema as RepositorySubmoduleSchema,
    types_RepositoryTreeSchema as RepositoryTreeSchema,
    types_ResourceGroupSchema as ResourceGroupSchema,
    types_ReviewAppSchema as ReviewAppSchema,
    types_RunnerSchema as RunnerSchema,
    types_RunnerToken as RunnerToken,
    types_SAMLGroupSchema as SAMLGroupSchema,
    types_SearchScopes as SearchScopes,
    types_SecureFileSchema as SecureFileSchema,
    types_ShowExpanded as ShowExpanded,
    types_SidekickCompoundMetricsSchema as SidekickCompoundMetricsSchema,
    types_SidekickJobStatsSchema as SidekickJobStatsSchema,
    types_SidekickProcessMetricsSchema as SidekickProcessMetricsSchema,
    types_SidekickQueueMetricsSchema as SidekickQueueMetricsSchema,
    types_SidekiqQueueStatus as SidekiqQueueStatus,
    types_SimpleGroupSchema as SimpleGroupSchema,
    types_SimpleMemberSchema as SimpleMemberSchema,
    types_SimpleProjectSchema as SimpleProjectSchema,
    types_SimpleSnippetSchema as SimpleSnippetSchema,
    types_SnippetNoteSchema as SnippetNoteSchema,
    types_SnippetRepositoryStorageMoveSchema as SnippetRepositoryStorageMoveSchema,
    types_SnippetSchema as SnippetSchema,
    types_SnippetVisibility as SnippetVisibility,
    types_StarredDashboardSchema as StarredDashboardSchema,
    types_StateEventSchema as StateEventSchema,
    types_StatisticsSchema as StatisticsSchema,
    types_Sudo as Sudo,
    types_SuggestionSchema as SuggestionSchema,
    types_SupportedIntegration as SupportedIntegration,
    types_SystemHookTestResponse as SystemHookTestResponse,
    types_TagSchema as TagSchema,
    types_TaskCompletionStatusSchema as TaskCompletionStatusSchema,
    types_TemplateSchema as TemplateSchema,
    types_TimeStatsSchema as TimeStatsSchema,
    types_TodoAction as TodoAction,
    types_TodoSchema as TodoSchema,
    types_TodoState as TodoState,
    types_TodoType as TodoType,
    types_TopicSchema as TopicSchema,
    types_UpdateMergeRequestOptions as UpdateMergeRequestOptions,
    types_UserActivitySchema as UserActivitySchema,
    types_UserCountSchema as UserCountSchema,
    types_UserEmailSchema as UserEmailSchema,
    types_UserGPGKeySchema as UserGPGKeySchema,
    types_UserImpersonationTokenSchema as UserImpersonationTokenSchema,
    types_UserMembershipSchema as UserMembershipSchema,
    types_UserPreferenceSchema as UserPreferenceSchema,
    types_UserSSHKeySchema as UserSSHKeySchema,
    types_UserSchema as UserSchema,
    types_UserStatusSchema as UserStatusSchema,
    types_VariableFilter as VariableFilter,
    types_VariableSchema as VariableSchema,
    types_VariableType as VariableType,
    types_VersionSchema as VersionSchema,
    types_VulnerabilityFindingSchema as VulnerabilityFindingSchema,
    types_VulnerabilitySchema as VulnerabilitySchema,
    types_WeightEventSchema as WeightEventSchema,
    types_WikiAttachmentSchema as WikiAttachmentSchema,
    types_WikiSchema as WikiSchema,
    types_X509SignatureSchema as X509SignatureSchema,
  };
}

export { Agents, AlertManagement, ApplicationAppearance, ApplicationPlanLimits, ApplicationSettings, ApplicationStatistics, Applications, AuditEvents, Avatar, Branches, BroadcastMessages, CommitDiscussions, Commits, Composer, Conan, ContainerRegistry, DashboardAnnotations, Debian, DependencyProxy, DeployKeys, DeployTokens, Deployments, DockerfileTemplates, Environments, EpicAwardEmojis, EpicDiscussions, EpicIssues, EpicLabelEvents, EpicLinks, EpicNotes, Epics, ErrorTrackingClientKeys, ErrorTrackingSettings, Events, Experiments, ExternalStatusChecks, FeatureFlagUserLists, FeatureFlags, FreezePeriods, GeoNodes, GitLabCIYMLTemplates, GitignoreTemplates, Gitlab, GitlabPages, GoProxy, GroupAccessRequests, GroupAccessTokens, GroupActivityAnalytics, GroupBadges, GroupCustomAttributes, GroupDORA4Metrics, GroupHooks, GroupImportExports, GroupInvitations, GroupIssueBoards, GroupIterations, GroupLDAPLinks, GroupLabels, GroupMembers, GroupMilestones, GroupProtectedEnvironments, GroupPushRules, GroupRelationExports, GroupReleases, GroupRepositoryStorageMoves, GroupSAMLIdentities, GroupSCIMIdentities, GroupVariables, GroupWikis, Groups, Helm, Import, InstanceLevelCICDVariables, Integrations, IssueAwardEmojis, IssueDiscussions, IssueIterationEvents, IssueLabelEvents, IssueLinks, IssueMilestoneEvents, IssueNoteAwardEmojis, IssueNotes, IssueStateEvents, IssueWeightEvents, Issues, IssuesStatistics, JobArtifacts, Jobs, Keys, License, LicenseTemplates, LinkedEpics, Lint, ManagedLicenses, Markdown, Maven, MergeRequestApprovals, MergeRequestAwardEmojis, MergeRequestContextCommits, MergeRequestDiscussions, MergeRequestLabelEvents, MergeRequestMilestoneEvents, MergeRequestNotes, MergeRequests, MergeTrains, Metadata, Migrations, NPM, Namespaces, NotificationSettings, NuGet, PackageRegistry, Packages, PagesDomains, PersonalAccessTokens, PipelineScheduleVariables, PipelineSchedules, PipelineTriggerTokens, Pipelines, ProductAnalytics, ProjectAccessRequests, ProjectAccessTokens, ProjectAliases, ProjectBadges, ProjectCustomAttributes, ProjectDORA4Metrics, ProjectHooks, ProjectImportExport, ProjectInvitations, ProjectIssueBoards, ProjectIterations, ProjectLabels, ProjectMembers, ProjectMilestones, ProjectProtectedEnvironments, ProjectPushRules, ProjectRelationsExport, ProjectReleases, ProjectRemoteMirrors, ProjectRepositoryStorageMoves, ProjectSnippetAwardEmojis, ProjectSnippetDiscussions, ProjectSnippetNotes, ProjectSnippets, ProjectStatistics, ProjectTemplates, ProjectVariables, ProjectVulnerabilities, ProjectWikis, Projects, ProtectedBranches, ProtectedTags, PyPI, ReleaseLinks, Repositories, RepositoryFiles, RepositorySubmodules, ResourceGroups, index as Resources, Runners, Search, SecureFiles, ServiceData, SidekiqMetrics, SidekiqQueues, SnippetRepositoryStorageMoves, Snippets, Suggestions, SystemHooks, Tags, TodoLists, Topics, types as Types, UserCustomAttributes, UserEmails, UserGPGKeys, UserImpersonationTokens, UserSSHKeys, UserStarredMetricsDashboard, Users, Version, VisualReviewDiscussions, Vulnerabilities, VulnerabilityFindings };
