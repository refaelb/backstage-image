import { decamelizeKeys } from 'xcase';
import { stringify } from 'qs';

// src/RequesterUtils.ts
function formatQuery(params = {}) {
  const decamelized = decamelizeKeys(params);
  return stringify(decamelized, { arrayFormat: "brackets" });
}
function isFormData(object) {
  return typeof object === "object" && object.constructor.name === "FormData";
}
function defaultOptionsHandler(resourceOptions, { body, searchParams, sudo, asStream = false, method = "get" } = {}) {
  const { headers: preconfiguredHeaders, requestTimeout, url } = resourceOptions;
  const headers = { ...preconfiguredHeaders };
  const defaultOptions = {
    headers,
    timeout: requestTimeout,
    method,
    asStream,
    prefixUrl: url
  };
  if (sudo)
    defaultOptions.headers.sudo = sudo;
  if (body) {
    if (isFormData(body)) {
      defaultOptions.body = body;
    } else {
      defaultOptions.body = JSON.stringify(decamelizeKeys(body));
      headers["content-type"] = "application/json";
    }
  }
  const q = formatQuery(searchParams);
  if (q)
    defaultOptions.searchParams = q;
  return Promise.resolve(defaultOptions);
}
function createRequesterFn(optionsHandler, requestHandler) {
  const methods = ["get", "post", "put", "patch", "delete"];
  return (serviceOptions) => {
    const requester = {};
    methods.forEach((m) => {
      requester[m] = async (endpoint, options) => {
        const requestOptions = await optionsHandler(serviceOptions, { ...options, method: m });
        return requestHandler(endpoint, requestOptions);
      };
    });
    return requester;
  };
}
function extendClass(Base, customConfig = {}) {
  return class extends Base {
    constructor(...options) {
      const [config, ...opts] = options;
      super({ ...customConfig, ...config }, ...opts);
    }
  };
}
function presetResourceArguments(resources, customConfig = {}) {
  const updated = {};
  Object.entries(resources).filter(([, s]) => typeof s === "function").forEach(([k, r]) => {
    updated[k] = extendClass(r, customConfig);
  });
  return updated;
}

// src/BaseResource.ts
var BaseResource = class {
  url;
  requester;
  requestTimeout;
  headers;
  camelize;
  rejectUnauthorized;
  constructor({
    token,
    jobToken,
    oauthToken,
    sudo,
    profileToken,
    requesterFn,
    camelize,
    profileMode = "execution",
    host = "https://gitlab.com",
    prefixUrl = "",
    rejectUnauthorized = true,
    requestTimeout = 3e5
  } = {}) {
    if (!requesterFn)
      throw new ReferenceError("requesterFn must be passed");
    this.url = [host, "api", "v4", prefixUrl].join("/");
    this.headers = {};
    this.rejectUnauthorized = rejectUnauthorized;
    this.camelize = camelize;
    this.requestTimeout = requestTimeout;
    if (oauthToken)
      this.headers.authorization = `Bearer ${oauthToken}`;
    else if (jobToken)
      this.headers["job-token"] = jobToken;
    else if (token)
      this.headers["private-token"] = token;
    if (profileToken) {
      this.headers["X-Profile-Token"] = profileToken;
      this.headers["X-Profile-Mode"] = profileMode;
    }
    if (sudo)
      this.headers.Sudo = `${sudo}`;
    this.requester = requesterFn({ ...this });
  }
};

export { BaseResource, createRequesterFn, defaultOptionsHandler, formatQuery, presetResourceArguments };
