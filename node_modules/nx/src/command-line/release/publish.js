"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.publishHandler = void 0;
const nx_json_1 = require("../../config/nx-json");
const project_graph_1 = require("../../project-graph/project-graph");
const run_command_1 = require("../../tasks-runner/run-command");
const command_line_utils_1 = require("../../utils/command-line-utils");
const find_matching_projects_1 = require("../../utils/find-matching-projects");
const logger_1 = require("../../utils/logger");
const output_1 = require("../../utils/output");
const graph_1 = require("../graph/graph");
const config_1 = require("./config/config");
const create_release_groups_1 = require("./config/create-release-groups");
async function publishHandler(args) {
    const projectGraph = await (0, project_graph_1.createProjectGraphAsync)({ exitOnError: true });
    const nxJson = (0, nx_json_1.readNxJson)();
    // Apply default configuration to any optional user configuration
    const nxReleaseConfig = (0, config_1.createNxReleaseConfig)(nxJson.release);
    const releaseGroupsData = await (0, create_release_groups_1.createReleaseGroups)(projectGraph, nxReleaseConfig.groups);
    if (releaseGroupsData.error) {
        return await (0, create_release_groups_1.handleCreateReleaseGroupsError)(releaseGroupsData.error);
    }
    let { releaseGroups } = releaseGroupsData;
    /**
     * User is filtering to a subset of projects. We need to make sure that what they have provided can be reconciled
     * against their configuration in terms of release groups and the ungroupedProjectsHandling option.
     */
    if (args.projects?.length) {
        const matchingProjectsForFilter = (0, find_matching_projects_1.findMatchingProjects)(args.projects, projectGraph.nodes);
        if (!matchingProjectsForFilter.length) {
            output_1.output.error({
                title: `Your --projects filter "${args.projects}" did not match any projects in the workspace`,
            });
            process.exit(1);
        }
        const filteredProjectToReleaseGroup = new Map();
        const releaseGroupToFilteredProjects = new Map();
        // Figure out which release groups, if any, that the filtered projects belong to so that we can resolve other config
        for (const releaseGroup of releaseGroups) {
            const matchingProjectsForReleaseGroup = (0, find_matching_projects_1.findMatchingProjects)(releaseGroup.projects, projectGraph.nodes);
            for (const matchingProject of matchingProjectsForFilter) {
                if (matchingProjectsForReleaseGroup.includes(matchingProject)) {
                    filteredProjectToReleaseGroup.set(matchingProject, releaseGroup);
                    if (!releaseGroupToFilteredProjects.has(releaseGroup)) {
                        releaseGroupToFilteredProjects.set(releaseGroup, new Set());
                    }
                    releaseGroupToFilteredProjects.get(releaseGroup).add(matchingProject);
                }
            }
        }
        /**
         * If there are release groups specified, each filtered project must match at least one release
         * group, otherwise the command + config combination is invalid.
         */
        if (Object.keys(nxReleaseConfig.groups).length) {
            const unmatchedProjects = matchingProjectsForFilter.filter((p) => !filteredProjectToReleaseGroup.has(p));
            if (unmatchedProjects.length) {
                output_1.output.error({
                    title: `The following projects which match your projects filter "${args.projects}" did not match any configured release groups:`,
                    bodyLines: unmatchedProjects.map((p) => `- ${p}`),
                });
                process.exit(1);
            }
        }
        output_1.output.note({
            title: `Your filter "${args.projects}" matched the following projects:`,
            bodyLines: matchingProjectsForFilter.map((p) => {
                const releaseGroupForProject = filteredProjectToReleaseGroup.get(p);
                if (releaseGroupForProject.name === create_release_groups_1.CATCH_ALL_RELEASE_GROUP) {
                    return `- ${p}`;
                }
                return `- ${p} (release group "${releaseGroupForProject.name}")`;
            }),
        });
        // Filter the releaseGroups collection appropriately
        releaseGroups = releaseGroups.filter((rg) => releaseGroupToFilteredProjects.has(rg));
        /**
         * Run publishing for all remaining release groups and filtered projects within them
         */
        for (const releaseGroup of releaseGroups) {
            await runPublishOnProjects(args, projectGraph, nxJson, Array.from(releaseGroupToFilteredProjects.get(releaseGroup)));
        }
        return process.exit(0);
    }
    /**
     * The user is filtering by release group
     */
    if (args.groups?.length) {
        releaseGroups = releaseGroups.filter((g) => args.groups?.includes(g.name));
    }
    // Should be an impossible state, as we should have explicitly handled any errors/invalid config by now
    if (!releaseGroups.length) {
        output_1.output.error({
            title: `No projects could be matched for versioning, please report this case and include your nx.json config`,
        });
        process.exit(1);
    }
    /**
     * Run publishing for all remaining release groups
     */
    for (const releaseGroup of releaseGroups) {
        await runPublishOnProjects(args, projectGraph, nxJson, releaseGroup.projects);
    }
    if (args.dryRun) {
        logger_1.logger.warn(`\nNOTE: The "dryRun" flag means no projects were actually published.`);
    }
    process.exit(0);
}
exports.publishHandler = publishHandler;
async function runPublishOnProjects(args, projectGraph, nxJson, projectNames) {
    const projectsToRun = projectNames.map((projectName) => projectGraph.nodes[projectName]);
    const overrides = (0, command_line_utils_1.createOverrides)(args.__overrides_unparsed__);
    if (args.registry) {
        overrides.registry = args.registry;
    }
    if (args.tag) {
        overrides.tag = args.tag;
    }
    if (args.dryRun) {
        overrides.dryRun = args.dryRun;
    }
    if (args.verbose) {
        process.env.NX_VERBOSE_LOGGING = 'true';
    }
    const targets = ['nx-release-publish'];
    if (args.graph) {
        const file = (0, command_line_utils_1.readGraphFileFromGraphArg)(args);
        const projectNames = projectsToRun.map((t) => t.name);
        return await (0, graph_1.generateGraph)({
            watch: false,
            all: false,
            open: true,
            view: 'tasks',
            targets,
            projects: projectNames,
            file,
        }, projectNames);
    }
    else {
        /**
         * Run the relevant nx-release-publish executor on each of the selected projects.
         */
        const status = await (0, run_command_1.runCommand)(projectsToRun, projectGraph, { nxJson }, {
            targets,
            outputStyle: 'static',
            ...args,
        }, overrides, null, {}, { excludeTaskDependencies: false, loadDotEnvFiles: true });
        if (status !== 0) {
            // fix for https://github.com/nrwl/nx/issues/1666
            if (process.stdin['unref'])
                process.stdin.unref();
            process.exit(status);
        }
    }
}
