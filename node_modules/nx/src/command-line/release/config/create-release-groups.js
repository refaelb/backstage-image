"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.handleCreateReleaseGroupsError = exports.createReleaseGroups = exports.CATCH_ALL_RELEASE_GROUP = void 0;
const devkit_exports_1 = require("../../../devkit-exports");
const find_matching_projects_1 = require("../../../utils/find-matching-projects");
const project_graph_utils_1 = require("../../../utils/project-graph-utils");
const resolve_nx_json_error_message_1 = require("../utils/resolve-nx-json-error-message");
exports.CATCH_ALL_RELEASE_GROUP = '__default__';
/**
 * Create a set of release groups based on the relevant user specified config ready
 * to be consumed by the release commands.
 */
async function createReleaseGroups(projectGraph, userSpecifiedGroups = {}, requiredTargetName) {
    const DEFAULT_VERSION_GENERATOR = '@nx/js:release-version';
    const DEFAULT_VERSION_GENERATOR_OPTIONS = {};
    const allProjects = (0, find_matching_projects_1.findMatchingProjects)(['*'], projectGraph.nodes);
    /**
     * No user specified release groups, so we treat all projects as being in one release group
     * together in which all projects are released in lock step.
     */
    if (Object.keys(userSpecifiedGroups).length === 0) {
        // Ensure all projects have the relevant target available, if applicable
        if (requiredTargetName) {
            const error = ensureProjectsHaveTarget(allProjects, projectGraph, requiredTargetName);
            if (error) {
                return {
                    error,
                    releaseGroups: [],
                };
            }
        }
        return {
            error: null,
            releaseGroups: [
                {
                    name: exports.CATCH_ALL_RELEASE_GROUP,
                    projects: allProjects,
                    version: {
                        generator: DEFAULT_VERSION_GENERATOR,
                        generatorOptions: DEFAULT_VERSION_GENERATOR_OPTIONS,
                    },
                },
            ],
        };
    }
    /**
     * The user has specified at least one release group.
     *
     * Resolve all the project names into their release groups, and check
     * that individual projects are not found in multiple groups.
     */
    const releaseGroups = [];
    const alreadyMatchedProjects = new Set();
    for (const [releaseGroupName, userSpecifiedGroup] of Object.entries(userSpecifiedGroups)) {
        // Ensure that the user config for the release group can resolve at least one project
        const matchingProjects = (0, find_matching_projects_1.findMatchingProjects)(Array.isArray(userSpecifiedGroup.projects)
            ? userSpecifiedGroup.projects
            : [userSpecifiedGroup.projects], projectGraph.nodes);
        if (!matchingProjects.length) {
            return {
                error: {
                    code: 'RELEASE_GROUP_MATCHES_NO_PROJECTS',
                    data: {
                        releaseGroupName: releaseGroupName,
                    },
                },
                releaseGroups: [],
            };
        }
        // Ensure all matching projects have the relevant target available, if applicable
        if (requiredTargetName) {
            const error = ensureProjectsHaveTarget(matchingProjects, projectGraph, requiredTargetName);
            if (error) {
                return {
                    error,
                    releaseGroups: [],
                };
            }
        }
        for (const project of matchingProjects) {
            if (alreadyMatchedProjects.has(project)) {
                return {
                    error: {
                        code: 'PROJECT_MATCHES_MULTIPLE_GROUPS',
                        data: {
                            project,
                        },
                    },
                    releaseGroups: [],
                };
            }
            alreadyMatchedProjects.add(project);
        }
        releaseGroups.push({
            name: releaseGroupName,
            projects: matchingProjects,
            version: userSpecifiedGroup.version
                ? {
                    generator: userSpecifiedGroup.version.generator || DEFAULT_VERSION_GENERATOR,
                    generatorOptions: userSpecifiedGroup.version.generatorOptions ||
                        DEFAULT_VERSION_GENERATOR_OPTIONS,
                }
                : {
                    generator: DEFAULT_VERSION_GENERATOR,
                    generatorOptions: DEFAULT_VERSION_GENERATOR_OPTIONS,
                },
        });
    }
    return {
        error: null,
        releaseGroups,
    };
}
exports.createReleaseGroups = createReleaseGroups;
async function handleCreateReleaseGroupsError(error) {
    switch (error.code) {
        case 'RELEASE_GROUP_MATCHES_NO_PROJECTS':
            {
                const nxJsonMessage = await (0, resolve_nx_json_error_message_1.resolveNxJsonConfigErrorMessage)([
                    'release',
                    'groups',
                ]);
                devkit_exports_1.output.error({
                    title: `Release group "${error.data.releaseGroupName}" matches no projects. Please ensure all release groups match at least one project:`,
                    bodyLines: [nxJsonMessage],
                });
            }
            break;
        case 'PROJECT_MATCHES_MULTIPLE_GROUPS':
            {
                const nxJsonMessage = await (0, resolve_nx_json_error_message_1.resolveNxJsonConfigErrorMessage)([
                    'release',
                    'groups',
                ]);
                devkit_exports_1.output.error({
                    title: `Project "${error.data.project}" matches multiple release groups. Please ensure all projects are part of only one release group:`,
                    bodyLines: [nxJsonMessage],
                });
            }
            break;
        case 'PROJECTS_MISSING_TARGET':
            {
                devkit_exports_1.output.error({
                    title: `Based on your config, the following projects were matched for release but do not have a "${error.data.targetName}" target specified. Please ensure you have an appropriate plugin such as @nx/js installed, or have configured the target manually, or exclude the projects using release groups config in nx.json:`,
                    bodyLines: Array.from(error.data.projects).map((name) => `- ${name}`),
                });
            }
            break;
        default:
            throw new Error(`Unhandled error code: ${error.code}`);
    }
    process.exit(1);
}
exports.handleCreateReleaseGroupsError = handleCreateReleaseGroupsError;
function ensureProjectsHaveTarget(projects, projectGraph, requiredTargetName) {
    const missingTargetProjects = projects.filter((project) => !(0, project_graph_utils_1.projectHasTarget)(projectGraph.nodes[project], requiredTargetName));
    if (missingTargetProjects.length) {
        return {
            code: 'PROJECTS_MISSING_TARGET',
            data: {
                targetName: requiredTargetName,
                projects: missingTargetProjects,
            },
        };
    }
    return null;
}
