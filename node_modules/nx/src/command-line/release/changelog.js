"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.changelogHandler = void 0;
const chalk = require("chalk");
const node_fs_1 = require("node:fs");
const semver_1 = require("semver");
const tmp_1 = require("tmp");
const tree_1 = require("../../generators/tree");
const logger_1 = require("../../utils/logger");
const output_1 = require("../../utils/output");
const path_1 = require("../../utils/path");
const workspace_root_1 = require("../../utils/workspace-root");
const git_1 = require("./utils/git");
const github_1 = require("./utils/github");
const launch_editor_1 = require("./utils/launch-editor");
const markdown_1 = require("./utils/markdown");
const print_changes_1 = require("./utils/print-changes");
async function changelogHandler(args) {
    /**
     * TODO: allow the prefix and version to be controllable via config as well once we flesh out
     * changelog customization, and how it will interact with independently released projects.
     */
    const tagVersionPrefix = args.tagVersionPrefix ?? 'v';
    // Allow the user to pass the version with or without the prefix already applied
    const releaseVersion = args.version.startsWith(tagVersionPrefix)
        ? args.version
        : `${tagVersionPrefix}${args.version}`;
    // We are either creating/previewing a changelog file, a Github release, or both
    let logTitle = args.dryRun ? 'Previewing a ' : 'Generating a ';
    switch (true) {
        case args.file !== false && args.createRelease === 'github':
            logTitle += `${args.file} entry and a Github release for ${chalk.white(releaseVersion)}`;
            break;
        case args.file !== false:
            logTitle += `${args.file} entry for ${chalk.white(releaseVersion)}`;
            break;
        case args.createRelease === 'github':
            logTitle += `Github release for ${chalk.white(releaseVersion)}`;
    }
    output_1.output.log({
        title: logTitle,
    });
    const from = args.from || (await (0, git_1.getLastGitTag)());
    if (!from) {
        output_1.output.error({
            title: `Unable to determine the previous git tag, please provide an explicit git reference using --from`,
        });
        process.exit(1);
    }
    const rawCommits = await (0, git_1.getGitDiff)(from, args.to);
    // Parse as conventional commits
    const commits = (0, git_1.parseCommits)(rawCommits).filter((c) => {
        const type = c.type;
        // Always ignore non user-facing commits for now
        // TODO: allow this filter to be configurable via config in a future release
        if (type === 'feat' || type === 'fix' || type === 'perf') {
            return true;
        }
        return false;
    });
    const githubRepoSlug = args.createRelease === 'github'
        ? (0, github_1.getGitHubRepoSlug)(args.gitRemote)
        : undefined;
    const finalMarkdown = await resolveFinalMarkdown(args, commits, releaseVersion, githubRepoSlug);
    /**
     * The exact logic we use for printing the summary/diff to the user is dependent upon whether they are creating
     * a CHANGELOG.md file, a Github release, or both.
     */
    let printSummary = () => { };
    const noDiffInChangelogMessage = chalk.yellow(`NOTE: There was no diff detected for the changelog entry. Maybe you intended to pass alternative git references via --from and --to?`);
    if (args.file !== false) {
        const tree = new tree_1.FsTree(workspace_root_1.workspaceRoot, args.verbose);
        let rootChangelogContents = tree.read(args.file)?.toString() ?? '';
        if (rootChangelogContents) {
            const changelogReleases = (0, markdown_1.parseChangelogMarkdown)(rootChangelogContents, args.tagVersionPrefix).releases;
            const existingVersionToUpdate = changelogReleases.find((r) => `${tagVersionPrefix}${r.version}` === releaseVersion);
            if (existingVersionToUpdate) {
                rootChangelogContents = rootChangelogContents.replace(`## ${releaseVersion}\n\n\n${existingVersionToUpdate.body}`, finalMarkdown);
            }
            else {
                // No existing version, simply prepend the new release to the top of the file
                rootChangelogContents = `${finalMarkdown}\n\n${rootChangelogContents}`;
            }
        }
        else {
            // No existing changelog contents, simply create a new one using the generated markdown
            rootChangelogContents = finalMarkdown;
        }
        tree.write(args.file, rootChangelogContents);
        printSummary = () => (0, print_changes_1.printChanges)(tree, !!args.dryRun, 3, false, noDiffInChangelogMessage);
    }
    if (args.createRelease === 'github') {
        if (!githubRepoSlug) {
            output_1.output.error({
                title: `Unable to create a Github release because the Github repo slug could not be determined.`,
                bodyLines: [
                    `Please ensure you have a valid Github remote configured. You can run \`git remote -v\` to list your current remotes.`,
                ],
            });
            process.exit(1);
        }
        const token = await (0, github_1.resolveGithubToken)();
        const githubRequestConfig = {
            repo: githubRepoSlug,
            token,
        };
        let existingGithubReleaseForVersion;
        try {
            existingGithubReleaseForVersion = await (0, github_1.getGithubReleaseByTag)(githubRequestConfig, releaseVersion);
        }
        catch (err) {
            if (err.response?.status === 401) {
                output_1.output.error({
                    title: `Unable to resolve data via the Github API. You can use any of the following options to resolve this:`,
                    bodyLines: [
                        '- Set the `GITHUB_TOKEN` or `GH_TOKEN` environment variable to a valid Github token with `repo` scope',
                        '- Have an active session via the official gh CLI tool (https://cli.github.com) in your current terminal',
                    ],
                });
                process.exit(1);
            }
            if (err.response?.status === 404) {
                // No existing release found, this is fine
            }
            else {
                // Rethrow unknown errors for now
                throw err;
            }
        }
        let existingPrintSummaryFn = printSummary;
        printSummary = () => {
            const logTitle = `https://github.com/${githubRepoSlug}/releases/tag/${releaseVersion}`;
            if (existingGithubReleaseForVersion) {
                console.error(`${chalk.white('UPDATE')} ${logTitle}${args.dryRun ? chalk.keyword('orange')(' [dry-run]') : ''}`);
            }
            else {
                console.error(`${chalk.green('CREATE')} ${logTitle}${args.dryRun ? chalk.keyword('orange')(' [dry-run]') : ''}`);
            }
            // Only print the diff here if we are not already going to be printing changes from the Tree
            if (args.file === false) {
                console.log('');
                (0, print_changes_1.printDiff)(existingGithubReleaseForVersion
                    ? existingGithubReleaseForVersion.body
                    : '', finalMarkdown, 3, noDiffInChangelogMessage);
            }
            existingPrintSummaryFn();
        };
        if (!args.dryRun) {
            await (0, github_1.createOrUpdateGithubRelease)(githubRequestConfig, {
                version: releaseVersion,
                body: finalMarkdown,
                prerelease: isPrerelease(releaseVersion.replace(args.tagVersionPrefix, '')),
            }, existingGithubReleaseForVersion);
        }
    }
    printSummary();
    if (args.dryRun) {
        logger_1.logger.warn(`\nNOTE: The "dryRun" flag means no changes were made.`);
    }
    process.exit(0);
}
exports.changelogHandler = changelogHandler;
/**
 * Based on the commits available, and some optional additional user modifications,
 * generate the final markdown for the changelog which will be used for a CHANGELOG.md
 * file and/or a Github release.
 */
async function resolveFinalMarkdown(args, commits, releaseVersion, githubRepoSlug) {
    let markdown = await (0, markdown_1.generateMarkdown)(commits, releaseVersion, githubRepoSlug);
    /**
     * If interactive mode, make the markdown available for the user to modify in their editor of choice,
     * in a similar style to git interactive rebases/merges.
     */
    if (args.interactive) {
        const tmpDir = (0, tmp_1.dirSync)().name;
        const changelogPath = (0, path_1.joinPathFragments)(tmpDir, 'c.md');
        (0, node_fs_1.writeFileSync)(changelogPath, markdown);
        await (0, launch_editor_1.launchEditor)(changelogPath);
        markdown = (0, node_fs_1.readFileSync)(changelogPath, 'utf-8');
    }
    return markdown;
}
function isPrerelease(version) {
    // prerelease returns an array of matching prerelease "components", or null if the version is not a prerelease
    return (0, semver_1.prerelease)(version) !== null;
}
