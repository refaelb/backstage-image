"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.versionHandler = exports.deriveNewSemverVersion = void 0;
const chalk = require("chalk");
const enquirer = require("enquirer");
const node_fs_1 = require("node:fs");
const node_path_1 = require("node:path");
const semver_1 = require("semver");
const nx_json_1 = require("../../config/nx-json");
const devkit_exports_1 = require("../../devkit-exports");
const tree_1 = require("../../generators/tree");
const project_graph_1 = require("../../project-graph/project-graph");
const find_matching_projects_1 = require("../../utils/find-matching-projects");
const params_1 = require("../../utils/params");
const generate_1 = require("../generate/generate");
const generator_utils_1 = require("../generate/generator-utils");
const config_1 = require("./config/config");
const create_release_groups_1 = require("./config/create-release-groups");
const print_changes_1 = require("./utils/print-changes");
const semver_2 = require("./utils/semver");
// Reexport for use in plugin release-version generator implementations
var semver_3 = require("./utils/semver");
Object.defineProperty(exports, "deriveNewSemverVersion", { enumerable: true, get: function () { return semver_3.deriveNewSemverVersion; } });
async function versionHandler(args) {
    const projectGraph = await (0, project_graph_1.createProjectGraphAsync)({ exitOnError: true });
    const nxJson = (0, nx_json_1.readNxJson)();
    if (args.verbose) {
        process.env.NX_VERBOSE_LOGGING = 'true';
    }
    // Apply default configuration to any optional user configuration
    const nxReleaseConfig = (0, config_1.createNxReleaseConfig)(nxJson.release);
    const releaseGroupsData = await (0, create_release_groups_1.createReleaseGroups)(projectGraph, nxReleaseConfig.groups);
    if (releaseGroupsData.error) {
        return await (0, create_release_groups_1.handleCreateReleaseGroupsError)(releaseGroupsData.error);
    }
    const tree = new tree_1.FsTree(devkit_exports_1.workspaceRoot, args.verbose);
    let { releaseGroups } = releaseGroupsData;
    /**
     * User is filtering to a subset of projects. We need to make sure that what they have provided can be reconciled
     * against their configuration in terms of release groups and the ungroupedProjectsHandling option.
     */
    if (args.projects?.length) {
        const matchingProjectsForFilter = (0, find_matching_projects_1.findMatchingProjects)(args.projects, projectGraph.nodes);
        if (!matchingProjectsForFilter.length) {
            devkit_exports_1.output.error({
                title: `Your --projects filter "${args.projects}" did not match any projects in the workspace`,
            });
            process.exit(1);
        }
        const filteredProjectToReleaseGroup = new Map();
        const releaseGroupToFilteredProjects = new Map();
        // Figure out which release groups, if any, that the filtered projects belong to so that we can resolve other config
        for (const releaseGroup of releaseGroups) {
            const matchingProjectsForReleaseGroup = (0, find_matching_projects_1.findMatchingProjects)(releaseGroup.projects, projectGraph.nodes);
            for (const matchingProject of matchingProjectsForFilter) {
                if (matchingProjectsForReleaseGroup.includes(matchingProject)) {
                    filteredProjectToReleaseGroup.set(matchingProject, releaseGroup);
                    if (!releaseGroupToFilteredProjects.has(releaseGroup)) {
                        releaseGroupToFilteredProjects.set(releaseGroup, new Set());
                    }
                    releaseGroupToFilteredProjects.get(releaseGroup).add(matchingProject);
                }
            }
        }
        /**
         * If there are release groups specified, each filtered project must match at least one release
         * group, otherwise the command + config combination is invalid.
         */
        if (Object.keys(nxReleaseConfig.groups).length) {
            const unmatchedProjects = matchingProjectsForFilter.filter((p) => !filteredProjectToReleaseGroup.has(p));
            if (unmatchedProjects.length) {
                devkit_exports_1.output.error({
                    title: `The following projects which match your projects filter "${args.projects}" did not match any configured release groups:`,
                    bodyLines: unmatchedProjects.map((p) => `- ${p}`),
                });
                process.exit(1);
            }
        }
        devkit_exports_1.output.note({
            title: `Your filter "${args.projects}" matched the following projects:`,
            bodyLines: matchingProjectsForFilter.map((p) => {
                const releaseGroupForProject = filteredProjectToReleaseGroup.get(p);
                if (releaseGroupForProject.name === create_release_groups_1.CATCH_ALL_RELEASE_GROUP) {
                    return `- ${p}`;
                }
                return `- ${p} (release group "${releaseGroupForProject.name}")`;
            }),
        });
        // Filter the releaseGroups collection appropriately
        releaseGroups = releaseGroups.filter((rg) => releaseGroupToFilteredProjects.has(rg));
        /**
         * Run semver versioning for all remaining release groups and filtered projects within them
         */
        for (const releaseGroup of releaseGroups) {
            const releaseGroupName = releaseGroup.name;
            // Resolve the generator data for the current release group
            const generatorData = resolveGeneratorData({
                ...extractGeneratorCollectionAndName(`release-group "${releaseGroupName}"`, releaseGroup.version.generator),
                configGeneratorOptions: releaseGroup.version.generatorOptions,
            });
            const semverSpecifier = await resolveSemverSpecifier(args.specifier, `What kind of change is this for the ${releaseGroupToFilteredProjects.get(releaseGroup).size} matched project(s) within release group "${releaseGroupName}"?`, `What is the exact version for the ${releaseGroupToFilteredProjects.get(releaseGroup).size} matched project(s) within release group "${releaseGroupName}"?`);
            await runVersionOnProjects(projectGraph, nxJson, args, tree, generatorData, Array.from(releaseGroupToFilteredProjects.get(releaseGroup)), semverSpecifier);
        }
        printChanges(tree, !!args.dryRun);
        return process.exit(0);
    }
    /**
     * The user is filtering by release group
     */
    if (args.groups?.length) {
        releaseGroups = releaseGroups.filter((g) => args.groups?.includes(g.name));
    }
    // Should be an impossible state, as we should have explicitly handled any errors/invalid config by now
    if (!releaseGroups.length) {
        devkit_exports_1.output.error({
            title: `No projects could be matched for versioning, please report this case and include your nx.json config`,
        });
        process.exit(1);
    }
    /**
     * Run semver versioning for all remaining release groups
     */
    for (const releaseGroup of releaseGroups) {
        const releaseGroupName = releaseGroup.name;
        // Resolve the generator data for the current release group
        const generatorData = resolveGeneratorData({
            ...extractGeneratorCollectionAndName(`release-group "${releaseGroupName}"`, releaseGroup.version.generator),
            configGeneratorOptions: releaseGroup.version.generatorOptions,
        });
        const semverSpecifier = await resolveSemverSpecifier(args.specifier, releaseGroupName === create_release_groups_1.CATCH_ALL_RELEASE_GROUP
            ? `What kind of change is this for all packages?`
            : `What kind of change is this for release group "${releaseGroupName}"?`, releaseGroupName === create_release_groups_1.CATCH_ALL_RELEASE_GROUP
            ? `What is the exact version for all packages?`
            : `What is the exact version for release group "${releaseGroupName}"?`);
        await runVersionOnProjects(projectGraph, nxJson, args, tree, generatorData, releaseGroup.projects, semverSpecifier);
    }
    printChanges(tree, !!args.dryRun);
    process.exit(0);
}
exports.versionHandler = versionHandler;
async function runVersionOnProjects(projectGraph, nxJson, args, tree, generatorData, projectNames, newVersionSpecifier) {
    // Should be impossible state
    if (!newVersionSpecifier) {
        devkit_exports_1.output.error({
            title: `No version or semver keyword could be determined`,
        });
        process.exit(1);
    }
    // Specifier could be user provided so we need to validate it
    if (!(0, semver_1.valid)(newVersionSpecifier) &&
        !(0, semver_2.isRelativeVersionKeyword)(newVersionSpecifier)) {
        devkit_exports_1.output.error({
            title: `The given version specifier "${newVersionSpecifier}" is not valid. You provide an exact version or a valid semver keyword such as "major", "minor", "patch", etc.`,
        });
        process.exit(1);
    }
    const generatorOptions = {
        projects: projectNames.map((p) => projectGraph.nodes[p]),
        projectGraph,
        specifier: newVersionSpecifier,
        preid: args.preid,
        ...generatorData.configGeneratorOptions,
    };
    // Apply generator defaults from schema.json file etc
    const combinedOpts = await (0, params_1.combineOptionsForGenerator)(generatorOptions, generatorData.collectionName, generatorData.normalizedGeneratorName, (0, project_graph_1.readProjectsConfigurationFromProjectGraph)(projectGraph), nxJson, generatorData.schema, false, null, (0, node_path_1.relative)(process.cwd(), devkit_exports_1.workspaceRoot), args.verbose);
    const releaseVersionGenerator = generatorData.implementationFactory();
    await releaseVersionGenerator(tree, combinedOpts);
}
function printChanges(tree, isDryRun) {
    const changes = tree.listChanges();
    console.log('');
    // Print the changes
    changes.forEach((f) => {
        if (f.type === 'CREATE') {
            console.error(`${chalk.green('CREATE')} ${f.path}${isDryRun ? chalk.keyword('orange')(' [dry-run]') : ''}`);
            (0, print_changes_1.printDiff)('', f.content?.toString() || '');
        }
        else if (f.type === 'UPDATE') {
            console.error(`${chalk.white('UPDATE')} ${f.path}${isDryRun ? chalk.keyword('orange')(' [dry-run]') : ''}`);
            const currentContentsOnDisk = (0, node_fs_1.readFileSync)((0, devkit_exports_1.joinPathFragments)(tree.root, f.path)).toString();
            (0, print_changes_1.printDiff)(currentContentsOnDisk, f.content?.toString() || '');
        }
        else if (f.type === 'DELETE') {
            throw new Error('Unexpected DELETE change, please report this as an issue');
        }
    });
    if (!isDryRun) {
        (0, tree_1.flushChanges)(devkit_exports_1.workspaceRoot, changes);
    }
    if (isDryRun) {
        devkit_exports_1.logger.warn(`\nNOTE: The "dryRun" flag means no changes were made.`);
    }
}
async function resolveSemverSpecifier(cliArgSpecifier, selectionMessage, customVersionMessage) {
    try {
        let newVersionSpecifier = cliArgSpecifier;
        // If the user didn't provide a new version specifier directly on the CLI, prompt for one
        if (!newVersionSpecifier) {
            const reply = await enquirer.prompt([
                {
                    name: 'specifier',
                    message: selectionMessage,
                    type: 'select',
                    choices: [
                        ...semver_1.RELEASE_TYPES.map((t) => ({ name: t, message: t })),
                        {
                            name: 'custom',
                            message: 'Custom exact version',
                        },
                    ],
                },
            ]);
            if (reply.specifier !== 'custom') {
                newVersionSpecifier = reply.specifier;
            }
            else {
                const reply = await enquirer.prompt([
                    {
                        name: 'specifier',
                        message: customVersionMessage,
                        type: 'input',
                        validate: (input) => {
                            if ((0, semver_1.valid)(input)) {
                                return true;
                            }
                            return 'Please enter a valid semver version';
                        },
                    },
                ]);
                newVersionSpecifier = reply.specifier;
            }
        }
        return newVersionSpecifier;
    }
    catch {
        // We need to catch the error from enquirer prompt, otherwise yargs will print its help
        process.exit(1);
    }
}
function extractGeneratorCollectionAndName(description, generatorString) {
    let collectionName;
    let generatorName;
    const parsedGeneratorString = (0, generate_1.parseGeneratorString)(generatorString);
    collectionName = parsedGeneratorString.collection;
    generatorName = parsedGeneratorString.generator;
    if (!collectionName || !generatorName) {
        throw new Error(`Invalid generator string: ${generatorString} used for ${description}. Must be in the format of [collectionName]:[generatorName]`);
    }
    return { collectionName, generatorName };
}
function resolveGeneratorData({ collectionName, generatorName, configGeneratorOptions, }) {
    const { normalizedGeneratorName, schema, implementationFactory } = (0, generator_utils_1.getGeneratorInformation)(collectionName, generatorName, devkit_exports_1.workspaceRoot);
    return {
        collectionName,
        generatorName,
        configGeneratorOptions,
        normalizedGeneratorName,
        schema,
        implementationFactory,
    };
}
