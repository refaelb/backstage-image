"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.readTargetDefaultsForTarget = exports.resolveNxTokensInOptions = exports.mergeTargetConfigurations = exports.readProjectConfigurationsFromRootMap = exports.buildProjectsConfigurationsFromProjectPathsAndPlugins = exports.mergeProjectConfigurationIntoRootMap = void 0;
const node_path_1 = require("node:path");
const logger_1 = require("../../utils/logger");
const workspace_root_1 = require("../../utils/workspace-root");
const minimatch = require("minimatch");
function mergeProjectConfigurationIntoRootMap(projectRootMap, project, 
// project.json is a special case, so we need to detect it.
file) {
    const matchingProject = projectRootMap.get(project.root);
    if (!matchingProject) {
        projectRootMap.set(project.root, project);
        return;
    }
    else if (project.name &&
        project.name !== matchingProject.name &&
        (0, node_path_1.basename)(file) === 'project.json') {
        // `name` inside project.json overrides any names from
        // inference plugins
        matchingProject.name = project.name;
    }
    // This handles top level properties that are overwritten.
    // e.g. `srcRoot`, `projectType`, or other fields that shouldn't be extended
    // Note: `name` is set specifically here to keep it from changing. The name is
    // always determined by the first inference plugin to ID a project, unless it has
    // a project.json in which case it was already updated above.
    const updatedProjectConfiguration = {
        ...matchingProject,
        ...project,
        name: matchingProject.name,
    };
    // The next blocks handle properties that should be themselves merged (e.g. targets, tags, and implicit dependencies)
    if (project.tags && matchingProject.tags) {
        updatedProjectConfiguration.tags = matchingProject.tags.concat(project.tags);
    }
    if (project.implicitDependencies && matchingProject.implicitDependencies) {
        updatedProjectConfiguration.implicitDependencies =
            matchingProject.implicitDependencies.concat(project.implicitDependencies);
    }
    if (project.generators && matchingProject.generators) {
        updatedProjectConfiguration.generators = {
            ...matchingProject.generators,
            ...project.generators,
        };
    }
    if (project.targets && matchingProject.targets) {
        updatedProjectConfiguration.targets = {
            ...matchingProject.targets,
            ...project.targets,
        };
    }
    projectRootMap.set(updatedProjectConfiguration.root, updatedProjectConfiguration);
}
exports.mergeProjectConfigurationIntoRootMap = mergeProjectConfigurationIntoRootMap;
function buildProjectsConfigurationsFromProjectPathsAndPlugins(nxJson, projectFiles, // making this parameter allows devkit to pick up newly created projects
plugins, root = workspace_root_1.workspaceRoot) {
    const projectRootMap = new Map();
    const externalNodes = {};
    // We iterate over plugins first - this ensures that plugins specified first take precedence.
    for (const plugin of plugins) {
        const [pattern, createNodes] = plugin.createNodes ?? [];
        if (!pattern) {
            continue;
        }
        for (const file of projectFiles) {
            if (minimatch(file, pattern, { dot: true })) {
                const { projects: projectNodes, externalNodes: pluginExternalNodes } = createNodes(file, {
                    nxJsonConfiguration: nxJson,
                    workspaceRoot: root,
                });
                for (const node in projectNodes) {
                    projectNodes[node].name ??= node;
                    mergeProjectConfigurationIntoRootMap(projectRootMap, projectNodes[node], file);
                }
                Object.assign(externalNodes, pluginExternalNodes);
            }
        }
    }
    return {
        projects: readProjectConfigurationsFromRootMap(projectRootMap),
        externalNodes,
    };
}
exports.buildProjectsConfigurationsFromProjectPathsAndPlugins = buildProjectsConfigurationsFromProjectPathsAndPlugins;
function readProjectConfigurationsFromRootMap(projectRootMap) {
    const projects = {};
    // If there are projects that have the same name, that is an error.
    // This object tracks name -> (all roots of projects with that name)
    // to provide better error messaging.
    const errors = new Map();
    for (const [root, configuration] of projectRootMap.entries()) {
        if (!configuration.name) {
            throw new Error(`Project at ${root} has no name provided.`);
        }
        else if (configuration.name in projects) {
            let rootErrors = errors.get(configuration.name) ?? [
                projects[configuration.name].root,
            ];
            rootErrors.push(root);
            errors.set(configuration.name, rootErrors);
        }
        else {
            projects[configuration.name] = configuration;
        }
    }
    if (errors.size > 0) {
        throw new Error([
            `The following projects are defined in multiple locations:`,
            ...Array.from(errors.entries()).map(([project, roots]) => [`- ${project}: `, ...roots.map((r) => `  - ${r}`)].join('\n')),
            '',
            "To fix this, set a unique name for each project in a project.json inside the project's root. If the project does not currently have a project.json, you can create one that contains only a name.",
        ].join('\n'));
    }
    return projects;
}
exports.readProjectConfigurationsFromRootMap = readProjectConfigurationsFromRootMap;
function mergeTargetConfigurations(projectConfiguration, target, targetDefaults) {
    const targetConfiguration = projectConfiguration.targets?.[target];
    if (!targetConfiguration) {
        throw new Error(`Attempted to merge targetDefaults for ${projectConfiguration.name}.${target}, which doesn't exist.`);
    }
    const { configurations: defaultConfigurations, options: defaultOptions, ...defaults } = targetDefaults;
    const result = {
        ...defaults,
        ...targetConfiguration,
    };
    // Target is "compatible", e.g. executor is defined only once or is the same
    // in both places. This means that it is likely safe to merge options
    if (!targetDefaults.executor ||
        !targetConfiguration.executor ||
        targetDefaults.executor === targetConfiguration.executor) {
        result.options = { ...defaultOptions, ...targetConfiguration?.options };
        result.configurations = mergeConfigurations(defaultConfigurations, targetConfiguration.configurations);
    }
    return result;
}
exports.mergeTargetConfigurations = mergeTargetConfigurations;
function mergeConfigurations(defaultConfigurations, projectDefinedConfigurations) {
    const result = {};
    const configurations = new Set([
        ...Object.keys(defaultConfigurations ?? {}),
        ...Object.keys(projectDefinedConfigurations ?? {}),
    ]);
    for (const configuration of configurations) {
        result[configuration] = {
            ...(defaultConfigurations?.[configuration] ?? {}),
            ...(projectDefinedConfigurations?.[configuration] ?? {}),
        };
    }
    return result;
}
function resolveNxTokensInOptions(object, project, key) {
    const result = Array.isArray(object) ? [...object] : { ...object };
    for (let [opt, value] of Object.entries(object ?? {})) {
        if (typeof value === 'string') {
            const workspaceRootMatch = /^(\{workspaceRoot\}\/?)/.exec(value);
            if (workspaceRootMatch?.length) {
                value = value.replace(workspaceRootMatch[0], '');
            }
            if (value.includes('{workspaceRoot}')) {
                throw new Error(`${logger_1.NX_PREFIX} The {workspaceRoot} token is only valid at the beginning of an option. (${key})`);
            }
            value = value.replace(/\{projectRoot\}/g, project.root);
            result[opt] = value.replace(/\{projectName\}/g, project.name);
        }
        else if (typeof value === 'object' && value) {
            result[opt] = resolveNxTokensInOptions(value, project, [key, opt].join('.'));
        }
    }
    return result;
}
exports.resolveNxTokensInOptions = resolveNxTokensInOptions;
function readTargetDefaultsForTarget(targetName, targetDefaults, executor) {
    if (executor) {
        // If an executor is defined in project.json, defaults should be read
        // from the most specific key that matches that executor.
        // e.g. If executor === run-commands, and the target is named build:
        // Use, use nx:run-commands if it is present
        // If not, use build if it is present.
        const key = [executor, targetName].find((x) => targetDefaults?.[x]);
        return key ? targetDefaults?.[key] : null;
    }
    else {
        // If the executor is not defined, the only key we have is the target name.
        return targetDefaults?.[targetName];
    }
}
exports.readTargetDefaultsForTarget = readTargetDefaultsForTarget;
