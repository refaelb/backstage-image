"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useAsync = void 0;
const react_1 = require("react");
const useSyncedRef_1 = require("../useSyncedRef");
/**
 * Tracks the result and errors of the provided async function and provides handles to control its execution.
 *
 * @param asyncFn Function that returns a promise.
 * @param initialValue Value that will be set on initialisation before the async function is
 * executed.
 */
function useAsync(asyncFn, initialValue) {
    const [state, setState] = (0, react_1.useState)({
        status: 'not-executed',
        error: undefined,
        result: initialValue,
    });
    const promiseRef = (0, react_1.useRef)();
    const argsRef = (0, react_1.useRef)();
    const methods = (0, useSyncedRef_1.useSyncedRef)({
        execute(...params) {
            argsRef.current = params;
            const promise = asyncFn(...params);
            promiseRef.current = promise;
            setState((s) => ({ ...s, status: 'loading' }));
            // eslint-disable-next-line promise/catch-or-return
            promise.then((result) => {
                // We dont want to handle result/error of non-latest function
                // this approach helps to avoid race conditions
                // eslint-disable-next-line promise/always-return
                if (promise === promiseRef.current) {
                    setState((s) => ({ ...s, status: 'success', error: undefined, result }));
                }
            }, (error) => {
                // We dont want to handle result/error of non-latest function
                // this approach helps to avoid race conditions
                if (promise === promiseRef.current) {
                    setState((s) => ({ ...s, status: 'error', error }));
                }
            });
            return promise;
        },
        reset() {
            setState({
                status: 'not-executed',
                error: undefined,
                result: initialValue,
            });
            promiseRef.current = undefined;
            argsRef.current = undefined;
        },
    });
    return [
        state,
        (0, react_1.useMemo)(() => ({
            reset() {
                methods.current.reset();
            },
            execute: (...params) => methods.current.execute(...params),
        }), []),
        { promise: promiseRef.current, lastArgs: argsRef.current },
    ];
}
exports.useAsync = useAsync;
