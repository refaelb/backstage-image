"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useTimeoutEffect = void 0;
const react_1 = require("react");
const useSyncedRef_1 = require("../useSyncedRef");
const cancelTimeout = (id) => {
    if (id) {
        clearTimeout(id);
    }
};
/**
 * Like `setTimeout` but in the form of a react hook.
 *
 * @param callback Callback to be called after the timeout. Changing this
 * will not reset the timeout.
 * @param ms Timeout delay in milliseconds. `undefined` disables the timeout.
 * Keep in mind, that changing this parameter will re-set timeout, meaning
 * that it will be set as new after the change.
 */
function useTimeoutEffect(callback, ms) {
    const cbRef = (0, useSyncedRef_1.useSyncedRef)(callback);
    const msRef = (0, useSyncedRef_1.useSyncedRef)(ms);
    const timeoutIdRef = (0, react_1.useRef)(null);
    const cancel = (0, react_1.useCallback)(() => {
        cancelTimeout(timeoutIdRef.current);
    }, []);
    const reset = (0, react_1.useCallback)(() => {
        if (msRef.current === undefined)
            return;
        cancel();
        timeoutIdRef.current = setTimeout(() => {
            cbRef.current();
        }, msRef.current);
    }, []);
    (0, react_1.useEffect)(() => {
        reset();
        return cancel;
    }, [ms]);
    return [cancel, reset];
}
exports.useTimeoutEffect = useTimeoutEffect;
