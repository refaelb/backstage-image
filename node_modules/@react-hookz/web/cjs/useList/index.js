"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useList = void 0;
const react_1 = require("react");
const resolveHookState_1 = require("../util/resolveHookState");
const useRerender_1 = require("../useRerender");
const useSyncedRef_1 = require("../useSyncedRef");
function useList(initialList) {
    const initial = (0, useSyncedRef_1.useSyncedRef)(initialList);
    const list = (0, react_1.useRef)((0, resolveHookState_1.resolveHookState)(initial.current));
    const rerender = (0, useRerender_1.useRerender)();
    const actions = (0, react_1.useMemo)(() => ({
        set(newList) {
            list.current = (0, resolveHookState_1.resolveHookState)(newList, list.current);
            rerender();
        },
        push(...items) {
            actions.set((currentList) => [...currentList, ...items]);
        },
        updateAt(index, newItem) {
            actions.set((currentList) => {
                const listCopy = [...currentList];
                listCopy[index] = newItem;
                return listCopy;
            });
        },
        insertAt(index, newItem) {
            actions.set((currentList) => {
                const listCopy = [...currentList];
                if (index >= listCopy.length) {
                    listCopy[index] = newItem;
                }
                else {
                    listCopy.splice(index, 0, newItem);
                }
                return listCopy;
            });
        },
        update(predicate, newItem) {
            actions.set((currentList) => currentList.map((item) => (predicate(item, newItem) ? newItem : item)));
        },
        updateFirst(predicate, newItem) {
            const indexOfMatch = list.current.findIndex((item) => predicate(item, newItem));
            const NO_MATCH = -1;
            if (indexOfMatch > NO_MATCH) {
                actions.updateAt(indexOfMatch, newItem);
            }
        },
        upsert(predicate, newItem) {
            const indexOfMatch = list.current.findIndex((item) => predicate(item, newItem));
            const NO_MATCH = -1;
            if (indexOfMatch > NO_MATCH) {
                actions.updateAt(indexOfMatch, newItem);
            }
            else {
                actions.push(newItem);
            }
        },
        sort(compareFn) {
            actions.set((currentList) => [...currentList].sort(compareFn));
        },
        filter(callbackFn, thisArg) {
            actions.set((currentList) => [...currentList].filter(callbackFn, thisArg));
        },
        removeAt(index) {
            actions.set((currentList) => {
                const listCopy = [...currentList];
                if (index < listCopy.length) {
                    listCopy.splice(index, 1);
                }
                return listCopy;
            });
        },
        clear() {
            actions.set([]);
        },
        reset() {
            actions.set([...(0, resolveHookState_1.resolveHookState)(initial.current)]);
        },
    }), [initial, rerender]);
    return [list.current, actions];
}
exports.useList = useList;
