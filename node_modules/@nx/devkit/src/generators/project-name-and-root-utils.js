"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.determineProjectNameAndRootOptions = void 0;
const enquirer_1 = require("enquirer");
const path_1 = require("path");
const nx_1 = require("../../nx");
const get_workspace_layout_1 = require("../utils/get-workspace-layout");
const names_1 = require("../utils/names");
const { joinPathFragments, normalizePath, logger, readJson, readNxJson, updateNxJson, stripIndents, workspaceRoot, } = (0, nx_1.requireNx)();
const deprecationWarning = stripIndents `
    In Nx 18, generating projects will no longer derive the name and root.
    Please provide the exact project name and root in the future.`;
async function determineProjectNameAndRootOptions(tree, options) {
    validateName(options.name, options.projectNameAndRootFormat);
    const formats = getProjectNameAndRootFormats(tree, options);
    const format = options.projectNameAndRootFormat ??
        (await determineFormat(tree, formats, options.callingGenerator));
    return {
        ...formats[format],
        projectNameAndRootFormat: format,
    };
}
exports.determineProjectNameAndRootOptions = determineProjectNameAndRootOptions;
function validateName(name, projectNameAndRootFormat) {
    if (projectNameAndRootFormat === 'derived' && name.startsWith('@')) {
        throw new Error(`The project name "${name}" cannot start with "@" when the "projectNameAndRootFormat" is "derived".`);
    }
    /**
     * Matches two types of project names:
     *
     * 1. Valid npm package names (e.g., '@scope/name' or 'name').
     * 2. Names starting with a letter and can contain any character except whitespace and ':'.
     *
     * The second case is to support the legacy behavior (^[a-zA-Z].*$) with the difference
     * that it doesn't allow the ":" character. It was wrong to allow it because it would
     * conflict with the notation for tasks.
     */
    const pattern = '(?:^@[a-zA-Z0-9-*~][a-zA-Z0-9-*._~]*\\/[a-zA-Z0-9-~][a-zA-Z0-9-._~]*|^[a-zA-Z][^:]*)$';
    const validationRegex = new RegExp(pattern);
    if (!validationRegex.test(name)) {
        throw new Error(`The project name should match the pattern "${pattern}". The provided value "${name}" does not match.`);
    }
}
function getExample(callingGenerator, formats) {
    return `Example: nx g ${callingGenerator} ${formats['as-provided'].projectName} --directory ${formats['as-provided'].projectRoot}`;
}
async function determineFormat(tree, formats, callingGenerator) {
    if (!formats.derived) {
        return 'as-provided';
    }
    if (process.env.NX_INTERACTIVE !== 'true' || !isTTY()) {
        return 'derived';
    }
    const asProvidedDescription = `As provided:
    Name: ${formats['as-provided'].projectName}
    Root: ${formats['as-provided'].projectRoot}`;
    const asProvidedSelectedValue = `${formats['as-provided'].projectName} @ ${formats['as-provided'].projectRoot}`;
    const derivedDescription = `Derived:
    Name: ${formats['derived'].projectName}
    Root: ${formats['derived'].projectRoot}`;
    const derivedSelectedValue = `${formats['derived'].projectName} @ ${formats['derived'].projectRoot}`;
    if (asProvidedSelectedValue === derivedSelectedValue) {
        return 'as-provided';
    }
    const result = await (0, enquirer_1.prompt)({
        type: 'select',
        name: 'format',
        message: 'What should be the project name and where should it be generated?',
        choices: [
            {
                message: asProvidedDescription,
                name: asProvidedSelectedValue,
            },
            {
                message: derivedDescription,
                name: derivedSelectedValue,
            },
        ],
        initial: 'as-provided',
    }).then(({ format }) => format === asProvidedSelectedValue ? 'as-provided' : 'derived');
    if (result === 'derived' && callingGenerator) {
        const example = getExample(callingGenerator, formats);
        logger.warn(deprecationWarning + '\n' + example);
    }
    return result;
}
function getProjectNameAndRootFormats(tree, options) {
    const name = (0, names_1.names)(options.name).fileName;
    const directory = options.directory
        ? normalizePath(options.directory.replace(/^\.?\//, ''))
        : undefined;
    const asProvidedProjectName = name;
    let asProvidedProjectDirectory;
    const relativeCwd = normalizePath((0, path_1.relative)(workspaceRoot, getCwd())).replace(/\/$/, '');
    if (directory) {
        // append the directory to the current working directory if it doesn't start with it
        if (directory === relativeCwd || directory.startsWith(`${relativeCwd}/`)) {
            asProvidedProjectDirectory = (0, names_1.names)(directory).fileName;
        }
        else {
            asProvidedProjectDirectory = joinPathFragments(relativeCwd, (0, names_1.names)(directory).fileName);
        }
    }
    else if (options.rootProject) {
        asProvidedProjectDirectory = '.';
    }
    else {
        asProvidedProjectDirectory = relativeCwd;
        // append the project name to the current working directory if it doesn't end with it
        if (!relativeCwd.endsWith(asProvidedProjectName) &&
            !relativeCwd.endsWith(options.name)) {
            asProvidedProjectDirectory = joinPathFragments(relativeCwd, asProvidedProjectName);
        }
    }
    if (name.startsWith('@')) {
        const nameWithoutScope = asProvidedProjectName.split('/')[1];
        return {
            'as-provided': {
                projectName: asProvidedProjectName,
                names: {
                    projectSimpleName: nameWithoutScope,
                    projectFileName: nameWithoutScope,
                },
                importPath: options.importPath ?? asProvidedProjectName,
                projectRoot: asProvidedProjectDirectory,
            },
        };
    }
    let asProvidedImportPath;
    let npmScope;
    if (options.projectType === 'library') {
        asProvidedImportPath = options.importPath;
        if (!asProvidedImportPath) {
            npmScope = getNpmScope(tree);
            asProvidedImportPath =
                asProvidedProjectDirectory === '.'
                    ? readJson(tree, 'package.json').name ??
                        getImportPath(npmScope, asProvidedProjectName)
                    : getImportPath(npmScope, asProvidedProjectName);
        }
    }
    let { projectDirectory, layoutDirectory } = getDirectories(tree, directory, options.projectType);
    const derivedProjectDirectoryWithoutLayout = projectDirectory
        ? `${(0, names_1.names)(projectDirectory).fileName}/${name}`
        : options.rootProject
            ? '.'
            : name;
    // the project name uses the directory without the layout directory
    const derivedProjectName = derivedProjectDirectoryWithoutLayout === '.'
        ? name
        : derivedProjectDirectoryWithoutLayout.replace(/\//g, '-');
    const derivedSimpleProjectName = name;
    let derivedProjectDirectory = derivedProjectDirectoryWithoutLayout;
    if (derivedProjectDirectoryWithoutLayout !== '.') {
        // prepend the layout directory
        derivedProjectDirectory = joinPathFragments(layoutDirectory, derivedProjectDirectory);
    }
    let derivedImportPath;
    if (options.projectType === 'library') {
        derivedImportPath = options.importPath;
        if (!derivedImportPath) {
            derivedImportPath =
                derivedProjectDirectory === '.'
                    ? readJson(tree, 'package.json').name ??
                        getImportPath(npmScope, derivedProjectName)
                    : getImportPath(npmScope, derivedProjectDirectoryWithoutLayout);
        }
    }
    return {
        'as-provided': {
            projectName: asProvidedProjectName,
            names: {
                projectSimpleName: asProvidedProjectName,
                projectFileName: asProvidedProjectName,
            },
            importPath: asProvidedImportPath,
            projectRoot: asProvidedProjectDirectory,
        },
        derived: {
            projectName: derivedProjectName,
            names: {
                projectSimpleName: derivedSimpleProjectName,
                projectFileName: derivedProjectName,
            },
            importPath: derivedImportPath,
            projectRoot: derivedProjectDirectory,
        },
    };
}
function getDirectories(tree, directory, projectType) {
    let { projectDirectory, layoutDirectory } = (0, get_workspace_layout_1.extractLayoutDirectory)(directory);
    if (!layoutDirectory) {
        const { appsDir, libsDir } = (0, get_workspace_layout_1.getWorkspaceLayout)(tree);
        layoutDirectory = projectType === 'application' ? appsDir : libsDir;
    }
    return { projectDirectory, layoutDirectory };
}
function getImportPath(npmScope, name) {
    return npmScope ? `${npmScope === '@' ? '' : '@'}${npmScope}/${name}` : name;
}
function getNpmScope(tree) {
    const nxJson = readNxJson(tree);
    // TODO(v17): Remove reading this from nx.json
    if (nxJson?.npmScope) {
        return nxJson.npmScope;
    }
    const { name } = tree.exists('package.json')
        ? readJson(tree, 'package.json')
        : { name: null };
    return name?.startsWith('@') ? name.split('/')[0].substring(1) : undefined;
}
function isTTY() {
    return !!process.stdout.isTTY && process.env['CI'] !== 'true';
}
/**
 * When running a script with the package manager (e.g. `npm run`), the package manager will
 * traverse the directory tree upwards until it finds a `package.json` and will set `process.cwd()`
 * to the folder where it found it. The actual working directory is stored in the INIT_CWD
 * environment variable (see here: https://docs.npmjs.com/cli/v9/commands/npm-run-script#description).
 */
function getCwd() {
    return process.env.INIT_CWD?.startsWith(workspaceRoot)
        ? process.env.INIT_CWD
        : process.cwd();
}
