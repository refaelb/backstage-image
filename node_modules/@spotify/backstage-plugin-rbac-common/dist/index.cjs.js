"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var a=require("@backstage/plugin-permission-common"),e=require("zod"),u=require("@backstage/catalog-model"),f=require("uuid");const g=(r,s)=>`${r} must be at least ${s} characters`,h=(r,s)=>`${r} must be less than ${s} characters`,b="Untitled policy",U=":backstageUser",R=e.z.object({rule:e.z.string(),params:e.z.record(e.z.any()).optional()}),c=e.z.lazy(()=>e.z.union([e.z.object({allOf:e.z.array(c).nonempty()}).strict(),e.z.object({anyOf:e.z.array(c).nonempty()}).strict(),e.z.object({not:c}).strict(),R])),m=e.z.object({pluginId:e.z.string().min(1).describe("Plugin ID that defines the permission and rules used."),resourceType:e.z.string().min(1).describe("Resource type associated with the conditions used."),conditions:c}),D=e.z.union([e.z.literal("allow"),e.z.literal("deny")]),d=e.z.union([D,m]),j=e.z.union([e.z.literal("*"),e.z.object({name:e.z.string().optional().describe("Name that must match the incoming permission request."),actions:e.z.array(e.z.string()).optional().describe("Actions that must be present on the incoming permission's attributes."),resourceType:e.z.string().min(1).optional().describe("Resource type that must match that of the incoming permission request.")})]),C=e.z.string().default(()=>f.v4().split("-")[0]).describe("ID of the permission."),A=e.z.object({id:C,match:j.describe("Values used to match against the incoming permission request."),decision:d.describe("Authorization result or conditions to send if this role permission applies.")}).refine(({decision:r,match:s})=>M(r)?s!=="*"&&(s==null?void 0:s.resourceType)!==void 0:!0,{path:["match","resourceType"],message:"match.resourceType is required for conditional decisions."}),O=e.z.array(A).superRefine((r,s)=>{const i=y(r,"id");i>=0&&s.addIssue({code:e.z.ZodIssueCode.custom,message:"Permission ids must be unique",path:[i,"id"]})}).describe("Permission decisions used to determine authorization responses."),w=e.z.string().refine(L,{message:"Invalid entity ref for member.",path:[]}).transform(r=>u.stringifyEntityRef(u.parseEntityRef(r,{defaultKind:"group",defaultNamespace:"default"}))),T=e.z.string().default(()=>f.v4().split("-")[0]).describe("ID of the role."),q=e.z.object({name:e.z.string().min(1,{message:g("Role name",1)}).max(1024,{message:h("Role name",1024)}).describe("Name of the role."),id:T,members:e.z.union([e.z.literal("*"),e.z.array(w).min(1)]).describe("Entity references used to map users to this role. These entities don't need to exist in the catalog."),permissions:O}),P=e.z.array(q).default([]).superRefine((r,s)=>{const i=y(r,"name");i>=0&&s.addIssue({code:e.z.ZodIssueCode.custom,message:"Role names must be unique",path:[i,"name"]});const t=y(r,"id");t>=0&&s.addIssue({code:e.z.ZodIssueCode.custom,message:"Role ids must be unique",path:[t,"id"]})}),I=e.z.object({decision:d.describe("The authorization result or conditions the corresponding role resulted in"),roleId:T.describe("The id of the role that resulted in the decision"),rolePermissionId:C.describe("The id of the role permission that resulted in the decisions.")}),z=e.z.string().min(1,{message:g("Policy name",1)}).max(1024,{message:h("Policy name",1024)}).default(b).describe("Name of the policy."),v=e.z.union([e.z.literal("first-match"),e.z.literal("any-allow")]),p=e.z.object({resolutionStrategy:v}).default({resolutionStrategy:"first-match"}),o=e.z.object({name:z,options:p,roles:P}),B=o.default({roles:[]});function L(r){try{return u.parseEntityRef(r,{defaultKind:"group",defaultNamespace:"default"}),!0}catch{return!1}}function y(r,s){let i=0;const t=new Set;for(;i<r.length;){const n=r[i][s];if(t.has(n))return i;t.add(n),i++}return-1}function M(r){return typeof r!="string"}function $(r){const s=Object.entries(r);return s.length===1&&s[0][0]==="allOf"&&Array.isArray(s[0][1])}function V(r){const s=Object.entries(r);return s.length===1&&s[0][0]==="anyOf"&&Array.isArray(s[0][1])}function Z(r){const s=Object.entries(r);return s.length===1&&s[0][0]==="not"&&!Array.isArray(s[0][1])}const N=o.extend({id:e.z.string(),createdAt:e.z.string(),createdBy:e.z.string(),updatedAt:e.z.string(),updatedBy:e.z.string(),description:e.z.string().optional().nullable(),lastPublishedAt:e.z.string().optional().nullable(),lastPublishedBy:e.z.string().optional().nullable(),status:e.z.enum(["draft","active","inactive"])}),x=e.z.object({action:e.z.union([e.z.literal("create"),e.z.literal("read"),e.z.literal("update"),e.z.literal("delete")]).optional()}),K=e.z.union([e.z.object({type:e.z.literal("basic"),name:e.z.string(),attributes:x}),e.z.object({type:e.z.literal("resource"),name:e.z.string(),attributes:x,resourceType:e.z.string()})]),l=e.z.lazy(()=>e.z.object({rule:e.z.string(),resourceType:e.z.string(),params:e.z.record(e.z.any()).optional()}).or(e.z.object({anyOf:e.z.array(l).nonempty()})).or(e.z.object({allOf:e.z.array(l).nonempty()})).or(e.z.object({not:l}))),_=e.z.object({result:e.z.union([e.z.literal(a.AuthorizeResult.ALLOW),e.z.literal(a.AuthorizeResult.DENY)])}),W=m.extend({result:e.z.literal(a.AuthorizeResult.CONDITIONAL),conditions:l}),Y=e.z.union([_,W]),F=o,E=o.extend({name:z.optional(),options:p.optional(),roles:P.optional()}),G=e.z.object({description:e.z.string().optional(),update:E.optional()}),H=e.z.object({decision:Y,decisionOrigin:e.z.array(I)}),J=e.z.object({permission:K,policyConfig:o,roleIds:e.z.array(e.z.string())}),Q=e.z.object({id:e.z.string()}),X=e.z.object({authorized:e.z.boolean()}),S=e.z.object({name:e.z.string().optional(),type:e.z.enum(["user","group","all","unknown"]),entityRef:e.z.string()}),ee=e.z.object({members:e.z.array(S)}),se=e.z.object({items:e.z.array(N),nextCursor:e.z.string().optional(),prevCursor:e.z.string().optional(),totalItems:e.z.number()}),re=(r,s)=>s?s===r.name:!0,ie=(r,s)=>s?a.isResourcePermission(r)&&s===r.resourceType:!0,te=(r,s)=>s?s.some(i=>i===r.attributes.action):!0,k=(r,s)=>s==="*"?!0:re(r,s.name)&&ie(r,s.resourceType)&&te(r,s.actions),oe=(r,s)=>r.permissions.filter(({match:i})=>k(s,i)),ne=(r,s)=>r.kind!==s.kind||r.namespace!==s.namespace?!1:s.name==="*"?!0:r.name===s.name;function ae(r,s){const i={};if(r)for(const[t,n]of Object.entries(r))i[t]=s(n);return i}exports.AuthorizeResponseParser=X,exports.BackstageUserPlaceholder=U,exports.ConditionalDecisionParser=m,exports.CreateDraftRequestParser=F,exports.DefaultingPolicyConfigParser=B,exports.DraftResponseParser=Q,exports.LiteralDecisionParser=D,exports.MemberResponseParser=S,exports.PermissionConditionParser=R,exports.PermissionDecisionParser=d,exports.PermissionMatchParser=j,exports.PolicyConfigOptionsParser=p,exports.PolicyConfigParser=o,exports.PolicyDefaultName=b,exports.PolicyParser=N,exports.PolicyResponseParser=se,exports.PolicyRoleResolutionStrategyParser=v,exports.PolicyTitleParser=z,exports.PublishVersionRequestParser=G,exports.RoleDecisionParser=I,exports.RoleParser=q,exports.RolePermissionParser=A,exports.RolePermissionsParser=O,exports.RolesParser=P,exports.SearchMemberResponseParser=ee,exports.TestPolicyDecisionRequestParser=J,exports.TestPolicyDecisionResponseParser=H,exports.UpdateDraftRequestParser=E,exports.getMatchingRolePermissions=oe,exports.isAllOfPermissionCriteria=$,exports.isAnyOfPermissionCriteria=V,exports.isConditionalDecision=M,exports.isMatchingPermission=k,exports.isNotPermissionCriteria=Z,exports.mapParams=ae,exports.matchesEntityRef=ne;
//# sourceMappingURL=index.cjs.js.map
