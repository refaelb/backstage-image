import{AuthorizeResult as l,isResourcePermission as S}from"@backstage/plugin-permission-common";import{z as e}from"zod";import{stringifyEntityRef as $,parseEntityRef as b}from"@backstage/catalog-model";import{v4 as g}from"uuid";const h=(s,t)=>`${s} must be at least ${t} characters`,P=(s,t)=>`${s} must be less than ${t} characters`,R="Untitled policy",B=":backstageUser",j=e.object({rule:e.string(),params:e.record(e.any()).optional()}),a=e.lazy(()=>e.union([e.object({allOf:e.array(a).nonempty()}).strict(),e.object({anyOf:e.array(a).nonempty()}).strict(),e.object({not:a}).strict(),j])),u=e.object({pluginId:e.string().min(1).describe("Plugin ID that defines the permission and rules used."),resourceType:e.string().min(1).describe("Resource type associated with the conditions used."),conditions:a}),C=e.union([e.literal("allow"),e.literal("deny")]),m=e.union([C,u]),D=e.union([e.literal("*"),e.object({name:e.string().optional().describe("Name that must match the incoming permission request."),actions:e.array(e.string()).optional().describe("Actions that must be present on the incoming permission's attributes."),resourceType:e.string().min(1).optional().describe("Resource type that must match that of the incoming permission request.")})]),A=e.string().default(()=>g().split("-")[0]).describe("ID of the permission."),I=e.object({id:A,match:D.describe("Values used to match against the incoming permission request."),decision:m.describe("Authorization result or conditions to send if this role permission applies.")}).refine(({decision:s,match:t})=>z(s)?t!=="*"&&(t==null?void 0:t.resourceType)!==void 0:!0,{path:["match","resourceType"],message:"match.resourceType is required for conditional decisions."}),O=e.array(I).superRefine((s,t)=>{const i=f(s,"id");i>=0&&t.addIssue({code:e.ZodIssueCode.custom,message:"Permission ids must be unique",path:[i,"id"]})}).describe("Permission decisions used to determine authorization responses."),L=e.string().refine(Z,{message:"Invalid entity ref for member.",path:[]}).transform(s=>$(b(s,{defaultKind:"group",defaultNamespace:"default"}))),T=e.string().default(()=>g().split("-")[0]).describe("ID of the role."),q=e.object({name:e.string().min(1,{message:h("Role name",1)}).max(1024,{message:P("Role name",1024)}).describe("Name of the role."),id:T,members:e.union([e.literal("*"),e.array(L).min(1)]).describe("Entity references used to map users to this role. These entities don't need to exist in the catalog."),permissions:O}),d=e.array(q).default([]).superRefine((s,t)=>{const i=f(s,"name");i>=0&&t.addIssue({code:e.ZodIssueCode.custom,message:"Role names must be unique",path:[i,"name"]});const r=f(s,"id");r>=0&&t.addIssue({code:e.ZodIssueCode.custom,message:"Role ids must be unique",path:[r,"id"]})}),N=e.object({decision:m.describe("The authorization result or conditions the corresponding role resulted in"),roleId:T.describe("The id of the role that resulted in the decision"),rolePermissionId:A.describe("The id of the role permission that resulted in the decisions.")}),p=e.string().min(1,{message:h("Policy name",1)}).max(1024,{message:P("Policy name",1024)}).default(R).describe("Name of the policy."),x=e.union([e.literal("first-match"),e.literal("any-allow")]),y=e.object({resolutionStrategy:x}).default({resolutionStrategy:"first-match"}),o=e.object({name:p,options:y,roles:d}),U=o.default({roles:[]});function Z(s){try{return b(s,{defaultKind:"group",defaultNamespace:"default"}),!0}catch{return!1}}function f(s,t){let i=0;const r=new Set;for(;i<s.length;){const n=s[i][t];if(r.has(n))return i;r.add(n),i++}return-1}function z(s){return typeof s!="string"}function K(s){const t=Object.entries(s);return t.length===1&&t[0][0]==="allOf"&&Array.isArray(t[0][1])}function V(s){const t=Object.entries(s);return t.length===1&&t[0][0]==="anyOf"&&Array.isArray(t[0][1])}function W(s){const t=Object.entries(s);return t.length===1&&t[0][0]==="not"&&!Array.isArray(t[0][1])}const v=o.extend({id:e.string(),createdAt:e.string(),createdBy:e.string(),updatedAt:e.string(),updatedBy:e.string(),description:e.string().optional().nullable(),lastPublishedAt:e.string().optional().nullable(),lastPublishedBy:e.string().optional().nullable(),status:e.enum(["draft","active","inactive"])}),k=e.object({action:e.union([e.literal("create"),e.literal("read"),e.literal("update"),e.literal("delete")]).optional()}),Y=e.union([e.object({type:e.literal("basic"),name:e.string(),attributes:k}),e.object({type:e.literal("resource"),name:e.string(),attributes:k,resourceType:e.string()})]),c=e.lazy(()=>e.object({rule:e.string(),resourceType:e.string(),params:e.record(e.any()).optional()}).or(e.object({anyOf:e.array(c).nonempty()})).or(e.object({allOf:e.array(c).nonempty()})).or(e.object({not:c}))),F=e.object({result:e.union([e.literal(l.ALLOW),e.literal(l.DENY)])}),G=u.extend({result:e.literal(l.CONDITIONAL),conditions:c}),H=e.union([F,G]),J=o,w=o.extend({name:p.optional(),options:y.optional(),roles:d.optional()}),Q=e.object({description:e.string().optional(),update:w.optional()}),X=e.object({decision:H,decisionOrigin:e.array(N)}),_=e.object({permission:Y,policyConfig:o,roleIds:e.array(e.string())}),ee=e.object({id:e.string()}),te=e.object({authorized:e.boolean()}),E=e.object({name:e.string().optional(),type:e.enum(["user","group","all","unknown"]),entityRef:e.string()}),se=e.object({members:e.array(E)}),ie=e.object({items:e.array(v),nextCursor:e.string().optional(),prevCursor:e.string().optional(),totalItems:e.number()}),re=(s,t)=>t?t===s.name:!0,oe=(s,t)=>t?S(s)&&t===s.resourceType:!0,ne=(s,t)=>t?t.some(i=>i===s.attributes.action):!0,M=(s,t)=>t==="*"?!0:re(s,t.name)&&oe(s,t.resourceType)&&ne(s,t.actions),ae=(s,t)=>s.permissions.filter(({match:i})=>M(t,i)),ce=(s,t)=>s.kind!==t.kind||s.namespace!==t.namespace?!1:t.name==="*"?!0:s.name===t.name;function le(s,t){const i={};if(s)for(const[r,n]of Object.entries(s))i[r]=t(n);return i}export{te as AuthorizeResponseParser,B as BackstageUserPlaceholder,u as ConditionalDecisionParser,J as CreateDraftRequestParser,U as DefaultingPolicyConfigParser,ee as DraftResponseParser,C as LiteralDecisionParser,E as MemberResponseParser,j as PermissionConditionParser,m as PermissionDecisionParser,D as PermissionMatchParser,y as PolicyConfigOptionsParser,o as PolicyConfigParser,R as PolicyDefaultName,v as PolicyParser,ie as PolicyResponseParser,x as PolicyRoleResolutionStrategyParser,p as PolicyTitleParser,Q as PublishVersionRequestParser,N as RoleDecisionParser,q as RoleParser,I as RolePermissionParser,O as RolePermissionsParser,d as RolesParser,se as SearchMemberResponseParser,_ as TestPolicyDecisionRequestParser,X as TestPolicyDecisionResponseParser,w as UpdateDraftRequestParser,ae as getMatchingRolePermissions,K as isAllOfPermissionCriteria,V as isAnyOfPermissionCriteria,z as isConditionalDecision,M as isMatchingPermission,W as isNotPermissionCriteria,le as mapParams,ce as matchesEntityRef};
//# sourceMappingURL=index.esm.js.map
