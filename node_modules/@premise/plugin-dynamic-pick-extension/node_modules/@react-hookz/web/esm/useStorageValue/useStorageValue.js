var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
/* eslint-disable @typescript-eslint/no-use-before-define,no-use-before-define */
import { useEffect, useMemo, useState } from 'react';
import { useFirstMountState } from "../useFirstMountState/useFirstMountState.js";
import { useIsomorphicLayoutEffect } from "../useIsomorphicLayoutEffect/useIsomorphicLayoutEffect.js";
import { useSyncedRef } from "../useSyncedRef/useSyncedRef.js";
import { useUpdateEffect } from "../useUpdateEffect/useUpdateEffect.js";
import { isBrowser } from "../util/const.js";
import { off, on } from "../util/misc.js";
import { resolveHookState } from "../util/resolveHookState.js";
var storageListeners = new Map();
var invokeStorageKeyListeners = function (s, key, value, skipListener) {
    var _a, _b;
    (_b = (_a = storageListeners
        .get(s)) === null || _a === void 0 ? void 0 : _a.get(key)) === null || _b === void 0 ? void 0 : _b.forEach(function (listener) {
        if (listener !== skipListener) {
            listener(value);
        }
    });
};
var storageEventHandler = function (evt) {
    if (evt.storageArea && evt.key && evt.newValue) {
        invokeStorageKeyListeners(evt.storageArea, evt.key, evt.newValue);
    }
};
var addStorageListener = function (s, key, listener) {
    // in case of first listener added within browser environment we
    // want to bind single storage event handler
    if (isBrowser && storageListeners.size === 0) {
        on(window, 'storage', storageEventHandler, { passive: true });
    }
    var keys = storageListeners.get(s);
    if (!keys) {
        keys = new Map();
        storageListeners.set(s, keys);
    }
    var listeners = keys.get(key);
    if (!listeners) {
        listeners = new Set();
        keys.set(key, listeners);
    }
    listeners.add(listener);
};
var removeStorageListener = function (s, key, listener) {
    var keys = storageListeners.get(s);
    /* istanbul ignore next */
    if (!keys) {
        return;
    }
    var listeners = keys.get(key);
    /* istanbul ignore next */
    if (!listeners) {
        return;
    }
    listeners.delete(listener);
    if (!listeners.size) {
        keys.delete(key);
    }
    if (!keys.size) {
        storageListeners.delete(s);
    }
    // unbind storage event handler in browser environment in case there is no
    // storage keys listeners left
    if (isBrowser && !storageListeners.size) {
        off(window, 'storage', storageEventHandler);
    }
};
var DEFAULT_OPTIONS = {
    defaultValue: null,
    initializeWithValue: true,
};
export function useStorageValue(storage, key, options) {
    var _a;
    var optionsRef = useSyncedRef(__assign(__assign({}, DEFAULT_OPTIONS), options));
    var parse = function (str, fallback) {
        var _a;
        var parseFunction = (_a = optionsRef.current.parse) !== null && _a !== void 0 ? _a : defaultParse;
        return parseFunction(str, fallback);
    };
    var stringify = function (data) {
        var _a;
        var stringifyFunction = (_a = optionsRef.current.stringify) !== null && _a !== void 0 ? _a : defaultStringify;
        return stringifyFunction(data);
    };
    var storageActions = useSyncedRef({
        fetchRaw: function () { return storage.getItem(key); },
        fetch: function () {
            return parse(storageActions.current.fetchRaw(), optionsRef.current.defaultValue);
        },
        remove: function () { return storage.removeItem(key); },
        store: function (val) {
            var stringified = stringify(val);
            if (stringified !== null) {
                storage.setItem(key, stringified);
            }
            return stringified;
        },
    });
    var isFirstMount = useFirstMountState();
    var _b = useState(((_a = optionsRef.current) === null || _a === void 0 ? void 0 : _a.initializeWithValue) && isFirstMount
        ? storageActions.current.fetch()
        : undefined), state = _b[0], setState = _b[1];
    var stateRef = useSyncedRef(state);
    var stateActions = useSyncedRef({
        fetch: function () { return setState(storageActions.current.fetch()); },
        setRawVal: function (val) {
            setState(parse(val, optionsRef.current.defaultValue));
        },
    });
    useUpdateEffect(function () {
        stateActions.current.fetch();
    }, [key]);
    useEffect(function () {
        if (!optionsRef.current.initializeWithValue) {
            stateActions.current.fetch();
        }
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, []);
    useIsomorphicLayoutEffect(function () {
        var handler = stateActions.current.setRawVal;
        addStorageListener(storage, key, handler);
        return function () {
            removeStorageListener(storage, key, handler);
        };
    }, [storage, key]);
    var actions = useSyncedRef({
        set: function (val) {
            if (!isBrowser)
                return;
            var s = resolveHookState(val, stateRef.current);
            var storeVal = storageActions.current.store(s);
            if (storeVal !== null) {
                invokeStorageKeyListeners(storage, key, storeVal);
            }
        },
        delete: function () {
            if (!isBrowser)
                return;
            storageActions.current.remove();
            invokeStorageKeyListeners(storage, key, null);
        },
        fetch: function () {
            if (!isBrowser)
                return;
            invokeStorageKeyListeners(storage, key, storageActions.current.fetchRaw());
        },
    });
    // make actions static so developers can pass methods further
    var staticActions = useMemo(function () { return ({
        set: (function (v) { return actions.current.set(v); }),
        remove: function () { return actions.current.delete(); },
        fetch: function () { return actions.current.fetch(); },
    }); }, 
    // eslint-disable-next-line react-hooks/exhaustive-deps
    []);
    return useMemo(function () { return (__assign({ value: state }, staticActions)); }, 
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [state]);
}
var defaultStringify = function (data) {
    if (data === null) {
        /* istanbul ignore next */
        if (process.env.NODE_ENV === 'development') {
            // eslint-disable-next-line no-console
            console.warn("'null' is not a valid data for useStorageValue hook, this operation will take no effect");
        }
        return null;
    }
    try {
        return JSON.stringify(data);
    }
    catch (error) /* istanbul ignore next */ {
        // I have absolutely no idea how to cover this, since modern JSON.stringify does not throw on
        // cyclic references anymore
        // eslint-disable-next-line no-console
        console.warn(error);
        return null;
    }
};
var defaultParse = function (str, fallback) {
    if (str === null)
        return fallback;
    try {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-return
        return JSON.parse(str);
    }
    catch (error) {
        // eslint-disable-next-line no-console
        console.warn(error);
        return fallback;
    }
};
