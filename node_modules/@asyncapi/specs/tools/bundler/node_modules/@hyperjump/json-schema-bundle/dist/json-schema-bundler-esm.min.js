var e,t="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:{};function n(e){if(e.__esModule)return e;var t=Object.defineProperty({},"__esModule",{value:!0});return Object.keys(e).forEach((function(n){var r=Object.getOwnPropertyDescriptor(e,n);Object.defineProperty(t,n,r.get?r:{enumerable:!0,get:function(){return e[n]}})})),t}var r=new Uint8Array(16);function a(){if(!e&&!(e="undefined"!=typeof crypto&&crypto.getRandomValues&&crypto.getRandomValues.bind(crypto)||"undefined"!=typeof msCrypto&&"function"==typeof msCrypto.getRandomValues&&msCrypto.getRandomValues.bind(msCrypto)))throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");return e(r)}var i=/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;function o(e){return"string"==typeof e&&i.test(e)}for(var s,c,m=[],l=0;l<256;++l)m.push((l+256).toString(16).substr(1));function p(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=(m[e[t+0]]+m[e[t+1]]+m[e[t+2]]+m[e[t+3]]+"-"+m[e[t+4]]+m[e[t+5]]+"-"+m[e[t+6]]+m[e[t+7]]+"-"+m[e[t+8]]+m[e[t+9]]+"-"+m[e[t+10]]+m[e[t+11]]+m[e[t+12]]+m[e[t+13]]+m[e[t+14]]+m[e[t+15]]).toLowerCase();if(!o(n))throw TypeError("Stringified UUID is invalid");return n}var d=0,u=0;function f(e){if(!o(e))throw TypeError("Invalid UUID");var t,n=new Uint8Array(16);return n[0]=(t=parseInt(e.slice(0,8),16))>>>24,n[1]=t>>>16&255,n[2]=t>>>8&255,n[3]=255&t,n[4]=(t=parseInt(e.slice(9,13),16))>>>8,n[5]=255&t,n[6]=(t=parseInt(e.slice(14,18),16))>>>8,n[7]=255&t,n[8]=(t=parseInt(e.slice(19,23),16))>>>8,n[9]=255&t,n[10]=(t=parseInt(e.slice(24,36),16))/1099511627776&255,n[11]=t/4294967296&255,n[12]=t>>>24&255,n[13]=t>>>16&255,n[14]=t>>>8&255,n[15]=255&t,n}function y(e,t,n){function r(e,r,a,i){if("string"==typeof e&&(e=function(e){e=unescape(encodeURIComponent(e));for(var t=[],n=0;n<e.length;++n)t.push(e.charCodeAt(n));return t}(e)),"string"==typeof r&&(r=f(r)),16!==r.length)throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");var o=new Uint8Array(16+e.length);if(o.set(r),o.set(e,r.length),(o=n(o))[6]=15&o[6]|t,o[8]=63&o[8]|128,a){i=i||0;for(var s=0;s<16;++s)a[i+s]=o[s];return a}return p(o)}try{r.name=e}catch(e){}return r.DNS="6ba7b810-9dad-11d1-80b4-00c04fd430c8",r.URL="6ba7b811-9dad-11d1-80b4-00c04fd430c8",r}function h(e){return 14+(e+64>>>9<<4)+1}function v(e,t){var n=(65535&e)+(65535&t);return(e>>16)+(t>>16)+(n>>16)<<16|65535&n}function g(e,t,n,r,a,i){return v((o=v(v(t,e),v(r,i)))<<(s=a)|o>>>32-s,n);var o,s}function b(e,t,n,r,a,i,o){return g(t&n|~t&r,e,t,a,i,o)}function $(e,t,n,r,a,i,o){return g(t&r|n&~r,e,t,a,i,o)}function I(e,t,n,r,a,i,o){return g(t^n^r,e,t,a,i,o)}function w(e,t,n,r,a,i,o){return g(n^(t|~r),e,t,a,i,o)}var O=y("v3",48,(function(e){if("string"==typeof e){var t=unescape(encodeURIComponent(e));e=new Uint8Array(t.length);for(var n=0;n<t.length;++n)e[n]=t.charCodeAt(n)}return function(e){for(var t=[],n=32*e.length,r="0123456789abcdef",a=0;a<n;a+=8){var i=e[a>>5]>>>a%32&255,o=parseInt(r.charAt(i>>>4&15)+r.charAt(15&i),16);t.push(o)}return t}(function(e,t){e[t>>5]|=128<<t%32,e[h(t)-1]=t;for(var n=1732584193,r=-271733879,a=-1732584194,i=271733878,o=0;o<e.length;o+=16){var s=n,c=r,m=a,l=i;n=b(n,r,a,i,e[o],7,-680876936),i=b(i,n,r,a,e[o+1],12,-389564586),a=b(a,i,n,r,e[o+2],17,606105819),r=b(r,a,i,n,e[o+3],22,-1044525330),n=b(n,r,a,i,e[o+4],7,-176418897),i=b(i,n,r,a,e[o+5],12,1200080426),a=b(a,i,n,r,e[o+6],17,-1473231341),r=b(r,a,i,n,e[o+7],22,-45705983),n=b(n,r,a,i,e[o+8],7,1770035416),i=b(i,n,r,a,e[o+9],12,-1958414417),a=b(a,i,n,r,e[o+10],17,-42063),r=b(r,a,i,n,e[o+11],22,-1990404162),n=b(n,r,a,i,e[o+12],7,1804603682),i=b(i,n,r,a,e[o+13],12,-40341101),a=b(a,i,n,r,e[o+14],17,-1502002290),n=$(n,r=b(r,a,i,n,e[o+15],22,1236535329),a,i,e[o+1],5,-165796510),i=$(i,n,r,a,e[o+6],9,-1069501632),a=$(a,i,n,r,e[o+11],14,643717713),r=$(r,a,i,n,e[o],20,-373897302),n=$(n,r,a,i,e[o+5],5,-701558691),i=$(i,n,r,a,e[o+10],9,38016083),a=$(a,i,n,r,e[o+15],14,-660478335),r=$(r,a,i,n,e[o+4],20,-405537848),n=$(n,r,a,i,e[o+9],5,568446438),i=$(i,n,r,a,e[o+14],9,-1019803690),a=$(a,i,n,r,e[o+3],14,-187363961),r=$(r,a,i,n,e[o+8],20,1163531501),n=$(n,r,a,i,e[o+13],5,-1444681467),i=$(i,n,r,a,e[o+2],9,-51403784),a=$(a,i,n,r,e[o+7],14,1735328473),n=I(n,r=$(r,a,i,n,e[o+12],20,-1926607734),a,i,e[o+5],4,-378558),i=I(i,n,r,a,e[o+8],11,-2022574463),a=I(a,i,n,r,e[o+11],16,1839030562),r=I(r,a,i,n,e[o+14],23,-35309556),n=I(n,r,a,i,e[o+1],4,-1530992060),i=I(i,n,r,a,e[o+4],11,1272893353),a=I(a,i,n,r,e[o+7],16,-155497632),r=I(r,a,i,n,e[o+10],23,-1094730640),n=I(n,r,a,i,e[o+13],4,681279174),i=I(i,n,r,a,e[o],11,-358537222),a=I(a,i,n,r,e[o+3],16,-722521979),r=I(r,a,i,n,e[o+6],23,76029189),n=I(n,r,a,i,e[o+9],4,-640364487),i=I(i,n,r,a,e[o+12],11,-421815835),a=I(a,i,n,r,e[o+15],16,530742520),n=w(n,r=I(r,a,i,n,e[o+2],23,-995338651),a,i,e[o],6,-198630844),i=w(i,n,r,a,e[o+7],10,1126891415),a=w(a,i,n,r,e[o+14],15,-1416354905),r=w(r,a,i,n,e[o+5],21,-57434055),n=w(n,r,a,i,e[o+12],6,1700485571),i=w(i,n,r,a,e[o+3],10,-1894986606),a=w(a,i,n,r,e[o+10],15,-1051523),r=w(r,a,i,n,e[o+1],21,-2054922799),n=w(n,r,a,i,e[o+8],6,1873313359),i=w(i,n,r,a,e[o+15],10,-30611744),a=w(a,i,n,r,e[o+6],15,-1560198380),r=w(r,a,i,n,e[o+13],21,1309151649),n=w(n,r,a,i,e[o+4],6,-145523070),i=w(i,n,r,a,e[o+11],10,-1120210379),a=w(a,i,n,r,e[o+2],15,718787259),r=w(r,a,i,n,e[o+9],21,-343485551),n=v(n,s),r=v(r,c),a=v(a,m),i=v(i,l)}return[n,r,a,i]}(function(e){if(0===e.length)return[];for(var t=8*e.length,n=new Uint32Array(h(t)),r=0;r<t;r+=8)n[r>>5]|=(255&e[r/8])<<r%32;return n}(e),8*e.length))})),x=O;function S(e,t,n,r){switch(e){case 0:return t&n^~t&r;case 1:case 3:return t^n^r;case 2:return t&n^t&r^n&r}}function j(e,t){return e<<t|e>>>32-t}var E=y("v5",80,(function(e){var t=[1518500249,1859775393,2400959708,3395469782],n=[1732584193,4023233417,2562383102,271733878,3285377520];if("string"==typeof e){var r=unescape(encodeURIComponent(e));e=[];for(var a=0;a<r.length;++a)e.push(r.charCodeAt(a))}else Array.isArray(e)||(e=Array.prototype.slice.call(e));e.push(128);for(var i=e.length/4+2,o=Math.ceil(i/16),s=new Array(o),c=0;c<o;++c){for(var m=new Uint32Array(16),l=0;l<16;++l)m[l]=e[64*c+4*l]<<24|e[64*c+4*l+1]<<16|e[64*c+4*l+2]<<8|e[64*c+4*l+3];s[c]=m}s[o-1][14]=8*(e.length-1)/Math.pow(2,32),s[o-1][14]=Math.floor(s[o-1][14]),s[o-1][15]=8*(e.length-1)&4294967295;for(var p=0;p<o;++p){for(var d=new Uint32Array(80),u=0;u<16;++u)d[u]=s[p][u];for(var f=16;f<80;++f)d[f]=j(d[f-3]^d[f-8]^d[f-14]^d[f-16],1);for(var y=n[0],h=n[1],v=n[2],g=n[3],b=n[4],$=0;$<80;++$){var I=Math.floor($/20),w=j(y,5)+S(I,h,v,g)+b+t[I]+d[$]>>>0;b=g,g=v,v=j(h,30)>>>0,h=y,y=w}n[0]=n[0]+y>>>0,n[1]=n[1]+h>>>0,n[2]=n[2]+v>>>0,n[3]=n[3]+g>>>0,n[4]=n[4]+b>>>0}return[n[0]>>24&255,n[0]>>16&255,n[0]>>8&255,255&n[0],n[1]>>24&255,n[1]>>16&255,n[1]>>8&255,255&n[1],n[2]>>24&255,n[2]>>16&255,n[2]>>8&255,255&n[2],n[3]>>24&255,n[3]>>16&255,n[3]>>8&255,255&n[3],n[4]>>24&255,n[4]>>16&255,n[4]>>8&255,255&n[4]]})),P=E;var A=Object.freeze({__proto__:null,v1:function(e,t,n){var r=t&&n||0,i=t||new Array(16),o=(e=e||{}).node||s,m=void 0!==e.clockseq?e.clockseq:c;if(null==o||null==m){var l=e.random||(e.rng||a)();null==o&&(o=s=[1|l[0],l[1],l[2],l[3],l[4],l[5]]),null==m&&(m=c=16383&(l[6]<<8|l[7]))}var f=void 0!==e.msecs?e.msecs:Date.now(),y=void 0!==e.nsecs?e.nsecs:u+1,h=f-d+(y-u)/1e4;if(h<0&&void 0===e.clockseq&&(m=m+1&16383),(h<0||f>d)&&void 0===e.nsecs&&(y=0),y>=1e4)throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");d=f,u=y,c=m;var v=(1e4*(268435455&(f+=122192928e5))+y)%4294967296;i[r++]=v>>>24&255,i[r++]=v>>>16&255,i[r++]=v>>>8&255,i[r++]=255&v;var g=f/4294967296*1e4&268435455;i[r++]=g>>>8&255,i[r++]=255&g,i[r++]=g>>>24&15|16,i[r++]=g>>>16&255,i[r++]=m>>>8|128,i[r++]=255&m;for(var b=0;b<6;++b)i[r+b]=o[b];return t||p(i)},v3:x,v4:function(e,t,n){var r=(e=e||{}).random||(e.rng||a)();if(r[6]=15&r[6]|64,r[8]=63&r[8]|128,t){n=n||0;for(var i=0;i<16;++i)t[n+i]=r[i];return t}return p(r)},v5:P,NIL:"00000000-0000-0000-0000-000000000000",version:function(e){if(!o(e))throw TypeError("Invalid UUID");return parseInt(e.substr(14,1),16)},validate:o,stringify:p,parse:f}),C=n(A),N=function(e,t){return function n(){null==t&&(t=e.length);var r=[].slice.call(arguments);return r.length>=t?e.apply(this,r):function(){return n.apply(this,r.concat([].slice.call(arguments)))}}};var K,R,D={exports:{}};K=D,R=D.exports,function(e,t){var n={};e.PubSub?(n=e.PubSub,console.warn("PubSub already loaded, using existing version")):(e.PubSub=n,function(e){var t={},n=-1,r="*";function a(e){var t;for(t in e)if(Object.prototype.hasOwnProperty.call(e,t))return!0;return!1}function i(e){return function(){throw e}}function o(e,t,n){try{e(t,n)}catch(e){setTimeout(i(e),0)}}function s(e,t,n){e(t,n)}function c(e,n,r,a){var i,c=t[n],m=a?s:o;if(Object.prototype.hasOwnProperty.call(t,n))for(i in c)Object.prototype.hasOwnProperty.call(c,i)&&m(c[i],e,r)}function m(e,t,n){return function(){var a=String(e),i=a.lastIndexOf(".");for(c(e,e,t,n);-1!==i;)i=(a=a.substr(0,i)).lastIndexOf("."),c(e,a,t,n);c(e,r,t,n)}}function l(e){var n=String(e);return Boolean(Object.prototype.hasOwnProperty.call(t,n)&&a(t[n]))}function p(e){for(var t=String(e),n=l(t)||l(r),a=t.lastIndexOf(".");!n&&-1!==a;)a=(t=t.substr(0,a)).lastIndexOf("."),n=l(t);return n}function d(e,t,n,r){var a=m(e="symbol"==typeof e?e.toString():e,t,r);return!!p(e)&&(!0===n?a():setTimeout(a,0),!0)}e.publish=function(t,n){return d(t,n,!1,e.immediateExceptions)},e.publishSync=function(t,n){return d(t,n,!0,e.immediateExceptions)},e.subscribe=function(e,r){if("function"!=typeof r)return!1;e="symbol"==typeof e?e.toString():e,Object.prototype.hasOwnProperty.call(t,e)||(t[e]={});var a="uid_"+String(++n);return t[e][a]=r,a},e.subscribeAll=function(t){return e.subscribe(r,t)},e.subscribeOnce=function(t,n){var r=e.subscribe(t,(function(){e.unsubscribe(r),n.apply(this,arguments)}));return e},e.clearAllSubscriptions=function(){t={}},e.clearSubscriptions=function(e){var n;for(n in t)Object.prototype.hasOwnProperty.call(t,n)&&0===n.indexOf(e)&&delete t[n]},e.countSubscriptions=function(e){var n,r,a=0;for(n in t)if(Object.prototype.hasOwnProperty.call(t,n)&&0===n.indexOf(e)){for(r in t[n])a++;break}return a},e.getSubscriptions=function(e){var n,r=[];for(n in t)Object.prototype.hasOwnProperty.call(t,n)&&0===n.indexOf(e)&&r.push(n);return r},e.unsubscribe=function(n){var r,a,i,o=function(e){var n;for(n in t)if(Object.prototype.hasOwnProperty.call(t,n)&&0===n.indexOf(e))return!0;return!1},s="string"==typeof n&&(Object.prototype.hasOwnProperty.call(t,n)||o(n)),c=!s&&"string"==typeof n,m="function"==typeof n,l=!1;if(!s){for(r in t)if(Object.prototype.hasOwnProperty.call(t,r)){if(a=t[r],c&&a[n]){delete a[n],l=n;break}if(m)for(i in a)Object.prototype.hasOwnProperty.call(a,i)&&a[i]===n&&(delete a[i],l=!0)}return l}e.clearSubscriptions(n)}}(n)),void 0!==K&&K.exports&&(R=K.exports=n),R.PubSub=n,K.exports=R=n}("object"==typeof window&&window||t);var M=function(e,t){if(e=e.trim(),(t=t.trim()).startsWith("about:"))return t;const n=function(e){const t={host:"",path:"",query:"",protocol:""};let n=e,r=e.indexOf("//");t.protocol=n.substring(0,r),r+=2;const a=e.indexOf("/",r),i=e.indexOf("?"),o=e.indexOf("#");-1!==o&&(n=n.substring(0,o));if(-1!==i){const e=n.substring(i);t.query=e,n=n.substring(0,i)}if(-1!==a){const e=n.substring(0,a);t.host=e,n=n.substring(a),t.path=n}else t.host=n;return t}(e),r=function(e){const t={href:e,hash:"",query:"",netPath:!1,absolutePath:!1,relativePath:!1};if(L.test(e))return t.netPath=!0,t;"/"===e[0]?t.absolutePath=!0:""!==e&&(t.relativePath=!0);let n=e;const r=e.indexOf("?"),a=e.indexOf("#");if(-1!==a){const e=n.substring(a);t.hash=e,n=n.substring(0,a)}if(-1!==r){const e=n.substring(r);t.query=e,n=n.substring(0,r)}return t.path=n,t}(t);if(!n.protocol&&!r.netPath)throw new Error("Error, protocol is not specified");if(r.netPath)return r.href.startsWith("//")&&(r.href=n.protocol+r.href),function(e){const t=e.indexOf("//")+2,n=!e.includes("/",t),r=!e.includes("?",t),a=!e.includes("#",t);return n&&r&&a}(r.href)?T(r.href):r.href;if(r.absolutePath){const{path:e,query:t,hash:a}=r;return n.host+q(e)+t+a}if(r.relativePath){const{path:e,query:t,hash:a}=r;let i,o=n.path,s=n.host;return 0===e.length?i=o:(o=o.substring(0,o.lastIndexOf("/")),i=q(o+"/"+e)),s+=""!==i||t||a?i+t+a:"/",s}{const{host:e,path:t,query:a}=n;return t||a?e+t+a+r.hash:T(e)}};function T(e){return e+("/"===e[e.length-1]?"":"/")}function q(e){let t=e.split("/");""===t[0]&&(t=t.slice(1));let n=[];return t.forEach(((e,r)=>{"."!==e&&(".."===e?n.pop():""===e&&r!==t.length-1||n.push(e))})),"/"+n.join("/")}const L=new RegExp("^([a-z][a-z0-9+.-]*:)?//","i");const k=M,V={null:e=>null===e,boolean:e=>"boolean"==typeof e,object:e=>"object"==typeof e&&!Array.isArray(e)&&null!==e,array:e=>Array.isArray(e),number:e=>"number"==typeof e,integer:e=>Number.isInteger(e),string:e=>"string"==typeof e},U=e=>{const t=e.indexOf("#"),n=-1===t?e.length:t,r=e.slice(0,n),a=e.slice(n+1);return[decodeURI(r),decodeURI(a)]},_=e=>{const t=RegExp(/^(.+):\/\//).exec(e);return t?t[1]:""};var J={jsonTypeOf:(e,t)=>V[t](e),splitUrl:U,safeResolveUrl:(e,t)=>{const n=k(e,t),r=U(e)[0];if(r&&"file"===_(n)&&"file"!==_(r))throw Error(`Can't access file '${n}' resource from network context '${e}'`);return n},pathRelative:(e,t)=>{if(e===t)return"";let n=1;const r=e.length-1,a=t.length-n,i=r<a?r:a;let o=-1,s=0;for(;s<i;s++){const r=e.charCodeAt(s+1);if(r!==t.charCodeAt(n+s))break;47===r&&(o=s)}if(a>i){if(47===t.charCodeAt(n+s))return t.slice(n+s+1);if(0===s)return t.slice(n+s)}r>i&&(47===e.charCodeAt(s+1)?o=s:0===i&&(o=0));let c="";for(s=o+2;s<=e.length;++s)s!==e.length&&47!==e.charCodeAt(s)||(c+=0===c.length?"..":"/..");return n+=o,c.length>0?`${c}${t.slice(n,t.length)}`:(47===t.charCodeAt(n)&&++n,t.slice(n,t.length))}};const z=N,F=e=>{if(e.length>0&&"/"!==e[0])throw Error("Invalid JSON Pointer");return e.split("/").slice(1).map(Q)},B=(e,t,n,r)=>{if(0===e.length)return n;if(e.length>1){const a=e.shift();return{...t,[a]:B(e,ee(t,a,r),n,X(a,r))}}if(Array.isArray(t)){const r=[...t];return r[Y(t,e[0])]=n,r}return"object"==typeof t&&null!==t?{...t,[e[0]]:n}:ee(t,e[0],r)},Z=(e,t,n,r)=>{if(0!==e.length)if(1!==e.length||te(t)){const a=e.shift();Z(e,ee(t,a,r),n,X(a,r))}else{t[Y(t,e[0])]=n}},G=(e,t,n)=>{if(0!=e.length){if(e.length>1){const r=e.shift(),a=ee(t,r,n);return{...t,[r]:G(e,a,X(r,n))}}if(Array.isArray(t))return t.filter(((t,n)=>n!=e[0]));if("object"==typeof t&&null!==t){const{[e[0]]:n,...r}=t;return r}return ee(t,e[0],n)}},W=(e,t,n)=>{if(0!==e.length)if(e.length>1){const r=e.shift(),a=ee(t,r,n);W(e,a,X(r,n))}else Array.isArray(t)?t.splice(e[0],1):"object"==typeof t&&null!==t?delete t[e[0]]:ee(t,e[0],n)},X=z(((e,t)=>t+"/"+H(e))),H=e=>e.toString().replace(/~/g,"~0").replace(/\//g,"~1"),Q=e=>e.toString().replace(/~1/g,"/").replace(/~0/g,"~"),Y=(e,t)=>Array.isArray(e)&&"-"===t?e.length:t,ee=(e,t,n="")=>{if(void 0===e)throw TypeError(`Value at '${n}' is undefined and does not have property '${t}'`);if(null===e)throw TypeError(`Value at '${n}' is null and does not have property '${t}'`);if(te(e))throw TypeError(`Value at '${n}' is a ${typeof e} and does not have property '${t}'`);return e[Y(e,t)]},te=e=>null===e||"object"!=typeof e;var ne={nil:"",append:X,get:(e,t)=>{const n=F(e),r=e=>n.reduce((([e,t],n)=>[ee(e,n,t),X(n,t)]),[e,""])[0];return void 0===t?r:r(t)},set:(e,t,n)=>{const r=F(e),a=z(((e,t)=>B(r,e,t,"")));return void 0===t?a:a(t,n)},assign:(e,t,n)=>{const r=F(e),a=z(((e,t)=>Z(r,e,t,"")));return void 0===t?a:a(t,n)},unset:(e,t)=>{const n=F(e),r=e=>G(n,e,"");return void 0===t?r:r(t)},remove:(e,t)=>{const n=F(e),r=e=>W(n,e,"");return void 0===t?r:r(t)}};const re=Symbol("$__value"),ae=Symbol("$__href");var ie={cons:(e,t)=>Object.freeze({[ae]:e,[re]:t}),isReference:e=>e&&void 0!==e[ae],href:e=>e[ae],value:e=>e[re]};const oe=ne,se=N,{jsonTypeOf:ce}=J,me=ie,le=Object.freeze({id:"",pointer:"",instance:void 0,value:void 0}),pe=e=>me.isReference(e.value)?me.value(e.value):e.value,de=se(((e,t)=>ce(pe(e),t))),ue=(e,t)=>Object.freeze({...t,pointer:oe.append(e,t.pointer),value:pe(t)[e]}),fe=se(((e,t)=>pe(t).map(((n,r,a,i)=>e(ue(r,t),r,a,i))))),ye=se(((e,t)=>pe(t).map(((e,n,r,a)=>ue(n,t))).filter(((t,n,r,a)=>e(t,n,r,a))))),he=se(((e,t,n)=>pe(n).reduce(((t,r,a)=>e(t,ue(a,n),a)),t))),ve=se(((e,t)=>pe(t).every(((n,r,a,i)=>e(ue(r,t),r,a,i))))),ge=se(((e,t)=>pe(t).some(((n,r,a,i)=>e(ue(r,t),r,a,i)))));var be={nil:le,cons:(e,t="")=>Object.freeze({...le,id:t,instance:e,value:e}),uri:e=>`${e.id}#${encodeURI(e.pointer)}`,value:pe,has:(e,t)=>e in pe(t),typeOf:de,step:ue,entries:e=>Object.keys(pe(e)).map((t=>[t,ue(t,e)])),keys:e=>Object.keys(pe(e)),map:fe,filter:ye,reduce:he,every:ve,some:ge,length:e=>pe(e).length},$e={},Ie=/; *([!#$%&'*+.^_`|~0-9A-Za-z-]+) *= *("(?:[\u000b\u0020\u0021\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u000b\u0020-\u00ff])*"|[!#$%&'*+.^_`|~0-9A-Za-z-]+) */g,we=/^[\u000b\u0020-\u007e\u0080-\u00ff]+$/,Oe=/^[!#$%&'*+.^_`|~0-9A-Za-z-]+$/,xe=/\\([\u000b\u0020-\u00ff])/g,Se=/([\\"])/g,je=/^[!#$%&'*+.^_`|~0-9A-Za-z-]+\/[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;function Ee(e){var t=String(e);if(Oe.test(t))return t;if(t.length>0&&!we.test(t))throw new TypeError("invalid parameter value");return'"'+t.replace(Se,"\\$1")+'"'}function Pe(e){this.parameters=Object.create(null),this.type=e}$e.format=function(e){if(!e||"object"!=typeof e)throw new TypeError("argument obj is required");var t=e.parameters,n=e.type;if(!n||!je.test(n))throw new TypeError("invalid type");var r=n;if(t&&"object"==typeof t)for(var a,i=Object.keys(t).sort(),o=0;o<i.length;o++){if(a=i[o],!Oe.test(a))throw new TypeError("invalid parameter name");r+="; "+a+"="+Ee(t[a])}return r},$e.parse=function(e){if(!e)throw new TypeError("argument string is required");var t="object"==typeof e?function(e){var t;"function"==typeof e.getHeader?t=e.getHeader("content-type"):"object"==typeof e.headers&&(t=e.headers&&e.headers["content-type"]);if("string"!=typeof t)throw new TypeError("content-type header is missing from object");return t}(e):e;if("string"!=typeof t)throw new TypeError("argument string is required to be a string");var n=t.indexOf(";"),r=-1!==n?t.substr(0,n).trim():t.trim();if(!je.test(r))throw new TypeError("invalid media type");var a=new Pe(r.toLowerCase());if(-1!==n){var i,o,s;for(Ie.lastIndex=n;o=Ie.exec(t);){if(o.index!==n)throw new TypeError("invalid parameter format");n+=o[0].length,i=o[1].toLowerCase(),'"'===(s=o[2])[0]&&(s=s.substr(1,s.length-2).replace(xe,"$1")),a.parameters[i]=s}if(n!==t.length)throw new TypeError("invalid parameter format")}return a};var Ae=async e=>Object.entries(await e);var Ce=N((async(e,t)=>(await t).map(e)));var Ne=N((async(e,t,n)=>(await n).reduce((async(t,n)=>e(await t,n)),t)));const Ke=Ne;var Re=N((async(e,t,n={})=>Ke((async(t,n)=>await e(n)?t.concat([n]):t),[],t,n)));const De=Ce;var Me=N((async(e,t)=>{const n=await De(e,t);return(await Promise.all(n)).some((e=>e))}));const Te=Ce;var qe=N((async(e,t)=>{const n=await Te(e,t);return(await Promise.all(n)).every((e=>e))}));var Le=N(((e,t)=>e.reduce((async(e,t)=>t(await e)),t)));const ke=Le,Ve=Ae,Ue=Ne;var _e={entries:Ae,map:Ce,filter:Re,reduce:Ne,some:Me,every:qe,pipeline:Le,all:e=>Promise.all(e),allValues:e=>ke([Ve,Ue((async(e,[t,n])=>(e[t]=await n,e)),{})],e)},Je=fetch;const ze=$e,Fe=N,Be=_e,Ze=ne,{jsonTypeOf:Ge,splitUrl:We,safeResolveUrl:Xe,pathRelative:He}=J,Qe=Je,Ye=ie,et={},tt={},nt=(e,t)=>{const n=e in tt?tt[e]:e;if(n in et)return et[n][t]},rt={},at={},it=(e,t="",n="")=>{e=JSON.parse(JSON.stringify(e));const r=We(e.$schema||n)[0];if(!r)throw Error("Couldn't determine schema version");delete e.$schema;const a=nt(r,"baseToken"),i=nt(r,"anchorToken"),o=We(t)[0];if(!o&&!We(e[a]||"")[0])throw Error("Couldn't determine an identifier for the schema");const s=Xe(o,e[a]||""),[c,m]=We(s);delete e[a],m&&a===i&&(e[i]=i!==a?encodeURI(m):`#${encodeURI(m)}`),o&&(at[o]=c);const l={},p=nt(r,"recursiveAnchorToken");let d;!0===e[p]&&(l[""]=`${c}#`,e[i]="",delete e[p]);const u=nt(r,"vocabularyToken");Ge(e[u],"object")?(tt[c]=r,d=e[u],delete e[u]):(tt[c]=r,d={[r]:!0});const f={"":""};return rt[c]={id:c,schemaVersion:r,schema:ot(e,c,r,Ze.nil,f,l),anchors:f,dynamicAnchors:l,vocabulary:d,validated:!1},c},ot=(e,t,n,r,a,i)=>{if(Ge(e,"object")){const o="string"==typeof e.$schema?We(e.$schema)[0]:n,s=nt(o,"embeddedToken"),c=nt(o,"anchorToken");if("string"==typeof e[s]&&(s!==c||"#"!==e[s][0])){const r=Xe(t,e[s]);return e[s]=r,it(e,r,n),Ye.cons(e[s],e)}const m=nt(n,"anchorToken"),l=nt(n,"dynamicAnchorToken");"string"==typeof e[l]&&(i[e[l]]=`${t}#${encodeURI(r)}`,a[e[l]]=r,delete e[l]);const p=nt(n,"embeddedToken");if("string"==typeof e[m]){const t=m!==p?e[m]:e[m].slice(1);a[t]=r,delete e[m]}const d=nt(n,"jrefToken");if("string"==typeof e[d])return Ye.cons(e[d],e);for(const o in e)e[o]=ot(e[o],t,n,Ze.append(o,r),a,i);return e}return Array.isArray(e)?e.map(((e,o)=>ot(e,t,n,Ze.append(o,r),a,i))):e},st=e=>rt[at[e]]||rt[e],ct=Object.freeze({id:"",schemaVersion:void 0,vocabulary:{},pointer:Ze.nil,schema:void 0,value:void 0,anchors:{},dynamicAnchors:{},validated:!0}),mt=async(e,t=ct)=>{const n=Xe(dt(t),e),[r,a]=We(n);if(!(e=>e in rt||e in at)(r)){const e=await Qe(r,{headers:{Accept:"application/schema+json"}});if(e.status>=400)throw await e.text(),Error(`Failed to retrieve schema with id: ${r}`);if(e.headers.has("content-type")){const t=ze.parse(e.headers.get("content-type")).type;if("application/schema+json"!==t)throw Error(`${r} is not a schema. Found a document with media type: ${t}`)}it(await e.json(),r)}const i=st(r),o="/"!==a[0]?pt(i,a):a,s=Object.freeze({...i,pointer:o,value:Ze.get(o,i.schema)});return lt(s)},lt=e=>Ye.isReference(e.value)?mt(Ye.href(e.value),e):e,pt=(e,t)=>{if(!(t in e.anchors))throw Error(`No such anchor '${encodeURI(e.id)}#${encodeURI(t)}'`);return e.anchors[t]},dt=e=>`${e.id}#${encodeURI(e.pointer)}`,ut=e=>Ye.isReference(e.value)?Ye.value(e.value):e.value,ft=(e,t)=>{const n=st(t.id),r=Object.freeze({...t,pointer:Ze.append(e,t.pointer),value:ut(t)[e],validated:n.validated});return lt(r)},yt=Fe(((e,t)=>Be.pipeline([ut,Be.map((async(n,r)=>e(await ft(r,t),r))),Be.all],t))),ht={parentId:"",parentDialect:"",includeEmbedded:!0},vt=(e,t)=>{if(t.startsWith("file://")){const n=e.slice(7,e.lastIndexOf("/"));return""===e?"":He(n,t.slice(7))}return t};var gt={setConfig:(e,t,n)=>{et[e]||(et[e]={}),et[e][t]=n},getConfig:nt,add:it,get:mt,markValidated:e=>{rt[e].validated=!0},uri:dt,value:ut,getAnchorPointer:pt,typeOf:(e,t)=>Ge(ut(e),t),has:(e,t)=>e in ut(t),step:ft,keys:e=>Object.keys(ut(e)),entries:e=>Be.pipeline([ut,Object.keys,Be.map((async t=>[t,await ft(t,e)])),Be.all],e),map:yt,length:e=>ut(e).length,toSchema:(e,t={})=>{const n={...ht,...t},r=JSON.parse(JSON.stringify(e.schema,((t,r)=>{if(!Ye.isReference(r))return r;const a=Ye.value(r),i=a.$schema||e.schemaVersion,o=nt(i,"embeddedToken");return!n.includeEmbedded&&o in a?void 0:Ye.value(r)}))),a=nt(e.schemaVersion,"dynamicAnchorToken");Object.entries(e.dynamicAnchors).forEach((([e,t])=>{const n=We(t)[1];Ze.assign(n,r,{[a]:e,...Ze.get(n,r)})}));const i=nt(e.schemaVersion,"anchorToken");Object.entries(e.anchors).filter((([e])=>""!==e)).forEach((([e,t])=>{Ze.assign(t,r,{[i]:e,...Ze.get(t,r)})}));const o=nt(e.schemaVersion,"baseToken"),s=vt(n.parentId,e.id),c=n.parentDialect===e.schemaVersion?"":e.schemaVersion;return{...s&&{[o]:s},...c&&{$schema:c},...r}}};class bt extends Error{constructor(e){super("Invalid Schema"),this.name=this.constructor.name,this.output=e}}var $t=bt;const It=N,wt=D.exports,{splitUrl:Ot}=J,xt=be,St=gt,jt=$t,Et="FLAG",Pt="BASIC",At="DETAILED",Ct="VERBOSE";let Nt=At,Kt=!0;const Rt=async e=>{const t={metaData:{}};return{ast:t,schemaUri:await Ut(e,t)}},Dt=It((({ast:e,schemaUri:t},n,r=Et)=>{if(![Et,Pt,At,Ct].includes(r))throw Error(`The '${r}' error format is not supported`);const a=[],i=wt.subscribe("result",Mt(r,a));return Jt(t,n,e,{}),wt.unsubscribe(i),a[0]})),Mt=(e,t)=>{const n=[];return(r,a)=>{if("result"===r){const{keyword:e,absoluteKeywordLocation:t,instanceLocation:r,valid:i}=a,o={keyword:e,absoluteKeywordLocation:t,instanceLocation:r,valid:i,errors:[]};n.push(o)}else if("result.start"===r)n.push(r);else if("result.end"===r){const r=n.pop();for(;"result.start"!==n[n.length-1];){const t=n.pop(),a=[t];e===Pt&&(a.push(...t.errors),delete t.errors),(e===Ct||e!==Et&&!t.valid)&&r.errors.unshift(...a)}n[n.length-1]=r,t[0]=r}}},Tt={},qt=e=>Tt[e],Lt=e=>e in Tt,kt={},Vt={},Ut=async(e,t)=>{if(e=await _t(e),!Lt(`${e.schemaVersion}#validate`)){const t=await St.get(e.schemaVersion);(St.getConfig(t.id,"mandatoryVocabularies")||[]).forEach((e=>{if(!t.vocabulary[e])throw Error(`Vocabulary '${e}' must be explicitly declared and required`)})),Object.entries(t.vocabulary).forEach((([e,n])=>{if(e in kt)Object.entries(kt[e]).forEach((([e,n])=>{((e,t)=>{Tt[e]={collectEvaluatedItems:(e,n,r,a,i)=>t.interpret(e,n,r,a,i)&&new Set,collectEvaluatedProperties:(e,n,r,a,i)=>t.interpret(e,n,r,a,i)&&[],...t}})(`${t.id}#${e}`,n)}));else if(n)throw Error(`Missing required vocabulary: ${e}`)}))}if(Kt&&!e.validated){if(St.markValidated(e.id),!(e.schemaVersion in Vt)){const t=await St.get(e.schemaVersion),n=await Rt(t);Vt[t.id]=Dt(n)}const t=xt.cons(e.schema,e.id),n=Vt[e.schemaVersion](t,Nt);if(!n.valid)throw new jt(n)}return e.id in t.metaData||(t.metaData[e.id]={id:e.id,dynamicAnchors:e.dynamicAnchors,anchors:e.anchors}),qt(`${e.schemaVersion}#validate`).compile(e,t)},_t=async e=>St.typeOf(e,"string")?_t(await St.get(St.value(e),e)):e,Jt=(e,t,n,r)=>{const a=zt(e,n),i=Ot(e)[0];return qt(a).interpret(e,t,n,{...n.metaData[i].dynamicAnchors,...r})},zt=(e,t)=>{if(!(e in t))throw Error(`No schema found at ${e}`);return t[e][0]};var Ft={validate:async(e,t,n)=>{const r=await Rt(e),a=(e,t)=>Dt(r,xt.cons(e),t);return void 0===t?a:a(t,n)},compile:Rt,interpret:Dt,setMetaOutputFormat:e=>{Nt=e},setShouldMetaValidate:e=>{Kt=e},FLAG:Et,BASIC:Pt,DETAILED:At,VERBOSE:Ct,add:(e,t="",n="")=>{const r=St.add(e,t,n);delete Vt[r]},getKeyword:qt,hasKeyword:Lt,defineVocabulary:(e,t)=>{kt[e]=t},compileSchema:Ut,interpretSchema:Jt,collectEvaluatedProperties:(e,t,n,r,a)=>{const i=zt(e,n);return qt(i).collectEvaluatedProperties(e,t,n,r,a)},collectEvaluatedItems:(e,t,n,r,a)=>{const i=zt(e,n);return qt(i).collectEvaluatedItems(e,t,n,r,a)}};const Bt=gt;var Zt={compile:e=>Bt.value(e),interpret:()=>!0};const Gt=_e,Wt=D.exports,Xt=Ft,Ht=be,Qt=gt;var Yt={compile:async(e,t)=>{const n=Qt.uri(e);if(!(n in t)){t[n]=!1;const r=Qt.value(e);if(!["object","boolean"].includes(typeof r))throw Error(`No schema found at '${Qt.uri(e)}'`);t[n]=[`${e.schemaVersion}#validate`,Qt.uri(e),"boolean"==typeof r?r:await Gt.pipeline([Qt.entries,Gt.map((([t,n])=>[`${e.schemaVersion}#${t}`,n])),Gt.filter((([t])=>Xt.hasKeyword(t)&&t!==`${e.schemaVersion}#validate`)),Gt.map((async([n,r])=>{const a=await Xt.getKeyword(n).compile(r,t,e);return[n,Qt.uri(r),a]})),Gt.all],e)]}return n},interpret:(e,t,n,r)=>{const[a,i,o]=n[e];Wt.publishSync("result.start");const s="boolean"==typeof o?o:o.every((([e,a,i])=>{Wt.publishSync("result.start");const o=Xt.getKeyword(e).interpret(i,t,n,r);return Wt.publishSync("result",{keyword:e,absoluteKeywordLocation:a,instanceLocation:Ht.uri(t),valid:o,ast:i}),Wt.publishSync("result.end"),o}));return Wt.publishSync("result",{keyword:a,absoluteKeywordLocation:i,instanceLocation:Ht.uri(t),valid:s,ast:e}),Wt.publishSync("result.end"),s},collectEvaluatedProperties:(e,t,n,r,a=!1)=>{const i=n[e][2];return"boolean"==typeof i?!!i&&[]:i.filter((([e])=>!a||!e.endsWith("#unevaluatedProperties"))).reduce(((e,[a,,i])=>{const o=e&&Xt.getKeyword(a).collectEvaluatedProperties(i,t,n,r);return!1!==o&&[...e,...o]}),[])},collectEvaluatedItems:(e,t,n,r,a=!1)=>{const i=n[e][2];return"boolean"==typeof i?!!i&&new Set:i.filter((([e])=>!a||!e.endsWith("#unevaluatedItems"))).reduce(((e,[a,,i])=>{const o=!1!==e&&Xt.getKeyword(a).collectEvaluatedItems(i,t,n,r);return!1!==o&&new Set([...e,...o])}),new Set)}};var en={Core:Ft,Schema:gt,Instance:be,Reference:ie,Keywords:{metaData:Zt,validate:Yt},InvalidSchemaError:$t};const{Core:tn,Schema:nn,Instance:rn}=en;var an={compile:async(e,t,n)=>{const r=await nn.step("items",n),a=nn.typeOf(r,"array")?nn.length(r):Number.MAX_SAFE_INTEGER;return nn.typeOf(e,"boolean")?[a,nn.value(e)]:[a,await tn.compileSchema(e,t)]},interpret:([e,t],n,r,a)=>!rn.typeOf(n,"array")||("string"==typeof t?rn.every(((n,i)=>i<e||tn.interpretSchema(t,n,r,a)),n):rn.every(((n,r)=>r<e||t),n))};const{Core:on,Schema:sn,Instance:cn}=en,mn=([e,t],n,r,a)=>!cn.typeOf(n,"array")||cn.every(((n,i)=>i<e||on.interpretSchema(t,n,r,a)),n);var ln={compile:async(e,t,n)=>{const r=await sn.step("items",n);return[sn.typeOf(r,"array")?sn.length(r):Number.MAX_SAFE_INTEGER,await on.compileSchema(e,t)]},interpret:mn,collectEvaluatedItems:(e,t,n,r)=>mn(e,t,n,r)&&new Set(cn.map(((e,t)=>t),t))};const{Core:pn,Schema:dn,Instance:un}=en;var fn={compile:async(e,t,n)=>{const r=await dn.step("properties",n),a=dn.typeOf(r,"object")?dn.keys(r):[],i=await dn.step("patternProperties",n),o=dn.typeOf(i,"object")?dn.keys(i).map((e=>new RegExp(e))):[];return dn.typeOf(e,"boolean")?[a,o,dn.value(e)]:[a,o,await pn.compileSchema(e,t)]},interpret:([e,t,n],r,a,i)=>{if(!un.typeOf(r,"object"))return!0;const o=un.entries(r).filter((([n])=>!e.includes(n)&&!t.some((e=>e.test(n)))));return"string"==typeof n?o.every((([,e])=>pn.interpretSchema(n,e,a,i))):0===o.length||n}};const{Core:yn,Schema:hn,Instance:vn}=en,gn=([e,t,n],r,a,i)=>!vn.typeOf(r,"object")||vn.entries(r).filter((([n])=>!e.includes(n)&&!t.some((e=>e.test(n))))).every((([,e])=>yn.interpretSchema(n,e,a,i)));var bn={compile:async(e,t,n)=>{const r=await hn.step("properties",n),a=hn.typeOf(r,"object")?hn.keys(r):[],i=await hn.step("patternProperties",n),o=hn.typeOf(i,"object")?hn.keys(i).map((e=>new RegExp(e))):[];return[a,o,await yn.compileSchema(e,t)]},interpret:gn,collectEvaluatedProperties:(e,t,n,r)=>gn(e,t,n,r)&&[new RegExp("")]};const{Core:$n,Schema:In}=en,wn=_e;var On={compile:(e,t)=>wn.pipeline([In.map((async e=>$n.compileSchema(await e,t))),wn.all],e),interpret:(e,t,n,r)=>e.every((e=>$n.interpretSchema(e,t,n,r))),collectEvaluatedProperties:(e,t,n,r)=>e.reduce(((e,a)=>{const i=e&&$n.collectEvaluatedProperties(a,t,n,r);return!1!==i&&[...e,...i]}),[]),collectEvaluatedItems:(e,t,n,r)=>e.reduce(((e,a)=>{const i=!1!==e&&$n.collectEvaluatedItems(a,t,n,r);return!1!==i&&new Set([...e,...i])}),new Set)};const{Core:xn,Schema:Sn}=en,jn=_e;var En={compile:(e,t)=>jn.pipeline([Sn.map((async e=>xn.compileSchema(await e,t))),jn.all],e),interpret:(e,t,n,r)=>e.filter((e=>xn.interpretSchema(e,t,n,r))).length>0,collectEvaluatedProperties:(e,t,n,r)=>e.reduce(((e,a)=>{const i=xn.collectEvaluatedProperties(a,t,n,r);return!1!==i?[...e||[],...i]:e}),!1),collectEvaluatedItems:(e,t,n,r)=>e.reduce(((e,a)=>{const i=xn.collectEvaluatedItems(a,t,n,r);return!1!==i?new Set([...e||[],...i]):e}),!1)},Pn=Object.keys,An=JSON.stringify;function Cn(e,t){var n,r,a,i,o,s,c;if("string"===(c=typeof e))return An(e);if(!0===e)return"true";if(!1===e)return"false";if(null===e)return"null";if(e instanceof Array){for(a="[",r=e.length-1,n=0;n<r;n++)a+=Cn(e[n],!1)+",";return r>-1&&(a+=Cn(e[n],!1)),a+"]"}if(e instanceof Object){if("function"==typeof e.toJSON)return Cn(e.toJSON(),t);for(r=(i=Pn(e).sort()).length,a="",n=0;n<r;)void 0!==(s=Cn(e[o=i[n]],!0))&&(n&&""!==a&&(a+=","),a+=An(o)+":"+s),n++;return"{"+a+"}"}switch(c){case"function":case"undefined":return t?void 0:null;default:return isFinite(e)?e:null}}var Nn=function(e){return""+Cn(e,!1)};const{Schema:Kn,Instance:Rn}=en,Dn=Nn;var Mn={compile:e=>Dn(Kn.value(e)),interpret:(e,t)=>Dn(Rn.value(t))===e};const{Core:Tn,Instance:qn}=en;var Ln={compile:(e,t)=>Tn.compileSchema(e,t),interpret:(e,t,n,r)=>!qn.typeOf(t,"array")||qn.some((t=>Tn.interpretSchema(e,t,n,r)),t)};const{Core:kn,Schema:Vn,Instance:Un}=en,_n=({contains:e,minContains:t,maxContains:n},r,a,i)=>{if(!Un.typeOf(r,"array"))return!0;const o=Un.reduce(((t,n)=>kn.interpretSchema(e,n,a,i)?t+1:t),0,r);return o>=t&&o<=n};var Jn={compile:async(e,t,n)=>{const r=await kn.compileSchema(e,t),a=await Vn.step("minContains",n),i=Vn.typeOf(a,"number")?Vn.value(a):1,o=await Vn.step("maxContains",n);return{contains:r,minContains:i,maxContains:Vn.typeOf(o,"number")?Vn.value(o):Number.MAX_SAFE_INTEGER}},interpret:_n,collectEvaluatedItems:(e,t,n,r)=>_n(e,t,n,r)&&Un.reduce(((t,a,i)=>kn.interpretSchema(e.contains,a,n,r)?t.add(i):t),new Set,t)};const{Core:zn,Schema:Fn}=en,Bn=_e;var Zn={compile:async(e,t)=>{await Bn.pipeline([Fn.entries,Bn.map((([,e])=>zn.compileSchema(e,t))),Bn.all],e)},interpret:()=>!0};const{Core:Gn,Schema:Wn,Instance:Xn}=en,Hn=_e;var Qn={compile:(e,t)=>Hn.pipeline([Wn.entries,Hn.map((async([e,n])=>[e,Wn.typeOf(n,"array")?Wn.value(n):await Gn.compileSchema(n,t)])),Hn.all],e),interpret:(e,t,n,r)=>{const a=Xn.value(t);return!Xn.typeOf(t,"object")||e.every((([e,i])=>!(e in a)||(Array.isArray(i)?i.every((e=>e in a)):Gn.interpretSchema(i,t,n,r))))}};const{Schema:Yn,Instance:er}=en,tr=_e;var nr={compile:e=>tr.pipeline([Yn.entries,tr.map((([e,t])=>[e,Yn.value(t)])),tr.all],e),interpret:(e,t)=>{const n=er.value(t);return!er.typeOf(t,"object")||e.every((([e,t])=>!(e in n)||t.every((e=>e in n))))}};const{Core:rr,Schema:ar,Instance:ir}=en,or=_e;var sr={compile:(e,t)=>or.pipeline([ar.entries,or.map((async([e,n])=>[e,await rr.compileSchema(n,t)])),or.all],e),interpret:(e,t,n,r)=>{const a=ir.value(t);return!ir.typeOf(t,"object")||e.every((([e,i])=>!(e in a)||rr.interpretSchema(i,t,n,r)))},collectEvaluatedProperties:(e,t,n,r)=>e.reduce(((e,[a,i])=>{if(!e||!ir.has(a,t))return e;const o=rr.collectEvaluatedProperties(i,t,n,r);return!1!==o&&e.concat(o)}),[])};const{Schema:cr,Instance:mr}=en,lr=Nn;var pr={compile:e=>cr.value(e).map(lr),interpret:(e,t)=>e.some((e=>lr(mr.value(t))===e))};const{Schema:dr,Instance:ur}=en;var fr={compile:async e=>dr.value(e),interpret:(e,t)=>!ur.typeOf(t,"number")||ur.value(t)<e};const{Schema:yr,Instance:hr}=en;var vr={compile:async e=>yr.value(e),interpret:(e,t)=>!hr.typeOf(t,"number")||hr.value(t)>e};const{Core:gr}=en;var br={compile:(e,t)=>gr.compileSchema(e,t),interpret:(e,t,n,r)=>(gr.interpretSchema(e,t,n,r),!0),collectEvaluatedProperties:(e,t,n,r)=>gr.collectEvaluatedProperties(e,t,n,r)||[],collectEvaluatedItems:(e,t,n,r)=>gr.collectEvaluatedItems(e,t,n,r)||new Set};const{Core:$r,Schema:Ir}=en,wr=(e,t,n,r)=>{const a=n[e][2];return"boolean"==typeof a?a:a.every((([e,,a])=>$r.getKeyword(e).interpret(a,t,n,r)))};var Or={compile:async(e,t,n)=>{if(Ir.has("if",n)){const r=await Ir.step("if",n);return[await $r.compileSchema(r,t),await $r.compileSchema(e,t)]}return[]},interpret:([e,t],n,r,a)=>void 0===e||!wr(e,n,r,a)||$r.interpretSchema(t,n,r,a),collectEvaluatedProperties:([e,t],n,r,a)=>void 0!==e&&wr(e,n,r,a)?$r.collectEvaluatedProperties(t,n,r,a):[],collectEvaluatedItems:([e,t],n,r,a)=>void 0!==e&&wr(e,n,r,a)?$r.collectEvaluatedItems(t,n,r,a):new Set};const{Core:xr,Schema:Sr}=en,jr=(e,t,n,r)=>{const a=n[e][2];return"boolean"==typeof a?a:a.every((([e,,a])=>xr.getKeyword(e).interpret(a,t,n,r)))};var Er={compile:async(e,t,n)=>{if(Sr.has("if",n)){const r=await Sr.step("if",n);return[await xr.compileSchema(r,t),await xr.compileSchema(e,t)]}return[]},interpret:([e,t],n,r,a)=>void 0===e||jr(e,n,r,a)||xr.interpretSchema(t,n,r,a),collectEvaluatedProperties:([e,t],n,r,a)=>void 0===e||jr(e,n,r,a)?[]:xr.collectEvaluatedProperties(t,n,r,a),collectEvaluatedItems:([e,t],n,r,a)=>void 0===e||jr(e,n,r,a)?new Set:xr.collectEvaluatedItems(t,n,r,a)};const{Core:Pr,Schema:Ar,Instance:Cr}=en,Nr=(e,t,n,r)=>!Cr.typeOf(t,"array")||("string"==typeof e?Cr.every((t=>Pr.interpretSchema(e,t,n,r)),t):Cr.every(((t,a)=>!(a in e)||Pr.interpretSchema(e[a],t,n,r)),t));var Kr={compile:async(e,t)=>{if(Ar.typeOf(e,"array")){const n=await Ar.map((e=>Pr.compileSchema(e,t)),e);return Promise.all(n)}return Pr.compileSchema(e,t)},interpret:Nr,collectEvaluatedItems:(e,t,n,r)=>Nr(e,t,n,r)&&("string"==typeof e?new Set(Cr.map(((e,t)=>t),t)):new Set(e.map(((e,t)=>t))))};const{Core:Rr,Schema:Dr,Instance:Mr}=en,Tr=([e,t],n,r,a)=>!Mr.typeOf(n,"array")||Mr.every(((n,i)=>i<e||Rr.interpretSchema(t,n,r,a)),n);var qr={compile:async(e,t,n)=>{const r=await Dr.step("prefixItems",n);return[Dr.typeOf(r,"array")?Dr.length(r):0,await Rr.compileSchema(e,t)]},interpret:Tr,collectEvaluatedItems:(e,t,n,r)=>Tr(e,t,n,r)&&new Set(Mr.map(((e,t)=>t),t))};const{Schema:Lr,Instance:kr}=en;var Vr={compile:e=>Lr.value(e),interpret:(e,t)=>!kr.typeOf(t,"array")||kr.length(t)<=e};const{Schema:Ur,Instance:_r}=en;var Jr={compile:e=>Ur.value(e),interpret:(e,t)=>!_r.typeOf(t,"string")||_r.length(t)<=e};const{Schema:zr,Instance:Fr}=en;var Br={compile:e=>zr.value(e),interpret:(e,t)=>!Fr.typeOf(t,"string")||[...Fr.value(t)].length<=e};const{Schema:Zr,Instance:Gr}=en;var Wr={compile:e=>Zr.value(e),interpret:(e,t)=>!Gr.typeOf(t,"object")||Gr.keys(t).length<=e};const{Schema:Xr,Instance:Hr}=en;var Qr={compile:async(e,t,n)=>{const r=await Xr.step("exclusiveMaximum",n),a=Xr.value(r);return[Xr.value(e),a]},interpret:([e,t],n)=>{if(!Hr.typeOf(n,"number"))return!0;const r=Hr.value(n);return t?r<e:r<=e}};const{Schema:Yr,Instance:ea}=en;var ta={compile:async e=>Yr.value(e),interpret:(e,t)=>!ea.typeOf(t,"number")||ea.value(t)<=e};const{Schema:na,Instance:ra}=en;var aa={compile:e=>na.value(e),interpret:(e,t)=>!ra.typeOf(t,"array")||ra.length(t)>=e};const{Schema:ia,Instance:oa}=en;var sa={compile:e=>ia.value(e),interpret:(e,t)=>!oa.typeOf(t,"string")||oa.length(t)>=e};const{Schema:ca,Instance:ma}=en;var la={compile:e=>ca.value(e),interpret:(e,t)=>!ma.typeOf(t,"string")||[...ma.value(t)].length>=e};const{Schema:pa,Instance:da}=en;var ua={compile:e=>pa.value(e),interpret:(e,t)=>!da.typeOf(t,"object")||da.keys(t).length>=e};const{Schema:fa,Instance:ya}=en;var ha={compile:async(e,t,n)=>{const r=await fa.step("exclusiveMinimum",n),a=fa.value(r);return[fa.value(e),a]},interpret:([e,t],n)=>{if(!ya.typeOf(n,"number"))return!0;const r=ya.value(n);return t?r>e:r>=e}};const{Schema:va,Instance:ga}=en;var ba={compile:async e=>va.value(e),interpret:(e,t)=>!ga.typeOf(t,"number")||ga.value(t)>=e};const{Schema:$a,Instance:Ia}=en,wa=(e,t)=>Math.abs(e-t)<1.1920929e-7;var Oa={compile:e=>$a.value(e),interpret:(e,t)=>{if(!Ia.typeOf(t,"number"))return!0;const n=Ia.value(t)%e;return wa(0,n)||wa(e,n)}};const{Core:xa}=en;var Sa={compile:xa.compileSchema,interpret:(e,t,n,r)=>!xa.interpretSchema(e,t,n,r)};const{Core:ja,Schema:Ea}=en;var Pa={compile:async(e,t)=>{const n=await Ea.map((e=>ja.compileSchema(e,t)),e);return Promise.all(n)},interpret:(e,t,n,r)=>{let a=0;for(const i of e)if(ja.interpretSchema(i,t,n,r)&&a++,a>1)break;return 1===a},collectEvaluatedProperties:(e,t,n,r)=>{let a=0;return e.reduce(((e,i)=>{if(a>1)return!1;const o=ja.collectEvaluatedProperties(i,t,n,r);return o?0==a++&&o:e}),!1)},collectEvaluatedItems:(e,t,n,r)=>{let a=0;return e.reduce(((e,i)=>{if(a>1)return!1;const o=ja.collectEvaluatedItems(i,t,n,r);return o?0==a++&&o:e}),!1)}};const{Schema:Aa,Instance:Ca}=en;var Na={compile:e=>new RegExp(Aa.value(e),"u"),interpret:(e,t)=>!Ca.typeOf(t,"string")||e.test(Ca.value(t))};const{Core:Ka,Schema:Ra,Instance:Da}=en,Ma=_e,Ta=(e,t,n,r)=>!Da.typeOf(t,"object")||e.every((([e,a])=>Da.entries(t).filter((([t])=>e.test(t))).every((([,e])=>Ka.interpretSchema(a,e,n,r)))));var qa={compile:(e,t)=>Ma.pipeline([Ra.entries,Ma.map((async([e,n])=>[new RegExp(e,"u"),await Ka.compileSchema(n,t)])),Ma.all],e),interpret:Ta,collectEvaluatedProperties:(e,t,n,r)=>Ta(e,t,n,r)&&e.map((([e])=>e))};var La={isObject:e=>"object"==typeof e&&!Array.isArray(e)&&null!==e,escapeRegExp:e=>e.replace(/[.*+\-?^${}()|[\]\\]/g,"\\$&"),splitUrl:e=>{const t=e.indexOf("#"),n=-1===t?e.length:t,r=e.slice(0,n),a=e.slice(n+1);return[decodeURI(r),decodeURI(a)]}};const{Core:ka,Schema:Va,Instance:Ua}=en,_a=_e,{escapeRegExp:Ja}=La,za=(e,t,n,r)=>!Ua.typeOf(t,"object")||Ua.entries(t).filter((([t])=>t in e)).every((([t,a])=>ka.interpretSchema(e[t],a,n,r)));var Fa={compile:(e,t)=>_a.pipeline([Va.entries,_a.reduce((async(e,[n,r])=>(e[n]=await ka.compileSchema(r,t),e)),Object.create(null))],e),interpret:za,collectEvaluatedProperties:(e,t,n,r)=>za(e,t,n,r)&&Object.keys(e).map((e=>new RegExp(`^${Ja(e)}$`)))};const{Core:Ba,Instance:Za}=en;var Ga={compile:(e,t)=>Ba.compileSchema(e,t),interpret:(e,t,n,r)=>!Za.typeOf(t,"object")||Za.keys(t).every((t=>Ba.interpretSchema(e,Za.cons(t),n,r)))};const{Core:Wa,Schema:Xa}=en,{splitUrl:Ha}=La;var Qa={compile:async(e,t)=>{const[,n]=Ha(Xa.value(e)),r=await Xa.get(Xa.value(e),e);return await Wa.compileSchema(r,t),[r.id,n]},interpret:([e,t],n,r,a)=>{if(t in r.metaData[e].dynamicAnchors)return Wa.interpretSchema(a[t],n,r,a);{const i=Xa.getAnchorPointer(r.metaData[e],t);return Wa.interpretSchema(`${e}#${encodeURI(i)}`,n,r,a)}},collectEvaluatedProperties:Wa.collectEvaluatedProperties,collectEvaluatedItems:Wa.collectEvaluatedItems};const{Core:Ya,Schema:ei}=en;var ti={compile:async(e,t)=>{const n=await ei.get(ei.value(e),e);return Ya.compileSchema(n,t)},interpret:Ya.interpretSchema,collectEvaluatedProperties:Ya.collectEvaluatedProperties,collectEvaluatedItems:Ya.collectEvaluatedItems};const{Schema:ni,Instance:ri}=en;var ai={compile:e=>ni.value(e),interpret:(e,t)=>!ri.typeOf(t,"object")||e.every((e=>Object.prototype.hasOwnProperty.call(ri.value(t),e)))};const{Core:ii,Schema:oi,Instance:si}=en,ci=_e,mi=(e,t,n,r)=>!si.typeOf(t,"array")||si.every(((t,a)=>!(a in e)||ii.interpretSchema(e[a],t,n,r)),t);var li={compile:(e,t)=>ci.pipeline([oi.map((e=>ii.compileSchema(e,t))),ci.all],e),interpret:mi,collectEvaluatedItems:(e,t,n,r)=>mi(e,t,n,r)&&new Set(e.map(((e,t)=>t)))};const{Schema:pi,Instance:di}=en;var ui={compile:e=>pi.value(e),interpret:(e,t)=>"string"==typeof e?di.typeOf(t,e):e.some(di.typeOf(t))};const{Core:fi,Schema:yi,Instance:hi}=en,vi=([e,t],n,r,a)=>{if(!hi.typeOf(n,"array"))return!0;const i=fi.collectEvaluatedItems(e,n,r,a,!0);return!1===i||hi.every(((e,o)=>i.has(o)||fi.interpretSchema(t,hi.step(o,n),r,a)),n)};var gi={compile:async(e,t,n)=>[yi.uri(n),await fi.compileSchema(e,t)],interpret:vi,collectEvaluatedItems:(e,t,n,r)=>vi(e,t,n,r)&&new Set(hi.map(((e,t)=>t),t))};const{Core:bi,Schema:$i,Instance:Ii}=en,wi=([e,t],n,r,a)=>{if(!Ii.typeOf(n,"object"))return!0;const i=bi.collectEvaluatedProperties(e,n,r,a,!0);return!i||Ii.entries(n).filter((([e])=>!i.some((t=>e.match(t))))).every((([,e])=>bi.interpretSchema(t,e,r,a)))};var Oi={compile:async(e,t,n)=>[$i.uri(n),await bi.compileSchema(e,t)],interpret:wi,collectEvaluatedProperties:(e,t,n,r)=>wi(e,t,n,r)&&[new RegExp("")]};const{Schema:xi,Instance:Si}=en,ji=Nn;var Ei={compile:e=>xi.value(e),interpret:(e,t)=>{if(!Si.typeOf(t,"array")||!1===e)return!0;const n=Si.map((e=>ji(Si.value(e))),t);return new Set(n).size===n.length}};const{Keywords:Pi}=en;var Ai={additionalItems:an,additionalItems6:ln,additionalProperties:fn,additionalProperties6:bn,allOf:On,anyOf:En,const:Mn,contains:Ln,containsMinContainsMaxContains:Jn,definitions:Zn,dependencies:Qn,dependentRequired:nr,dependentSchemas:sr,enum:pr,exclusiveMaximum:fr,exclusiveMinimum:vr,if:br,then:Or,else:Er,items:Kr,items202012:qr,maxItems:Vr,maxLength:Jr,maxLength6:Br,maxProperties:Wr,maximumExclusiveMaximum:Qr,maximum:ta,metaData:Pi.metaData,minItems:aa,minLength:sa,minLength6:la,minProperties:ua,minimumExclusiveMinimum:ha,minimum:ba,multipleOf:Oa,not:Sa,oneOf:Pa,pattern:Na,patternProperties:qa,properties:Fa,propertyNames:Ga,dynamicRef:Qa,ref:ti,required:ai,tupleItems:li,type:ui,unevaluatedItems:gi,unevaluatedProperties:Oi,uniqueItems:Ei,validate:Pi.validate};const{Core:Ci,Schema:Ni}=en,Ki=Ai,Ri="http://json-schema.org/draft-04/schema";Ni.setConfig(Ri,"baseToken","id"),Ni.setConfig(Ri,"embeddedToken","id"),Ni.setConfig(Ri,"anchorToken","id"),Ni.setConfig(Ri,"jrefToken","$ref"),Ni.add(JSON.parse('{\n    "id": "http://json-schema.org/draft-04/schema#",\n    "$schema": "http://json-schema.org/draft-04/schema#",\n    "description": "Core schema meta-schema",\n    "definitions": {\n        "schemaArray": {\n            "type": "array",\n            "minItems": 1,\n            "items": { "$ref": "#" }\n        },\n        "positiveInteger": {\n            "type": "integer",\n            "minimum": 0\n        },\n        "positiveIntegerDefault0": {\n            "allOf": [ { "$ref": "#/definitions/positiveInteger" }, { "default": 0 } ]\n        },\n        "simpleTypes": {\n            "enum": [ "array", "boolean", "integer", "null", "number", "object", "string" ]\n        },\n        "stringArray": {\n            "type": "array",\n            "items": { "type": "string" },\n            "minItems": 1,\n            "uniqueItems": true\n        }\n    },\n    "type": "object",\n    "properties": {\n        "id": {\n            "type": "string"\n        },\n        "$schema": {\n            "type": "string"\n        },\n        "title": {\n            "type": "string"\n        },\n        "description": {\n            "type": "string"\n        },\n        "default": {},\n        "multipleOf": {\n            "type": "number",\n            "minimum": 0,\n            "exclusiveMinimum": true\n        },\n        "maximum": {\n            "type": "number"\n        },\n        "exclusiveMaximum": {\n            "type": "boolean",\n            "default": false\n        },\n        "minimum": {\n            "type": "number"\n        },\n        "exclusiveMinimum": {\n            "type": "boolean",\n            "default": false\n        },\n        "maxLength": { "$ref": "#/definitions/positiveInteger" },\n        "minLength": { "$ref": "#/definitions/positiveIntegerDefault0" },\n        "pattern": {\n            "type": "string",\n            "format": "regex"\n        },\n        "additionalItems": {\n            "anyOf": [\n                { "type": "boolean" },\n                { "$ref": "#" }\n            ],\n            "default": {}\n        },\n        "items": {\n            "anyOf": [\n                { "$ref": "#" },\n                { "$ref": "#/definitions/schemaArray" }\n            ],\n            "default": {}\n        },\n        "maxItems": { "$ref": "#/definitions/positiveInteger" },\n        "minItems": { "$ref": "#/definitions/positiveIntegerDefault0" },\n        "uniqueItems": {\n            "type": "boolean",\n            "default": false\n        },\n        "maxProperties": { "$ref": "#/definitions/positiveInteger" },\n        "minProperties": { "$ref": "#/definitions/positiveIntegerDefault0" },\n        "required": { "$ref": "#/definitions/stringArray" },\n        "additionalProperties": {\n            "anyOf": [\n                { "type": "boolean" },\n                { "$ref": "#" }\n            ],\n            "default": {}\n        },\n        "definitions": {\n            "type": "object",\n            "additionalProperties": { "$ref": "#" },\n            "default": {}\n        },\n        "properties": {\n            "type": "object",\n            "additionalProperties": { "$ref": "#" },\n            "default": {}\n        },\n        "patternProperties": {\n            "type": "object",\n            "additionalProperties": { "$ref": "#" },\n            "default": {}\n        },\n        "dependencies": {\n            "type": "object",\n            "additionalProperties": {\n                "anyOf": [\n                    { "$ref": "#" },\n                    { "$ref": "#/definitions/stringArray" }\n                ]\n            }\n        },\n        "enum": {\n            "type": "array",\n            "minItems": 1,\n            "uniqueItems": true\n        },\n        "type": {\n            "anyOf": [\n                { "$ref": "#/definitions/simpleTypes" },\n                {\n                    "type": "array",\n                    "items": { "$ref": "#/definitions/simpleTypes" },\n                    "minItems": 1,\n                    "uniqueItems": true\n                }\n            ]\n        },\n        "format": { "type": "string" },\n        "allOf": { "$ref": "#/definitions/schemaArray" },\n        "anyOf": { "$ref": "#/definitions/schemaArray" },\n        "oneOf": { "$ref": "#/definitions/schemaArray" },\n        "not": { "$ref": "#" }\n    },\n    "dependencies": {\n        "exclusiveMaximum": [ "maximum" ],\n        "exclusiveMinimum": [ "minimum" ]\n    },\n    "default": {}\n}')),Ci.defineVocabulary(Ri,{validate:Ki.validate,additionalItems:Ki.additionalItems,additionalProperties:Ki.additionalProperties,allOf:Ki.allOf,anyOf:Ki.anyOf,default:Ki.metaData,definitions:Ki.definitions,dependencies:Ki.dependencies,description:Ki.metaData,enum:Ki.enum,format:Ki.metaData,items:Ki.items,maxItems:Ki.maxItems,maxLength:Ki.maxLength,maxProperties:Ki.maxProperties,maximum:Ki.maximumExclusiveMaximum,minItems:Ki.minItems,minLength:Ki.minLength,minProperties:Ki.minProperties,minimum:Ki.minimumExclusiveMinimum,multipleOf:Ki.multipleOf,not:Ki.not,oneOf:Ki.oneOf,pattern:Ki.pattern,patternProperties:Ki.patternProperties,properties:Ki.properties,required:Ki.required,title:Ki.metaData,type:Ki.type,uniqueItems:Ki.uniqueItems});const{Core:Di,Schema:Mi}=en,Ti=Ai,qi="http://json-schema.org/draft-06/schema";Mi.setConfig(qi,"baseToken","$id"),Mi.setConfig(qi,"embeddedToken","$id"),Mi.setConfig(qi,"anchorToken","$id"),Mi.setConfig(qi,"jrefToken","$ref"),Mi.add(JSON.parse('{\n    "$schema": "http://json-schema.org/draft-06/schema#",\n    "$id": "http://json-schema.org/draft-06/schema#",\n    "title": "Core schema meta-schema",\n    "definitions": {\n        "schemaArray": {\n            "type": "array",\n            "minItems": 1,\n            "items": { "$ref": "#" }\n        },\n        "nonNegativeInteger": {\n            "type": "integer",\n            "minimum": 0\n        },\n        "nonNegativeIntegerDefault0": {\n            "allOf": [\n                { "$ref": "#/definitions/nonNegativeInteger" },\n                { "default": 0 }\n            ]\n        },\n        "simpleTypes": {\n            "enum": [\n                "array",\n                "boolean",\n                "integer",\n                "null",\n                "number",\n                "object",\n                "string"\n            ]\n        },\n        "stringArray": {\n            "type": "array",\n            "items": { "type": "string" },\n            "uniqueItems": true,\n            "default": []\n        }\n    },\n    "type": ["object", "boolean"],\n    "properties": {\n        "$id": {\n            "type": "string",\n            "format": "uri-reference"\n        },\n        "$schema": {\n            "type": "string",\n            "format": "uri"\n        },\n        "$ref": {\n            "type": "string",\n            "format": "uri-reference"\n        },\n        "title": {\n            "type": "string"\n        },\n        "description": {\n            "type": "string"\n        },\n        "default": {},\n        "examples": {\n            "type": "array",\n            "items": {}\n        },\n        "multipleOf": {\n            "type": "number",\n            "exclusiveMinimum": 0\n        },\n        "maximum": {\n            "type": "number"\n        },\n        "exclusiveMaximum": {\n            "type": "number"\n        },\n        "minimum": {\n            "type": "number"\n        },\n        "exclusiveMinimum": {\n            "type": "number"\n        },\n        "maxLength": { "$ref": "#/definitions/nonNegativeInteger" },\n        "minLength": { "$ref": "#/definitions/nonNegativeIntegerDefault0" },\n        "pattern": {\n            "type": "string",\n            "format": "regex"\n        },\n        "additionalItems": { "$ref": "#" },\n        "items": {\n            "anyOf": [\n                { "$ref": "#" },\n                { "$ref": "#/definitions/schemaArray" }\n            ],\n            "default": {}\n        },\n        "maxItems": { "$ref": "#/definitions/nonNegativeInteger" },\n        "minItems": { "$ref": "#/definitions/nonNegativeIntegerDefault0" },\n        "uniqueItems": {\n            "type": "boolean",\n            "default": false\n        },\n        "contains": { "$ref": "#" },\n        "maxProperties": { "$ref": "#/definitions/nonNegativeInteger" },\n        "minProperties": { "$ref": "#/definitions/nonNegativeIntegerDefault0" },\n        "required": { "$ref": "#/definitions/stringArray" },\n        "additionalProperties": { "$ref": "#" },\n        "definitions": {\n            "type": "object",\n            "additionalProperties": { "$ref": "#" },\n            "default": {}\n        },\n        "properties": {\n            "type": "object",\n            "additionalProperties": { "$ref": "#" },\n            "default": {}\n        },\n        "patternProperties": {\n            "type": "object",\n            "additionalProperties": { "$ref": "#" },\n            "default": {}\n        },\n        "dependencies": {\n            "type": "object",\n            "additionalProperties": {\n                "anyOf": [\n                    { "$ref": "#" },\n                    { "$ref": "#/definitions/stringArray" }\n                ]\n            }\n        },\n        "propertyNames": { "$ref": "#" },\n        "const": {},\n        "enum": {\n            "type": "array",\n            "minItems": 1,\n            "uniqueItems": true\n        },\n        "type": {\n            "anyOf": [\n                { "$ref": "#/definitions/simpleTypes" },\n                {\n                    "type": "array",\n                    "items": { "$ref": "#/definitions/simpleTypes" },\n                    "minItems": 1,\n                    "uniqueItems": true\n                }\n            ]\n        },\n        "format": { "type": "string" },\n        "allOf": { "$ref": "#/definitions/schemaArray" },\n        "anyOf": { "$ref": "#/definitions/schemaArray" },\n        "oneOf": { "$ref": "#/definitions/schemaArray" },\n        "not": { "$ref": "#" }\n    },\n    "default": {}\n}')),Di.defineVocabulary(qi,{validate:Ti.validate,additionalItems:Ti.additionalItems6,additionalProperties:Ti.additionalProperties6,allOf:Ti.allOf,anyOf:Ti.anyOf,const:Ti.const,contains:Ti.contains,default:Ti.metaData,definitions:Ti.definitions,dependencies:Ti.dependencies,description:Ti.metaData,enum:Ti.enum,examples:Ti.metaData,exclusiveMaximum:Ti.exclusiveMaximum,exclusiveMinimum:Ti.exclusiveMinimum,format:Ti.metaData,items:Ti.items,maxItems:Ti.maxItems,maxLength:Ti.maxLength6,maxProperties:Ti.maxProperties,maximum:Ti.maximum,minItems:Ti.minItems,minLength:Ti.minLength6,minProperties:Ti.minProperties,minimum:Ti.minimum,multipleOf:Ti.multipleOf,not:Ti.not,oneOf:Ti.oneOf,pattern:Ti.pattern,patternProperties:Ti.patternProperties,properties:Ti.properties,propertyNames:Ti.propertyNames,required:Ti.required,title:Ti.metaData,type:Ti.type,uniqueItems:Ti.uniqueItems});const{Core:Li,Schema:ki}=en,Vi=Ai,Ui="http://json-schema.org/draft-07/schema";ki.setConfig(Ui,"baseToken","$id"),ki.setConfig(Ui,"embeddedToken","$id"),ki.setConfig(Ui,"anchorToken","$id"),ki.setConfig(Ui,"jrefToken","$ref"),ki.add(JSON.parse('{\n    "$schema": "http://json-schema.org/draft-07/schema#",\n    "$id": "http://json-schema.org/draft-07/schema#",\n    "title": "Core schema meta-schema",\n    "definitions": {\n        "schemaArray": {\n            "type": "array",\n            "minItems": 1,\n            "items": { "$ref": "#" }\n        },\n        "nonNegativeInteger": {\n            "type": "integer",\n            "minimum": 0\n        },\n        "nonNegativeIntegerDefault0": {\n            "allOf": [\n                { "$ref": "#/definitions/nonNegativeInteger" },\n                { "default": 0 }\n            ]\n        },\n        "simpleTypes": {\n            "enum": [\n                "array",\n                "boolean",\n                "integer",\n                "null",\n                "number",\n                "object",\n                "string"\n            ]\n        },\n        "stringArray": {\n            "type": "array",\n            "items": { "type": "string" },\n            "uniqueItems": true,\n            "default": []\n        }\n    },\n    "type": ["object", "boolean"],\n    "properties": {\n        "$id": {\n            "type": "string",\n            "format": "uri-reference"\n        },\n        "$schema": {\n            "type": "string",\n            "format": "uri"\n        },\n        "$ref": {\n            "type": "string",\n            "format": "uri-reference"\n        },\n        "$comment": {\n            "type": "string"\n        },\n        "title": {\n            "type": "string"\n        },\n        "description": {\n            "type": "string"\n        },\n        "default": true,\n        "readOnly": {\n            "type": "boolean",\n            "default": false\n        },\n        "writeOnly": {\n            "type": "boolean",\n            "default": false\n        },\n        "examples": {\n            "type": "array",\n            "items": true\n        },\n        "multipleOf": {\n            "type": "number",\n            "exclusiveMinimum": 0\n        },\n        "maximum": {\n            "type": "number"\n        },\n        "exclusiveMaximum": {\n            "type": "number"\n        },\n        "minimum": {\n            "type": "number"\n        },\n        "exclusiveMinimum": {\n            "type": "number"\n        },\n        "maxLength": { "$ref": "#/definitions/nonNegativeInteger" },\n        "minLength": { "$ref": "#/definitions/nonNegativeIntegerDefault0" },\n        "pattern": {\n            "type": "string",\n            "format": "regex"\n        },\n        "additionalItems": { "$ref": "#" },\n        "items": {\n            "anyOf": [\n                { "$ref": "#" },\n                { "$ref": "#/definitions/schemaArray" }\n            ],\n            "default": true\n        },\n        "maxItems": { "$ref": "#/definitions/nonNegativeInteger" },\n        "minItems": { "$ref": "#/definitions/nonNegativeIntegerDefault0" },\n        "uniqueItems": {\n            "type": "boolean",\n            "default": false\n        },\n        "contains": { "$ref": "#" },\n        "maxProperties": { "$ref": "#/definitions/nonNegativeInteger" },\n        "minProperties": { "$ref": "#/definitions/nonNegativeIntegerDefault0" },\n        "required": { "$ref": "#/definitions/stringArray" },\n        "additionalProperties": { "$ref": "#" },\n        "definitions": {\n            "type": "object",\n            "additionalProperties": { "$ref": "#" },\n            "default": {}\n        },\n        "properties": {\n            "type": "object",\n            "additionalProperties": { "$ref": "#" },\n            "default": {}\n        },\n        "patternProperties": {\n            "type": "object",\n            "additionalProperties": { "$ref": "#" },\n            "propertyNames": { "format": "regex" },\n            "default": {}\n        },\n        "dependencies": {\n            "type": "object",\n            "additionalProperties": {\n                "anyOf": [\n                    { "$ref": "#" },\n                    { "$ref": "#/definitions/stringArray" }\n                ]\n            }\n        },\n        "propertyNames": { "$ref": "#" },\n        "const": true,\n        "enum": {\n            "type": "array",\n            "items": true,\n            "minItems": 1,\n            "uniqueItems": true\n        },\n        "type": {\n            "anyOf": [\n                { "$ref": "#/definitions/simpleTypes" },\n                {\n                    "type": "array",\n                    "items": { "$ref": "#/definitions/simpleTypes" },\n                    "minItems": 1,\n                    "uniqueItems": true\n                }\n            ]\n        },\n        "format": { "type": "string" },\n        "contentMediaType": { "type": "string" },\n        "contentEncoding": { "type": "string" },\n        "if": { "$ref": "#" },\n        "then": { "$ref": "#" },\n        "else": { "$ref": "#" },\n        "allOf": { "$ref": "#/definitions/schemaArray" },\n        "anyOf": { "$ref": "#/definitions/schemaArray" },\n        "oneOf": { "$ref": "#/definitions/schemaArray" },\n        "not": { "$ref": "#" }\n    },\n    "default": true\n}')),Li.defineVocabulary(Ui,{validate:Vi.validate,additionalItems:Vi.additionalItems6,additionalProperties:Vi.additionalProperties6,allOf:Vi.allOf,anyOf:Vi.anyOf,const:Vi.const,contains:Vi.contains,default:Vi.metaData,definitions:Vi.definitions,dependencies:Vi.dependencies,description:Vi.metaData,enum:Vi.enum,exclusiveMaximum:Vi.exclusiveMaximum,exclusiveMinimum:Vi.exclusiveMinimum,format:Vi.metaData,if:Vi.if,then:Vi.then,else:Vi.else,items:Vi.items,maxItems:Vi.maxItems,maxLength:Vi.maxLength6,maxProperties:Vi.maxProperties,maximum:Vi.maximum,minItems:Vi.minItems,minLength:Vi.minLength6,minProperties:Vi.minProperties,minimum:Vi.minimum,multipleOf:Vi.multipleOf,not:Vi.not,oneOf:Vi.oneOf,pattern:Vi.pattern,patternProperties:Vi.patternProperties,properties:Vi.properties,propertyNames:Vi.propertyNames,readOnly:Vi.metaData,required:Vi.required,title:Vi.metaData,type:Vi.type,uniqueItems:Vi.uniqueItems,writeOnly:Vi.metaData});const{Core:_i,Schema:Ji}=en,zi=Ai,Fi="https://json-schema.org/draft/2019-09/schema";Ji.setConfig(Fi,"baseToken","$id"),Ji.setConfig(Fi,"embeddedToken","$id"),Ji.setConfig(Fi,"anchorToken","$anchor"),Ji.setConfig(Fi,"recursiveAnchorToken","$recursiveAnchor"),Ji.setConfig(Fi,"vocabularyToken","$vocabulary"),Ji.setConfig(Fi,"mandatoryVocabularies",["https://json-schema.org/draft/2019-09/vocab/core"]),Ji.add(JSON.parse('{\n    "$schema": "https://json-schema.org/draft/2019-09/schema",\n    "$id": "https://json-schema.org/draft/2019-09/schema",\n    "$vocabulary": {\n        "https://json-schema.org/draft/2019-09/vocab/core": true,\n        "https://json-schema.org/draft/2019-09/vocab/applicator": true,\n        "https://json-schema.org/draft/2019-09/vocab/validation": true,\n        "https://json-schema.org/draft/2019-09/vocab/meta-data": true,\n        "https://json-schema.org/draft/2019-09/vocab/format": false,\n        "https://json-schema.org/draft/2019-09/vocab/content": true\n    },\n    "$recursiveAnchor": true,\n\n    "title": "Core and Validation specifications meta-schema",\n    "allOf": [\n        {"$ref": "meta/core"},\n        {"$ref": "meta/applicator"},\n        {"$ref": "meta/validation"},\n        {"$ref": "meta/meta-data"},\n        {"$ref": "meta/format"},\n        {"$ref": "meta/content"}\n    ],\n    "type": ["object", "boolean"],\n    "properties": {\n        "definitions": {\n            "$comment": "While no longer an official keyword as it is replaced by $defs, this keyword is retained in the meta-schema to prevent incompatible extensions as it remains in common use.",\n            "type": "object",\n            "additionalProperties": { "$recursiveRef": "#" },\n            "default": {}\n        },\n        "dependencies": {\n            "$comment": "\\"dependencies\\" is no longer a keyword, but schema authors should avoid redefining it to facilitate a smooth transition to \\"dependentSchemas\\" and \\"dependentRequired\\"",\n            "type": "object",\n            "additionalProperties": {\n                "anyOf": [\n                    { "$recursiveRef": "#" },\n                    { "$ref": "meta/validation#/$defs/stringArray" }\n                ]\n            }\n        }\n    }\n}')),Ji.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/2019-09/meta/core",\n    "$schema": "https://json-schema.org/draft/2019-09/schema",\n    "$vocabulary": {\n      "https://json-schema.org/draft/2019-09/vocab/core": true\n    },\n    "$recursiveAnchor": true,\n\n    "title": "Core vocabulary meta-schema",\n    "type": ["object", "boolean"],\n    "properties": {\n        "$id": {\n            "type": "string",\n            "format": "uri-reference",\n            "$comment": "Non-empty fragments not allowed.",\n            "pattern": "^[^#]*#?$"\n        },\n        "$schema": {\n            "type": "string",\n            "format": "uri"\n        },\n        "$anchor": {\n            "type": "string",\n            "pattern": "^[A-Za-z][-A-Za-z0-9.:_]*$"\n        },\n        "$ref": {\n            "type": "string",\n            "format": "uri-reference"\n        },\n        "$recursiveRef": {\n            "type": "string",\n            "format": "uri-reference"\n        },\n        "$recursiveAnchor": {\n            "type": "boolean",\n            "default": false\n        },\n        "$vocabulary": {\n            "type": "object",\n            "propertyNames": {\n                "type": "string",\n                "format": "uri"\n            },\n            "additionalProperties": {\n                "type": "boolean"\n            }\n        },\n        "$comment": {\n            "type": "string"\n        },\n        "$defs": {\n            "type": "object",\n            "additionalProperties": { "$recursiveRef": "#" },\n            "default": {}\n        }\n    }\n}')),_i.defineVocabulary("https://json-schema.org/draft/2019-09/vocab/core",{validate:zi.validate,$defs:zi.definitions,$recursiveRef:zi.dynamicRef,$ref:zi.ref}),Ji.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/2019-09/meta/applicator",\n    "$schema": "https://json-schema.org/draft/2019-09/schema",\n    "$vocabulary": {\n        "https://json-schema.org/draft/2019-09/vocab/applicator": true\n    },\n    "$recursiveAnchor": true,\n\n    "title": "Applicator vocabulary meta-schema",\n    "properties": {\n        "additionalItems": { "$recursiveRef": "#" },\n        "unevaluatedItems": { "$recursiveRef": "#" },\n        "items": {\n            "anyOf": [\n                { "$recursiveRef": "#" },\n                { "$ref": "#/$defs/schemaArray" }\n            ]\n        },\n        "contains": { "$recursiveRef": "#" },\n        "additionalProperties": { "$recursiveRef": "#" },\n        "unevaluatedProperties": { "$recursiveRef": "#" },\n        "properties": {\n            "type": "object",\n            "additionalProperties": { "$recursiveRef": "#" },\n            "default": {}\n        },\n        "patternProperties": {\n            "type": "object",\n            "additionalProperties": { "$recursiveRef": "#" },\n            "propertyNames": { "format": "regex" },\n            "default": {}\n        },\n        "dependentSchemas": {\n            "type": "object",\n            "additionalProperties": {\n                "$recursiveRef": "#"\n            }\n        },\n        "propertyNames": { "$recursiveRef": "#" },\n        "if": { "$recursiveRef": "#" },\n        "then": { "$recursiveRef": "#" },\n        "else": { "$recursiveRef": "#" },\n        "allOf": { "$ref": "#/$defs/schemaArray" },\n        "anyOf": { "$ref": "#/$defs/schemaArray" },\n        "oneOf": { "$ref": "#/$defs/schemaArray" },\n        "not": { "$recursiveRef": "#" }\n    },\n    "$defs": {\n        "schemaArray": {\n            "type": "array",\n            "minItems": 1,\n            "items": { "$recursiveRef": "#" }\n        }\n    }\n}')),_i.defineVocabulary("https://json-schema.org/draft/2019-09/vocab/applicator",{additionalItems:zi.additionalItems6,additionalProperties:zi.additionalProperties6,allOf:zi.allOf,anyOf:zi.anyOf,contains:zi.containsMinContainsMaxContains,dependentSchemas:zi.dependentSchemas,if:zi.if,then:zi.then,else:zi.else,items:zi.items,not:zi.not,oneOf:zi.oneOf,patternProperties:zi.patternProperties,properties:zi.properties,propertyNames:zi.propertyNames,unevaluatedItems:zi.unevaluatedItems,unevaluatedProperties:zi.unevaluatedProperties}),Ji.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/2019-09/meta/validation",\n    "$schema": "https://json-schema.org/draft/2019-09/schema",\n    "$vocabulary": {\n      "https://json-schema.org/draft/2019-09/vocab/validation": true\n    },\n    "$recursiveAnchor": true,\n\n    "title": "Validation vocabulary meta-schema",\n    "type": ["object", "boolean"],\n    "properties": {\n        "multipleOf": {\n            "type": "number",\n            "exclusiveMinimum": 0\n        },\n        "maximum": {\n            "type": "number"\n        },\n        "exclusiveMaximum": {\n            "type": "number"\n        },\n        "minimum": {\n            "type": "number"\n        },\n        "exclusiveMinimum": {\n            "type": "number"\n        },\n        "maxLength": { "$ref": "#/$defs/nonNegativeInteger" },\n        "minLength": { "$ref": "#/$defs/nonNegativeIntegerDefault0" },\n        "pattern": {\n            "type": "string",\n            "format": "regex"\n        },\n        "maxItems": { "$ref": "#/$defs/nonNegativeInteger" },\n        "minItems": { "$ref": "#/$defs/nonNegativeIntegerDefault0" },\n        "uniqueItems": {\n            "type": "boolean",\n            "default": false\n        },\n        "maxContains": { "$ref": "#/$defs/nonNegativeInteger" },\n        "minContains": {\n            "$ref": "#/$defs/nonNegativeInteger",\n            "default": 1\n        },\n        "maxProperties": { "$ref": "#/$defs/nonNegativeInteger" },\n        "minProperties": { "$ref": "#/$defs/nonNegativeIntegerDefault0" },\n        "required": { "$ref": "#/$defs/stringArray" },\n        "dependentRequired": {\n            "type": "object",\n            "additionalProperties": {\n                "$ref": "#/$defs/stringArray"\n            }\n        },\n        "const": true,\n        "enum": {\n            "type": "array",\n            "items": true\n        },\n        "type": {\n            "anyOf": [\n                { "$ref": "#/$defs/simpleTypes" },\n                {\n                    "type": "array",\n                    "items": { "$ref": "#/$defs/simpleTypes" },\n                    "minItems": 1,\n                    "uniqueItems": true\n                }\n            ]\n        }\n    },\n    "$defs": {\n        "nonNegativeInteger": {\n            "type": "integer",\n            "minimum": 0\n        },\n        "nonNegativeIntegerDefault0": {\n            "$ref": "#/$defs/nonNegativeInteger",\n            "default": 0\n        },\n        "simpleTypes": {\n            "enum": [\n                "array",\n                "boolean",\n                "integer",\n                "null",\n                "number",\n                "object",\n                "string"\n            ]\n        },\n        "stringArray": {\n            "type": "array",\n            "items": { "type": "string" },\n            "uniqueItems": true,\n            "default": []\n        }\n    }\n}')),_i.defineVocabulary("https://json-schema.org/draft/2019-09/vocab/validation",{const:zi.const,dependentRequired:zi.dependentRequired,enum:zi.enum,exclusiveMaximum:zi.exclusiveMaximum,exclusiveMinimum:zi.exclusiveMinimum,maxItems:zi.maxItems,maxLength:zi.maxLength6,maxProperties:zi.maxProperties,maximum:zi.maximum,minItems:zi.minItems,minLength:zi.minLength6,minProperties:zi.minProperties,minimum:zi.minimum,multipleOf:zi.multipleOf,pattern:zi.pattern,required:zi.required,type:zi.type,uniqueItems:zi.uniqueItems}),Ji.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/2019-09/meta/meta-data",\n    "$schema": "https://json-schema.org/draft/2019-09/schema",\n    "$vocabulary": {\n      "https://json-schema.org/draft/2019-09/vocab/meta-data": true\n    },\n    "$recursiveAnchor": true,\n\n    "title": "Meta-data vocabulary meta-schema",\n\n    "type": ["object", "boolean"],\n    "properties": {\n        "title": {\n            "type": "string"\n        },\n        "description": {\n            "type": "string"\n        },\n        "default": true,\n        "deprecated": {\n            "type": "boolean",\n            "default": false\n        },\n        "readOnly": {\n            "type": "boolean",\n            "default": false\n        },\n        "writeOnly": {\n            "type": "boolean",\n            "default": false\n        },\n        "examples": {\n            "type": "array",\n            "items": true\n        }\n    }\n}')),_i.defineVocabulary("https://json-schema.org/draft/2019-09/vocab/meta-data",{default:zi.metaData,deprecated:zi.metaData,description:zi.metaData,examples:zi.metaData,readOnly:zi.metaData,title:zi.metaData,writeOnly:zi.metaData}),Ji.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/2019-09/meta/format",\n    "$schema": "https://json-schema.org/draft/2019-09/schema",\n    "$vocabulary": {\n      "https://json-schema.org/draft/2019-09/vocab/format": true\n    },\n    "$recursiveAnchor": true,\n\n    "title": "Format vocabulary meta-schema",\n    "type": ["object", "boolean"],\n    "properties": {\n        "format": { "type": "string" }\n    }\n}')),Ji.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/2019-09/meta/content",\n    "$schema": "https://json-schema.org/draft/2019-09/schema",\n    "$vocabulary": {\n      "https://json-schema.org/draft/2019-09/vocab/content": true\n    },\n    "$recursiveAnchor": true,\n\n    "title": "Content vocabulary meta-schema",\n\n    "type": ["object", "boolean"],\n    "properties": {\n        "contentMediaType": { "type": "string" },\n        "contentEncoding": { "type": "string" },\n        "contentSchema": { "$recursiveRef": "#" }\n    }\n}')),_i.defineVocabulary("https://json-schema.org/draft/2019-09/vocab/content",{contentEncoding:zi.metaData,contentMediaType:zi.metaData,contentSchema:zi.metaData});const{Core:Bi,Schema:Zi}=en,Gi=Ai,Wi="https://json-schema.org/draft/2020-12/schema";Zi.setConfig(Wi,"baseToken","$id"),Zi.setConfig(Wi,"embeddedToken","$id"),Zi.setConfig(Wi,"anchorToken","$anchor"),Zi.setConfig(Wi,"dynamicAnchorToken","$dynamicAnchor"),Zi.setConfig(Wi,"vocabularyToken","$vocabulary"),Zi.setConfig(Wi,"mandatoryVocabularies",["https://json-schema.org/draft/2020-12/vocab/core"]),Zi.add(JSON.parse('{\n    "$schema": "https://json-schema.org/draft/2020-12/schema",\n    "$id": "https://json-schema.org/draft/2020-12/schema",\n    "$vocabulary": {\n        "https://json-schema.org/draft/2020-12/vocab/core": true,\n        "https://json-schema.org/draft/2020-12/vocab/applicator": true,\n        "https://json-schema.org/draft/2020-12/vocab/unevaluated": true,\n        "https://json-schema.org/draft/2020-12/vocab/validation": true,\n        "https://json-schema.org/draft/2020-12/vocab/meta-data": true,\n        "https://json-schema.org/draft/2020-12/vocab/format-annotation": true,\n        "https://json-schema.org/draft/2020-12/vocab/content": true\n    },\n    "$dynamicAnchor": "meta",\n\n    "title": "Core and Validation specifications meta-schema",\n    "allOf": [\n        {"$ref": "meta/core"},\n        {"$ref": "meta/applicator"},\n        {"$ref": "meta/unevaluated"},\n        {"$ref": "meta/validation"},\n        {"$ref": "meta/meta-data"},\n        {"$ref": "meta/format-annotation"},\n        {"$ref": "meta/content"}\n    ],\n    "type": ["object", "boolean"],\n    "properties": {\n        "definitions": {\n            "$comment": "While no longer an official keyword as it is replaced by $defs, this keyword is retained in the meta-schema to prevent incompatible extensions as it remains in common use.",\n            "type": "object",\n            "additionalProperties": { "$dynamicRef": "#meta" },\n            "default": {}\n        },\n        "dependencies": {\n            "$comment": "\\"dependencies\\" is no longer a keyword, but schema authors should avoid redefining it to facilitate a smooth transition to \\"dependentSchemas\\" and \\"dependentRequired\\"",\n            "type": "object",\n            "additionalProperties": {\n                "anyOf": [\n                    { "$dynamicRef": "#meta" },\n                    { "$ref": "meta/validation#/$defs/stringArray" }\n                ]\n            }\n        }\n    }\n}')),Zi.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/2020-12/meta/core",\n    "$schema": "https://json-schema.org/draft/2020-12/schema",\n    "$vocabulary": {\n        "https://json-schema.org/draft/2020-12/vocab/core": true\n    },\n    "$dynamicAnchor": "meta",\n\n    "title": "Core vocabulary meta-schema",\n    "type": ["object", "boolean"],\n    "properties": {\n        "$id": {\n            "type": "string",\n            "format": "uri-reference",\n            "$comment": "Non-empty fragments not allowed.",\n            "pattern": "^[^#]*#?$"\n        },\n        "$schema": {\n            "type": "string",\n            "format": "uri"\n        },\n        "$anchor": {\n            "type": "string",\n            "pattern": "^[A-Za-z_][-A-Za-z0-9._]*$"\n        },\n        "$ref": {\n            "type": "string",\n            "format": "uri-reference"\n        },\n        "$dynamicRef": {\n            "type": "string",\n            "format": "uri-reference"\n        },\n        "$dynamicAnchor": {\n            "type": "string",\n            "pattern": "^[A-Za-z_][-A-Za-z0-9._]*$"\n        },\n        "$vocabulary": {\n            "type": "object",\n            "propertyNames": {\n                "type": "string",\n                "format": "uri"\n            },\n            "additionalProperties": {\n                "type": "boolean"\n            }\n        },\n        "$comment": {\n            "type": "string"\n        },\n        "$defs": {\n            "type": "object",\n            "additionalProperties": { "$dynamicRef": "#meta" },\n            "default": {}\n        }\n    }\n}')),Bi.defineVocabulary("https://json-schema.org/draft/2020-12/vocab/core",{validate:Gi.validate,$defs:Gi.definitions,$dynamicRef:Gi.dynamicRef,$ref:Gi.ref}),Zi.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/2020-12/meta/applicator",\n    "$schema": "https://json-schema.org/draft/2020-12/schema",\n    "$vocabulary": {\n        "https://json-schema.org/draft/2020-12/vocab/applicator": true\n    },\n    "$dynamicAnchor": "meta",\n\n    "title": "Applicator vocabulary meta-schema",\n    "type": ["object", "boolean"],\n    "properties": {\n        "prefixItems": { "$ref": "#/$defs/schemaArray" },\n        "items": { "$dynamicRef": "#meta" },\n        "contains": { "$dynamicRef": "#meta" },\n        "additionalProperties": { "$dynamicRef": "#meta" },\n        "properties": {\n            "type": "object",\n            "additionalProperties": { "$dynamicRef": "#meta" },\n            "default": {}\n        },\n        "patternProperties": {\n            "type": "object",\n            "additionalProperties": { "$dynamicRef": "#meta" },\n            "propertyNames": { "format": "regex" },\n            "default": {}\n        },\n        "dependentSchemas": {\n            "type": "object",\n            "additionalProperties": {\n                "$dynamicRef": "#meta"\n            }\n        },\n        "propertyNames": { "$dynamicRef": "#meta" },\n        "if": { "$dynamicRef": "#meta" },\n        "then": { "$dynamicRef": "#meta" },\n        "else": { "$dynamicRef": "#meta" },\n        "allOf": { "$ref": "#/$defs/schemaArray" },\n        "anyOf": { "$ref": "#/$defs/schemaArray" },\n        "oneOf": { "$ref": "#/$defs/schemaArray" },\n        "not": { "$dynamicRef": "#meta" }\n    },\n    "$defs": {\n        "schemaArray": {\n            "type": "array",\n            "minItems": 1,\n            "items": { "$dynamicRef": "#meta" }\n        }\n    }\n}')),Bi.defineVocabulary("https://json-schema.org/draft/2020-12/vocab/applicator",{additionalProperties:Gi.additionalProperties6,allOf:Gi.allOf,anyOf:Gi.anyOf,contains:Gi.containsMinContainsMaxContains,dependentSchemas:Gi.dependentSchemas,if:Gi.if,then:Gi.then,else:Gi.else,items:Gi.items202012,not:Gi.not,oneOf:Gi.oneOf,patternProperties:Gi.patternProperties,prefixItems:Gi.tupleItems,properties:Gi.properties,propertyNames:Gi.propertyNames}),Zi.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/2020-12/meta/validation",\n    "$schema": "https://json-schema.org/draft/2020-12/schema",\n    "$vocabulary": {\n        "https://json-schema.org/draft/2020-12/vocab/validation": true\n    },\n    "$dynamicAnchor": "meta",\n\n    "title": "Validation vocabulary meta-schema",\n    "type": ["object", "boolean"],\n    "properties": {\n        "multipleOf": {\n            "type": "number",\n            "exclusiveMinimum": 0\n        },\n        "maximum": {\n            "type": "number"\n        },\n        "exclusiveMaximum": {\n            "type": "number"\n        },\n        "minimum": {\n            "type": "number"\n        },\n        "exclusiveMinimum": {\n            "type": "number"\n        },\n        "maxLength": { "$ref": "#/$defs/nonNegativeInteger" },\n        "minLength": { "$ref": "#/$defs/nonNegativeIntegerDefault0" },\n        "pattern": {\n            "type": "string",\n            "format": "regex"\n        },\n        "maxItems": { "$ref": "#/$defs/nonNegativeInteger" },\n        "minItems": { "$ref": "#/$defs/nonNegativeIntegerDefault0" },\n        "uniqueItems": {\n            "type": "boolean",\n            "default": false\n        },\n        "maxContains": { "$ref": "#/$defs/nonNegativeInteger" },\n        "minContains": {\n            "$ref": "#/$defs/nonNegativeInteger",\n            "default": 1\n        },\n        "maxProperties": { "$ref": "#/$defs/nonNegativeInteger" },\n        "minProperties": { "$ref": "#/$defs/nonNegativeIntegerDefault0" },\n        "required": { "$ref": "#/$defs/stringArray" },\n        "dependentRequired": {\n            "type": "object",\n            "additionalProperties": {\n                "$ref": "#/$defs/stringArray"\n            }\n        },\n        "const": true,\n        "enum": {\n            "type": "array",\n            "items": true\n        },\n        "type": {\n            "anyOf": [\n                { "$ref": "#/$defs/simpleTypes" },\n                {\n                    "type": "array",\n                    "items": { "$ref": "#/$defs/simpleTypes" },\n                    "minItems": 1,\n                    "uniqueItems": true\n                }\n            ]\n        }\n    },\n    "$defs": {\n        "nonNegativeInteger": {\n            "type": "integer",\n            "minimum": 0\n        },\n        "nonNegativeIntegerDefault0": {\n            "$ref": "#/$defs/nonNegativeInteger",\n            "default": 0\n        },\n        "simpleTypes": {\n            "enum": [\n                "array",\n                "boolean",\n                "integer",\n                "null",\n                "number",\n                "object",\n                "string"\n            ]\n        },\n        "stringArray": {\n            "type": "array",\n            "items": { "type": "string" },\n            "uniqueItems": true,\n            "default": []\n        }\n    }\n}')),Bi.defineVocabulary("https://json-schema.org/draft/2020-12/vocab/validation",{const:Gi.const,dependentRequired:Gi.dependentRequired,enum:Gi.enum,exclusiveMaximum:Gi.exclusiveMaximum,exclusiveMinimum:Gi.exclusiveMinimum,maxItems:Gi.maxItems,maxLength:Gi.maxLength6,maxProperties:Gi.maxProperties,maximum:Gi.maximum,minItems:Gi.minItems,minLength:Gi.minLength6,minProperties:Gi.minProperties,minimum:Gi.minimum,multipleOf:Gi.multipleOf,pattern:Gi.pattern,required:Gi.required,type:Gi.type,uniqueItems:Gi.uniqueItems}),Zi.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/2020-12/meta/meta-data",\n    "$schema": "https://json-schema.org/draft/2020-12/schema",\n    "$vocabulary": {\n        "https://json-schema.org/draft/2020-12/vocab/meta-data": true\n    },\n    "$dynamicAnchor": "meta",\n\n    "title": "Meta-data vocabulary meta-schema",\n\n    "type": ["object", "boolean"],\n    "properties": {\n        "title": {\n            "type": "string"\n        },\n        "description": {\n            "type": "string"\n        },\n        "default": true,\n        "deprecated": {\n            "type": "boolean",\n            "default": false\n        },\n        "readOnly": {\n            "type": "boolean",\n            "default": false\n        },\n        "writeOnly": {\n            "type": "boolean",\n            "default": false\n        },\n        "examples": {\n            "type": "array",\n            "items": true\n        }\n    }\n}')),Bi.defineVocabulary("https://json-schema.org/draft/2020-12/vocab/meta-data",{default:Gi.metaData,deprecated:Gi.metaData,description:Gi.metaData,examples:Gi.metaData,readOnly:Gi.metaData,title:Gi.metaData,writeOnly:Gi.metaData}),Zi.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/2020-12/meta/format-annotation",\n    "$schema": "https://json-schema.org/draft/2020-12/schema",\n    "$vocabulary": {\n        "https://json-schema.org/draft/2020-12/vocab/format-annotation": true\n    },\n    "$dynamicAnchor": "meta",\n\n    "title": "Format vocabulary meta-schema for annotation results",\n    "type": ["object", "boolean"],\n    "properties": {\n        "format": { "type": "string" }\n    }\n}')),Bi.defineVocabulary("https://json-schema.org/draft/2020-12/vocab/format-annotation",{format:Gi.metaData}),Zi.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/2020-12/meta/format-assertion",\n    "$schema": "https://json-schema.org/draft/2020-12/schema",\n    "$vocabulary": {\n        "https://json-schema.org/draft/2020-12/vocab/format-assertion": true\n    },\n    "$dynamicAnchor": "meta",\n\n    "title": "Format vocabulary meta-schema for assertion results",\n    "type": ["object", "boolean"],\n    "properties": {\n        "format": { "type": "string" }\n    }\n}')),Zi.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/2020-12/meta/content",\n    "$schema": "https://json-schema.org/draft/2020-12/schema",\n    "$vocabulary": {\n        "https://json-schema.org/draft/2020-12/vocab/content": true\n    },\n    "$dynamicAnchor": "meta",\n\n    "title": "Content vocabulary meta-schema",\n\n    "type": ["object", "boolean"],\n    "properties": {\n        "contentMediaType": { "type": "string" },\n        "contentEncoding": { "type": "string" },\n        "contentSchema": { "$dynamicRef": "#meta" }\n    }\n}')),Bi.defineVocabulary("https://json-schema.org/draft/2020-12/vocab/content",{contentEncoding:Gi.metaData,contentMediaType:Gi.metaData,contentSchema:Gi.metaData}),Zi.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/2020-12/meta/unevaluated",\n    "$schema": "https://json-schema.org/draft/2020-12/schema",\n    "$vocabulary": {\n        "https://json-schema.org/draft/2020-12/vocab/unevaluated": true\n    },\n    "$dynamicAnchor": "meta",\n\n    "title": "Unevaluated applicator vocabulary meta-schema",\n    "type": ["object", "boolean"],\n    "properties": {\n        "unevaluatedItems": { "$dynamicRef": "#meta" },\n        "unevaluatedProperties": { "$dynamicRef": "#meta" }\n    }\n}')),Bi.defineVocabulary("https://json-schema.org/draft/2020-12/vocab/unevaluated",{unevaluatedItems:Gi.unevaluatedItems,unevaluatedProperties:Gi.unevaluatedProperties});const{Core:Xi,Schema:Hi,InvalidSchemaError:Qi}=en,Yi=Ai;var eo={add:Xi.add,get:Hi.get,validate:Xi.validate,compile:Xi.compile,interpret:Xi.interpret,setMetaOutputFormat:Xi.setMetaOutputFormat,setShouldMetaValidate:Xi.setShouldMetaValidate,FLAG:Xi.FLAG,BASIC:Xi.BASIC,DETAILED:Xi.DETAILED,VERBOSE:Xi.VERBOSE,Keywords:Yi,InvalidSchemaError:Qi};var to={splitUri:e=>{const t=e.indexOf("#"),n=-1===t?e.length:t,r=e.slice(0,n),a=e.slice(n+1);return[decodeURI(r),decodeURI(a)]}};const{Core:no}=en,{splitUri:ro}=to;var ao={collectExternalIds:(e,t,n,r)=>{const a=n[e][0],i=ro(e)[0];no.getKeyword(a).collectExternalIds(e,t,n,{...n.metaData[i].dynamicAnchors,...r})}};const io=eo,{Core:oo}=en,so=ao,co={...io.Keywords.validate,collectExternalIds:(e,t,n,r)=>{const a=n[e][2];if(!t.has(e)&&"boolean"!=typeof a){t.add(e);for(const[e,,i]of a){const a=oo.getKeyword(e);a.collectExternalIds&&a.collectExternalIds(i,t,n,r)}}}},mo={...io.Keywords.ref,collectExternalIds:so.collectExternalIds},lo={...io.Keywords.additionalItems,collectExternalIds:([,e],t,n,r)=>{"string"==typeof e&&so.collectExternalIds(e,t,n,r)}},po={...io.Keywords.additionalProperties,collectExternalIds:([,,e],t,n,r)=>{"string"==typeof e&&so.collectExternalIds(e,t,n,r)}},uo={...io.Keywords.additionalItems6,collectExternalIds:([,e],t,n,r)=>{so.collectExternalIds(e,t,n,r)}},fo={...io.Keywords.additionalProperties6,collectExternalIds:([,,e],t,n,r)=>{so.collectExternalIds(e,t,n,r)}},yo={...io.Keywords.allOf,collectExternalIds:(e,t,n,r)=>{e.forEach((e=>so.collectExternalIds(e,t,n,r)))}},ho={...io.Keywords.anyOf,collectExternalIds:(e,t,n,r)=>{e.forEach((e=>so.collectExternalIds(e,t,n,r)))}},vo={...io.Keywords.contains,collectExternalIds:so.collectExternalIds},go={...io.Keywords.containsMinContainsMaxContains,collectExternalIds:({contains:e},t,n,r)=>{so.collectExternalIds(e,t,n,r)}},bo={...io.Keywords.dependencies,collectExternalIds:(e,t,n,r)=>{Object.values(e).forEach((([,e])=>{"string"==typeof e&&so.collectExternalIds(e,t,n,r)}))}},$o={...io.Keywords.dependentSchemas,collectExternalIds:(e,t,n,r)=>{Object.values(e).forEach((([,e])=>so.collectExternalIds(e,t,n,r)))}},Io={...io.Keywords.if,collectExternalIds:so.collectExternalIds},wo={...io.Keywords.then,collectExternalIds:([,e],t,n,r)=>{so.collectExternalIds(e,t,n,r)}},Oo={...io.Keywords.else,collectExternalIds:([,e],t,n,r)=>{so.collectExternalIds(e,t,n,r)}},xo={...io.Keywords.items,collectExternalIds:(e,t,n,r)=>{"string"==typeof e?so.collectExternalIds(e,t,n,r):e.forEach((e=>so.collectExternalIds(e,t,n,r)))}},So={...io.Keywords.items202012,collectExternalIds:([,e],t,n,r)=>{so.collectExternalIds(e,t,n,r)}};var jo={validate:co,ref:mo,additionalItems:lo,additionalItems6:uo,additionalProperties:po,additionalProperties6:fo,allOf:yo,anyOf:ho,contains:vo,containsMinContainsMaxContains:go,dependencies:bo,dependentSchemas:$o,if:Io,then:wo,else:Oo,items:xo,items202012:So,not:{...io.Keywords.not,collectExternalIds:so.collectExternalIds},oneOf:{...io.Keywords.oneOf,collectExternalIds:(e,t,n,r)=>{e.forEach((e=>so.collectExternalIds(e,t,n,r)))}},patternProperties:{...io.Keywords.patternProperties,collectExternalIds:(e,t,n,r)=>{e.forEach((([,e])=>so.collectExternalIds(e,t,n,r)))}},tupleItems:{...io.Keywords.tupleItems,collectExternalIds:(e,t,n,r)=>{e.forEach((e=>so.collectExternalIds(e,t,n,r)))}},properties:{...io.Keywords.properties,collectExternalIds:(e,t,n,r)=>{Object.values(e).forEach((e=>so.collectExternalIds(e,t,n,r)))}},propertyNames:{...io.Keywords.propertyNames,collectExternalIds:so.collectExternalIds},unevaluatedItems:{...io.Keywords.unevaluatedItems,collectExternalIds:([,e],t,n,r)=>{so.collectExternalIds(e,t,n,r)}},unevaluatedProperties:{...io.Keywords.unevaluatedProperties,collectExternalIds:([,e],t,n,r)=>{so.collectExternalIds(e,t,n,r)}}};const Eo=eo,{Core:Po,Schema:Ao}=en,Co=jo;Ao.setConfig("http://json-schema.org/draft-04/schema","bundlingLocation","/definitions"),Po.defineVocabulary("http://json-schema.org/draft-04/schema",{validate:Co.validate,additionalItems:Co.additionalItems,additionalProperties:Co.additionalProperties,allOf:Co.allOf,anyOf:Co.anyOf,default:Eo.Keywords.metaData,definitions:Eo.Keywords.definitions,dependencies:Co.dependencies,description:Eo.Keywords.metaData,enum:Eo.Keywords.enum,format:Eo.Keywords.metaData,items:Co.items,maxItems:Eo.Keywords.maxItems,maxLength:Eo.Keywords.maxLength,maxProperties:Eo.Keywords.maxProperties,maximum:Eo.Keywords.maximumExclusiveMaximum,minItems:Eo.Keywords.minItems,minLength:Eo.Keywords.minLength,minProperties:Eo.Keywords.minProperties,minimum:Eo.Keywords.minimumExclusiveMinimum,multipleOf:Eo.Keywords.multipleOf,not:Co.not,oneOf:Co.oneOf,pattern:Eo.Keywords.pattern,patternProperties:Co.patternProperties,properties:Co.properties,required:Eo.Keywords.required,title:Eo.Keywords.metaData,type:Eo.Keywords.type,uniqueItems:Eo.Keywords.uniqueItems});const No=eo,{Core:Ko,Schema:Ro}=en,Do=jo;Ro.setConfig("http://json-schema.org/draft-06/schema","bundlingLocation","/definitions"),Ko.defineVocabulary("http://json-schema.org/draft-06/schema",{validate:Do.validate,additionalItems:Do.additionalItems6,additionalProperties:Do.additionalProperties6,allOf:Do.allOf,anyOf:Do.anyOf,const:No.Keywords.const,contains:Do.contains,default:No.Keywords.metaData,definitions:No.Keywords.definitions,dependencies:Do.dependencies,description:No.Keywords.metaData,enum:No.Keywords.enum,examples:No.Keywords.metaData,exclusiveMaximum:No.Keywords.exclusiveMaximum,exclusiveMinimum:No.Keywords.exclusiveMinimum,format:No.Keywords.metaData,items:Do.items,maxItems:No.Keywords.maxItems,maxLength:No.Keywords.maxLength6,maxProperties:No.Keywords.maxProperties,maximum:No.Keywords.maximum,minItems:No.Keywords.minItems,minLength:No.Keywords.minLength6,minProperties:No.Keywords.minProperties,minimum:No.Keywords.minimum,multipleOf:No.Keywords.multipleOf,not:Do.not,oneOf:Do.oneOf,pattern:No.Keywords.pattern,patternProperties:Do.patternProperties,properties:Do.properties,propertyNames:Do.propertyNames,required:No.Keywords.required,title:No.Keywords.metaData,type:No.Keywords.type,uniqueItems:No.Keywords.uniqueItems});const Mo=eo,{Core:To,Schema:qo}=en,Lo=jo;qo.setConfig("http://json-schema.org/draft-07/schema","bundlingLocation","/definitions"),To.defineVocabulary("http://json-schema.org/draft-07/schema",{validate:Lo.validate,additionalItems:Lo.additionalItems6,additionalProperties:Lo.additionalProperties6,allOf:Lo.allOf,anyOf:Lo.anyOf,const:Mo.Keywords.const,contains:Lo.contains,default:Mo.Keywords.metaData,definitions:Mo.Keywords.definitions,dependencies:Lo.dependencies,description:Mo.Keywords.metaData,enum:Mo.Keywords.enum,exclusiveMaximum:Mo.Keywords.exclusiveMaximum,exclusiveMinimum:Mo.Keywords.exclusiveMinimum,format:Mo.Keywords.metaData,if:Lo.if,then:Lo.then,else:Lo.else,items:Lo.items,maxItems:Mo.Keywords.maxItems,maxLength:Mo.Keywords.maxLength6,maxProperties:Mo.Keywords.maxProperties,maximum:Mo.Keywords.maximum,minItems:Mo.Keywords.minItems,minLength:Mo.Keywords.minLength6,minProperties:Mo.Keywords.minProperties,minimum:Mo.Keywords.minimum,multipleOf:Mo.Keywords.multipleOf,not:Lo.not,oneOf:Lo.oneOf,pattern:Mo.Keywords.pattern,patternProperties:Lo.patternProperties,properties:Lo.properties,propertyNames:Lo.propertyNames,readOnly:Mo.Keywords.metaData,required:Mo.Keywords.required,title:Mo.Keywords.metaData,type:Mo.Keywords.type,uniqueItems:Mo.Keywords.uniqueItems,writeOnly:Mo.Keywords.metaData});const ko=eo,{Core:Vo,Schema:Uo}=en,_o=jo;Uo.setConfig("https://json-schema.org/draft/2019-09/schema","bundlingLocation","/$defs"),Vo.defineVocabulary("https://json-schema.org/draft/2019-09/vocab/core",{validate:_o.validate,$defs:ko.Keywords.definitions,$recursiveRef:ko.Keywords.dynamicRef,$ref:_o.ref}),Vo.defineVocabulary("https://json-schema.org/draft/2019-09/vocab/applicator",{additionalItems:_o.additionalItems6,additionalProperties:_o.additionalProperties6,allOf:_o.allOf,anyOf:_o.anyOf,contains:_o.containsMinContainsMaxContains,dependentSchemas:_o.dependentSchemas,if:_o.if,then:_o.then,else:_o.else,items:_o.items,not:_o.not,oneOf:_o.oneOf,patternProperties:_o.patternProperties,properties:_o.properties,propertyNames:_o.propertyNames,unevaluatedItems:_o.unevaluatedItems,unevaluatedProperties:_o.unevaluatedProperties});const Jo=eo,{Core:zo,Schema:Fo}=en,Bo=jo;Fo.setConfig("https://json-schema.org/draft/2020-12/schema","bundlingLocation","/$defs"),zo.defineVocabulary("https://json-schema.org/draft/2020-12/vocab/core",{validate:Bo.validate,$defs:Jo.Keywords.definitions,$dynamicRef:Jo.Keywords.dynamicRef,$ref:Bo.ref}),zo.defineVocabulary("https://json-schema.org/draft/2020-12/vocab/applicator",{additionalProperties:Bo.additionalProperties6,allOf:Bo.allOf,anyOf:Bo.anyOf,contains:Bo.containsMinContainsMaxContains,dependentSchemas:Bo.dependentSchemas,if:Bo.if,then:Bo.then,else:Bo.else,items:Bo.items202012,not:Bo.not,oneOf:Bo.oneOf,patternProperties:Bo.patternProperties,prefixItems:Bo.tupleItems,properties:Bo.properties,propertyNames:Bo.propertyNames}),zo.defineVocabulary("https://json-schema.org/draft/2020-12/vocab/unevaluated",{unevaluatedItems:Bo.unevaluatedItems,unevaluatedProperties:Bo.unevaluatedProperties});const{v4:Zo}=C,Go=eo,Wo=ne,{Core:Xo,Schema:Ho,InvalidSchemaError:Qo}=en,Yo=ao,{splitUri:es}=to,ts={alwaysIncludeDialect:!1,bundleMode:"flat",definitionNamingStrategy:"uri"};var ns={add:Go.add,get:Ho.get,bundle:async(e,t={})=>{const n={...ts,...t},{ast:r,schemaUri:a}=await Xo.compile(e),i=new Set;Yo.collectExternalIds(a,i,r,{});const o=new Set([...i].map((e=>es(e)[0])));o.delete(e.id);const s=Ho.toSchema(e,{includeEmbedded:"full"===n.bundleMode}),c=Ho.getConfig(e.schemaVersion,"bundlingLocation");void 0===Wo.get(c,s)&&o.size>0&&Wo.assign(c,s,{});for(const t of o.values()){const r=await Go.get(t),a=Ho.toSchema(r,{parentId:e.id,parentDialect:n.alwaysIncludeDialect?"":e.schemaVersion,includeEmbedded:"full"===n.bundleMode});let i;if("uri"===n.definitionNamingStrategy){i=a[Ho.getConfig(r.schemaVersion,"embeddedToken")]}else{if("uuid"!==n.definitionNamingStrategy)throw Error(`Unknown definition naming stragety: ${n.definitionNamingStrategy}`);i=Zo()}const o=Wo.append(i,c);Wo.assign(o,s,a)}return s},FULL:"full",FLAT:"flat",URI:"uri",UUID:"uuid",setMetaOutputFormat:Xo.setMetaOutputFormat,setShouldMetaValidate:Xo.setShouldMetaValidate,FLAG:Xo.FLAG,BASIC:Xo.BASIC,DETAILED:Xo.DETAILED,VERBOSE:Xo.VERBOSE,InvalidSchemaError:Qo};export{ns as default};
//# sourceMappingURL=json-schema-bundler-esm.min.js.map
