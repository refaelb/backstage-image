"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var e,t="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:{};function n(e){if(e.__esModule)return e;var t=Object.defineProperty({},"__esModule",{value:!0});return Object.keys(e).forEach((function(n){var r=Object.getOwnPropertyDescriptor(e,n);Object.defineProperty(t,n,r.get?r:{enumerable:!0,get:function(){return e[n]}})})),t}var r=new Uint8Array(16);function a(){if(!e&&!(e="undefined"!=typeof crypto&&crypto.getRandomValues&&crypto.getRandomValues.bind(crypto)||"undefined"!=typeof msCrypto&&"function"==typeof msCrypto.getRandomValues&&msCrypto.getRandomValues.bind(msCrypto)))throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");return e(r)}var i=/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;function o(e){return"string"==typeof e&&i.test(e)}for(var s,c,m=[],l=0;l<256;++l)m.push((l+256).toString(16).substr(1));function p(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=(m[e[t+0]]+m[e[t+1]]+m[e[t+2]]+m[e[t+3]]+"-"+m[e[t+4]]+m[e[t+5]]+"-"+m[e[t+6]]+m[e[t+7]]+"-"+m[e[t+8]]+m[e[t+9]]+"-"+m[e[t+10]]+m[e[t+11]]+m[e[t+12]]+m[e[t+13]]+m[e[t+14]]+m[e[t+15]]).toLowerCase();if(!o(n))throw TypeError("Stringified UUID is invalid");return n}var d=0,u=0;function f(e){if(!o(e))throw TypeError("Invalid UUID");var t,n=new Uint8Array(16);return n[0]=(t=parseInt(e.slice(0,8),16))>>>24,n[1]=t>>>16&255,n[2]=t>>>8&255,n[3]=255&t,n[4]=(t=parseInt(e.slice(9,13),16))>>>8,n[5]=255&t,n[6]=(t=parseInt(e.slice(14,18),16))>>>8,n[7]=255&t,n[8]=(t=parseInt(e.slice(19,23),16))>>>8,n[9]=255&t,n[10]=(t=parseInt(e.slice(24,36),16))/1099511627776&255,n[11]=t/4294967296&255,n[12]=t>>>24&255,n[13]=t>>>16&255,n[14]=t>>>8&255,n[15]=255&t,n}function y(e,t,n){function r(e,r,a,i){if("string"==typeof e&&(e=function(e){e=unescape(encodeURIComponent(e));for(var t=[],n=0;n<e.length;++n)t.push(e.charCodeAt(n));return t}(e)),"string"==typeof r&&(r=f(r)),16!==r.length)throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");var o=new Uint8Array(16+e.length);if(o.set(r),o.set(e,r.length),(o=n(o))[6]=15&o[6]|t,o[8]=63&o[8]|128,a){i=i||0;for(var s=0;s<16;++s)a[i+s]=o[s];return a}return p(o)}try{r.name=e}catch(e){}return r.DNS="6ba7b810-9dad-11d1-80b4-00c04fd430c8",r.URL="6ba7b811-9dad-11d1-80b4-00c04fd430c8",r}function h(e){return 14+(e+64>>>9<<4)+1}function v(e,t){var n=(65535&e)+(65535&t);return(e>>16)+(t>>16)+(n>>16)<<16|65535&n}function g(e,t,n,r,a,i){return v((o=v(v(t,e),v(r,i)))<<(s=a)|o>>>32-s,n);var o,s}function b(e,t,n,r,a,i,o){return g(t&n|~t&r,e,t,a,i,o)}function $(e,t,n,r,a,i,o){return g(t&r|n&~r,e,t,a,i,o)}function I(e,t,n,r,a,i,o){return g(t^n^r,e,t,a,i,o)}function w(e,t,n,r,a,i,o){return g(n^(t|~r),e,t,a,i,o)}var O=y("v3",48,(function(e){if("string"==typeof e){var t=unescape(encodeURIComponent(e));e=new Uint8Array(t.length);for(var n=0;n<t.length;++n)e[n]=t.charCodeAt(n)}return function(e){for(var t=[],n=32*e.length,r="0123456789abcdef",a=0;a<n;a+=8){var i=e[a>>5]>>>a%32&255,o=parseInt(r.charAt(i>>>4&15)+r.charAt(15&i),16);t.push(o)}return t}(function(e,t){e[t>>5]|=128<<t%32,e[h(t)-1]=t;for(var n=1732584193,r=-271733879,a=-1732584194,i=271733878,o=0;o<e.length;o+=16){var s=n,c=r,m=a,l=i;n=b(n,r,a,i,e[o],7,-680876936),i=b(i,n,r,a,e[o+1],12,-389564586),a=b(a,i,n,r,e[o+2],17,606105819),r=b(r,a,i,n,e[o+3],22,-1044525330),n=b(n,r,a,i,e[o+4],7,-176418897),i=b(i,n,r,a,e[o+5],12,1200080426),a=b(a,i,n,r,e[o+6],17,-1473231341),r=b(r,a,i,n,e[o+7],22,-45705983),n=b(n,r,a,i,e[o+8],7,1770035416),i=b(i,n,r,a,e[o+9],12,-1958414417),a=b(a,i,n,r,e[o+10],17,-42063),r=b(r,a,i,n,e[o+11],22,-1990404162),n=b(n,r,a,i,e[o+12],7,1804603682),i=b(i,n,r,a,e[o+13],12,-40341101),a=b(a,i,n,r,e[o+14],17,-1502002290),n=$(n,r=b(r,a,i,n,e[o+15],22,1236535329),a,i,e[o+1],5,-165796510),i=$(i,n,r,a,e[o+6],9,-1069501632),a=$(a,i,n,r,e[o+11],14,643717713),r=$(r,a,i,n,e[o],20,-373897302),n=$(n,r,a,i,e[o+5],5,-701558691),i=$(i,n,r,a,e[o+10],9,38016083),a=$(a,i,n,r,e[o+15],14,-660478335),r=$(r,a,i,n,e[o+4],20,-405537848),n=$(n,r,a,i,e[o+9],5,568446438),i=$(i,n,r,a,e[o+14],9,-1019803690),a=$(a,i,n,r,e[o+3],14,-187363961),r=$(r,a,i,n,e[o+8],20,1163531501),n=$(n,r,a,i,e[o+13],5,-1444681467),i=$(i,n,r,a,e[o+2],9,-51403784),a=$(a,i,n,r,e[o+7],14,1735328473),n=I(n,r=$(r,a,i,n,e[o+12],20,-1926607734),a,i,e[o+5],4,-378558),i=I(i,n,r,a,e[o+8],11,-2022574463),a=I(a,i,n,r,e[o+11],16,1839030562),r=I(r,a,i,n,e[o+14],23,-35309556),n=I(n,r,a,i,e[o+1],4,-1530992060),i=I(i,n,r,a,e[o+4],11,1272893353),a=I(a,i,n,r,e[o+7],16,-155497632),r=I(r,a,i,n,e[o+10],23,-1094730640),n=I(n,r,a,i,e[o+13],4,681279174),i=I(i,n,r,a,e[o],11,-358537222),a=I(a,i,n,r,e[o+3],16,-722521979),r=I(r,a,i,n,e[o+6],23,76029189),n=I(n,r,a,i,e[o+9],4,-640364487),i=I(i,n,r,a,e[o+12],11,-421815835),a=I(a,i,n,r,e[o+15],16,530742520),n=w(n,r=I(r,a,i,n,e[o+2],23,-995338651),a,i,e[o],6,-198630844),i=w(i,n,r,a,e[o+7],10,1126891415),a=w(a,i,n,r,e[o+14],15,-1416354905),r=w(r,a,i,n,e[o+5],21,-57434055),n=w(n,r,a,i,e[o+12],6,1700485571),i=w(i,n,r,a,e[o+3],10,-1894986606),a=w(a,i,n,r,e[o+10],15,-1051523),r=w(r,a,i,n,e[o+1],21,-2054922799),n=w(n,r,a,i,e[o+8],6,1873313359),i=w(i,n,r,a,e[o+15],10,-30611744),a=w(a,i,n,r,e[o+6],15,-1560198380),r=w(r,a,i,n,e[o+13],21,1309151649),n=w(n,r,a,i,e[o+4],6,-145523070),i=w(i,n,r,a,e[o+11],10,-1120210379),a=w(a,i,n,r,e[o+2],15,718787259),r=w(r,a,i,n,e[o+9],21,-343485551),n=v(n,s),r=v(r,c),a=v(a,m),i=v(i,l)}return[n,r,a,i]}(function(e){if(0===e.length)return[];for(var t=8*e.length,n=new Uint32Array(h(t)),r=0;r<t;r+=8)n[r>>5]|=(255&e[r/8])<<r%32;return n}(e),8*e.length))})),x=O;function S(e,t,n,r){switch(e){case 0:return t&n^~t&r;case 1:case 3:return t^n^r;case 2:return t&n^t&r^n&r}}function j(e,t){return e<<t|e>>>32-t}var E=y("v5",80,(function(e){var t=[1518500249,1859775393,2400959708,3395469782],n=[1732584193,4023233417,2562383102,271733878,3285377520];if("string"==typeof e){var r=unescape(encodeURIComponent(e));e=[];for(var a=0;a<r.length;++a)e.push(r.charCodeAt(a))}else Array.isArray(e)||(e=Array.prototype.slice.call(e));e.push(128);for(var i=e.length/4+2,o=Math.ceil(i/16),s=new Array(o),c=0;c<o;++c){for(var m=new Uint32Array(16),l=0;l<16;++l)m[l]=e[64*c+4*l]<<24|e[64*c+4*l+1]<<16|e[64*c+4*l+2]<<8|e[64*c+4*l+3];s[c]=m}s[o-1][14]=8*(e.length-1)/Math.pow(2,32),s[o-1][14]=Math.floor(s[o-1][14]),s[o-1][15]=8*(e.length-1)&4294967295;for(var p=0;p<o;++p){for(var d=new Uint32Array(80),u=0;u<16;++u)d[u]=s[p][u];for(var f=16;f<80;++f)d[f]=j(d[f-3]^d[f-8]^d[f-14]^d[f-16],1);for(var y=n[0],h=n[1],v=n[2],g=n[3],b=n[4],$=0;$<80;++$){var I=Math.floor($/20),w=j(y,5)+S(I,h,v,g)+b+t[I]+d[$]>>>0;b=g,g=v,v=j(h,30)>>>0,h=y,y=w}n[0]=n[0]+y>>>0,n[1]=n[1]+h>>>0,n[2]=n[2]+v>>>0,n[3]=n[3]+g>>>0,n[4]=n[4]+b>>>0}return[n[0]>>24&255,n[0]>>16&255,n[0]>>8&255,255&n[0],n[1]>>24&255,n[1]>>16&255,n[1]>>8&255,255&n[1],n[2]>>24&255,n[2]>>16&255,n[2]>>8&255,255&n[2],n[3]>>24&255,n[3]>>16&255,n[3]>>8&255,255&n[3],n[4]>>24&255,n[4]>>16&255,n[4]>>8&255,255&n[4]]})),P=E;var A=Object.freeze({__proto__:null,v1:function(e,t,n){var r=t&&n||0,i=t||new Array(16),o=(e=e||{}).node||s,m=void 0!==e.clockseq?e.clockseq:c;if(null==o||null==m){var l=e.random||(e.rng||a)();null==o&&(o=s=[1|l[0],l[1],l[2],l[3],l[4],l[5]]),null==m&&(m=c=16383&(l[6]<<8|l[7]))}var f=void 0!==e.msecs?e.msecs:Date.now(),y=void 0!==e.nsecs?e.nsecs:u+1,h=f-d+(y-u)/1e4;if(h<0&&void 0===e.clockseq&&(m=m+1&16383),(h<0||f>d)&&void 0===e.nsecs&&(y=0),y>=1e4)throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");d=f,u=y,c=m;var v=(1e4*(268435455&(f+=122192928e5))+y)%4294967296;i[r++]=v>>>24&255,i[r++]=v>>>16&255,i[r++]=v>>>8&255,i[r++]=255&v;var g=f/4294967296*1e4&268435455;i[r++]=g>>>8&255,i[r++]=255&g,i[r++]=g>>>24&15|16,i[r++]=g>>>16&255,i[r++]=m>>>8|128,i[r++]=255&m;for(var b=0;b<6;++b)i[r+b]=o[b];return t||p(i)},v3:x,v4:function(e,t,n){var r=(e=e||{}).random||(e.rng||a)();if(r[6]=15&r[6]|64,r[8]=63&r[8]|128,t){n=n||0;for(var i=0;i<16;++i)t[n+i]=r[i];return t}return p(r)},v5:P,NIL:"00000000-0000-0000-0000-000000000000",version:function(e){if(!o(e))throw TypeError("Invalid UUID");return parseInt(e.substr(14,1),16)},validate:o,stringify:p,parse:f}),C=n(A),N=function(e,t){return function n(){null==t&&(t=e.length);var r=[].slice.call(arguments);return r.length>=t?e.apply(this,r):function(){return n.apply(this,r.concat([].slice.call(arguments)))}}};var K={exports:{}};!function(e,n){!function(t,r){var a={};t.PubSub?(a=t.PubSub,console.warn("PubSub already loaded, using existing version")):(t.PubSub=a,function(e){var t={},n=-1,r="*";function a(e){var t;for(t in e)if(Object.prototype.hasOwnProperty.call(e,t))return!0;return!1}function i(e){return function(){throw e}}function o(e,t,n){try{e(t,n)}catch(e){setTimeout(i(e),0)}}function s(e,t,n){e(t,n)}function c(e,n,r,a){var i,c=t[n],m=a?s:o;if(Object.prototype.hasOwnProperty.call(t,n))for(i in c)Object.prototype.hasOwnProperty.call(c,i)&&m(c[i],e,r)}function m(e,t,n){return function(){var a=String(e),i=a.lastIndexOf(".");for(c(e,e,t,n);-1!==i;)i=(a=a.substr(0,i)).lastIndexOf("."),c(e,a,t,n);c(e,r,t,n)}}function l(e){var n=String(e);return Boolean(Object.prototype.hasOwnProperty.call(t,n)&&a(t[n]))}function p(e){for(var t=String(e),n=l(t)||l(r),a=t.lastIndexOf(".");!n&&-1!==a;)a=(t=t.substr(0,a)).lastIndexOf("."),n=l(t);return n}function d(e,t,n,r){var a=m(e="symbol"==typeof e?e.toString():e,t,r);return!!p(e)&&(!0===n?a():setTimeout(a,0),!0)}e.publish=function(t,n){return d(t,n,!1,e.immediateExceptions)},e.publishSync=function(t,n){return d(t,n,!0,e.immediateExceptions)},e.subscribe=function(e,r){if("function"!=typeof r)return!1;e="symbol"==typeof e?e.toString():e,Object.prototype.hasOwnProperty.call(t,e)||(t[e]={});var a="uid_"+String(++n);return t[e][a]=r,a},e.subscribeAll=function(t){return e.subscribe(r,t)},e.subscribeOnce=function(t,n){var r=e.subscribe(t,(function(){e.unsubscribe(r),n.apply(this,arguments)}));return e},e.clearAllSubscriptions=function(){t={}},e.clearSubscriptions=function(e){var n;for(n in t)Object.prototype.hasOwnProperty.call(t,n)&&0===n.indexOf(e)&&delete t[n]},e.countSubscriptions=function(e){var n,r,a=0;for(n in t)if(Object.prototype.hasOwnProperty.call(t,n)&&0===n.indexOf(e)){for(r in t[n])a++;break}return a},e.getSubscriptions=function(e){var n,r=[];for(n in t)Object.prototype.hasOwnProperty.call(t,n)&&0===n.indexOf(e)&&r.push(n);return r},e.unsubscribe=function(n){var r,a,i,o=function(e){var n;for(n in t)if(Object.prototype.hasOwnProperty.call(t,n)&&0===n.indexOf(e))return!0;return!1},s="string"==typeof n&&(Object.prototype.hasOwnProperty.call(t,n)||o(n)),c=!s&&"string"==typeof n,m="function"==typeof n,l=!1;if(!s){for(r in t)if(Object.prototype.hasOwnProperty.call(t,r)){if(a=t[r],c&&a[n]){delete a[n],l=n;break}if(m)for(i in a)Object.prototype.hasOwnProperty.call(a,i)&&a[i]===n&&(delete a[i],l=!0)}return l}e.clearSubscriptions(n)}}(a)),void 0!==e&&e.exports&&(n=e.exports=a),n.PubSub=a,e.exports=n=a}("object"==typeof window&&window||t)}(K,K.exports);var R=function(e,t){if(e=e.trim(),(t=t.trim()).startsWith("about:"))return t;const n=function(e){const t={host:"",path:"",query:"",protocol:""};let n=e,r=e.indexOf("//");t.protocol=n.substring(0,r),r+=2;const a=e.indexOf("/",r),i=e.indexOf("?"),o=e.indexOf("#");-1!==o&&(n=n.substring(0,o));if(-1!==i){const e=n.substring(i);t.query=e,n=n.substring(0,i)}if(-1!==a){const e=n.substring(0,a);t.host=e,n=n.substring(a),t.path=n}else t.host=n;return t}(e),r=function(e){const t={href:e,hash:"",query:"",netPath:!1,absolutePath:!1,relativePath:!1};if(T.test(e))return t.netPath=!0,t;"/"===e[0]?t.absolutePath=!0:""!==e&&(t.relativePath=!0);let n=e;const r=e.indexOf("?"),a=e.indexOf("#");if(-1!==a){const e=n.substring(a);t.hash=e,n=n.substring(0,a)}if(-1!==r){const e=n.substring(r);t.query=e,n=n.substring(0,r)}return t.path=n,t}(t);if(!n.protocol&&!r.netPath)throw new Error("Error, protocol is not specified");if(r.netPath)return r.href.startsWith("//")&&(r.href=n.protocol+r.href),function(e){const t=e.indexOf("//")+2,n=!e.includes("/",t),r=!e.includes("?",t),a=!e.includes("#",t);return n&&r&&a}(r.href)?D(r.href):r.href;if(r.absolutePath){const{path:e,query:t,hash:a}=r;return n.host+M(e)+t+a}if(r.relativePath){const{path:e,query:t,hash:a}=r;let i,o=n.path,s=n.host;return 0===e.length?i=o:(o=o.substring(0,o.lastIndexOf("/")),i=M(o+"/"+e)),s+=""!==i||t||a?i+t+a:"/",s}{const{host:e,path:t,query:a}=n;return t||a?e+t+a+r.hash:D(e)}};function D(e){return e+("/"===e[e.length-1]?"":"/")}function M(e){let t=e.split("/");""===t[0]&&(t=t.slice(1));let n=[];return t.forEach(((e,r)=>{"."!==e&&(".."===e?n.pop():""===e&&r!==t.length-1||n.push(e))})),"/"+n.join("/")}const T=new RegExp("^([a-z][a-z0-9+.-]*:)?//","i");const q=R,L={null:e=>null===e,boolean:e=>"boolean"==typeof e,object:e=>"object"==typeof e&&!Array.isArray(e)&&null!==e,array:e=>Array.isArray(e),number:e=>"number"==typeof e,integer:e=>Number.isInteger(e),string:e=>"string"==typeof e},k=e=>{const t=e.indexOf("#"),n=-1===t?e.length:t,r=e.slice(0,n),a=e.slice(n+1);return[decodeURI(r),decodeURI(a)]},V=e=>{const t=RegExp(/^(.+):\/\//).exec(e);return t?t[1]:""};var U={jsonTypeOf:(e,t)=>L[t](e),splitUrl:k,safeResolveUrl:(e,t)=>{const n=q(e,t),r=k(e)[0];if(r&&"file"===V(n)&&"file"!==V(r))throw Error(`Can't access file '${n}' resource from network context '${e}'`);return n},pathRelative:(e,t)=>{if(e===t)return"";let n=1;const r=e.length-1,a=t.length-n,i=r<a?r:a;let o=-1,s=0;for(;s<i;s++){const r=e.charCodeAt(s+1);if(r!==t.charCodeAt(n+s))break;47===r&&(o=s)}if(a>i){if(47===t.charCodeAt(n+s))return t.slice(n+s+1);if(0===s)return t.slice(n+s)}r>i&&(47===e.charCodeAt(s+1)?o=s:0===i&&(o=0));let c="";for(s=o+2;s<=e.length;++s)s!==e.length&&47!==e.charCodeAt(s)||(c+=0===c.length?"..":"/..");return n+=o,c.length>0?`${c}${t.slice(n,t.length)}`:(47===t.charCodeAt(n)&&++n,t.slice(n,t.length))}};const _=N,J=e=>{if(e.length>0&&"/"!==e[0])throw Error("Invalid JSON Pointer");return e.split("/").slice(1).map(X)},z=(e,t,n,r)=>{if(0===e.length)return n;if(e.length>1){const a=e.shift();return{...t,[a]:z(e,Q(t,a,r),n,G(a,r))}}if(Array.isArray(t)){const r=[...t];return r[H(t,e[0])]=n,r}return"object"==typeof t&&null!==t?{...t,[e[0]]:n}:Q(t,e[0],r)},F=(e,t,n,r)=>{if(0!==e.length)if(1!==e.length||Y(t)){const a=e.shift();F(e,Q(t,a,r),n,G(a,r))}else{t[H(t,e[0])]=n}},B=(e,t,n)=>{if(0!=e.length){if(e.length>1){const r=e.shift(),a=Q(t,r,n);return{...t,[r]:B(e,a,G(r,n))}}if(Array.isArray(t))return t.filter(((t,n)=>n!=e[0]));if("object"==typeof t&&null!==t){const{[e[0]]:n,...r}=t;return r}return Q(t,e[0],n)}},Z=(e,t,n)=>{if(0!==e.length)if(e.length>1){const r=e.shift(),a=Q(t,r,n);Z(e,a,G(r,n))}else Array.isArray(t)?t.splice(e[0],1):"object"==typeof t&&null!==t?delete t[e[0]]:Q(t,e[0],n)},G=_(((e,t)=>t+"/"+W(e))),W=e=>e.toString().replace(/~/g,"~0").replace(/\//g,"~1"),X=e=>e.toString().replace(/~1/g,"/").replace(/~0/g,"~"),H=(e,t)=>Array.isArray(e)&&"-"===t?e.length:t,Q=(e,t,n="")=>{if(void 0===e)throw TypeError(`Value at '${n}' is undefined and does not have property '${t}'`);if(null===e)throw TypeError(`Value at '${n}' is null and does not have property '${t}'`);if(Y(e))throw TypeError(`Value at '${n}' is a ${typeof e} and does not have property '${t}'`);return e[H(e,t)]},Y=e=>null===e||"object"!=typeof e;var ee={nil:"",append:G,get:(e,t)=>{const n=J(e),r=e=>n.reduce((([e,t],n)=>[Q(e,n,t),G(n,t)]),[e,""])[0];return void 0===t?r:r(t)},set:(e,t,n)=>{const r=J(e),a=_(((e,t)=>z(r,e,t,"")));return void 0===t?a:a(t,n)},assign:(e,t,n)=>{const r=J(e),a=_(((e,t)=>F(r,e,t,"")));return void 0===t?a:a(t,n)},unset:(e,t)=>{const n=J(e),r=e=>B(n,e,"");return void 0===t?r:r(t)},remove:(e,t)=>{const n=J(e),r=e=>Z(n,e,"");return void 0===t?r:r(t)}};const te=Symbol("$__value"),ne=Symbol("$__href");var re={cons:(e,t)=>Object.freeze({[ne]:e,[te]:t}),isReference:e=>e&&void 0!==e[ne],href:e=>e[ne],value:e=>e[te]};const ae=ee,ie=N,{jsonTypeOf:oe}=U,se=re,ce=Object.freeze({id:"",pointer:"",instance:void 0,value:void 0}),me=e=>se.isReference(e.value)?se.value(e.value):e.value,le=ie(((e,t)=>oe(me(e),t))),pe=(e,t)=>Object.freeze({...t,pointer:ae.append(e,t.pointer),value:me(t)[e]}),de=ie(((e,t)=>me(t).map(((n,r,a,i)=>e(pe(r,t),r,a,i))))),ue=ie(((e,t)=>me(t).map(((e,n,r,a)=>pe(n,t))).filter(((t,n,r,a)=>e(t,n,r,a))))),fe=ie(((e,t,n)=>me(n).reduce(((t,r,a)=>e(t,pe(a,n),a)),t))),ye=ie(((e,t)=>me(t).every(((n,r,a,i)=>e(pe(r,t),r,a,i))))),he=ie(((e,t)=>me(t).some(((n,r,a,i)=>e(pe(r,t),r,a,i)))));var ve={nil:ce,cons:(e,t="")=>Object.freeze({...ce,id:t,instance:e,value:e}),uri:e=>`${e.id}#${encodeURI(e.pointer)}`,value:me,has:(e,t)=>e in me(t),typeOf:le,step:pe,entries:e=>Object.keys(me(e)).map((t=>[t,pe(t,e)])),keys:e=>Object.keys(me(e)),map:de,filter:ue,reduce:fe,every:ye,some:he,length:e=>me(e).length},ge={},be=/; *([!#$%&'*+.^_`|~0-9A-Za-z-]+) *= *("(?:[\u000b\u0020\u0021\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u000b\u0020-\u00ff])*"|[!#$%&'*+.^_`|~0-9A-Za-z-]+) */g,$e=/^[\u000b\u0020-\u007e\u0080-\u00ff]+$/,Ie=/^[!#$%&'*+.^_`|~0-9A-Za-z-]+$/,we=/\\([\u000b\u0020-\u00ff])/g,Oe=/([\\"])/g,xe=/^[!#$%&'*+.^_`|~0-9A-Za-z-]+\/[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;function Se(e){var t=String(e);if(Ie.test(t))return t;if(t.length>0&&!$e.test(t))throw new TypeError("invalid parameter value");return'"'+t.replace(Oe,"\\$1")+'"'}function je(e){this.parameters=Object.create(null),this.type=e}ge.format=function(e){if(!e||"object"!=typeof e)throw new TypeError("argument obj is required");var t=e.parameters,n=e.type;if(!n||!xe.test(n))throw new TypeError("invalid type");var r=n;if(t&&"object"==typeof t)for(var a,i=Object.keys(t).sort(),o=0;o<i.length;o++){if(a=i[o],!Ie.test(a))throw new TypeError("invalid parameter name");r+="; "+a+"="+Se(t[a])}return r},ge.parse=function(e){if(!e)throw new TypeError("argument string is required");var t="object"==typeof e?function(e){var t;"function"==typeof e.getHeader?t=e.getHeader("content-type"):"object"==typeof e.headers&&(t=e.headers&&e.headers["content-type"]);if("string"!=typeof t)throw new TypeError("content-type header is missing from object");return t}(e):e;if("string"!=typeof t)throw new TypeError("argument string is required to be a string");var n=t.indexOf(";"),r=-1!==n?t.substr(0,n).trim():t.trim();if(!xe.test(r))throw new TypeError("invalid media type");var a=new je(r.toLowerCase());if(-1!==n){var i,o,s;for(be.lastIndex=n;o=be.exec(t);){if(o.index!==n)throw new TypeError("invalid parameter format");n+=o[0].length,i=o[1].toLowerCase(),'"'===(s=o[2])[0]&&(s=s.substr(1,s.length-2).replace(we,"$1")),a.parameters[i]=s}if(n!==t.length)throw new TypeError("invalid parameter format")}return a};var Ee=async e=>Object.entries(await e);var Pe=N((async(e,t)=>(await t).map(e)));var Ae=N((async(e,t,n)=>(await n).reduce((async(t,n)=>e(await t,n)),t)));const Ce=Ae;var Ne=N((async(e,t,n={})=>Ce((async(t,n)=>await e(n)?t.concat([n]):t),[],t,n)));const Ke=Pe;var Re=N((async(e,t)=>{const n=await Ke(e,t);return(await Promise.all(n)).some((e=>e))}));const De=Pe;var Me=N((async(e,t)=>{const n=await De(e,t);return(await Promise.all(n)).every((e=>e))}));var Te=N(((e,t)=>e.reduce((async(e,t)=>t(await e)),t)));const qe=Te,Le=Ee,ke=Ae;var Ve={entries:Ee,map:Pe,filter:Ne,reduce:Ae,some:Re,every:Me,pipeline:Te,all:e=>Promise.all(e),allValues:e=>qe([Le,ke((async(e,[t,n])=>(e[t]=await n,e)),{})],e)},Ue=fetch;const _e=ge,Je=N,ze=Ve,Fe=ee,{jsonTypeOf:Be,splitUrl:Ze,safeResolveUrl:Ge,pathRelative:We}=U,Xe=Ue,He=re,Qe={},Ye={},et=(e,t)=>{const n=e in Ye?Ye[e]:e;if(n in Qe)return Qe[n][t]},tt={},nt={},rt=(e,t="",n="")=>{e=JSON.parse(JSON.stringify(e));const r=Ze(e.$schema||n)[0];if(!r)throw Error("Couldn't determine schema version");delete e.$schema;const a=et(r,"baseToken"),i=et(r,"anchorToken"),o=Ze(t)[0];if(!o&&!Ze(e[a]||"")[0])throw Error("Couldn't determine an identifier for the schema");const s=Ge(o,e[a]||""),[c,m]=Ze(s);delete e[a],m&&a===i&&(e[i]=i!==a?encodeURI(m):`#${encodeURI(m)}`),o&&(nt[o]=c);const l={},p=et(r,"recursiveAnchorToken");let d;!0===e[p]&&(l[""]=`${c}#`,e[i]="",delete e[p]);const u=et(r,"vocabularyToken");Be(e[u],"object")?(Ye[c]=r,d=e[u],delete e[u]):(Ye[c]=r,d={[r]:!0});const f={"":""};return tt[c]={id:c,schemaVersion:r,schema:at(e,c,r,Fe.nil,f,l),anchors:f,dynamicAnchors:l,vocabulary:d,validated:!1},c},at=(e,t,n,r,a,i)=>{if(Be(e,"object")){const o="string"==typeof e.$schema?Ze(e.$schema)[0]:n,s=et(o,"embeddedToken"),c=et(o,"anchorToken");if("string"==typeof e[s]&&(s!==c||"#"!==e[s][0])){const r=Ge(t,e[s]);return e[s]=r,rt(e,r,n),He.cons(e[s],e)}const m=et(n,"anchorToken"),l=et(n,"dynamicAnchorToken");"string"==typeof e[l]&&(i[e[l]]=`${t}#${encodeURI(r)}`,a[e[l]]=r,delete e[l]);const p=et(n,"embeddedToken");if("string"==typeof e[m]){const t=m!==p?e[m]:e[m].slice(1);a[t]=r,delete e[m]}const d=et(n,"jrefToken");if("string"==typeof e[d])return He.cons(e[d],e);for(const o in e)e[o]=at(e[o],t,n,Fe.append(o,r),a,i);return e}return Array.isArray(e)?e.map(((e,o)=>at(e,t,n,Fe.append(o,r),a,i))):e},it=e=>tt[nt[e]]||tt[e],ot=Object.freeze({id:"",schemaVersion:void 0,vocabulary:{},pointer:Fe.nil,schema:void 0,value:void 0,anchors:{},dynamicAnchors:{},validated:!0}),st=async(e,t=ot)=>{const n=Ge(lt(t),e),[r,a]=Ze(n);if(!(e=>e in tt||e in nt)(r)){const e=await Xe(r,{headers:{Accept:"application/schema+json"}});if(e.status>=400)throw await e.text(),Error(`Failed to retrieve schema with id: ${r}`);if(e.headers.has("content-type")){const t=_e.parse(e.headers.get("content-type")).type;if("application/schema+json"!==t)throw Error(`${r} is not a schema. Found a document with media type: ${t}`)}rt(await e.json(),r)}const i=it(r),o="/"!==a[0]?mt(i,a):a,s=Object.freeze({...i,pointer:o,value:Fe.get(o,i.schema)});return ct(s)},ct=e=>He.isReference(e.value)?st(He.href(e.value),e):e,mt=(e,t)=>{if(!(t in e.anchors))throw Error(`No such anchor '${encodeURI(e.id)}#${encodeURI(t)}'`);return e.anchors[t]},lt=e=>`${e.id}#${encodeURI(e.pointer)}`,pt=e=>He.isReference(e.value)?He.value(e.value):e.value,dt=(e,t)=>{const n=it(t.id),r=Object.freeze({...t,pointer:Fe.append(e,t.pointer),value:pt(t)[e],validated:n.validated});return ct(r)},ut=Je(((e,t)=>ze.pipeline([pt,ze.map((async(n,r)=>e(await dt(r,t),r))),ze.all],t))),ft={parentId:"",parentDialect:"",includeEmbedded:!0},yt=(e,t)=>{if(t.startsWith("file://")){const n=e.slice(7,e.lastIndexOf("/"));return""===e?"":We(n,t.slice(7))}return t};var ht={setConfig:(e,t,n)=>{Qe[e]||(Qe[e]={}),Qe[e][t]=n},getConfig:et,add:rt,get:st,markValidated:e=>{tt[e].validated=!0},uri:lt,value:pt,getAnchorPointer:mt,typeOf:(e,t)=>Be(pt(e),t),has:(e,t)=>e in pt(t),step:dt,keys:e=>Object.keys(pt(e)),entries:e=>ze.pipeline([pt,Object.keys,ze.map((async t=>[t,await dt(t,e)])),ze.all],e),map:ut,length:e=>pt(e).length,toSchema:(e,t={})=>{const n={...ft,...t},r=JSON.parse(JSON.stringify(e.schema,((t,r)=>{if(!He.isReference(r))return r;const a=He.value(r),i=a.$schema||e.schemaVersion,o=et(i,"embeddedToken");return!n.includeEmbedded&&o in a?void 0:He.value(r)}))),a=et(e.schemaVersion,"dynamicAnchorToken");Object.entries(e.dynamicAnchors).forEach((([e,t])=>{const n=Ze(t)[1];Fe.assign(n,r,{[a]:e,...Fe.get(n,r)})}));const i=et(e.schemaVersion,"anchorToken");Object.entries(e.anchors).filter((([e])=>""!==e)).forEach((([e,t])=>{Fe.assign(t,r,{[i]:e,...Fe.get(t,r)})}));const o=et(e.schemaVersion,"baseToken"),s=yt(n.parentId,e.id),c=n.parentDialect===e.schemaVersion?"":e.schemaVersion;return{...s&&{[o]:s},...c&&{$schema:c},...r}}};class vt extends Error{constructor(e){super("Invalid Schema"),this.name=this.constructor.name,this.output=e}}var gt=vt;const bt=N,$t=K.exports,{splitUrl:It}=U,wt=ve,Ot=ht,xt=gt,St="FLAG",jt="BASIC",Et="DETAILED",Pt="VERBOSE";let At=Et,Ct=!0;const Nt=async e=>{const t={metaData:{}};return{ast:t,schemaUri:await kt(e,t)}},Kt=bt((({ast:e,schemaUri:t},n,r=St)=>{if(![St,jt,Et,Pt].includes(r))throw Error(`The '${r}' error format is not supported`);const a=[],i=$t.subscribe("result",Rt(r,a));return Ut(t,n,e,{}),$t.unsubscribe(i),a[0]})),Rt=(e,t)=>{const n=[];return(r,a)=>{if("result"===r){const{keyword:e,absoluteKeywordLocation:t,instanceLocation:r,valid:i}=a,o={keyword:e,absoluteKeywordLocation:t,instanceLocation:r,valid:i,errors:[]};n.push(o)}else if("result.start"===r)n.push(r);else if("result.end"===r){const r=n.pop();for(;"result.start"!==n[n.length-1];){const t=n.pop(),a=[t];e===jt&&(a.push(...t.errors),delete t.errors),(e===Pt||e!==St&&!t.valid)&&r.errors.unshift(...a)}n[n.length-1]=r,t[0]=r}}},Dt={},Mt=e=>Dt[e],Tt=e=>e in Dt,qt={},Lt={},kt=async(e,t)=>{if(e=await Vt(e),!Tt(`${e.schemaVersion}#validate`)){const t=await Ot.get(e.schemaVersion);(Ot.getConfig(t.id,"mandatoryVocabularies")||[]).forEach((e=>{if(!t.vocabulary[e])throw Error(`Vocabulary '${e}' must be explicitly declared and required`)})),Object.entries(t.vocabulary).forEach((([e,n])=>{if(e in qt)Object.entries(qt[e]).forEach((([e,n])=>{((e,t)=>{Dt[e]={collectEvaluatedItems:(e,n,r,a,i)=>t.interpret(e,n,r,a,i)&&new Set,collectEvaluatedProperties:(e,n,r,a,i)=>t.interpret(e,n,r,a,i)&&[],...t}})(`${t.id}#${e}`,n)}));else if(n)throw Error(`Missing required vocabulary: ${e}`)}))}if(Ct&&!e.validated){if(Ot.markValidated(e.id),!(e.schemaVersion in Lt)){const t=await Ot.get(e.schemaVersion),n=await Nt(t);Lt[t.id]=Kt(n)}const t=wt.cons(e.schema,e.id),n=Lt[e.schemaVersion](t,At);if(!n.valid)throw new xt(n)}return e.id in t.metaData||(t.metaData[e.id]={id:e.id,dynamicAnchors:e.dynamicAnchors,anchors:e.anchors}),Mt(`${e.schemaVersion}#validate`).compile(e,t)},Vt=async e=>Ot.typeOf(e,"string")?Vt(await Ot.get(Ot.value(e),e)):e,Ut=(e,t,n,r)=>{const a=_t(e,n),i=It(e)[0];return Mt(a).interpret(e,t,n,{...n.metaData[i].dynamicAnchors,...r})},_t=(e,t)=>{if(!(e in t))throw Error(`No schema found at ${e}`);return t[e][0]};var Jt={validate:async(e,t,n)=>{const r=await Nt(e),a=(e,t)=>Kt(r,wt.cons(e),t);return void 0===t?a:a(t,n)},compile:Nt,interpret:Kt,setMetaOutputFormat:e=>{At=e},setShouldMetaValidate:e=>{Ct=e},FLAG:St,BASIC:jt,DETAILED:Et,VERBOSE:Pt,add:(e,t="",n="")=>{const r=Ot.add(e,t,n);delete Lt[r]},getKeyword:Mt,hasKeyword:Tt,defineVocabulary:(e,t)=>{qt[e]=t},compileSchema:kt,interpretSchema:Ut,collectEvaluatedProperties:(e,t,n,r,a)=>{const i=_t(e,n);return Mt(i).collectEvaluatedProperties(e,t,n,r,a)},collectEvaluatedItems:(e,t,n,r,a)=>{const i=_t(e,n);return Mt(i).collectEvaluatedItems(e,t,n,r,a)}};const zt=ht;var Ft={compile:e=>zt.value(e),interpret:()=>!0};const Bt=Ve,Zt=K.exports,Gt=Jt,Wt=ve,Xt=ht;var Ht={compile:async(e,t)=>{const n=Xt.uri(e);if(!(n in t)){t[n]=!1;const r=Xt.value(e);if(!["object","boolean"].includes(typeof r))throw Error(`No schema found at '${Xt.uri(e)}'`);t[n]=[`${e.schemaVersion}#validate`,Xt.uri(e),"boolean"==typeof r?r:await Bt.pipeline([Xt.entries,Bt.map((([t,n])=>[`${e.schemaVersion}#${t}`,n])),Bt.filter((([t])=>Gt.hasKeyword(t)&&t!==`${e.schemaVersion}#validate`)),Bt.map((async([n,r])=>{const a=await Gt.getKeyword(n).compile(r,t,e);return[n,Xt.uri(r),a]})),Bt.all],e)]}return n},interpret:(e,t,n,r)=>{const[a,i,o]=n[e];Zt.publishSync("result.start");const s="boolean"==typeof o?o:o.every((([e,a,i])=>{Zt.publishSync("result.start");const o=Gt.getKeyword(e).interpret(i,t,n,r);return Zt.publishSync("result",{keyword:e,absoluteKeywordLocation:a,instanceLocation:Wt.uri(t),valid:o,ast:i}),Zt.publishSync("result.end"),o}));return Zt.publishSync("result",{keyword:a,absoluteKeywordLocation:i,instanceLocation:Wt.uri(t),valid:s,ast:e}),Zt.publishSync("result.end"),s},collectEvaluatedProperties:(e,t,n,r,a=!1)=>{const i=n[e][2];return"boolean"==typeof i?!!i&&[]:i.filter((([e])=>!a||!e.endsWith("#unevaluatedProperties"))).reduce(((e,[a,,i])=>{const o=e&&Gt.getKeyword(a).collectEvaluatedProperties(i,t,n,r);return!1!==o&&[...e,...o]}),[])},collectEvaluatedItems:(e,t,n,r,a=!1)=>{const i=n[e][2];return"boolean"==typeof i?!!i&&new Set:i.filter((([e])=>!a||!e.endsWith("#unevaluatedItems"))).reduce(((e,[a,,i])=>{const o=!1!==e&&Gt.getKeyword(a).collectEvaluatedItems(i,t,n,r);return!1!==o&&new Set([...e,...o])}),new Set)}};var Qt={Core:Jt,Schema:ht,Instance:ve,Reference:re,Keywords:{metaData:Ft,validate:Ht},InvalidSchemaError:gt};const{Core:Yt,Schema:en,Instance:tn}=Qt;var nn={compile:async(e,t,n)=>{const r=await en.step("items",n),a=en.typeOf(r,"array")?en.length(r):Number.MAX_SAFE_INTEGER;return en.typeOf(e,"boolean")?[a,en.value(e)]:[a,await Yt.compileSchema(e,t)]},interpret:([e,t],n,r,a)=>!tn.typeOf(n,"array")||("string"==typeof t?tn.every(((n,i)=>i<e||Yt.interpretSchema(t,n,r,a)),n):tn.every(((n,r)=>r<e||t),n))};const{Core:rn,Schema:an,Instance:on}=Qt,sn=([e,t],n,r,a)=>!on.typeOf(n,"array")||on.every(((n,i)=>i<e||rn.interpretSchema(t,n,r,a)),n);var cn={compile:async(e,t,n)=>{const r=await an.step("items",n);return[an.typeOf(r,"array")?an.length(r):Number.MAX_SAFE_INTEGER,await rn.compileSchema(e,t)]},interpret:sn,collectEvaluatedItems:(e,t,n,r)=>sn(e,t,n,r)&&new Set(on.map(((e,t)=>t),t))};const{Core:mn,Schema:ln,Instance:pn}=Qt;var dn={compile:async(e,t,n)=>{const r=await ln.step("properties",n),a=ln.typeOf(r,"object")?ln.keys(r):[],i=await ln.step("patternProperties",n),o=ln.typeOf(i,"object")?ln.keys(i).map((e=>new RegExp(e))):[];return ln.typeOf(e,"boolean")?[a,o,ln.value(e)]:[a,o,await mn.compileSchema(e,t)]},interpret:([e,t,n],r,a,i)=>{if(!pn.typeOf(r,"object"))return!0;const o=pn.entries(r).filter((([n])=>!e.includes(n)&&!t.some((e=>e.test(n)))));return"string"==typeof n?o.every((([,e])=>mn.interpretSchema(n,e,a,i))):0===o.length||n}};const{Core:un,Schema:fn,Instance:yn}=Qt,hn=([e,t,n],r,a,i)=>!yn.typeOf(r,"object")||yn.entries(r).filter((([n])=>!e.includes(n)&&!t.some((e=>e.test(n))))).every((([,e])=>un.interpretSchema(n,e,a,i)));var vn={compile:async(e,t,n)=>{const r=await fn.step("properties",n),a=fn.typeOf(r,"object")?fn.keys(r):[],i=await fn.step("patternProperties",n),o=fn.typeOf(i,"object")?fn.keys(i).map((e=>new RegExp(e))):[];return[a,o,await un.compileSchema(e,t)]},interpret:hn,collectEvaluatedProperties:(e,t,n,r)=>hn(e,t,n,r)&&[new RegExp("")]};const{Core:gn,Schema:bn}=Qt,$n=Ve;var In={compile:(e,t)=>$n.pipeline([bn.map((async e=>gn.compileSchema(await e,t))),$n.all],e),interpret:(e,t,n,r)=>e.every((e=>gn.interpretSchema(e,t,n,r))),collectEvaluatedProperties:(e,t,n,r)=>e.reduce(((e,a)=>{const i=e&&gn.collectEvaluatedProperties(a,t,n,r);return!1!==i&&[...e,...i]}),[]),collectEvaluatedItems:(e,t,n,r)=>e.reduce(((e,a)=>{const i=!1!==e&&gn.collectEvaluatedItems(a,t,n,r);return!1!==i&&new Set([...e,...i])}),new Set)};const{Core:wn,Schema:On}=Qt,xn=Ve;var Sn={compile:(e,t)=>xn.pipeline([On.map((async e=>wn.compileSchema(await e,t))),xn.all],e),interpret:(e,t,n,r)=>e.filter((e=>wn.interpretSchema(e,t,n,r))).length>0,collectEvaluatedProperties:(e,t,n,r)=>e.reduce(((e,a)=>{const i=wn.collectEvaluatedProperties(a,t,n,r);return!1!==i?[...e||[],...i]:e}),!1),collectEvaluatedItems:(e,t,n,r)=>e.reduce(((e,a)=>{const i=wn.collectEvaluatedItems(a,t,n,r);return!1!==i?new Set([...e||[],...i]):e}),!1)},jn=Object.keys,En=JSON.stringify;function Pn(e,t){var n,r,a,i,o,s,c;if("string"===(c=typeof e))return En(e);if(!0===e)return"true";if(!1===e)return"false";if(null===e)return"null";if(e instanceof Array){for(a="[",r=e.length-1,n=0;n<r;n++)a+=Pn(e[n],!1)+",";return r>-1&&(a+=Pn(e[n],!1)),a+"]"}if(e instanceof Object){if("function"==typeof e.toJSON)return Pn(e.toJSON(),t);for(r=(i=jn(e).sort()).length,a="",n=0;n<r;)void 0!==(s=Pn(e[o=i[n]],!0))&&(n&&""!==a&&(a+=","),a+=En(o)+":"+s),n++;return"{"+a+"}"}switch(c){case"function":case"undefined":return t?void 0:null;default:return isFinite(e)?e:null}}var An=function(e){return""+Pn(e,!1)};const{Schema:Cn,Instance:Nn}=Qt,Kn=An;var Rn={compile:e=>Kn(Cn.value(e)),interpret:(e,t)=>Kn(Nn.value(t))===e};const{Core:Dn,Instance:Mn}=Qt;var Tn={compile:(e,t)=>Dn.compileSchema(e,t),interpret:(e,t,n,r)=>!Mn.typeOf(t,"array")||Mn.some((t=>Dn.interpretSchema(e,t,n,r)),t)};const{Core:qn,Schema:Ln,Instance:kn}=Qt,Vn=({contains:e,minContains:t,maxContains:n},r,a,i)=>{if(!kn.typeOf(r,"array"))return!0;const o=kn.reduce(((t,n)=>qn.interpretSchema(e,n,a,i)?t+1:t),0,r);return o>=t&&o<=n};var Un={compile:async(e,t,n)=>{const r=await qn.compileSchema(e,t),a=await Ln.step("minContains",n),i=Ln.typeOf(a,"number")?Ln.value(a):1,o=await Ln.step("maxContains",n);return{contains:r,minContains:i,maxContains:Ln.typeOf(o,"number")?Ln.value(o):Number.MAX_SAFE_INTEGER}},interpret:Vn,collectEvaluatedItems:(e,t,n,r)=>Vn(e,t,n,r)&&kn.reduce(((t,a,i)=>qn.interpretSchema(e.contains,a,n,r)?t.add(i):t),new Set,t)};const{Core:_n,Schema:Jn}=Qt,zn=Ve;var Fn={compile:async(e,t)=>{await zn.pipeline([Jn.entries,zn.map((([,e])=>_n.compileSchema(e,t))),zn.all],e)},interpret:()=>!0};const{Core:Bn,Schema:Zn,Instance:Gn}=Qt,Wn=Ve;var Xn={compile:(e,t)=>Wn.pipeline([Zn.entries,Wn.map((async([e,n])=>[e,Zn.typeOf(n,"array")?Zn.value(n):await Bn.compileSchema(n,t)])),Wn.all],e),interpret:(e,t,n,r)=>{const a=Gn.value(t);return!Gn.typeOf(t,"object")||e.every((([e,i])=>!(e in a)||(Array.isArray(i)?i.every((e=>e in a)):Bn.interpretSchema(i,t,n,r))))}};const{Schema:Hn,Instance:Qn}=Qt,Yn=Ve;var er={compile:e=>Yn.pipeline([Hn.entries,Yn.map((([e,t])=>[e,Hn.value(t)])),Yn.all],e),interpret:(e,t)=>{const n=Qn.value(t);return!Qn.typeOf(t,"object")||e.every((([e,t])=>!(e in n)||t.every((e=>e in n))))}};const{Core:tr,Schema:nr,Instance:rr}=Qt,ar=Ve;var ir={compile:(e,t)=>ar.pipeline([nr.entries,ar.map((async([e,n])=>[e,await tr.compileSchema(n,t)])),ar.all],e),interpret:(e,t,n,r)=>{const a=rr.value(t);return!rr.typeOf(t,"object")||e.every((([e,i])=>!(e in a)||tr.interpretSchema(i,t,n,r)))},collectEvaluatedProperties:(e,t,n,r)=>e.reduce(((e,[a,i])=>{if(!e||!rr.has(a,t))return e;const o=tr.collectEvaluatedProperties(i,t,n,r);return!1!==o&&e.concat(o)}),[])};const{Schema:or,Instance:sr}=Qt,cr=An;var mr={compile:e=>or.value(e).map(cr),interpret:(e,t)=>e.some((e=>cr(sr.value(t))===e))};const{Schema:lr,Instance:pr}=Qt;var dr={compile:async e=>lr.value(e),interpret:(e,t)=>!pr.typeOf(t,"number")||pr.value(t)<e};const{Schema:ur,Instance:fr}=Qt;var yr={compile:async e=>ur.value(e),interpret:(e,t)=>!fr.typeOf(t,"number")||fr.value(t)>e};const{Core:hr}=Qt;var vr={compile:(e,t)=>hr.compileSchema(e,t),interpret:(e,t,n,r)=>(hr.interpretSchema(e,t,n,r),!0),collectEvaluatedProperties:(e,t,n,r)=>hr.collectEvaluatedProperties(e,t,n,r)||[],collectEvaluatedItems:(e,t,n,r)=>hr.collectEvaluatedItems(e,t,n,r)||new Set};const{Core:gr,Schema:br}=Qt,$r=(e,t,n,r)=>{const a=n[e][2];return"boolean"==typeof a?a:a.every((([e,,a])=>gr.getKeyword(e).interpret(a,t,n,r)))};var Ir={compile:async(e,t,n)=>{if(br.has("if",n)){const r=await br.step("if",n);return[await gr.compileSchema(r,t),await gr.compileSchema(e,t)]}return[]},interpret:([e,t],n,r,a)=>void 0===e||!$r(e,n,r,a)||gr.interpretSchema(t,n,r,a),collectEvaluatedProperties:([e,t],n,r,a)=>void 0!==e&&$r(e,n,r,a)?gr.collectEvaluatedProperties(t,n,r,a):[],collectEvaluatedItems:([e,t],n,r,a)=>void 0!==e&&$r(e,n,r,a)?gr.collectEvaluatedItems(t,n,r,a):new Set};const{Core:wr,Schema:Or}=Qt,xr=(e,t,n,r)=>{const a=n[e][2];return"boolean"==typeof a?a:a.every((([e,,a])=>wr.getKeyword(e).interpret(a,t,n,r)))};var Sr={compile:async(e,t,n)=>{if(Or.has("if",n)){const r=await Or.step("if",n);return[await wr.compileSchema(r,t),await wr.compileSchema(e,t)]}return[]},interpret:([e,t],n,r,a)=>void 0===e||xr(e,n,r,a)||wr.interpretSchema(t,n,r,a),collectEvaluatedProperties:([e,t],n,r,a)=>void 0===e||xr(e,n,r,a)?[]:wr.collectEvaluatedProperties(t,n,r,a),collectEvaluatedItems:([e,t],n,r,a)=>void 0===e||xr(e,n,r,a)?new Set:wr.collectEvaluatedItems(t,n,r,a)};const{Core:jr,Schema:Er,Instance:Pr}=Qt,Ar=(e,t,n,r)=>!Pr.typeOf(t,"array")||("string"==typeof e?Pr.every((t=>jr.interpretSchema(e,t,n,r)),t):Pr.every(((t,a)=>!(a in e)||jr.interpretSchema(e[a],t,n,r)),t));var Cr={compile:async(e,t)=>{if(Er.typeOf(e,"array")){const n=await Er.map((e=>jr.compileSchema(e,t)),e);return Promise.all(n)}return jr.compileSchema(e,t)},interpret:Ar,collectEvaluatedItems:(e,t,n,r)=>Ar(e,t,n,r)&&("string"==typeof e?new Set(Pr.map(((e,t)=>t),t)):new Set(e.map(((e,t)=>t))))};const{Core:Nr,Schema:Kr,Instance:Rr}=Qt,Dr=([e,t],n,r,a)=>!Rr.typeOf(n,"array")||Rr.every(((n,i)=>i<e||Nr.interpretSchema(t,n,r,a)),n);var Mr={compile:async(e,t,n)=>{const r=await Kr.step("prefixItems",n);return[Kr.typeOf(r,"array")?Kr.length(r):0,await Nr.compileSchema(e,t)]},interpret:Dr,collectEvaluatedItems:(e,t,n,r)=>Dr(e,t,n,r)&&new Set(Rr.map(((e,t)=>t),t))};const{Schema:Tr,Instance:qr}=Qt;var Lr={compile:e=>Tr.value(e),interpret:(e,t)=>!qr.typeOf(t,"array")||qr.length(t)<=e};const{Schema:kr,Instance:Vr}=Qt;var Ur={compile:e=>kr.value(e),interpret:(e,t)=>!Vr.typeOf(t,"string")||Vr.length(t)<=e};const{Schema:_r,Instance:Jr}=Qt;var zr={compile:e=>_r.value(e),interpret:(e,t)=>!Jr.typeOf(t,"string")||[...Jr.value(t)].length<=e};const{Schema:Fr,Instance:Br}=Qt;var Zr={compile:e=>Fr.value(e),interpret:(e,t)=>!Br.typeOf(t,"object")||Br.keys(t).length<=e};const{Schema:Gr,Instance:Wr}=Qt;var Xr={compile:async(e,t,n)=>{const r=await Gr.step("exclusiveMaximum",n),a=Gr.value(r);return[Gr.value(e),a]},interpret:([e,t],n)=>{if(!Wr.typeOf(n,"number"))return!0;const r=Wr.value(n);return t?r<e:r<=e}};const{Schema:Hr,Instance:Qr}=Qt;var Yr={compile:async e=>Hr.value(e),interpret:(e,t)=>!Qr.typeOf(t,"number")||Qr.value(t)<=e};const{Schema:ea,Instance:ta}=Qt;var na={compile:e=>ea.value(e),interpret:(e,t)=>!ta.typeOf(t,"array")||ta.length(t)>=e};const{Schema:ra,Instance:aa}=Qt;var ia={compile:e=>ra.value(e),interpret:(e,t)=>!aa.typeOf(t,"string")||aa.length(t)>=e};const{Schema:oa,Instance:sa}=Qt;var ca={compile:e=>oa.value(e),interpret:(e,t)=>!sa.typeOf(t,"string")||[...sa.value(t)].length>=e};const{Schema:ma,Instance:la}=Qt;var pa={compile:e=>ma.value(e),interpret:(e,t)=>!la.typeOf(t,"object")||la.keys(t).length>=e};const{Schema:da,Instance:ua}=Qt;var fa={compile:async(e,t,n)=>{const r=await da.step("exclusiveMinimum",n),a=da.value(r);return[da.value(e),a]},interpret:([e,t],n)=>{if(!ua.typeOf(n,"number"))return!0;const r=ua.value(n);return t?r>e:r>=e}};const{Schema:ya,Instance:ha}=Qt;var va={compile:async e=>ya.value(e),interpret:(e,t)=>!ha.typeOf(t,"number")||ha.value(t)>=e};const{Schema:ga,Instance:ba}=Qt,$a=(e,t)=>Math.abs(e-t)<1.1920929e-7;var Ia={compile:e=>ga.value(e),interpret:(e,t)=>{if(!ba.typeOf(t,"number"))return!0;const n=ba.value(t)%e;return $a(0,n)||$a(e,n)}};const{Core:wa}=Qt;var Oa={compile:wa.compileSchema,interpret:(e,t,n,r)=>!wa.interpretSchema(e,t,n,r)};const{Core:xa,Schema:Sa}=Qt;var ja={compile:async(e,t)=>{const n=await Sa.map((e=>xa.compileSchema(e,t)),e);return Promise.all(n)},interpret:(e,t,n,r)=>{let a=0;for(const i of e)if(xa.interpretSchema(i,t,n,r)&&a++,a>1)break;return 1===a},collectEvaluatedProperties:(e,t,n,r)=>{let a=0;return e.reduce(((e,i)=>{if(a>1)return!1;const o=xa.collectEvaluatedProperties(i,t,n,r);return o?0==a++&&o:e}),!1)},collectEvaluatedItems:(e,t,n,r)=>{let a=0;return e.reduce(((e,i)=>{if(a>1)return!1;const o=xa.collectEvaluatedItems(i,t,n,r);return o?0==a++&&o:e}),!1)}};const{Schema:Ea,Instance:Pa}=Qt;var Aa={compile:e=>new RegExp(Ea.value(e),"u"),interpret:(e,t)=>!Pa.typeOf(t,"string")||e.test(Pa.value(t))};const{Core:Ca,Schema:Na,Instance:Ka}=Qt,Ra=Ve,Da=(e,t,n,r)=>!Ka.typeOf(t,"object")||e.every((([e,a])=>Ka.entries(t).filter((([t])=>e.test(t))).every((([,e])=>Ca.interpretSchema(a,e,n,r)))));var Ma={compile:(e,t)=>Ra.pipeline([Na.entries,Ra.map((async([e,n])=>[new RegExp(e,"u"),await Ca.compileSchema(n,t)])),Ra.all],e),interpret:Da,collectEvaluatedProperties:(e,t,n,r)=>Da(e,t,n,r)&&e.map((([e])=>e))};var Ta={isObject:e=>"object"==typeof e&&!Array.isArray(e)&&null!==e,escapeRegExp:e=>e.replace(/[.*+\-?^${}()|[\]\\]/g,"\\$&"),splitUrl:e=>{const t=e.indexOf("#"),n=-1===t?e.length:t,r=e.slice(0,n),a=e.slice(n+1);return[decodeURI(r),decodeURI(a)]}};const{Core:qa,Schema:La,Instance:ka}=Qt,Va=Ve,{escapeRegExp:Ua}=Ta,_a=(e,t,n,r)=>!ka.typeOf(t,"object")||ka.entries(t).filter((([t])=>t in e)).every((([t,a])=>qa.interpretSchema(e[t],a,n,r)));var Ja={compile:(e,t)=>Va.pipeline([La.entries,Va.reduce((async(e,[n,r])=>(e[n]=await qa.compileSchema(r,t),e)),Object.create(null))],e),interpret:_a,collectEvaluatedProperties:(e,t,n,r)=>_a(e,t,n,r)&&Object.keys(e).map((e=>new RegExp(`^${Ua(e)}$`)))};const{Core:za,Instance:Fa}=Qt;var Ba={compile:(e,t)=>za.compileSchema(e,t),interpret:(e,t,n,r)=>!Fa.typeOf(t,"object")||Fa.keys(t).every((t=>za.interpretSchema(e,Fa.cons(t),n,r)))};const{Core:Za,Schema:Ga}=Qt,{splitUrl:Wa}=Ta;var Xa={compile:async(e,t)=>{const[,n]=Wa(Ga.value(e)),r=await Ga.get(Ga.value(e),e);return await Za.compileSchema(r,t),[r.id,n]},interpret:([e,t],n,r,a)=>{if(t in r.metaData[e].dynamicAnchors)return Za.interpretSchema(a[t],n,r,a);{const i=Ga.getAnchorPointer(r.metaData[e],t);return Za.interpretSchema(`${e}#${encodeURI(i)}`,n,r,a)}},collectEvaluatedProperties:Za.collectEvaluatedProperties,collectEvaluatedItems:Za.collectEvaluatedItems};const{Core:Ha,Schema:Qa}=Qt;var Ya={compile:async(e,t)=>{const n=await Qa.get(Qa.value(e),e);return Ha.compileSchema(n,t)},interpret:Ha.interpretSchema,collectEvaluatedProperties:Ha.collectEvaluatedProperties,collectEvaluatedItems:Ha.collectEvaluatedItems};const{Schema:ei,Instance:ti}=Qt;var ni={compile:e=>ei.value(e),interpret:(e,t)=>!ti.typeOf(t,"object")||e.every((e=>Object.prototype.hasOwnProperty.call(ti.value(t),e)))};const{Core:ri,Schema:ai,Instance:ii}=Qt,oi=Ve,si=(e,t,n,r)=>!ii.typeOf(t,"array")||ii.every(((t,a)=>!(a in e)||ri.interpretSchema(e[a],t,n,r)),t);var ci={compile:(e,t)=>oi.pipeline([ai.map((e=>ri.compileSchema(e,t))),oi.all],e),interpret:si,collectEvaluatedItems:(e,t,n,r)=>si(e,t,n,r)&&new Set(e.map(((e,t)=>t)))};const{Schema:mi,Instance:li}=Qt;var pi={compile:e=>mi.value(e),interpret:(e,t)=>"string"==typeof e?li.typeOf(t,e):e.some(li.typeOf(t))};const{Core:di,Schema:ui,Instance:fi}=Qt,yi=([e,t],n,r,a)=>{if(!fi.typeOf(n,"array"))return!0;const i=di.collectEvaluatedItems(e,n,r,a,!0);return!1===i||fi.every(((e,o)=>i.has(o)||di.interpretSchema(t,fi.step(o,n),r,a)),n)};var hi={compile:async(e,t,n)=>[ui.uri(n),await di.compileSchema(e,t)],interpret:yi,collectEvaluatedItems:(e,t,n,r)=>yi(e,t,n,r)&&new Set(fi.map(((e,t)=>t),t))};const{Core:vi,Schema:gi,Instance:bi}=Qt,$i=([e,t],n,r,a)=>{if(!bi.typeOf(n,"object"))return!0;const i=vi.collectEvaluatedProperties(e,n,r,a,!0);return!i||bi.entries(n).filter((([e])=>!i.some((t=>e.match(t))))).every((([,e])=>vi.interpretSchema(t,e,r,a)))};var Ii={compile:async(e,t,n)=>[gi.uri(n),await vi.compileSchema(e,t)],interpret:$i,collectEvaluatedProperties:(e,t,n,r)=>$i(e,t,n,r)&&[new RegExp("")]};const{Schema:wi,Instance:Oi}=Qt,xi=An;var Si={compile:e=>wi.value(e),interpret:(e,t)=>{if(!Oi.typeOf(t,"array")||!1===e)return!0;const n=Oi.map((e=>xi(Oi.value(e))),t);return new Set(n).size===n.length}};const{Keywords:ji}=Qt;var Ei={additionalItems:nn,additionalItems6:cn,additionalProperties:dn,additionalProperties6:vn,allOf:In,anyOf:Sn,const:Rn,contains:Tn,containsMinContainsMaxContains:Un,definitions:Fn,dependencies:Xn,dependentRequired:er,dependentSchemas:ir,enum:mr,exclusiveMaximum:dr,exclusiveMinimum:yr,if:vr,then:Ir,else:Sr,items:Cr,items202012:Mr,maxItems:Lr,maxLength:Ur,maxLength6:zr,maxProperties:Zr,maximumExclusiveMaximum:Xr,maximum:Yr,metaData:ji.metaData,minItems:na,minLength:ia,minLength6:ca,minProperties:pa,minimumExclusiveMinimum:fa,minimum:va,multipleOf:Ia,not:Oa,oneOf:ja,pattern:Aa,patternProperties:Ma,properties:Ja,propertyNames:Ba,dynamicRef:Xa,ref:Ya,required:ni,tupleItems:ci,type:pi,unevaluatedItems:hi,unevaluatedProperties:Ii,uniqueItems:Si,validate:ji.validate};const{Core:Pi,Schema:Ai}=Qt,Ci=Ei,Ni="http://json-schema.org/draft-04/schema";Ai.setConfig(Ni,"baseToken","id"),Ai.setConfig(Ni,"embeddedToken","id"),Ai.setConfig(Ni,"anchorToken","id"),Ai.setConfig(Ni,"jrefToken","$ref"),Ai.add(JSON.parse('{\n    "id": "http://json-schema.org/draft-04/schema#",\n    "$schema": "http://json-schema.org/draft-04/schema#",\n    "description": "Core schema meta-schema",\n    "definitions": {\n        "schemaArray": {\n            "type": "array",\n            "minItems": 1,\n            "items": { "$ref": "#" }\n        },\n        "positiveInteger": {\n            "type": "integer",\n            "minimum": 0\n        },\n        "positiveIntegerDefault0": {\n            "allOf": [ { "$ref": "#/definitions/positiveInteger" }, { "default": 0 } ]\n        },\n        "simpleTypes": {\n            "enum": [ "array", "boolean", "integer", "null", "number", "object", "string" ]\n        },\n        "stringArray": {\n            "type": "array",\n            "items": { "type": "string" },\n            "minItems": 1,\n            "uniqueItems": true\n        }\n    },\n    "type": "object",\n    "properties": {\n        "id": {\n            "type": "string"\n        },\n        "$schema": {\n            "type": "string"\n        },\n        "title": {\n            "type": "string"\n        },\n        "description": {\n            "type": "string"\n        },\n        "default": {},\n        "multipleOf": {\n            "type": "number",\n            "minimum": 0,\n            "exclusiveMinimum": true\n        },\n        "maximum": {\n            "type": "number"\n        },\n        "exclusiveMaximum": {\n            "type": "boolean",\n            "default": false\n        },\n        "minimum": {\n            "type": "number"\n        },\n        "exclusiveMinimum": {\n            "type": "boolean",\n            "default": false\n        },\n        "maxLength": { "$ref": "#/definitions/positiveInteger" },\n        "minLength": { "$ref": "#/definitions/positiveIntegerDefault0" },\n        "pattern": {\n            "type": "string",\n            "format": "regex"\n        },\n        "additionalItems": {\n            "anyOf": [\n                { "type": "boolean" },\n                { "$ref": "#" }\n            ],\n            "default": {}\n        },\n        "items": {\n            "anyOf": [\n                { "$ref": "#" },\n                { "$ref": "#/definitions/schemaArray" }\n            ],\n            "default": {}\n        },\n        "maxItems": { "$ref": "#/definitions/positiveInteger" },\n        "minItems": { "$ref": "#/definitions/positiveIntegerDefault0" },\n        "uniqueItems": {\n            "type": "boolean",\n            "default": false\n        },\n        "maxProperties": { "$ref": "#/definitions/positiveInteger" },\n        "minProperties": { "$ref": "#/definitions/positiveIntegerDefault0" },\n        "required": { "$ref": "#/definitions/stringArray" },\n        "additionalProperties": {\n            "anyOf": [\n                { "type": "boolean" },\n                { "$ref": "#" }\n            ],\n            "default": {}\n        },\n        "definitions": {\n            "type": "object",\n            "additionalProperties": { "$ref": "#" },\n            "default": {}\n        },\n        "properties": {\n            "type": "object",\n            "additionalProperties": { "$ref": "#" },\n            "default": {}\n        },\n        "patternProperties": {\n            "type": "object",\n            "additionalProperties": { "$ref": "#" },\n            "default": {}\n        },\n        "dependencies": {\n            "type": "object",\n            "additionalProperties": {\n                "anyOf": [\n                    { "$ref": "#" },\n                    { "$ref": "#/definitions/stringArray" }\n                ]\n            }\n        },\n        "enum": {\n            "type": "array",\n            "minItems": 1,\n            "uniqueItems": true\n        },\n        "type": {\n            "anyOf": [\n                { "$ref": "#/definitions/simpleTypes" },\n                {\n                    "type": "array",\n                    "items": { "$ref": "#/definitions/simpleTypes" },\n                    "minItems": 1,\n                    "uniqueItems": true\n                }\n            ]\n        },\n        "format": { "type": "string" },\n        "allOf": { "$ref": "#/definitions/schemaArray" },\n        "anyOf": { "$ref": "#/definitions/schemaArray" },\n        "oneOf": { "$ref": "#/definitions/schemaArray" },\n        "not": { "$ref": "#" }\n    },\n    "dependencies": {\n        "exclusiveMaximum": [ "maximum" ],\n        "exclusiveMinimum": [ "minimum" ]\n    },\n    "default": {}\n}')),Pi.defineVocabulary(Ni,{validate:Ci.validate,additionalItems:Ci.additionalItems,additionalProperties:Ci.additionalProperties,allOf:Ci.allOf,anyOf:Ci.anyOf,default:Ci.metaData,definitions:Ci.definitions,dependencies:Ci.dependencies,description:Ci.metaData,enum:Ci.enum,format:Ci.metaData,items:Ci.items,maxItems:Ci.maxItems,maxLength:Ci.maxLength,maxProperties:Ci.maxProperties,maximum:Ci.maximumExclusiveMaximum,minItems:Ci.minItems,minLength:Ci.minLength,minProperties:Ci.minProperties,minimum:Ci.minimumExclusiveMinimum,multipleOf:Ci.multipleOf,not:Ci.not,oneOf:Ci.oneOf,pattern:Ci.pattern,patternProperties:Ci.patternProperties,properties:Ci.properties,required:Ci.required,title:Ci.metaData,type:Ci.type,uniqueItems:Ci.uniqueItems});const{Core:Ki,Schema:Ri}=Qt,Di=Ei,Mi="http://json-schema.org/draft-06/schema";Ri.setConfig(Mi,"baseToken","$id"),Ri.setConfig(Mi,"embeddedToken","$id"),Ri.setConfig(Mi,"anchorToken","$id"),Ri.setConfig(Mi,"jrefToken","$ref"),Ri.add(JSON.parse('{\n    "$schema": "http://json-schema.org/draft-06/schema#",\n    "$id": "http://json-schema.org/draft-06/schema#",\n    "title": "Core schema meta-schema",\n    "definitions": {\n        "schemaArray": {\n            "type": "array",\n            "minItems": 1,\n            "items": { "$ref": "#" }\n        },\n        "nonNegativeInteger": {\n            "type": "integer",\n            "minimum": 0\n        },\n        "nonNegativeIntegerDefault0": {\n            "allOf": [\n                { "$ref": "#/definitions/nonNegativeInteger" },\n                { "default": 0 }\n            ]\n        },\n        "simpleTypes": {\n            "enum": [\n                "array",\n                "boolean",\n                "integer",\n                "null",\n                "number",\n                "object",\n                "string"\n            ]\n        },\n        "stringArray": {\n            "type": "array",\n            "items": { "type": "string" },\n            "uniqueItems": true,\n            "default": []\n        }\n    },\n    "type": ["object", "boolean"],\n    "properties": {\n        "$id": {\n            "type": "string",\n            "format": "uri-reference"\n        },\n        "$schema": {\n            "type": "string",\n            "format": "uri"\n        },\n        "$ref": {\n            "type": "string",\n            "format": "uri-reference"\n        },\n        "title": {\n            "type": "string"\n        },\n        "description": {\n            "type": "string"\n        },\n        "default": {},\n        "examples": {\n            "type": "array",\n            "items": {}\n        },\n        "multipleOf": {\n            "type": "number",\n            "exclusiveMinimum": 0\n        },\n        "maximum": {\n            "type": "number"\n        },\n        "exclusiveMaximum": {\n            "type": "number"\n        },\n        "minimum": {\n            "type": "number"\n        },\n        "exclusiveMinimum": {\n            "type": "number"\n        },\n        "maxLength": { "$ref": "#/definitions/nonNegativeInteger" },\n        "minLength": { "$ref": "#/definitions/nonNegativeIntegerDefault0" },\n        "pattern": {\n            "type": "string",\n            "format": "regex"\n        },\n        "additionalItems": { "$ref": "#" },\n        "items": {\n            "anyOf": [\n                { "$ref": "#" },\n                { "$ref": "#/definitions/schemaArray" }\n            ],\n            "default": {}\n        },\n        "maxItems": { "$ref": "#/definitions/nonNegativeInteger" },\n        "minItems": { "$ref": "#/definitions/nonNegativeIntegerDefault0" },\n        "uniqueItems": {\n            "type": "boolean",\n            "default": false\n        },\n        "contains": { "$ref": "#" },\n        "maxProperties": { "$ref": "#/definitions/nonNegativeInteger" },\n        "minProperties": { "$ref": "#/definitions/nonNegativeIntegerDefault0" },\n        "required": { "$ref": "#/definitions/stringArray" },\n        "additionalProperties": { "$ref": "#" },\n        "definitions": {\n            "type": "object",\n            "additionalProperties": { "$ref": "#" },\n            "default": {}\n        },\n        "properties": {\n            "type": "object",\n            "additionalProperties": { "$ref": "#" },\n            "default": {}\n        },\n        "patternProperties": {\n            "type": "object",\n            "additionalProperties": { "$ref": "#" },\n            "default": {}\n        },\n        "dependencies": {\n            "type": "object",\n            "additionalProperties": {\n                "anyOf": [\n                    { "$ref": "#" },\n                    { "$ref": "#/definitions/stringArray" }\n                ]\n            }\n        },\n        "propertyNames": { "$ref": "#" },\n        "const": {},\n        "enum": {\n            "type": "array",\n            "minItems": 1,\n            "uniqueItems": true\n        },\n        "type": {\n            "anyOf": [\n                { "$ref": "#/definitions/simpleTypes" },\n                {\n                    "type": "array",\n                    "items": { "$ref": "#/definitions/simpleTypes" },\n                    "minItems": 1,\n                    "uniqueItems": true\n                }\n            ]\n        },\n        "format": { "type": "string" },\n        "allOf": { "$ref": "#/definitions/schemaArray" },\n        "anyOf": { "$ref": "#/definitions/schemaArray" },\n        "oneOf": { "$ref": "#/definitions/schemaArray" },\n        "not": { "$ref": "#" }\n    },\n    "default": {}\n}')),Ki.defineVocabulary(Mi,{validate:Di.validate,additionalItems:Di.additionalItems6,additionalProperties:Di.additionalProperties6,allOf:Di.allOf,anyOf:Di.anyOf,const:Di.const,contains:Di.contains,default:Di.metaData,definitions:Di.definitions,dependencies:Di.dependencies,description:Di.metaData,enum:Di.enum,examples:Di.metaData,exclusiveMaximum:Di.exclusiveMaximum,exclusiveMinimum:Di.exclusiveMinimum,format:Di.metaData,items:Di.items,maxItems:Di.maxItems,maxLength:Di.maxLength6,maxProperties:Di.maxProperties,maximum:Di.maximum,minItems:Di.minItems,minLength:Di.minLength6,minProperties:Di.minProperties,minimum:Di.minimum,multipleOf:Di.multipleOf,not:Di.not,oneOf:Di.oneOf,pattern:Di.pattern,patternProperties:Di.patternProperties,properties:Di.properties,propertyNames:Di.propertyNames,required:Di.required,title:Di.metaData,type:Di.type,uniqueItems:Di.uniqueItems});const{Core:Ti,Schema:qi}=Qt,Li=Ei,ki="http://json-schema.org/draft-07/schema";qi.setConfig(ki,"baseToken","$id"),qi.setConfig(ki,"embeddedToken","$id"),qi.setConfig(ki,"anchorToken","$id"),qi.setConfig(ki,"jrefToken","$ref"),qi.add(JSON.parse('{\n    "$schema": "http://json-schema.org/draft-07/schema#",\n    "$id": "http://json-schema.org/draft-07/schema#",\n    "title": "Core schema meta-schema",\n    "definitions": {\n        "schemaArray": {\n            "type": "array",\n            "minItems": 1,\n            "items": { "$ref": "#" }\n        },\n        "nonNegativeInteger": {\n            "type": "integer",\n            "minimum": 0\n        },\n        "nonNegativeIntegerDefault0": {\n            "allOf": [\n                { "$ref": "#/definitions/nonNegativeInteger" },\n                { "default": 0 }\n            ]\n        },\n        "simpleTypes": {\n            "enum": [\n                "array",\n                "boolean",\n                "integer",\n                "null",\n                "number",\n                "object",\n                "string"\n            ]\n        },\n        "stringArray": {\n            "type": "array",\n            "items": { "type": "string" },\n            "uniqueItems": true,\n            "default": []\n        }\n    },\n    "type": ["object", "boolean"],\n    "properties": {\n        "$id": {\n            "type": "string",\n            "format": "uri-reference"\n        },\n        "$schema": {\n            "type": "string",\n            "format": "uri"\n        },\n        "$ref": {\n            "type": "string",\n            "format": "uri-reference"\n        },\n        "$comment": {\n            "type": "string"\n        },\n        "title": {\n            "type": "string"\n        },\n        "description": {\n            "type": "string"\n        },\n        "default": true,\n        "readOnly": {\n            "type": "boolean",\n            "default": false\n        },\n        "writeOnly": {\n            "type": "boolean",\n            "default": false\n        },\n        "examples": {\n            "type": "array",\n            "items": true\n        },\n        "multipleOf": {\n            "type": "number",\n            "exclusiveMinimum": 0\n        },\n        "maximum": {\n            "type": "number"\n        },\n        "exclusiveMaximum": {\n            "type": "number"\n        },\n        "minimum": {\n            "type": "number"\n        },\n        "exclusiveMinimum": {\n            "type": "number"\n        },\n        "maxLength": { "$ref": "#/definitions/nonNegativeInteger" },\n        "minLength": { "$ref": "#/definitions/nonNegativeIntegerDefault0" },\n        "pattern": {\n            "type": "string",\n            "format": "regex"\n        },\n        "additionalItems": { "$ref": "#" },\n        "items": {\n            "anyOf": [\n                { "$ref": "#" },\n                { "$ref": "#/definitions/schemaArray" }\n            ],\n            "default": true\n        },\n        "maxItems": { "$ref": "#/definitions/nonNegativeInteger" },\n        "minItems": { "$ref": "#/definitions/nonNegativeIntegerDefault0" },\n        "uniqueItems": {\n            "type": "boolean",\n            "default": false\n        },\n        "contains": { "$ref": "#" },\n        "maxProperties": { "$ref": "#/definitions/nonNegativeInteger" },\n        "minProperties": { "$ref": "#/definitions/nonNegativeIntegerDefault0" },\n        "required": { "$ref": "#/definitions/stringArray" },\n        "additionalProperties": { "$ref": "#" },\n        "definitions": {\n            "type": "object",\n            "additionalProperties": { "$ref": "#" },\n            "default": {}\n        },\n        "properties": {\n            "type": "object",\n            "additionalProperties": { "$ref": "#" },\n            "default": {}\n        },\n        "patternProperties": {\n            "type": "object",\n            "additionalProperties": { "$ref": "#" },\n            "propertyNames": { "format": "regex" },\n            "default": {}\n        },\n        "dependencies": {\n            "type": "object",\n            "additionalProperties": {\n                "anyOf": [\n                    { "$ref": "#" },\n                    { "$ref": "#/definitions/stringArray" }\n                ]\n            }\n        },\n        "propertyNames": { "$ref": "#" },\n        "const": true,\n        "enum": {\n            "type": "array",\n            "items": true,\n            "minItems": 1,\n            "uniqueItems": true\n        },\n        "type": {\n            "anyOf": [\n                { "$ref": "#/definitions/simpleTypes" },\n                {\n                    "type": "array",\n                    "items": { "$ref": "#/definitions/simpleTypes" },\n                    "minItems": 1,\n                    "uniqueItems": true\n                }\n            ]\n        },\n        "format": { "type": "string" },\n        "contentMediaType": { "type": "string" },\n        "contentEncoding": { "type": "string" },\n        "if": { "$ref": "#" },\n        "then": { "$ref": "#" },\n        "else": { "$ref": "#" },\n        "allOf": { "$ref": "#/definitions/schemaArray" },\n        "anyOf": { "$ref": "#/definitions/schemaArray" },\n        "oneOf": { "$ref": "#/definitions/schemaArray" },\n        "not": { "$ref": "#" }\n    },\n    "default": true\n}')),Ti.defineVocabulary(ki,{validate:Li.validate,additionalItems:Li.additionalItems6,additionalProperties:Li.additionalProperties6,allOf:Li.allOf,anyOf:Li.anyOf,const:Li.const,contains:Li.contains,default:Li.metaData,definitions:Li.definitions,dependencies:Li.dependencies,description:Li.metaData,enum:Li.enum,exclusiveMaximum:Li.exclusiveMaximum,exclusiveMinimum:Li.exclusiveMinimum,format:Li.metaData,if:Li.if,then:Li.then,else:Li.else,items:Li.items,maxItems:Li.maxItems,maxLength:Li.maxLength6,maxProperties:Li.maxProperties,maximum:Li.maximum,minItems:Li.minItems,minLength:Li.minLength6,minProperties:Li.minProperties,minimum:Li.minimum,multipleOf:Li.multipleOf,not:Li.not,oneOf:Li.oneOf,pattern:Li.pattern,patternProperties:Li.patternProperties,properties:Li.properties,propertyNames:Li.propertyNames,readOnly:Li.metaData,required:Li.required,title:Li.metaData,type:Li.type,uniqueItems:Li.uniqueItems,writeOnly:Li.metaData});const{Core:Vi,Schema:Ui}=Qt,_i=Ei,Ji="https://json-schema.org/draft/2019-09/schema";Ui.setConfig(Ji,"baseToken","$id"),Ui.setConfig(Ji,"embeddedToken","$id"),Ui.setConfig(Ji,"anchorToken","$anchor"),Ui.setConfig(Ji,"recursiveAnchorToken","$recursiveAnchor"),Ui.setConfig(Ji,"vocabularyToken","$vocabulary"),Ui.setConfig(Ji,"mandatoryVocabularies",["https://json-schema.org/draft/2019-09/vocab/core"]),Ui.add(JSON.parse('{\n    "$schema": "https://json-schema.org/draft/2019-09/schema",\n    "$id": "https://json-schema.org/draft/2019-09/schema",\n    "$vocabulary": {\n        "https://json-schema.org/draft/2019-09/vocab/core": true,\n        "https://json-schema.org/draft/2019-09/vocab/applicator": true,\n        "https://json-schema.org/draft/2019-09/vocab/validation": true,\n        "https://json-schema.org/draft/2019-09/vocab/meta-data": true,\n        "https://json-schema.org/draft/2019-09/vocab/format": false,\n        "https://json-schema.org/draft/2019-09/vocab/content": true\n    },\n    "$recursiveAnchor": true,\n\n    "title": "Core and Validation specifications meta-schema",\n    "allOf": [\n        {"$ref": "meta/core"},\n        {"$ref": "meta/applicator"},\n        {"$ref": "meta/validation"},\n        {"$ref": "meta/meta-data"},\n        {"$ref": "meta/format"},\n        {"$ref": "meta/content"}\n    ],\n    "type": ["object", "boolean"],\n    "properties": {\n        "definitions": {\n            "$comment": "While no longer an official keyword as it is replaced by $defs, this keyword is retained in the meta-schema to prevent incompatible extensions as it remains in common use.",\n            "type": "object",\n            "additionalProperties": { "$recursiveRef": "#" },\n            "default": {}\n        },\n        "dependencies": {\n            "$comment": "\\"dependencies\\" is no longer a keyword, but schema authors should avoid redefining it to facilitate a smooth transition to \\"dependentSchemas\\" and \\"dependentRequired\\"",\n            "type": "object",\n            "additionalProperties": {\n                "anyOf": [\n                    { "$recursiveRef": "#" },\n                    { "$ref": "meta/validation#/$defs/stringArray" }\n                ]\n            }\n        }\n    }\n}')),Ui.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/2019-09/meta/core",\n    "$schema": "https://json-schema.org/draft/2019-09/schema",\n    "$vocabulary": {\n      "https://json-schema.org/draft/2019-09/vocab/core": true\n    },\n    "$recursiveAnchor": true,\n\n    "title": "Core vocabulary meta-schema",\n    "type": ["object", "boolean"],\n    "properties": {\n        "$id": {\n            "type": "string",\n            "format": "uri-reference",\n            "$comment": "Non-empty fragments not allowed.",\n            "pattern": "^[^#]*#?$"\n        },\n        "$schema": {\n            "type": "string",\n            "format": "uri"\n        },\n        "$anchor": {\n            "type": "string",\n            "pattern": "^[A-Za-z][-A-Za-z0-9.:_]*$"\n        },\n        "$ref": {\n            "type": "string",\n            "format": "uri-reference"\n        },\n        "$recursiveRef": {\n            "type": "string",\n            "format": "uri-reference"\n        },\n        "$recursiveAnchor": {\n            "type": "boolean",\n            "default": false\n        },\n        "$vocabulary": {\n            "type": "object",\n            "propertyNames": {\n                "type": "string",\n                "format": "uri"\n            },\n            "additionalProperties": {\n                "type": "boolean"\n            }\n        },\n        "$comment": {\n            "type": "string"\n        },\n        "$defs": {\n            "type": "object",\n            "additionalProperties": { "$recursiveRef": "#" },\n            "default": {}\n        }\n    }\n}')),Vi.defineVocabulary("https://json-schema.org/draft/2019-09/vocab/core",{validate:_i.validate,$defs:_i.definitions,$recursiveRef:_i.dynamicRef,$ref:_i.ref}),Ui.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/2019-09/meta/applicator",\n    "$schema": "https://json-schema.org/draft/2019-09/schema",\n    "$vocabulary": {\n        "https://json-schema.org/draft/2019-09/vocab/applicator": true\n    },\n    "$recursiveAnchor": true,\n\n    "title": "Applicator vocabulary meta-schema",\n    "properties": {\n        "additionalItems": { "$recursiveRef": "#" },\n        "unevaluatedItems": { "$recursiveRef": "#" },\n        "items": {\n            "anyOf": [\n                { "$recursiveRef": "#" },\n                { "$ref": "#/$defs/schemaArray" }\n            ]\n        },\n        "contains": { "$recursiveRef": "#" },\n        "additionalProperties": { "$recursiveRef": "#" },\n        "unevaluatedProperties": { "$recursiveRef": "#" },\n        "properties": {\n            "type": "object",\n            "additionalProperties": { "$recursiveRef": "#" },\n            "default": {}\n        },\n        "patternProperties": {\n            "type": "object",\n            "additionalProperties": { "$recursiveRef": "#" },\n            "propertyNames": { "format": "regex" },\n            "default": {}\n        },\n        "dependentSchemas": {\n            "type": "object",\n            "additionalProperties": {\n                "$recursiveRef": "#"\n            }\n        },\n        "propertyNames": { "$recursiveRef": "#" },\n        "if": { "$recursiveRef": "#" },\n        "then": { "$recursiveRef": "#" },\n        "else": { "$recursiveRef": "#" },\n        "allOf": { "$ref": "#/$defs/schemaArray" },\n        "anyOf": { "$ref": "#/$defs/schemaArray" },\n        "oneOf": { "$ref": "#/$defs/schemaArray" },\n        "not": { "$recursiveRef": "#" }\n    },\n    "$defs": {\n        "schemaArray": {\n            "type": "array",\n            "minItems": 1,\n            "items": { "$recursiveRef": "#" }\n        }\n    }\n}')),Vi.defineVocabulary("https://json-schema.org/draft/2019-09/vocab/applicator",{additionalItems:_i.additionalItems6,additionalProperties:_i.additionalProperties6,allOf:_i.allOf,anyOf:_i.anyOf,contains:_i.containsMinContainsMaxContains,dependentSchemas:_i.dependentSchemas,if:_i.if,then:_i.then,else:_i.else,items:_i.items,not:_i.not,oneOf:_i.oneOf,patternProperties:_i.patternProperties,properties:_i.properties,propertyNames:_i.propertyNames,unevaluatedItems:_i.unevaluatedItems,unevaluatedProperties:_i.unevaluatedProperties}),Ui.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/2019-09/meta/validation",\n    "$schema": "https://json-schema.org/draft/2019-09/schema",\n    "$vocabulary": {\n      "https://json-schema.org/draft/2019-09/vocab/validation": true\n    },\n    "$recursiveAnchor": true,\n\n    "title": "Validation vocabulary meta-schema",\n    "type": ["object", "boolean"],\n    "properties": {\n        "multipleOf": {\n            "type": "number",\n            "exclusiveMinimum": 0\n        },\n        "maximum": {\n            "type": "number"\n        },\n        "exclusiveMaximum": {\n            "type": "number"\n        },\n        "minimum": {\n            "type": "number"\n        },\n        "exclusiveMinimum": {\n            "type": "number"\n        },\n        "maxLength": { "$ref": "#/$defs/nonNegativeInteger" },\n        "minLength": { "$ref": "#/$defs/nonNegativeIntegerDefault0" },\n        "pattern": {\n            "type": "string",\n            "format": "regex"\n        },\n        "maxItems": { "$ref": "#/$defs/nonNegativeInteger" },\n        "minItems": { "$ref": "#/$defs/nonNegativeIntegerDefault0" },\n        "uniqueItems": {\n            "type": "boolean",\n            "default": false\n        },\n        "maxContains": { "$ref": "#/$defs/nonNegativeInteger" },\n        "minContains": {\n            "$ref": "#/$defs/nonNegativeInteger",\n            "default": 1\n        },\n        "maxProperties": { "$ref": "#/$defs/nonNegativeInteger" },\n        "minProperties": { "$ref": "#/$defs/nonNegativeIntegerDefault0" },\n        "required": { "$ref": "#/$defs/stringArray" },\n        "dependentRequired": {\n            "type": "object",\n            "additionalProperties": {\n                "$ref": "#/$defs/stringArray"\n            }\n        },\n        "const": true,\n        "enum": {\n            "type": "array",\n            "items": true\n        },\n        "type": {\n            "anyOf": [\n                { "$ref": "#/$defs/simpleTypes" },\n                {\n                    "type": "array",\n                    "items": { "$ref": "#/$defs/simpleTypes" },\n                    "minItems": 1,\n                    "uniqueItems": true\n                }\n            ]\n        }\n    },\n    "$defs": {\n        "nonNegativeInteger": {\n            "type": "integer",\n            "minimum": 0\n        },\n        "nonNegativeIntegerDefault0": {\n            "$ref": "#/$defs/nonNegativeInteger",\n            "default": 0\n        },\n        "simpleTypes": {\n            "enum": [\n                "array",\n                "boolean",\n                "integer",\n                "null",\n                "number",\n                "object",\n                "string"\n            ]\n        },\n        "stringArray": {\n            "type": "array",\n            "items": { "type": "string" },\n            "uniqueItems": true,\n            "default": []\n        }\n    }\n}')),Vi.defineVocabulary("https://json-schema.org/draft/2019-09/vocab/validation",{const:_i.const,dependentRequired:_i.dependentRequired,enum:_i.enum,exclusiveMaximum:_i.exclusiveMaximum,exclusiveMinimum:_i.exclusiveMinimum,maxItems:_i.maxItems,maxLength:_i.maxLength6,maxProperties:_i.maxProperties,maximum:_i.maximum,minItems:_i.minItems,minLength:_i.minLength6,minProperties:_i.minProperties,minimum:_i.minimum,multipleOf:_i.multipleOf,pattern:_i.pattern,required:_i.required,type:_i.type,uniqueItems:_i.uniqueItems}),Ui.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/2019-09/meta/meta-data",\n    "$schema": "https://json-schema.org/draft/2019-09/schema",\n    "$vocabulary": {\n      "https://json-schema.org/draft/2019-09/vocab/meta-data": true\n    },\n    "$recursiveAnchor": true,\n\n    "title": "Meta-data vocabulary meta-schema",\n\n    "type": ["object", "boolean"],\n    "properties": {\n        "title": {\n            "type": "string"\n        },\n        "description": {\n            "type": "string"\n        },\n        "default": true,\n        "deprecated": {\n            "type": "boolean",\n            "default": false\n        },\n        "readOnly": {\n            "type": "boolean",\n            "default": false\n        },\n        "writeOnly": {\n            "type": "boolean",\n            "default": false\n        },\n        "examples": {\n            "type": "array",\n            "items": true\n        }\n    }\n}')),Vi.defineVocabulary("https://json-schema.org/draft/2019-09/vocab/meta-data",{default:_i.metaData,deprecated:_i.metaData,description:_i.metaData,examples:_i.metaData,readOnly:_i.metaData,title:_i.metaData,writeOnly:_i.metaData}),Ui.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/2019-09/meta/format",\n    "$schema": "https://json-schema.org/draft/2019-09/schema",\n    "$vocabulary": {\n      "https://json-schema.org/draft/2019-09/vocab/format": true\n    },\n    "$recursiveAnchor": true,\n\n    "title": "Format vocabulary meta-schema",\n    "type": ["object", "boolean"],\n    "properties": {\n        "format": { "type": "string" }\n    }\n}')),Ui.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/2019-09/meta/content",\n    "$schema": "https://json-schema.org/draft/2019-09/schema",\n    "$vocabulary": {\n      "https://json-schema.org/draft/2019-09/vocab/content": true\n    },\n    "$recursiveAnchor": true,\n\n    "title": "Content vocabulary meta-schema",\n\n    "type": ["object", "boolean"],\n    "properties": {\n        "contentMediaType": { "type": "string" },\n        "contentEncoding": { "type": "string" },\n        "contentSchema": { "$recursiveRef": "#" }\n    }\n}')),Vi.defineVocabulary("https://json-schema.org/draft/2019-09/vocab/content",{contentEncoding:_i.metaData,contentMediaType:_i.metaData,contentSchema:_i.metaData});const{Core:zi,Schema:Fi}=Qt,Bi=Ei,Zi="https://json-schema.org/draft/2020-12/schema";Fi.setConfig(Zi,"baseToken","$id"),Fi.setConfig(Zi,"embeddedToken","$id"),Fi.setConfig(Zi,"anchorToken","$anchor"),Fi.setConfig(Zi,"dynamicAnchorToken","$dynamicAnchor"),Fi.setConfig(Zi,"vocabularyToken","$vocabulary"),Fi.setConfig(Zi,"mandatoryVocabularies",["https://json-schema.org/draft/2020-12/vocab/core"]),Fi.add(JSON.parse('{\n    "$schema": "https://json-schema.org/draft/2020-12/schema",\n    "$id": "https://json-schema.org/draft/2020-12/schema",\n    "$vocabulary": {\n        "https://json-schema.org/draft/2020-12/vocab/core": true,\n        "https://json-schema.org/draft/2020-12/vocab/applicator": true,\n        "https://json-schema.org/draft/2020-12/vocab/unevaluated": true,\n        "https://json-schema.org/draft/2020-12/vocab/validation": true,\n        "https://json-schema.org/draft/2020-12/vocab/meta-data": true,\n        "https://json-schema.org/draft/2020-12/vocab/format-annotation": true,\n        "https://json-schema.org/draft/2020-12/vocab/content": true\n    },\n    "$dynamicAnchor": "meta",\n\n    "title": "Core and Validation specifications meta-schema",\n    "allOf": [\n        {"$ref": "meta/core"},\n        {"$ref": "meta/applicator"},\n        {"$ref": "meta/unevaluated"},\n        {"$ref": "meta/validation"},\n        {"$ref": "meta/meta-data"},\n        {"$ref": "meta/format-annotation"},\n        {"$ref": "meta/content"}\n    ],\n    "type": ["object", "boolean"],\n    "properties": {\n        "definitions": {\n            "$comment": "While no longer an official keyword as it is replaced by $defs, this keyword is retained in the meta-schema to prevent incompatible extensions as it remains in common use.",\n            "type": "object",\n            "additionalProperties": { "$dynamicRef": "#meta" },\n            "default": {}\n        },\n        "dependencies": {\n            "$comment": "\\"dependencies\\" is no longer a keyword, but schema authors should avoid redefining it to facilitate a smooth transition to \\"dependentSchemas\\" and \\"dependentRequired\\"",\n            "type": "object",\n            "additionalProperties": {\n                "anyOf": [\n                    { "$dynamicRef": "#meta" },\n                    { "$ref": "meta/validation#/$defs/stringArray" }\n                ]\n            }\n        }\n    }\n}')),Fi.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/2020-12/meta/core",\n    "$schema": "https://json-schema.org/draft/2020-12/schema",\n    "$vocabulary": {\n        "https://json-schema.org/draft/2020-12/vocab/core": true\n    },\n    "$dynamicAnchor": "meta",\n\n    "title": "Core vocabulary meta-schema",\n    "type": ["object", "boolean"],\n    "properties": {\n        "$id": {\n            "type": "string",\n            "format": "uri-reference",\n            "$comment": "Non-empty fragments not allowed.",\n            "pattern": "^[^#]*#?$"\n        },\n        "$schema": {\n            "type": "string",\n            "format": "uri"\n        },\n        "$anchor": {\n            "type": "string",\n            "pattern": "^[A-Za-z_][-A-Za-z0-9._]*$"\n        },\n        "$ref": {\n            "type": "string",\n            "format": "uri-reference"\n        },\n        "$dynamicRef": {\n            "type": "string",\n            "format": "uri-reference"\n        },\n        "$dynamicAnchor": {\n            "type": "string",\n            "pattern": "^[A-Za-z_][-A-Za-z0-9._]*$"\n        },\n        "$vocabulary": {\n            "type": "object",\n            "propertyNames": {\n                "type": "string",\n                "format": "uri"\n            },\n            "additionalProperties": {\n                "type": "boolean"\n            }\n        },\n        "$comment": {\n            "type": "string"\n        },\n        "$defs": {\n            "type": "object",\n            "additionalProperties": { "$dynamicRef": "#meta" },\n            "default": {}\n        }\n    }\n}')),zi.defineVocabulary("https://json-schema.org/draft/2020-12/vocab/core",{validate:Bi.validate,$defs:Bi.definitions,$dynamicRef:Bi.dynamicRef,$ref:Bi.ref}),Fi.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/2020-12/meta/applicator",\n    "$schema": "https://json-schema.org/draft/2020-12/schema",\n    "$vocabulary": {\n        "https://json-schema.org/draft/2020-12/vocab/applicator": true\n    },\n    "$dynamicAnchor": "meta",\n\n    "title": "Applicator vocabulary meta-schema",\n    "type": ["object", "boolean"],\n    "properties": {\n        "prefixItems": { "$ref": "#/$defs/schemaArray" },\n        "items": { "$dynamicRef": "#meta" },\n        "contains": { "$dynamicRef": "#meta" },\n        "additionalProperties": { "$dynamicRef": "#meta" },\n        "properties": {\n            "type": "object",\n            "additionalProperties": { "$dynamicRef": "#meta" },\n            "default": {}\n        },\n        "patternProperties": {\n            "type": "object",\n            "additionalProperties": { "$dynamicRef": "#meta" },\n            "propertyNames": { "format": "regex" },\n            "default": {}\n        },\n        "dependentSchemas": {\n            "type": "object",\n            "additionalProperties": {\n                "$dynamicRef": "#meta"\n            }\n        },\n        "propertyNames": { "$dynamicRef": "#meta" },\n        "if": { "$dynamicRef": "#meta" },\n        "then": { "$dynamicRef": "#meta" },\n        "else": { "$dynamicRef": "#meta" },\n        "allOf": { "$ref": "#/$defs/schemaArray" },\n        "anyOf": { "$ref": "#/$defs/schemaArray" },\n        "oneOf": { "$ref": "#/$defs/schemaArray" },\n        "not": { "$dynamicRef": "#meta" }\n    },\n    "$defs": {\n        "schemaArray": {\n            "type": "array",\n            "minItems": 1,\n            "items": { "$dynamicRef": "#meta" }\n        }\n    }\n}')),zi.defineVocabulary("https://json-schema.org/draft/2020-12/vocab/applicator",{additionalProperties:Bi.additionalProperties6,allOf:Bi.allOf,anyOf:Bi.anyOf,contains:Bi.containsMinContainsMaxContains,dependentSchemas:Bi.dependentSchemas,if:Bi.if,then:Bi.then,else:Bi.else,items:Bi.items202012,not:Bi.not,oneOf:Bi.oneOf,patternProperties:Bi.patternProperties,prefixItems:Bi.tupleItems,properties:Bi.properties,propertyNames:Bi.propertyNames}),Fi.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/2020-12/meta/validation",\n    "$schema": "https://json-schema.org/draft/2020-12/schema",\n    "$vocabulary": {\n        "https://json-schema.org/draft/2020-12/vocab/validation": true\n    },\n    "$dynamicAnchor": "meta",\n\n    "title": "Validation vocabulary meta-schema",\n    "type": ["object", "boolean"],\n    "properties": {\n        "multipleOf": {\n            "type": "number",\n            "exclusiveMinimum": 0\n        },\n        "maximum": {\n            "type": "number"\n        },\n        "exclusiveMaximum": {\n            "type": "number"\n        },\n        "minimum": {\n            "type": "number"\n        },\n        "exclusiveMinimum": {\n            "type": "number"\n        },\n        "maxLength": { "$ref": "#/$defs/nonNegativeInteger" },\n        "minLength": { "$ref": "#/$defs/nonNegativeIntegerDefault0" },\n        "pattern": {\n            "type": "string",\n            "format": "regex"\n        },\n        "maxItems": { "$ref": "#/$defs/nonNegativeInteger" },\n        "minItems": { "$ref": "#/$defs/nonNegativeIntegerDefault0" },\n        "uniqueItems": {\n            "type": "boolean",\n            "default": false\n        },\n        "maxContains": { "$ref": "#/$defs/nonNegativeInteger" },\n        "minContains": {\n            "$ref": "#/$defs/nonNegativeInteger",\n            "default": 1\n        },\n        "maxProperties": { "$ref": "#/$defs/nonNegativeInteger" },\n        "minProperties": { "$ref": "#/$defs/nonNegativeIntegerDefault0" },\n        "required": { "$ref": "#/$defs/stringArray" },\n        "dependentRequired": {\n            "type": "object",\n            "additionalProperties": {\n                "$ref": "#/$defs/stringArray"\n            }\n        },\n        "const": true,\n        "enum": {\n            "type": "array",\n            "items": true\n        },\n        "type": {\n            "anyOf": [\n                { "$ref": "#/$defs/simpleTypes" },\n                {\n                    "type": "array",\n                    "items": { "$ref": "#/$defs/simpleTypes" },\n                    "minItems": 1,\n                    "uniqueItems": true\n                }\n            ]\n        }\n    },\n    "$defs": {\n        "nonNegativeInteger": {\n            "type": "integer",\n            "minimum": 0\n        },\n        "nonNegativeIntegerDefault0": {\n            "$ref": "#/$defs/nonNegativeInteger",\n            "default": 0\n        },\n        "simpleTypes": {\n            "enum": [\n                "array",\n                "boolean",\n                "integer",\n                "null",\n                "number",\n                "object",\n                "string"\n            ]\n        },\n        "stringArray": {\n            "type": "array",\n            "items": { "type": "string" },\n            "uniqueItems": true,\n            "default": []\n        }\n    }\n}')),zi.defineVocabulary("https://json-schema.org/draft/2020-12/vocab/validation",{const:Bi.const,dependentRequired:Bi.dependentRequired,enum:Bi.enum,exclusiveMaximum:Bi.exclusiveMaximum,exclusiveMinimum:Bi.exclusiveMinimum,maxItems:Bi.maxItems,maxLength:Bi.maxLength6,maxProperties:Bi.maxProperties,maximum:Bi.maximum,minItems:Bi.minItems,minLength:Bi.minLength6,minProperties:Bi.minProperties,minimum:Bi.minimum,multipleOf:Bi.multipleOf,pattern:Bi.pattern,required:Bi.required,type:Bi.type,uniqueItems:Bi.uniqueItems}),Fi.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/2020-12/meta/meta-data",\n    "$schema": "https://json-schema.org/draft/2020-12/schema",\n    "$vocabulary": {\n        "https://json-schema.org/draft/2020-12/vocab/meta-data": true\n    },\n    "$dynamicAnchor": "meta",\n\n    "title": "Meta-data vocabulary meta-schema",\n\n    "type": ["object", "boolean"],\n    "properties": {\n        "title": {\n            "type": "string"\n        },\n        "description": {\n            "type": "string"\n        },\n        "default": true,\n        "deprecated": {\n            "type": "boolean",\n            "default": false\n        },\n        "readOnly": {\n            "type": "boolean",\n            "default": false\n        },\n        "writeOnly": {\n            "type": "boolean",\n            "default": false\n        },\n        "examples": {\n            "type": "array",\n            "items": true\n        }\n    }\n}')),zi.defineVocabulary("https://json-schema.org/draft/2020-12/vocab/meta-data",{default:Bi.metaData,deprecated:Bi.metaData,description:Bi.metaData,examples:Bi.metaData,readOnly:Bi.metaData,title:Bi.metaData,writeOnly:Bi.metaData}),Fi.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/2020-12/meta/format-annotation",\n    "$schema": "https://json-schema.org/draft/2020-12/schema",\n    "$vocabulary": {\n        "https://json-schema.org/draft/2020-12/vocab/format-annotation": true\n    },\n    "$dynamicAnchor": "meta",\n\n    "title": "Format vocabulary meta-schema for annotation results",\n    "type": ["object", "boolean"],\n    "properties": {\n        "format": { "type": "string" }\n    }\n}')),zi.defineVocabulary("https://json-schema.org/draft/2020-12/vocab/format-annotation",{format:Bi.metaData}),Fi.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/2020-12/meta/format-assertion",\n    "$schema": "https://json-schema.org/draft/2020-12/schema",\n    "$vocabulary": {\n        "https://json-schema.org/draft/2020-12/vocab/format-assertion": true\n    },\n    "$dynamicAnchor": "meta",\n\n    "title": "Format vocabulary meta-schema for assertion results",\n    "type": ["object", "boolean"],\n    "properties": {\n        "format": { "type": "string" }\n    }\n}')),Fi.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/2020-12/meta/content",\n    "$schema": "https://json-schema.org/draft/2020-12/schema",\n    "$vocabulary": {\n        "https://json-schema.org/draft/2020-12/vocab/content": true\n    },\n    "$dynamicAnchor": "meta",\n\n    "title": "Content vocabulary meta-schema",\n\n    "type": ["object", "boolean"],\n    "properties": {\n        "contentMediaType": { "type": "string" },\n        "contentEncoding": { "type": "string" },\n        "contentSchema": { "$dynamicRef": "#meta" }\n    }\n}')),zi.defineVocabulary("https://json-schema.org/draft/2020-12/vocab/content",{contentEncoding:Bi.metaData,contentMediaType:Bi.metaData,contentSchema:Bi.metaData}),Fi.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/2020-12/meta/unevaluated",\n    "$schema": "https://json-schema.org/draft/2020-12/schema",\n    "$vocabulary": {\n        "https://json-schema.org/draft/2020-12/vocab/unevaluated": true\n    },\n    "$dynamicAnchor": "meta",\n\n    "title": "Unevaluated applicator vocabulary meta-schema",\n    "type": ["object", "boolean"],\n    "properties": {\n        "unevaluatedItems": { "$dynamicRef": "#meta" },\n        "unevaluatedProperties": { "$dynamicRef": "#meta" }\n    }\n}')),zi.defineVocabulary("https://json-schema.org/draft/2020-12/vocab/unevaluated",{unevaluatedItems:Bi.unevaluatedItems,unevaluatedProperties:Bi.unevaluatedProperties});const{Core:Gi,Schema:Wi,InvalidSchemaError:Xi}=Qt,Hi=Ei;var Qi={add:Gi.add,get:Wi.get,validate:Gi.validate,compile:Gi.compile,interpret:Gi.interpret,setMetaOutputFormat:Gi.setMetaOutputFormat,setShouldMetaValidate:Gi.setShouldMetaValidate,FLAG:Gi.FLAG,BASIC:Gi.BASIC,DETAILED:Gi.DETAILED,VERBOSE:Gi.VERBOSE,Keywords:Hi,InvalidSchemaError:Xi};var Yi={splitUri:e=>{const t=e.indexOf("#"),n=-1===t?e.length:t,r=e.slice(0,n),a=e.slice(n+1);return[decodeURI(r),decodeURI(a)]}};const{Core:eo}=Qt,{splitUri:to}=Yi;var no={collectExternalIds:(e,t,n,r)=>{const a=n[e][0],i=to(e)[0];eo.getKeyword(a).collectExternalIds(e,t,n,{...n.metaData[i].dynamicAnchors,...r})}};const ro=Qi,{Core:ao}=Qt,io=no,oo={...ro.Keywords.validate,collectExternalIds:(e,t,n,r)=>{const a=n[e][2];if(!t.has(e)&&"boolean"!=typeof a){t.add(e);for(const[e,,i]of a){const a=ao.getKeyword(e);a.collectExternalIds&&a.collectExternalIds(i,t,n,r)}}}},so={...ro.Keywords.ref,collectExternalIds:io.collectExternalIds},co={...ro.Keywords.additionalItems,collectExternalIds:([,e],t,n,r)=>{"string"==typeof e&&io.collectExternalIds(e,t,n,r)}},mo={...ro.Keywords.additionalProperties,collectExternalIds:([,,e],t,n,r)=>{"string"==typeof e&&io.collectExternalIds(e,t,n,r)}},lo={...ro.Keywords.additionalItems6,collectExternalIds:([,e],t,n,r)=>{io.collectExternalIds(e,t,n,r)}},po={...ro.Keywords.additionalProperties6,collectExternalIds:([,,e],t,n,r)=>{io.collectExternalIds(e,t,n,r)}},uo={...ro.Keywords.allOf,collectExternalIds:(e,t,n,r)=>{e.forEach((e=>io.collectExternalIds(e,t,n,r)))}},fo={...ro.Keywords.anyOf,collectExternalIds:(e,t,n,r)=>{e.forEach((e=>io.collectExternalIds(e,t,n,r)))}},yo={...ro.Keywords.contains,collectExternalIds:io.collectExternalIds},ho={...ro.Keywords.containsMinContainsMaxContains,collectExternalIds:({contains:e},t,n,r)=>{io.collectExternalIds(e,t,n,r)}},vo={...ro.Keywords.dependencies,collectExternalIds:(e,t,n,r)=>{Object.values(e).forEach((([,e])=>{"string"==typeof e&&io.collectExternalIds(e,t,n,r)}))}},go={...ro.Keywords.dependentSchemas,collectExternalIds:(e,t,n,r)=>{Object.values(e).forEach((([,e])=>io.collectExternalIds(e,t,n,r)))}},bo={...ro.Keywords.if,collectExternalIds:io.collectExternalIds},$o={...ro.Keywords.then,collectExternalIds:([,e],t,n,r)=>{io.collectExternalIds(e,t,n,r)}},Io={...ro.Keywords.else,collectExternalIds:([,e],t,n,r)=>{io.collectExternalIds(e,t,n,r)}},wo={...ro.Keywords.items,collectExternalIds:(e,t,n,r)=>{"string"==typeof e?io.collectExternalIds(e,t,n,r):e.forEach((e=>io.collectExternalIds(e,t,n,r)))}},Oo={...ro.Keywords.items202012,collectExternalIds:([,e],t,n,r)=>{io.collectExternalIds(e,t,n,r)}};var xo={validate:oo,ref:so,additionalItems:co,additionalItems6:lo,additionalProperties:mo,additionalProperties6:po,allOf:uo,anyOf:fo,contains:yo,containsMinContainsMaxContains:ho,dependencies:vo,dependentSchemas:go,if:bo,then:$o,else:Io,items:wo,items202012:Oo,not:{...ro.Keywords.not,collectExternalIds:io.collectExternalIds},oneOf:{...ro.Keywords.oneOf,collectExternalIds:(e,t,n,r)=>{e.forEach((e=>io.collectExternalIds(e,t,n,r)))}},patternProperties:{...ro.Keywords.patternProperties,collectExternalIds:(e,t,n,r)=>{e.forEach((([,e])=>io.collectExternalIds(e,t,n,r)))}},tupleItems:{...ro.Keywords.tupleItems,collectExternalIds:(e,t,n,r)=>{e.forEach((e=>io.collectExternalIds(e,t,n,r)))}},properties:{...ro.Keywords.properties,collectExternalIds:(e,t,n,r)=>{Object.values(e).forEach((e=>io.collectExternalIds(e,t,n,r)))}},propertyNames:{...ro.Keywords.propertyNames,collectExternalIds:io.collectExternalIds},unevaluatedItems:{...ro.Keywords.unevaluatedItems,collectExternalIds:([,e],t,n,r)=>{io.collectExternalIds(e,t,n,r)}},unevaluatedProperties:{...ro.Keywords.unevaluatedProperties,collectExternalIds:([,e],t,n,r)=>{io.collectExternalIds(e,t,n,r)}}};const So=Qi,{Core:jo,Schema:Eo}=Qt,Po=xo;Eo.setConfig("http://json-schema.org/draft-04/schema","bundlingLocation","/definitions"),jo.defineVocabulary("http://json-schema.org/draft-04/schema",{validate:Po.validate,additionalItems:Po.additionalItems,additionalProperties:Po.additionalProperties,allOf:Po.allOf,anyOf:Po.anyOf,default:So.Keywords.metaData,definitions:So.Keywords.definitions,dependencies:Po.dependencies,description:So.Keywords.metaData,enum:So.Keywords.enum,format:So.Keywords.metaData,items:Po.items,maxItems:So.Keywords.maxItems,maxLength:So.Keywords.maxLength,maxProperties:So.Keywords.maxProperties,maximum:So.Keywords.maximumExclusiveMaximum,minItems:So.Keywords.minItems,minLength:So.Keywords.minLength,minProperties:So.Keywords.minProperties,minimum:So.Keywords.minimumExclusiveMinimum,multipleOf:So.Keywords.multipleOf,not:Po.not,oneOf:Po.oneOf,pattern:So.Keywords.pattern,patternProperties:Po.patternProperties,properties:Po.properties,required:So.Keywords.required,title:So.Keywords.metaData,type:So.Keywords.type,uniqueItems:So.Keywords.uniqueItems});const Ao=Qi,{Core:Co,Schema:No}=Qt,Ko=xo;No.setConfig("http://json-schema.org/draft-06/schema","bundlingLocation","/definitions"),Co.defineVocabulary("http://json-schema.org/draft-06/schema",{validate:Ko.validate,additionalItems:Ko.additionalItems6,additionalProperties:Ko.additionalProperties6,allOf:Ko.allOf,anyOf:Ko.anyOf,const:Ao.Keywords.const,contains:Ko.contains,default:Ao.Keywords.metaData,definitions:Ao.Keywords.definitions,dependencies:Ko.dependencies,description:Ao.Keywords.metaData,enum:Ao.Keywords.enum,examples:Ao.Keywords.metaData,exclusiveMaximum:Ao.Keywords.exclusiveMaximum,exclusiveMinimum:Ao.Keywords.exclusiveMinimum,format:Ao.Keywords.metaData,items:Ko.items,maxItems:Ao.Keywords.maxItems,maxLength:Ao.Keywords.maxLength6,maxProperties:Ao.Keywords.maxProperties,maximum:Ao.Keywords.maximum,minItems:Ao.Keywords.minItems,minLength:Ao.Keywords.minLength6,minProperties:Ao.Keywords.minProperties,minimum:Ao.Keywords.minimum,multipleOf:Ao.Keywords.multipleOf,not:Ko.not,oneOf:Ko.oneOf,pattern:Ao.Keywords.pattern,patternProperties:Ko.patternProperties,properties:Ko.properties,propertyNames:Ko.propertyNames,required:Ao.Keywords.required,title:Ao.Keywords.metaData,type:Ao.Keywords.type,uniqueItems:Ao.Keywords.uniqueItems});const Ro=Qi,{Core:Do,Schema:Mo}=Qt,To=xo;Mo.setConfig("http://json-schema.org/draft-07/schema","bundlingLocation","/definitions"),Do.defineVocabulary("http://json-schema.org/draft-07/schema",{validate:To.validate,additionalItems:To.additionalItems6,additionalProperties:To.additionalProperties6,allOf:To.allOf,anyOf:To.anyOf,const:Ro.Keywords.const,contains:To.contains,default:Ro.Keywords.metaData,definitions:Ro.Keywords.definitions,dependencies:To.dependencies,description:Ro.Keywords.metaData,enum:Ro.Keywords.enum,exclusiveMaximum:Ro.Keywords.exclusiveMaximum,exclusiveMinimum:Ro.Keywords.exclusiveMinimum,format:Ro.Keywords.metaData,if:To.if,then:To.then,else:To.else,items:To.items,maxItems:Ro.Keywords.maxItems,maxLength:Ro.Keywords.maxLength6,maxProperties:Ro.Keywords.maxProperties,maximum:Ro.Keywords.maximum,minItems:Ro.Keywords.minItems,minLength:Ro.Keywords.minLength6,minProperties:Ro.Keywords.minProperties,minimum:Ro.Keywords.minimum,multipleOf:Ro.Keywords.multipleOf,not:To.not,oneOf:To.oneOf,pattern:Ro.Keywords.pattern,patternProperties:To.patternProperties,properties:To.properties,propertyNames:To.propertyNames,readOnly:Ro.Keywords.metaData,required:Ro.Keywords.required,title:Ro.Keywords.metaData,type:Ro.Keywords.type,uniqueItems:Ro.Keywords.uniqueItems,writeOnly:Ro.Keywords.metaData});const qo=Qi,{Core:Lo,Schema:ko}=Qt,Vo=xo;ko.setConfig("https://json-schema.org/draft/2019-09/schema","bundlingLocation","/$defs"),Lo.defineVocabulary("https://json-schema.org/draft/2019-09/vocab/core",{validate:Vo.validate,$defs:qo.Keywords.definitions,$recursiveRef:qo.Keywords.dynamicRef,$ref:Vo.ref}),Lo.defineVocabulary("https://json-schema.org/draft/2019-09/vocab/applicator",{additionalItems:Vo.additionalItems6,additionalProperties:Vo.additionalProperties6,allOf:Vo.allOf,anyOf:Vo.anyOf,contains:Vo.containsMinContainsMaxContains,dependentSchemas:Vo.dependentSchemas,if:Vo.if,then:Vo.then,else:Vo.else,items:Vo.items,not:Vo.not,oneOf:Vo.oneOf,patternProperties:Vo.patternProperties,properties:Vo.properties,propertyNames:Vo.propertyNames,unevaluatedItems:Vo.unevaluatedItems,unevaluatedProperties:Vo.unevaluatedProperties});const Uo=Qi,{Core:_o,Schema:Jo}=Qt,zo=xo;Jo.setConfig("https://json-schema.org/draft/2020-12/schema","bundlingLocation","/$defs"),_o.defineVocabulary("https://json-schema.org/draft/2020-12/vocab/core",{validate:zo.validate,$defs:Uo.Keywords.definitions,$dynamicRef:Uo.Keywords.dynamicRef,$ref:zo.ref}),_o.defineVocabulary("https://json-schema.org/draft/2020-12/vocab/applicator",{additionalProperties:zo.additionalProperties6,allOf:zo.allOf,anyOf:zo.anyOf,contains:zo.containsMinContainsMaxContains,dependentSchemas:zo.dependentSchemas,if:zo.if,then:zo.then,else:zo.else,items:zo.items202012,not:zo.not,oneOf:zo.oneOf,patternProperties:zo.patternProperties,prefixItems:zo.tupleItems,properties:zo.properties,propertyNames:zo.propertyNames}),_o.defineVocabulary("https://json-schema.org/draft/2020-12/vocab/unevaluated",{unevaluatedItems:zo.unevaluatedItems,unevaluatedProperties:zo.unevaluatedProperties});const{v4:Fo}=C,Bo=Qi,Zo=ee,{Core:Go,Schema:Wo,InvalidSchemaError:Xo}=Qt,Ho=no,{splitUri:Qo}=Yi,Yo={alwaysIncludeDialect:!1,bundleMode:"flat",definitionNamingStrategy:"uri"};var es={add:Bo.add,get:Wo.get,bundle:async(e,t={})=>{const n={...Yo,...t},{ast:r,schemaUri:a}=await Go.compile(e),i=new Set;Ho.collectExternalIds(a,i,r,{});const o=new Set([...i].map((e=>Qo(e)[0])));o.delete(e.id);const s=Wo.toSchema(e,{includeEmbedded:"full"===n.bundleMode}),c=Wo.getConfig(e.schemaVersion,"bundlingLocation");void 0===Zo.get(c,s)&&o.size>0&&Zo.assign(c,s,{});for(const t of o.values()){const r=await Bo.get(t),a=Wo.toSchema(r,{parentId:e.id,parentDialect:n.alwaysIncludeDialect?"":e.schemaVersion,includeEmbedded:"full"===n.bundleMode});let i;if("uri"===n.definitionNamingStrategy){i=a[Wo.getConfig(r.schemaVersion,"embeddedToken")]}else{if("uuid"!==n.definitionNamingStrategy)throw Error(`Unknown definition naming stragety: ${n.definitionNamingStrategy}`);i=Fo()}const o=Zo.append(i,c);Zo.assign(o,s,a)}return s},FULL:"full",FLAT:"flat",URI:"uri",UUID:"uuid",setMetaOutputFormat:Go.setMetaOutputFormat,setShouldMetaValidate:Go.setShouldMetaValidate,FLAG:Go.FLAG,BASIC:Go.BASIC,DETAILED:Go.DETAILED,VERBOSE:Go.VERBOSE,InvalidSchemaError:Xo};exports.default=es;
//# sourceMappingURL=json-schema-bundler-cjs.min.js.map
