define(["exports"],(function(e){"use strict";var t,n="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:{};function r(e){if(e.__esModule)return e;var t=Object.defineProperty({},"__esModule",{value:!0});return Object.keys(e).forEach((function(n){var r=Object.getOwnPropertyDescriptor(e,n);Object.defineProperty(t,n,r.get?r:{enumerable:!0,get:function(){return e[n]}})})),t}var a=new Uint8Array(16);function i(){if(!t&&!(t="undefined"!=typeof crypto&&crypto.getRandomValues&&crypto.getRandomValues.bind(crypto)||"undefined"!=typeof msCrypto&&"function"==typeof msCrypto.getRandomValues&&msCrypto.getRandomValues.bind(msCrypto)))throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");return t(a)}var o=/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;function s(e){return"string"==typeof e&&o.test(e)}for(var c,m,l=[],p=0;p<256;++p)l.push((p+256).toString(16).substr(1));function d(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=(l[e[t+0]]+l[e[t+1]]+l[e[t+2]]+l[e[t+3]]+"-"+l[e[t+4]]+l[e[t+5]]+"-"+l[e[t+6]]+l[e[t+7]]+"-"+l[e[t+8]]+l[e[t+9]]+"-"+l[e[t+10]]+l[e[t+11]]+l[e[t+12]]+l[e[t+13]]+l[e[t+14]]+l[e[t+15]]).toLowerCase();if(!s(n))throw TypeError("Stringified UUID is invalid");return n}var u=0,f=0;function y(e){if(!s(e))throw TypeError("Invalid UUID");var t,n=new Uint8Array(16);return n[0]=(t=parseInt(e.slice(0,8),16))>>>24,n[1]=t>>>16&255,n[2]=t>>>8&255,n[3]=255&t,n[4]=(t=parseInt(e.slice(9,13),16))>>>8,n[5]=255&t,n[6]=(t=parseInt(e.slice(14,18),16))>>>8,n[7]=255&t,n[8]=(t=parseInt(e.slice(19,23),16))>>>8,n[9]=255&t,n[10]=(t=parseInt(e.slice(24,36),16))/1099511627776&255,n[11]=t/4294967296&255,n[12]=t>>>24&255,n[13]=t>>>16&255,n[14]=t>>>8&255,n[15]=255&t,n}function h(e,t,n){function r(e,r,a,i){if("string"==typeof e&&(e=function(e){e=unescape(encodeURIComponent(e));for(var t=[],n=0;n<e.length;++n)t.push(e.charCodeAt(n));return t}(e)),"string"==typeof r&&(r=y(r)),16!==r.length)throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");var o=new Uint8Array(16+e.length);if(o.set(r),o.set(e,r.length),(o=n(o))[6]=15&o[6]|t,o[8]=63&o[8]|128,a){i=i||0;for(var s=0;s<16;++s)a[i+s]=o[s];return a}return d(o)}try{r.name=e}catch(e){}return r.DNS="6ba7b810-9dad-11d1-80b4-00c04fd430c8",r.URL="6ba7b811-9dad-11d1-80b4-00c04fd430c8",r}function v(e){return 14+(e+64>>>9<<4)+1}function g(e,t){var n=(65535&e)+(65535&t);return(e>>16)+(t>>16)+(n>>16)<<16|65535&n}function b(e,t,n,r,a,i){return g((o=g(g(t,e),g(r,i)))<<(s=a)|o>>>32-s,n);var o,s}function $(e,t,n,r,a,i,o){return b(t&n|~t&r,e,t,a,i,o)}function I(e,t,n,r,a,i,o){return b(t&r|n&~r,e,t,a,i,o)}function w(e,t,n,r,a,i,o){return b(t^n^r,e,t,a,i,o)}function O(e,t,n,r,a,i,o){return b(n^(t|~r),e,t,a,i,o)}var x=h("v3",48,(function(e){if("string"==typeof e){var t=unescape(encodeURIComponent(e));e=new Uint8Array(t.length);for(var n=0;n<t.length;++n)e[n]=t.charCodeAt(n)}return function(e){for(var t=[],n=32*e.length,r="0123456789abcdef",a=0;a<n;a+=8){var i=e[a>>5]>>>a%32&255,o=parseInt(r.charAt(i>>>4&15)+r.charAt(15&i),16);t.push(o)}return t}(function(e,t){e[t>>5]|=128<<t%32,e[v(t)-1]=t;for(var n=1732584193,r=-271733879,a=-1732584194,i=271733878,o=0;o<e.length;o+=16){var s=n,c=r,m=a,l=i;n=$(n,r,a,i,e[o],7,-680876936),i=$(i,n,r,a,e[o+1],12,-389564586),a=$(a,i,n,r,e[o+2],17,606105819),r=$(r,a,i,n,e[o+3],22,-1044525330),n=$(n,r,a,i,e[o+4],7,-176418897),i=$(i,n,r,a,e[o+5],12,1200080426),a=$(a,i,n,r,e[o+6],17,-1473231341),r=$(r,a,i,n,e[o+7],22,-45705983),n=$(n,r,a,i,e[o+8],7,1770035416),i=$(i,n,r,a,e[o+9],12,-1958414417),a=$(a,i,n,r,e[o+10],17,-42063),r=$(r,a,i,n,e[o+11],22,-1990404162),n=$(n,r,a,i,e[o+12],7,1804603682),i=$(i,n,r,a,e[o+13],12,-40341101),a=$(a,i,n,r,e[o+14],17,-1502002290),n=I(n,r=$(r,a,i,n,e[o+15],22,1236535329),a,i,e[o+1],5,-165796510),i=I(i,n,r,a,e[o+6],9,-1069501632),a=I(a,i,n,r,e[o+11],14,643717713),r=I(r,a,i,n,e[o],20,-373897302),n=I(n,r,a,i,e[o+5],5,-701558691),i=I(i,n,r,a,e[o+10],9,38016083),a=I(a,i,n,r,e[o+15],14,-660478335),r=I(r,a,i,n,e[o+4],20,-405537848),n=I(n,r,a,i,e[o+9],5,568446438),i=I(i,n,r,a,e[o+14],9,-1019803690),a=I(a,i,n,r,e[o+3],14,-187363961),r=I(r,a,i,n,e[o+8],20,1163531501),n=I(n,r,a,i,e[o+13],5,-1444681467),i=I(i,n,r,a,e[o+2],9,-51403784),a=I(a,i,n,r,e[o+7],14,1735328473),n=w(n,r=I(r,a,i,n,e[o+12],20,-1926607734),a,i,e[o+5],4,-378558),i=w(i,n,r,a,e[o+8],11,-2022574463),a=w(a,i,n,r,e[o+11],16,1839030562),r=w(r,a,i,n,e[o+14],23,-35309556),n=w(n,r,a,i,e[o+1],4,-1530992060),i=w(i,n,r,a,e[o+4],11,1272893353),a=w(a,i,n,r,e[o+7],16,-155497632),r=w(r,a,i,n,e[o+10],23,-1094730640),n=w(n,r,a,i,e[o+13],4,681279174),i=w(i,n,r,a,e[o],11,-358537222),a=w(a,i,n,r,e[o+3],16,-722521979),r=w(r,a,i,n,e[o+6],23,76029189),n=w(n,r,a,i,e[o+9],4,-640364487),i=w(i,n,r,a,e[o+12],11,-421815835),a=w(a,i,n,r,e[o+15],16,530742520),n=O(n,r=w(r,a,i,n,e[o+2],23,-995338651),a,i,e[o],6,-198630844),i=O(i,n,r,a,e[o+7],10,1126891415),a=O(a,i,n,r,e[o+14],15,-1416354905),r=O(r,a,i,n,e[o+5],21,-57434055),n=O(n,r,a,i,e[o+12],6,1700485571),i=O(i,n,r,a,e[o+3],10,-1894986606),a=O(a,i,n,r,e[o+10],15,-1051523),r=O(r,a,i,n,e[o+1],21,-2054922799),n=O(n,r,a,i,e[o+8],6,1873313359),i=O(i,n,r,a,e[o+15],10,-30611744),a=O(a,i,n,r,e[o+6],15,-1560198380),r=O(r,a,i,n,e[o+13],21,1309151649),n=O(n,r,a,i,e[o+4],6,-145523070),i=O(i,n,r,a,e[o+11],10,-1120210379),a=O(a,i,n,r,e[o+2],15,718787259),r=O(r,a,i,n,e[o+9],21,-343485551),n=g(n,s),r=g(r,c),a=g(a,m),i=g(i,l)}return[n,r,a,i]}(function(e){if(0===e.length)return[];for(var t=8*e.length,n=new Uint32Array(v(t)),r=0;r<t;r+=8)n[r>>5]|=(255&e[r/8])<<r%32;return n}(e),8*e.length))})),S=x;function j(e,t,n,r){switch(e){case 0:return t&n^~t&r;case 1:case 3:return t^n^r;case 2:return t&n^t&r^n&r}}function E(e,t){return e<<t|e>>>32-t}var P=h("v5",80,(function(e){var t=[1518500249,1859775393,2400959708,3395469782],n=[1732584193,4023233417,2562383102,271733878,3285377520];if("string"==typeof e){var r=unescape(encodeURIComponent(e));e=[];for(var a=0;a<r.length;++a)e.push(r.charCodeAt(a))}else Array.isArray(e)||(e=Array.prototype.slice.call(e));e.push(128);for(var i=e.length/4+2,o=Math.ceil(i/16),s=new Array(o),c=0;c<o;++c){for(var m=new Uint32Array(16),l=0;l<16;++l)m[l]=e[64*c+4*l]<<24|e[64*c+4*l+1]<<16|e[64*c+4*l+2]<<8|e[64*c+4*l+3];s[c]=m}s[o-1][14]=8*(e.length-1)/Math.pow(2,32),s[o-1][14]=Math.floor(s[o-1][14]),s[o-1][15]=8*(e.length-1)&4294967295;for(var p=0;p<o;++p){for(var d=new Uint32Array(80),u=0;u<16;++u)d[u]=s[p][u];for(var f=16;f<80;++f)d[f]=E(d[f-3]^d[f-8]^d[f-14]^d[f-16],1);for(var y=n[0],h=n[1],v=n[2],g=n[3],b=n[4],$=0;$<80;++$){var I=Math.floor($/20),w=E(y,5)+j(I,h,v,g)+b+t[I]+d[$]>>>0;b=g,g=v,v=E(h,30)>>>0,h=y,y=w}n[0]=n[0]+y>>>0,n[1]=n[1]+h>>>0,n[2]=n[2]+v>>>0,n[3]=n[3]+g>>>0,n[4]=n[4]+b>>>0}return[n[0]>>24&255,n[0]>>16&255,n[0]>>8&255,255&n[0],n[1]>>24&255,n[1]>>16&255,n[1]>>8&255,255&n[1],n[2]>>24&255,n[2]>>16&255,n[2]>>8&255,255&n[2],n[3]>>24&255,n[3]>>16&255,n[3]>>8&255,255&n[3],n[4]>>24&255,n[4]>>16&255,n[4]>>8&255,255&n[4]]})),A=P;var C=Object.freeze({__proto__:null,v1:function(e,t,n){var r=t&&n||0,a=t||new Array(16),o=(e=e||{}).node||c,s=void 0!==e.clockseq?e.clockseq:m;if(null==o||null==s){var l=e.random||(e.rng||i)();null==o&&(o=c=[1|l[0],l[1],l[2],l[3],l[4],l[5]]),null==s&&(s=m=16383&(l[6]<<8|l[7]))}var p=void 0!==e.msecs?e.msecs:Date.now(),y=void 0!==e.nsecs?e.nsecs:f+1,h=p-u+(y-f)/1e4;if(h<0&&void 0===e.clockseq&&(s=s+1&16383),(h<0||p>u)&&void 0===e.nsecs&&(y=0),y>=1e4)throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");u=p,f=y,m=s;var v=(1e4*(268435455&(p+=122192928e5))+y)%4294967296;a[r++]=v>>>24&255,a[r++]=v>>>16&255,a[r++]=v>>>8&255,a[r++]=255&v;var g=p/4294967296*1e4&268435455;a[r++]=g>>>8&255,a[r++]=255&g,a[r++]=g>>>24&15|16,a[r++]=g>>>16&255,a[r++]=s>>>8|128,a[r++]=255&s;for(var b=0;b<6;++b)a[r+b]=o[b];return t||d(a)},v3:S,v4:function(e,t,n){var r=(e=e||{}).random||(e.rng||i)();if(r[6]=15&r[6]|64,r[8]=63&r[8]|128,t){n=n||0;for(var a=0;a<16;++a)t[n+a]=r[a];return t}return d(r)},v5:A,NIL:"00000000-0000-0000-0000-000000000000",version:function(e){if(!s(e))throw TypeError("Invalid UUID");return parseInt(e.substr(14,1),16)},validate:s,stringify:d,parse:y}),N=r(C),K=function(e,t){return function n(){null==t&&(t=e.length);var r=[].slice.call(arguments);return r.length>=t?e.apply(this,r):function(){return n.apply(this,r.concat([].slice.call(arguments)))}}};var R={exports:{}};!function(e,t){!function(n,r){var a={};n.PubSub?(a=n.PubSub,console.warn("PubSub already loaded, using existing version")):(n.PubSub=a,function(e){var t={},n=-1,r="*";function a(e){var t;for(t in e)if(Object.prototype.hasOwnProperty.call(e,t))return!0;return!1}function i(e){return function(){throw e}}function o(e,t,n){try{e(t,n)}catch(e){setTimeout(i(e),0)}}function s(e,t,n){e(t,n)}function c(e,n,r,a){var i,c=t[n],m=a?s:o;if(Object.prototype.hasOwnProperty.call(t,n))for(i in c)Object.prototype.hasOwnProperty.call(c,i)&&m(c[i],e,r)}function m(e,t,n){return function(){var a=String(e),i=a.lastIndexOf(".");for(c(e,e,t,n);-1!==i;)i=(a=a.substr(0,i)).lastIndexOf("."),c(e,a,t,n);c(e,r,t,n)}}function l(e){var n=String(e);return Boolean(Object.prototype.hasOwnProperty.call(t,n)&&a(t[n]))}function p(e){for(var t=String(e),n=l(t)||l(r),a=t.lastIndexOf(".");!n&&-1!==a;)a=(t=t.substr(0,a)).lastIndexOf("."),n=l(t);return n}function d(e,t,n,r){var a=m(e="symbol"==typeof e?e.toString():e,t,r);return!!p(e)&&(!0===n?a():setTimeout(a,0),!0)}e.publish=function(t,n){return d(t,n,!1,e.immediateExceptions)},e.publishSync=function(t,n){return d(t,n,!0,e.immediateExceptions)},e.subscribe=function(e,r){if("function"!=typeof r)return!1;e="symbol"==typeof e?e.toString():e,Object.prototype.hasOwnProperty.call(t,e)||(t[e]={});var a="uid_"+String(++n);return t[e][a]=r,a},e.subscribeAll=function(t){return e.subscribe(r,t)},e.subscribeOnce=function(t,n){var r=e.subscribe(t,(function(){e.unsubscribe(r),n.apply(this,arguments)}));return e},e.clearAllSubscriptions=function(){t={}},e.clearSubscriptions=function(e){var n;for(n in t)Object.prototype.hasOwnProperty.call(t,n)&&0===n.indexOf(e)&&delete t[n]},e.countSubscriptions=function(e){var n,r,a=0;for(n in t)if(Object.prototype.hasOwnProperty.call(t,n)&&0===n.indexOf(e)){for(r in t[n])a++;break}return a},e.getSubscriptions=function(e){var n,r=[];for(n in t)Object.prototype.hasOwnProperty.call(t,n)&&0===n.indexOf(e)&&r.push(n);return r},e.unsubscribe=function(n){var r,a,i,o=function(e){var n;for(n in t)if(Object.prototype.hasOwnProperty.call(t,n)&&0===n.indexOf(e))return!0;return!1},s="string"==typeof n&&(Object.prototype.hasOwnProperty.call(t,n)||o(n)),c=!s&&"string"==typeof n,m="function"==typeof n,l=!1;if(!s){for(r in t)if(Object.prototype.hasOwnProperty.call(t,r)){if(a=t[r],c&&a[n]){delete a[n],l=n;break}if(m)for(i in a)Object.prototype.hasOwnProperty.call(a,i)&&a[i]===n&&(delete a[i],l=!0)}return l}e.clearSubscriptions(n)}}(a)),void 0!==e&&e.exports&&(t=e.exports=a),t.PubSub=a,e.exports=t=a}("object"==typeof window&&window||n)}(R,R.exports);var D=function(e,t){if(e=e.trim(),(t=t.trim()).startsWith("about:"))return t;const n=function(e){const t={host:"",path:"",query:"",protocol:""};let n=e,r=e.indexOf("//");t.protocol=n.substring(0,r),r+=2;const a=e.indexOf("/",r),i=e.indexOf("?"),o=e.indexOf("#");-1!==o&&(n=n.substring(0,o));if(-1!==i){const e=n.substring(i);t.query=e,n=n.substring(0,i)}if(-1!==a){const e=n.substring(0,a);t.host=e,n=n.substring(a),t.path=n}else t.host=n;return t}(e),r=function(e){const t={href:e,hash:"",query:"",netPath:!1,absolutePath:!1,relativePath:!1};if(q.test(e))return t.netPath=!0,t;"/"===e[0]?t.absolutePath=!0:""!==e&&(t.relativePath=!0);let n=e;const r=e.indexOf("?"),a=e.indexOf("#");if(-1!==a){const e=n.substring(a);t.hash=e,n=n.substring(0,a)}if(-1!==r){const e=n.substring(r);t.query=e,n=n.substring(0,r)}return t.path=n,t}(t);if(!n.protocol&&!r.netPath)throw new Error("Error, protocol is not specified");if(r.netPath)return r.href.startsWith("//")&&(r.href=n.protocol+r.href),function(e){const t=e.indexOf("//")+2,n=!e.includes("/",t),r=!e.includes("?",t),a=!e.includes("#",t);return n&&r&&a}(r.href)?M(r.href):r.href;if(r.absolutePath){const{path:e,query:t,hash:a}=r;return n.host+T(e)+t+a}if(r.relativePath){const{path:e,query:t,hash:a}=r;let i,o=n.path,s=n.host;return 0===e.length?i=o:(o=o.substring(0,o.lastIndexOf("/")),i=T(o+"/"+e)),s+=""!==i||t||a?i+t+a:"/",s}{const{host:e,path:t,query:a}=n;return t||a?e+t+a+r.hash:M(e)}};function M(e){return e+("/"===e[e.length-1]?"":"/")}function T(e){let t=e.split("/");""===t[0]&&(t=t.slice(1));let n=[];return t.forEach(((e,r)=>{"."!==e&&(".."===e?n.pop():""===e&&r!==t.length-1||n.push(e))})),"/"+n.join("/")}const q=new RegExp("^([a-z][a-z0-9+.-]*:)?//","i");const L=D,k={null:e=>null===e,boolean:e=>"boolean"==typeof e,object:e=>"object"==typeof e&&!Array.isArray(e)&&null!==e,array:e=>Array.isArray(e),number:e=>"number"==typeof e,integer:e=>Number.isInteger(e),string:e=>"string"==typeof e},V=e=>{const t=e.indexOf("#"),n=-1===t?e.length:t,r=e.slice(0,n),a=e.slice(n+1);return[decodeURI(r),decodeURI(a)]},U=e=>{const t=RegExp(/^(.+):\/\//).exec(e);return t?t[1]:""};var _={jsonTypeOf:(e,t)=>k[t](e),splitUrl:V,safeResolveUrl:(e,t)=>{const n=L(e,t),r=V(e)[0];if(r&&"file"===U(n)&&"file"!==U(r))throw Error(`Can't access file '${n}' resource from network context '${e}'`);return n},pathRelative:(e,t)=>{if(e===t)return"";let n=1;const r=e.length-1,a=t.length-n,i=r<a?r:a;let o=-1,s=0;for(;s<i;s++){const r=e.charCodeAt(s+1);if(r!==t.charCodeAt(n+s))break;47===r&&(o=s)}if(a>i){if(47===t.charCodeAt(n+s))return t.slice(n+s+1);if(0===s)return t.slice(n+s)}r>i&&(47===e.charCodeAt(s+1)?o=s:0===i&&(o=0));let c="";for(s=o+2;s<=e.length;++s)s!==e.length&&47!==e.charCodeAt(s)||(c+=0===c.length?"..":"/..");return n+=o,c.length>0?`${c}${t.slice(n,t.length)}`:(47===t.charCodeAt(n)&&++n,t.slice(n,t.length))}};const J=K,z=e=>{if(e.length>0&&"/"!==e[0])throw Error("Invalid JSON Pointer");return e.split("/").slice(1).map(H)},F=(e,t,n,r)=>{if(0===e.length)return n;if(e.length>1){const a=e.shift();return{...t,[a]:F(e,Y(t,a,r),n,W(a,r))}}if(Array.isArray(t)){const r=[...t];return r[Q(t,e[0])]=n,r}return"object"==typeof t&&null!==t?{...t,[e[0]]:n}:Y(t,e[0],r)},B=(e,t,n,r)=>{if(0!==e.length)if(1!==e.length||ee(t)){const a=e.shift();B(e,Y(t,a,r),n,W(a,r))}else{t[Q(t,e[0])]=n}},Z=(e,t,n)=>{if(0!=e.length){if(e.length>1){const r=e.shift(),a=Y(t,r,n);return{...t,[r]:Z(e,a,W(r,n))}}if(Array.isArray(t))return t.filter(((t,n)=>n!=e[0]));if("object"==typeof t&&null!==t){const{[e[0]]:n,...r}=t;return r}return Y(t,e[0],n)}},G=(e,t,n)=>{if(0!==e.length)if(e.length>1){const r=e.shift(),a=Y(t,r,n);G(e,a,W(r,n))}else Array.isArray(t)?t.splice(e[0],1):"object"==typeof t&&null!==t?delete t[e[0]]:Y(t,e[0],n)},W=J(((e,t)=>t+"/"+X(e))),X=e=>e.toString().replace(/~/g,"~0").replace(/\//g,"~1"),H=e=>e.toString().replace(/~1/g,"/").replace(/~0/g,"~"),Q=(e,t)=>Array.isArray(e)&&"-"===t?e.length:t,Y=(e,t,n="")=>{if(void 0===e)throw TypeError(`Value at '${n}' is undefined and does not have property '${t}'`);if(null===e)throw TypeError(`Value at '${n}' is null and does not have property '${t}'`);if(ee(e))throw TypeError(`Value at '${n}' is a ${typeof e} and does not have property '${t}'`);return e[Q(e,t)]},ee=e=>null===e||"object"!=typeof e;var te={nil:"",append:W,get:(e,t)=>{const n=z(e),r=e=>n.reduce((([e,t],n)=>[Y(e,n,t),W(n,t)]),[e,""])[0];return void 0===t?r:r(t)},set:(e,t,n)=>{const r=z(e),a=J(((e,t)=>F(r,e,t,"")));return void 0===t?a:a(t,n)},assign:(e,t,n)=>{const r=z(e),a=J(((e,t)=>B(r,e,t,"")));return void 0===t?a:a(t,n)},unset:(e,t)=>{const n=z(e),r=e=>Z(n,e,"");return void 0===t?r:r(t)},remove:(e,t)=>{const n=z(e),r=e=>G(n,e,"");return void 0===t?r:r(t)}};const ne=Symbol("$__value"),re=Symbol("$__href");var ae={cons:(e,t)=>Object.freeze({[re]:e,[ne]:t}),isReference:e=>e&&void 0!==e[re],href:e=>e[re],value:e=>e[ne]};const ie=te,oe=K,{jsonTypeOf:se}=_,ce=ae,me=Object.freeze({id:"",pointer:"",instance:void 0,value:void 0}),le=e=>ce.isReference(e.value)?ce.value(e.value):e.value,pe=oe(((e,t)=>se(le(e),t))),de=(e,t)=>Object.freeze({...t,pointer:ie.append(e,t.pointer),value:le(t)[e]}),ue=oe(((e,t)=>le(t).map(((n,r,a,i)=>e(de(r,t),r,a,i))))),fe=oe(((e,t)=>le(t).map(((e,n,r,a)=>de(n,t))).filter(((t,n,r,a)=>e(t,n,r,a))))),ye=oe(((e,t,n)=>le(n).reduce(((t,r,a)=>e(t,de(a,n),a)),t))),he=oe(((e,t)=>le(t).every(((n,r,a,i)=>e(de(r,t),r,a,i))))),ve=oe(((e,t)=>le(t).some(((n,r,a,i)=>e(de(r,t),r,a,i)))));var ge={nil:me,cons:(e,t="")=>Object.freeze({...me,id:t,instance:e,value:e}),uri:e=>`${e.id}#${encodeURI(e.pointer)}`,value:le,has:(e,t)=>e in le(t),typeOf:pe,step:de,entries:e=>Object.keys(le(e)).map((t=>[t,de(t,e)])),keys:e=>Object.keys(le(e)),map:ue,filter:fe,reduce:ye,every:he,some:ve,length:e=>le(e).length},be={},$e=/; *([!#$%&'*+.^_`|~0-9A-Za-z-]+) *= *("(?:[\u000b\u0020\u0021\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u000b\u0020-\u00ff])*"|[!#$%&'*+.^_`|~0-9A-Za-z-]+) */g,Ie=/^[\u000b\u0020-\u007e\u0080-\u00ff]+$/,we=/^[!#$%&'*+.^_`|~0-9A-Za-z-]+$/,Oe=/\\([\u000b\u0020-\u00ff])/g,xe=/([\\"])/g,Se=/^[!#$%&'*+.^_`|~0-9A-Za-z-]+\/[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;function je(e){var t=String(e);if(we.test(t))return t;if(t.length>0&&!Ie.test(t))throw new TypeError("invalid parameter value");return'"'+t.replace(xe,"\\$1")+'"'}function Ee(e){this.parameters=Object.create(null),this.type=e}be.format=function(e){if(!e||"object"!=typeof e)throw new TypeError("argument obj is required");var t=e.parameters,n=e.type;if(!n||!Se.test(n))throw new TypeError("invalid type");var r=n;if(t&&"object"==typeof t)for(var a,i=Object.keys(t).sort(),o=0;o<i.length;o++){if(a=i[o],!we.test(a))throw new TypeError("invalid parameter name");r+="; "+a+"="+je(t[a])}return r},be.parse=function(e){if(!e)throw new TypeError("argument string is required");var t="object"==typeof e?function(e){var t;"function"==typeof e.getHeader?t=e.getHeader("content-type"):"object"==typeof e.headers&&(t=e.headers&&e.headers["content-type"]);if("string"!=typeof t)throw new TypeError("content-type header is missing from object");return t}(e):e;if("string"!=typeof t)throw new TypeError("argument string is required to be a string");var n=t.indexOf(";"),r=-1!==n?t.substr(0,n).trim():t.trim();if(!Se.test(r))throw new TypeError("invalid media type");var a=new Ee(r.toLowerCase());if(-1!==n){var i,o,s;for($e.lastIndex=n;o=$e.exec(t);){if(o.index!==n)throw new TypeError("invalid parameter format");n+=o[0].length,i=o[1].toLowerCase(),'"'===(s=o[2])[0]&&(s=s.substr(1,s.length-2).replace(Oe,"$1")),a.parameters[i]=s}if(n!==t.length)throw new TypeError("invalid parameter format")}return a};var Pe=async e=>Object.entries(await e);var Ae=K((async(e,t)=>(await t).map(e)));var Ce=K((async(e,t,n)=>(await n).reduce((async(t,n)=>e(await t,n)),t)));const Ne=Ce;var Ke=K((async(e,t,n={})=>Ne((async(t,n)=>await e(n)?t.concat([n]):t),[],t,n)));const Re=Ae;var De=K((async(e,t)=>{const n=await Re(e,t);return(await Promise.all(n)).some((e=>e))}));const Me=Ae;var Te=K((async(e,t)=>{const n=await Me(e,t);return(await Promise.all(n)).every((e=>e))}));var qe=K(((e,t)=>e.reduce((async(e,t)=>t(await e)),t)));const Le=qe,ke=Pe,Ve=Ce;var Ue={entries:Pe,map:Ae,filter:Ke,reduce:Ce,some:De,every:Te,pipeline:qe,all:e=>Promise.all(e),allValues:e=>Le([ke,Ve((async(e,[t,n])=>(e[t]=await n,e)),{})],e)},_e=fetch;const Je=be,ze=K,Fe=Ue,Be=te,{jsonTypeOf:Ze,splitUrl:Ge,safeResolveUrl:We,pathRelative:Xe}=_,He=_e,Qe=ae,Ye={},et={},tt=(e,t)=>{const n=e in et?et[e]:e;if(n in Ye)return Ye[n][t]},nt={},rt={},at=(e,t="",n="")=>{e=JSON.parse(JSON.stringify(e));const r=Ge(e.$schema||n)[0];if(!r)throw Error("Couldn't determine schema version");delete e.$schema;const a=tt(r,"baseToken"),i=tt(r,"anchorToken"),o=Ge(t)[0];if(!o&&!Ge(e[a]||"")[0])throw Error("Couldn't determine an identifier for the schema");const s=We(o,e[a]||""),[c,m]=Ge(s);delete e[a],m&&a===i&&(e[i]=i!==a?encodeURI(m):`#${encodeURI(m)}`),o&&(rt[o]=c);const l={},p=tt(r,"recursiveAnchorToken");let d;!0===e[p]&&(l[""]=`${c}#`,e[i]="",delete e[p]);const u=tt(r,"vocabularyToken");Ze(e[u],"object")?(et[c]=r,d=e[u],delete e[u]):(et[c]=r,d={[r]:!0});const f={"":""};return nt[c]={id:c,schemaVersion:r,schema:it(e,c,r,Be.nil,f,l),anchors:f,dynamicAnchors:l,vocabulary:d,validated:!1},c},it=(e,t,n,r,a,i)=>{if(Ze(e,"object")){const o="string"==typeof e.$schema?Ge(e.$schema)[0]:n,s=tt(o,"embeddedToken"),c=tt(o,"anchorToken");if("string"==typeof e[s]&&(s!==c||"#"!==e[s][0])){const r=We(t,e[s]);return e[s]=r,at(e,r,n),Qe.cons(e[s],e)}const m=tt(n,"anchorToken"),l=tt(n,"dynamicAnchorToken");"string"==typeof e[l]&&(i[e[l]]=`${t}#${encodeURI(r)}`,a[e[l]]=r,delete e[l]);const p=tt(n,"embeddedToken");if("string"==typeof e[m]){const t=m!==p?e[m]:e[m].slice(1);a[t]=r,delete e[m]}const d=tt(n,"jrefToken");if("string"==typeof e[d])return Qe.cons(e[d],e);for(const o in e)e[o]=it(e[o],t,n,Be.append(o,r),a,i);return e}return Array.isArray(e)?e.map(((e,o)=>it(e,t,n,Be.append(o,r),a,i))):e},ot=e=>nt[rt[e]]||nt[e],st=Object.freeze({id:"",schemaVersion:void 0,vocabulary:{},pointer:Be.nil,schema:void 0,value:void 0,anchors:{},dynamicAnchors:{},validated:!0}),ct=async(e,t=st)=>{const n=We(pt(t),e),[r,a]=Ge(n);if(!(e=>e in nt||e in rt)(r)){const e=await He(r,{headers:{Accept:"application/schema+json"}});if(e.status>=400)throw await e.text(),Error(`Failed to retrieve schema with id: ${r}`);if(e.headers.has("content-type")){const t=Je.parse(e.headers.get("content-type")).type;if("application/schema+json"!==t)throw Error(`${r} is not a schema. Found a document with media type: ${t}`)}at(await e.json(),r)}const i=ot(r),o="/"!==a[0]?lt(i,a):a,s=Object.freeze({...i,pointer:o,value:Be.get(o,i.schema)});return mt(s)},mt=e=>Qe.isReference(e.value)?ct(Qe.href(e.value),e):e,lt=(e,t)=>{if(!(t in e.anchors))throw Error(`No such anchor '${encodeURI(e.id)}#${encodeURI(t)}'`);return e.anchors[t]},pt=e=>`${e.id}#${encodeURI(e.pointer)}`,dt=e=>Qe.isReference(e.value)?Qe.value(e.value):e.value,ut=(e,t)=>{const n=ot(t.id),r=Object.freeze({...t,pointer:Be.append(e,t.pointer),value:dt(t)[e],validated:n.validated});return mt(r)},ft=ze(((e,t)=>Fe.pipeline([dt,Fe.map((async(n,r)=>e(await ut(r,t),r))),Fe.all],t))),yt={parentId:"",parentDialect:"",includeEmbedded:!0},ht=(e,t)=>{if(t.startsWith("file://")){const n=e.slice(7,e.lastIndexOf("/"));return""===e?"":Xe(n,t.slice(7))}return t};var vt={setConfig:(e,t,n)=>{Ye[e]||(Ye[e]={}),Ye[e][t]=n},getConfig:tt,add:at,get:ct,markValidated:e=>{nt[e].validated=!0},uri:pt,value:dt,getAnchorPointer:lt,typeOf:(e,t)=>Ze(dt(e),t),has:(e,t)=>e in dt(t),step:ut,keys:e=>Object.keys(dt(e)),entries:e=>Fe.pipeline([dt,Object.keys,Fe.map((async t=>[t,await ut(t,e)])),Fe.all],e),map:ft,length:e=>dt(e).length,toSchema:(e,t={})=>{const n={...yt,...t},r=JSON.parse(JSON.stringify(e.schema,((t,r)=>{if(!Qe.isReference(r))return r;const a=Qe.value(r),i=a.$schema||e.schemaVersion,o=tt(i,"embeddedToken");return!n.includeEmbedded&&o in a?void 0:Qe.value(r)}))),a=tt(e.schemaVersion,"dynamicAnchorToken");Object.entries(e.dynamicAnchors).forEach((([e,t])=>{const n=Ge(t)[1];Be.assign(n,r,{[a]:e,...Be.get(n,r)})}));const i=tt(e.schemaVersion,"anchorToken");Object.entries(e.anchors).filter((([e])=>""!==e)).forEach((([e,t])=>{Be.assign(t,r,{[i]:e,...Be.get(t,r)})}));const o=tt(e.schemaVersion,"baseToken"),s=ht(n.parentId,e.id),c=n.parentDialect===e.schemaVersion?"":e.schemaVersion;return{...s&&{[o]:s},...c&&{$schema:c},...r}}};class gt extends Error{constructor(e){super("Invalid Schema"),this.name=this.constructor.name,this.output=e}}var bt=gt;const $t=K,It=R.exports,{splitUrl:wt}=_,Ot=ge,xt=vt,St=bt,jt="FLAG",Et="BASIC",Pt="DETAILED",At="VERBOSE";let Ct=Pt,Nt=!0;const Kt=async e=>{const t={metaData:{}};return{ast:t,schemaUri:await Vt(e,t)}},Rt=$t((({ast:e,schemaUri:t},n,r=jt)=>{if(![jt,Et,Pt,At].includes(r))throw Error(`The '${r}' error format is not supported`);const a=[],i=It.subscribe("result",Dt(r,a));return _t(t,n,e,{}),It.unsubscribe(i),a[0]})),Dt=(e,t)=>{const n=[];return(r,a)=>{if("result"===r){const{keyword:e,absoluteKeywordLocation:t,instanceLocation:r,valid:i}=a,o={keyword:e,absoluteKeywordLocation:t,instanceLocation:r,valid:i,errors:[]};n.push(o)}else if("result.start"===r)n.push(r);else if("result.end"===r){const r=n.pop();for(;"result.start"!==n[n.length-1];){const t=n.pop(),a=[t];e===Et&&(a.push(...t.errors),delete t.errors),(e===At||e!==jt&&!t.valid)&&r.errors.unshift(...a)}n[n.length-1]=r,t[0]=r}}},Mt={},Tt=e=>Mt[e],qt=e=>e in Mt,Lt={},kt={},Vt=async(e,t)=>{if(e=await Ut(e),!qt(`${e.schemaVersion}#validate`)){const t=await xt.get(e.schemaVersion);(xt.getConfig(t.id,"mandatoryVocabularies")||[]).forEach((e=>{if(!t.vocabulary[e])throw Error(`Vocabulary '${e}' must be explicitly declared and required`)})),Object.entries(t.vocabulary).forEach((([e,n])=>{if(e in Lt)Object.entries(Lt[e]).forEach((([e,n])=>{((e,t)=>{Mt[e]={collectEvaluatedItems:(e,n,r,a,i)=>t.interpret(e,n,r,a,i)&&new Set,collectEvaluatedProperties:(e,n,r,a,i)=>t.interpret(e,n,r,a,i)&&[],...t}})(`${t.id}#${e}`,n)}));else if(n)throw Error(`Missing required vocabulary: ${e}`)}))}if(Nt&&!e.validated){if(xt.markValidated(e.id),!(e.schemaVersion in kt)){const t=await xt.get(e.schemaVersion),n=await Kt(t);kt[t.id]=Rt(n)}const t=Ot.cons(e.schema,e.id),n=kt[e.schemaVersion](t,Ct);if(!n.valid)throw new St(n)}return e.id in t.metaData||(t.metaData[e.id]={id:e.id,dynamicAnchors:e.dynamicAnchors,anchors:e.anchors}),Tt(`${e.schemaVersion}#validate`).compile(e,t)},Ut=async e=>xt.typeOf(e,"string")?Ut(await xt.get(xt.value(e),e)):e,_t=(e,t,n,r)=>{const a=Jt(e,n),i=wt(e)[0];return Tt(a).interpret(e,t,n,{...n.metaData[i].dynamicAnchors,...r})},Jt=(e,t)=>{if(!(e in t))throw Error(`No schema found at ${e}`);return t[e][0]};var zt={validate:async(e,t,n)=>{const r=await Kt(e),a=(e,t)=>Rt(r,Ot.cons(e),t);return void 0===t?a:a(t,n)},compile:Kt,interpret:Rt,setMetaOutputFormat:e=>{Ct=e},setShouldMetaValidate:e=>{Nt=e},FLAG:jt,BASIC:Et,DETAILED:Pt,VERBOSE:At,add:(e,t="",n="")=>{const r=xt.add(e,t,n);delete kt[r]},getKeyword:Tt,hasKeyword:qt,defineVocabulary:(e,t)=>{Lt[e]=t},compileSchema:Vt,interpretSchema:_t,collectEvaluatedProperties:(e,t,n,r,a)=>{const i=Jt(e,n);return Tt(i).collectEvaluatedProperties(e,t,n,r,a)},collectEvaluatedItems:(e,t,n,r,a)=>{const i=Jt(e,n);return Tt(i).collectEvaluatedItems(e,t,n,r,a)}};const Ft=vt;var Bt={compile:e=>Ft.value(e),interpret:()=>!0};const Zt=Ue,Gt=R.exports,Wt=zt,Xt=ge,Ht=vt;var Qt={compile:async(e,t)=>{const n=Ht.uri(e);if(!(n in t)){t[n]=!1;const r=Ht.value(e);if(!["object","boolean"].includes(typeof r))throw Error(`No schema found at '${Ht.uri(e)}'`);t[n]=[`${e.schemaVersion}#validate`,Ht.uri(e),"boolean"==typeof r?r:await Zt.pipeline([Ht.entries,Zt.map((([t,n])=>[`${e.schemaVersion}#${t}`,n])),Zt.filter((([t])=>Wt.hasKeyword(t)&&t!==`${e.schemaVersion}#validate`)),Zt.map((async([n,r])=>{const a=await Wt.getKeyword(n).compile(r,t,e);return[n,Ht.uri(r),a]})),Zt.all],e)]}return n},interpret:(e,t,n,r)=>{const[a,i,o]=n[e];Gt.publishSync("result.start");const s="boolean"==typeof o?o:o.every((([e,a,i])=>{Gt.publishSync("result.start");const o=Wt.getKeyword(e).interpret(i,t,n,r);return Gt.publishSync("result",{keyword:e,absoluteKeywordLocation:a,instanceLocation:Xt.uri(t),valid:o,ast:i}),Gt.publishSync("result.end"),o}));return Gt.publishSync("result",{keyword:a,absoluteKeywordLocation:i,instanceLocation:Xt.uri(t),valid:s,ast:e}),Gt.publishSync("result.end"),s},collectEvaluatedProperties:(e,t,n,r,a=!1)=>{const i=n[e][2];return"boolean"==typeof i?!!i&&[]:i.filter((([e])=>!a||!e.endsWith("#unevaluatedProperties"))).reduce(((e,[a,,i])=>{const o=e&&Wt.getKeyword(a).collectEvaluatedProperties(i,t,n,r);return!1!==o&&[...e,...o]}),[])},collectEvaluatedItems:(e,t,n,r,a=!1)=>{const i=n[e][2];return"boolean"==typeof i?!!i&&new Set:i.filter((([e])=>!a||!e.endsWith("#unevaluatedItems"))).reduce(((e,[a,,i])=>{const o=!1!==e&&Wt.getKeyword(a).collectEvaluatedItems(i,t,n,r);return!1!==o&&new Set([...e,...o])}),new Set)}};var Yt={Core:zt,Schema:vt,Instance:ge,Reference:ae,Keywords:{metaData:Bt,validate:Qt},InvalidSchemaError:bt};const{Core:en,Schema:tn,Instance:nn}=Yt;var rn={compile:async(e,t,n)=>{const r=await tn.step("items",n),a=tn.typeOf(r,"array")?tn.length(r):Number.MAX_SAFE_INTEGER;return tn.typeOf(e,"boolean")?[a,tn.value(e)]:[a,await en.compileSchema(e,t)]},interpret:([e,t],n,r,a)=>!nn.typeOf(n,"array")||("string"==typeof t?nn.every(((n,i)=>i<e||en.interpretSchema(t,n,r,a)),n):nn.every(((n,r)=>r<e||t),n))};const{Core:an,Schema:on,Instance:sn}=Yt,cn=([e,t],n,r,a)=>!sn.typeOf(n,"array")||sn.every(((n,i)=>i<e||an.interpretSchema(t,n,r,a)),n);var mn={compile:async(e,t,n)=>{const r=await on.step("items",n);return[on.typeOf(r,"array")?on.length(r):Number.MAX_SAFE_INTEGER,await an.compileSchema(e,t)]},interpret:cn,collectEvaluatedItems:(e,t,n,r)=>cn(e,t,n,r)&&new Set(sn.map(((e,t)=>t),t))};const{Core:ln,Schema:pn,Instance:dn}=Yt;var un={compile:async(e,t,n)=>{const r=await pn.step("properties",n),a=pn.typeOf(r,"object")?pn.keys(r):[],i=await pn.step("patternProperties",n),o=pn.typeOf(i,"object")?pn.keys(i).map((e=>new RegExp(e))):[];return pn.typeOf(e,"boolean")?[a,o,pn.value(e)]:[a,o,await ln.compileSchema(e,t)]},interpret:([e,t,n],r,a,i)=>{if(!dn.typeOf(r,"object"))return!0;const o=dn.entries(r).filter((([n])=>!e.includes(n)&&!t.some((e=>e.test(n)))));return"string"==typeof n?o.every((([,e])=>ln.interpretSchema(n,e,a,i))):0===o.length||n}};const{Core:fn,Schema:yn,Instance:hn}=Yt,vn=([e,t,n],r,a,i)=>!hn.typeOf(r,"object")||hn.entries(r).filter((([n])=>!e.includes(n)&&!t.some((e=>e.test(n))))).every((([,e])=>fn.interpretSchema(n,e,a,i)));var gn={compile:async(e,t,n)=>{const r=await yn.step("properties",n),a=yn.typeOf(r,"object")?yn.keys(r):[],i=await yn.step("patternProperties",n),o=yn.typeOf(i,"object")?yn.keys(i).map((e=>new RegExp(e))):[];return[a,o,await fn.compileSchema(e,t)]},interpret:vn,collectEvaluatedProperties:(e,t,n,r)=>vn(e,t,n,r)&&[new RegExp("")]};const{Core:bn,Schema:$n}=Yt,In=Ue;var wn={compile:(e,t)=>In.pipeline([$n.map((async e=>bn.compileSchema(await e,t))),In.all],e),interpret:(e,t,n,r)=>e.every((e=>bn.interpretSchema(e,t,n,r))),collectEvaluatedProperties:(e,t,n,r)=>e.reduce(((e,a)=>{const i=e&&bn.collectEvaluatedProperties(a,t,n,r);return!1!==i&&[...e,...i]}),[]),collectEvaluatedItems:(e,t,n,r)=>e.reduce(((e,a)=>{const i=!1!==e&&bn.collectEvaluatedItems(a,t,n,r);return!1!==i&&new Set([...e,...i])}),new Set)};const{Core:On,Schema:xn}=Yt,Sn=Ue;var jn={compile:(e,t)=>Sn.pipeline([xn.map((async e=>On.compileSchema(await e,t))),Sn.all],e),interpret:(e,t,n,r)=>e.filter((e=>On.interpretSchema(e,t,n,r))).length>0,collectEvaluatedProperties:(e,t,n,r)=>e.reduce(((e,a)=>{const i=On.collectEvaluatedProperties(a,t,n,r);return!1!==i?[...e||[],...i]:e}),!1),collectEvaluatedItems:(e,t,n,r)=>e.reduce(((e,a)=>{const i=On.collectEvaluatedItems(a,t,n,r);return!1!==i?new Set([...e||[],...i]):e}),!1)},En=Object.keys,Pn=JSON.stringify;function An(e,t){var n,r,a,i,o,s,c;if("string"===(c=typeof e))return Pn(e);if(!0===e)return"true";if(!1===e)return"false";if(null===e)return"null";if(e instanceof Array){for(a="[",r=e.length-1,n=0;n<r;n++)a+=An(e[n],!1)+",";return r>-1&&(a+=An(e[n],!1)),a+"]"}if(e instanceof Object){if("function"==typeof e.toJSON)return An(e.toJSON(),t);for(r=(i=En(e).sort()).length,a="",n=0;n<r;)void 0!==(s=An(e[o=i[n]],!0))&&(n&&""!==a&&(a+=","),a+=Pn(o)+":"+s),n++;return"{"+a+"}"}switch(c){case"function":case"undefined":return t?void 0:null;default:return isFinite(e)?e:null}}var Cn=function(e){return""+An(e,!1)};const{Schema:Nn,Instance:Kn}=Yt,Rn=Cn;var Dn={compile:e=>Rn(Nn.value(e)),interpret:(e,t)=>Rn(Kn.value(t))===e};const{Core:Mn,Instance:Tn}=Yt;var qn={compile:(e,t)=>Mn.compileSchema(e,t),interpret:(e,t,n,r)=>!Tn.typeOf(t,"array")||Tn.some((t=>Mn.interpretSchema(e,t,n,r)),t)};const{Core:Ln,Schema:kn,Instance:Vn}=Yt,Un=({contains:e,minContains:t,maxContains:n},r,a,i)=>{if(!Vn.typeOf(r,"array"))return!0;const o=Vn.reduce(((t,n)=>Ln.interpretSchema(e,n,a,i)?t+1:t),0,r);return o>=t&&o<=n};var _n={compile:async(e,t,n)=>{const r=await Ln.compileSchema(e,t),a=await kn.step("minContains",n),i=kn.typeOf(a,"number")?kn.value(a):1,o=await kn.step("maxContains",n);return{contains:r,minContains:i,maxContains:kn.typeOf(o,"number")?kn.value(o):Number.MAX_SAFE_INTEGER}},interpret:Un,collectEvaluatedItems:(e,t,n,r)=>Un(e,t,n,r)&&Vn.reduce(((t,a,i)=>Ln.interpretSchema(e.contains,a,n,r)?t.add(i):t),new Set,t)};const{Core:Jn,Schema:zn}=Yt,Fn=Ue;var Bn={compile:async(e,t)=>{await Fn.pipeline([zn.entries,Fn.map((([,e])=>Jn.compileSchema(e,t))),Fn.all],e)},interpret:()=>!0};const{Core:Zn,Schema:Gn,Instance:Wn}=Yt,Xn=Ue;var Hn={compile:(e,t)=>Xn.pipeline([Gn.entries,Xn.map((async([e,n])=>[e,Gn.typeOf(n,"array")?Gn.value(n):await Zn.compileSchema(n,t)])),Xn.all],e),interpret:(e,t,n,r)=>{const a=Wn.value(t);return!Wn.typeOf(t,"object")||e.every((([e,i])=>!(e in a)||(Array.isArray(i)?i.every((e=>e in a)):Zn.interpretSchema(i,t,n,r))))}};const{Schema:Qn,Instance:Yn}=Yt,er=Ue;var tr={compile:e=>er.pipeline([Qn.entries,er.map((([e,t])=>[e,Qn.value(t)])),er.all],e),interpret:(e,t)=>{const n=Yn.value(t);return!Yn.typeOf(t,"object")||e.every((([e,t])=>!(e in n)||t.every((e=>e in n))))}};const{Core:nr,Schema:rr,Instance:ar}=Yt,ir=Ue;var or={compile:(e,t)=>ir.pipeline([rr.entries,ir.map((async([e,n])=>[e,await nr.compileSchema(n,t)])),ir.all],e),interpret:(e,t,n,r)=>{const a=ar.value(t);return!ar.typeOf(t,"object")||e.every((([e,i])=>!(e in a)||nr.interpretSchema(i,t,n,r)))},collectEvaluatedProperties:(e,t,n,r)=>e.reduce(((e,[a,i])=>{if(!e||!ar.has(a,t))return e;const o=nr.collectEvaluatedProperties(i,t,n,r);return!1!==o&&e.concat(o)}),[])};const{Schema:sr,Instance:cr}=Yt,mr=Cn;var lr={compile:e=>sr.value(e).map(mr),interpret:(e,t)=>e.some((e=>mr(cr.value(t))===e))};const{Schema:pr,Instance:dr}=Yt;var ur={compile:async e=>pr.value(e),interpret:(e,t)=>!dr.typeOf(t,"number")||dr.value(t)<e};const{Schema:fr,Instance:yr}=Yt;var hr={compile:async e=>fr.value(e),interpret:(e,t)=>!yr.typeOf(t,"number")||yr.value(t)>e};const{Core:vr}=Yt;var gr={compile:(e,t)=>vr.compileSchema(e,t),interpret:(e,t,n,r)=>(vr.interpretSchema(e,t,n,r),!0),collectEvaluatedProperties:(e,t,n,r)=>vr.collectEvaluatedProperties(e,t,n,r)||[],collectEvaluatedItems:(e,t,n,r)=>vr.collectEvaluatedItems(e,t,n,r)||new Set};const{Core:br,Schema:$r}=Yt,Ir=(e,t,n,r)=>{const a=n[e][2];return"boolean"==typeof a?a:a.every((([e,,a])=>br.getKeyword(e).interpret(a,t,n,r)))};var wr={compile:async(e,t,n)=>{if($r.has("if",n)){const r=await $r.step("if",n);return[await br.compileSchema(r,t),await br.compileSchema(e,t)]}return[]},interpret:([e,t],n,r,a)=>void 0===e||!Ir(e,n,r,a)||br.interpretSchema(t,n,r,a),collectEvaluatedProperties:([e,t],n,r,a)=>void 0!==e&&Ir(e,n,r,a)?br.collectEvaluatedProperties(t,n,r,a):[],collectEvaluatedItems:([e,t],n,r,a)=>void 0!==e&&Ir(e,n,r,a)?br.collectEvaluatedItems(t,n,r,a):new Set};const{Core:Or,Schema:xr}=Yt,Sr=(e,t,n,r)=>{const a=n[e][2];return"boolean"==typeof a?a:a.every((([e,,a])=>Or.getKeyword(e).interpret(a,t,n,r)))};var jr={compile:async(e,t,n)=>{if(xr.has("if",n)){const r=await xr.step("if",n);return[await Or.compileSchema(r,t),await Or.compileSchema(e,t)]}return[]},interpret:([e,t],n,r,a)=>void 0===e||Sr(e,n,r,a)||Or.interpretSchema(t,n,r,a),collectEvaluatedProperties:([e,t],n,r,a)=>void 0===e||Sr(e,n,r,a)?[]:Or.collectEvaluatedProperties(t,n,r,a),collectEvaluatedItems:([e,t],n,r,a)=>void 0===e||Sr(e,n,r,a)?new Set:Or.collectEvaluatedItems(t,n,r,a)};const{Core:Er,Schema:Pr,Instance:Ar}=Yt,Cr=(e,t,n,r)=>!Ar.typeOf(t,"array")||("string"==typeof e?Ar.every((t=>Er.interpretSchema(e,t,n,r)),t):Ar.every(((t,a)=>!(a in e)||Er.interpretSchema(e[a],t,n,r)),t));var Nr={compile:async(e,t)=>{if(Pr.typeOf(e,"array")){const n=await Pr.map((e=>Er.compileSchema(e,t)),e);return Promise.all(n)}return Er.compileSchema(e,t)},interpret:Cr,collectEvaluatedItems:(e,t,n,r)=>Cr(e,t,n,r)&&("string"==typeof e?new Set(Ar.map(((e,t)=>t),t)):new Set(e.map(((e,t)=>t))))};const{Core:Kr,Schema:Rr,Instance:Dr}=Yt,Mr=([e,t],n,r,a)=>!Dr.typeOf(n,"array")||Dr.every(((n,i)=>i<e||Kr.interpretSchema(t,n,r,a)),n);var Tr={compile:async(e,t,n)=>{const r=await Rr.step("prefixItems",n);return[Rr.typeOf(r,"array")?Rr.length(r):0,await Kr.compileSchema(e,t)]},interpret:Mr,collectEvaluatedItems:(e,t,n,r)=>Mr(e,t,n,r)&&new Set(Dr.map(((e,t)=>t),t))};const{Schema:qr,Instance:Lr}=Yt;var kr={compile:e=>qr.value(e),interpret:(e,t)=>!Lr.typeOf(t,"array")||Lr.length(t)<=e};const{Schema:Vr,Instance:Ur}=Yt;var _r={compile:e=>Vr.value(e),interpret:(e,t)=>!Ur.typeOf(t,"string")||Ur.length(t)<=e};const{Schema:Jr,Instance:zr}=Yt;var Fr={compile:e=>Jr.value(e),interpret:(e,t)=>!zr.typeOf(t,"string")||[...zr.value(t)].length<=e};const{Schema:Br,Instance:Zr}=Yt;var Gr={compile:e=>Br.value(e),interpret:(e,t)=>!Zr.typeOf(t,"object")||Zr.keys(t).length<=e};const{Schema:Wr,Instance:Xr}=Yt;var Hr={compile:async(e,t,n)=>{const r=await Wr.step("exclusiveMaximum",n),a=Wr.value(r);return[Wr.value(e),a]},interpret:([e,t],n)=>{if(!Xr.typeOf(n,"number"))return!0;const r=Xr.value(n);return t?r<e:r<=e}};const{Schema:Qr,Instance:Yr}=Yt;var ea={compile:async e=>Qr.value(e),interpret:(e,t)=>!Yr.typeOf(t,"number")||Yr.value(t)<=e};const{Schema:ta,Instance:na}=Yt;var ra={compile:e=>ta.value(e),interpret:(e,t)=>!na.typeOf(t,"array")||na.length(t)>=e};const{Schema:aa,Instance:ia}=Yt;var oa={compile:e=>aa.value(e),interpret:(e,t)=>!ia.typeOf(t,"string")||ia.length(t)>=e};const{Schema:sa,Instance:ca}=Yt;var ma={compile:e=>sa.value(e),interpret:(e,t)=>!ca.typeOf(t,"string")||[...ca.value(t)].length>=e};const{Schema:la,Instance:pa}=Yt;var da={compile:e=>la.value(e),interpret:(e,t)=>!pa.typeOf(t,"object")||pa.keys(t).length>=e};const{Schema:ua,Instance:fa}=Yt;var ya={compile:async(e,t,n)=>{const r=await ua.step("exclusiveMinimum",n),a=ua.value(r);return[ua.value(e),a]},interpret:([e,t],n)=>{if(!fa.typeOf(n,"number"))return!0;const r=fa.value(n);return t?r>e:r>=e}};const{Schema:ha,Instance:va}=Yt;var ga={compile:async e=>ha.value(e),interpret:(e,t)=>!va.typeOf(t,"number")||va.value(t)>=e};const{Schema:ba,Instance:$a}=Yt,Ia=(e,t)=>Math.abs(e-t)<1.1920929e-7;var wa={compile:e=>ba.value(e),interpret:(e,t)=>{if(!$a.typeOf(t,"number"))return!0;const n=$a.value(t)%e;return Ia(0,n)||Ia(e,n)}};const{Core:Oa}=Yt;var xa={compile:Oa.compileSchema,interpret:(e,t,n,r)=>!Oa.interpretSchema(e,t,n,r)};const{Core:Sa,Schema:ja}=Yt;var Ea={compile:async(e,t)=>{const n=await ja.map((e=>Sa.compileSchema(e,t)),e);return Promise.all(n)},interpret:(e,t,n,r)=>{let a=0;for(const i of e)if(Sa.interpretSchema(i,t,n,r)&&a++,a>1)break;return 1===a},collectEvaluatedProperties:(e,t,n,r)=>{let a=0;return e.reduce(((e,i)=>{if(a>1)return!1;const o=Sa.collectEvaluatedProperties(i,t,n,r);return o?0==a++&&o:e}),!1)},collectEvaluatedItems:(e,t,n,r)=>{let a=0;return e.reduce(((e,i)=>{if(a>1)return!1;const o=Sa.collectEvaluatedItems(i,t,n,r);return o?0==a++&&o:e}),!1)}};const{Schema:Pa,Instance:Aa}=Yt;var Ca={compile:e=>new RegExp(Pa.value(e),"u"),interpret:(e,t)=>!Aa.typeOf(t,"string")||e.test(Aa.value(t))};const{Core:Na,Schema:Ka,Instance:Ra}=Yt,Da=Ue,Ma=(e,t,n,r)=>!Ra.typeOf(t,"object")||e.every((([e,a])=>Ra.entries(t).filter((([t])=>e.test(t))).every((([,e])=>Na.interpretSchema(a,e,n,r)))));var Ta={compile:(e,t)=>Da.pipeline([Ka.entries,Da.map((async([e,n])=>[new RegExp(e,"u"),await Na.compileSchema(n,t)])),Da.all],e),interpret:Ma,collectEvaluatedProperties:(e,t,n,r)=>Ma(e,t,n,r)&&e.map((([e])=>e))};var qa={isObject:e=>"object"==typeof e&&!Array.isArray(e)&&null!==e,escapeRegExp:e=>e.replace(/[.*+\-?^${}()|[\]\\]/g,"\\$&"),splitUrl:e=>{const t=e.indexOf("#"),n=-1===t?e.length:t,r=e.slice(0,n),a=e.slice(n+1);return[decodeURI(r),decodeURI(a)]}};const{Core:La,Schema:ka,Instance:Va}=Yt,Ua=Ue,{escapeRegExp:_a}=qa,Ja=(e,t,n,r)=>!Va.typeOf(t,"object")||Va.entries(t).filter((([t])=>t in e)).every((([t,a])=>La.interpretSchema(e[t],a,n,r)));var za={compile:(e,t)=>Ua.pipeline([ka.entries,Ua.reduce((async(e,[n,r])=>(e[n]=await La.compileSchema(r,t),e)),Object.create(null))],e),interpret:Ja,collectEvaluatedProperties:(e,t,n,r)=>Ja(e,t,n,r)&&Object.keys(e).map((e=>new RegExp(`^${_a(e)}$`)))};const{Core:Fa,Instance:Ba}=Yt;var Za={compile:(e,t)=>Fa.compileSchema(e,t),interpret:(e,t,n,r)=>!Ba.typeOf(t,"object")||Ba.keys(t).every((t=>Fa.interpretSchema(e,Ba.cons(t),n,r)))};const{Core:Ga,Schema:Wa}=Yt,{splitUrl:Xa}=qa;var Ha={compile:async(e,t)=>{const[,n]=Xa(Wa.value(e)),r=await Wa.get(Wa.value(e),e);return await Ga.compileSchema(r,t),[r.id,n]},interpret:([e,t],n,r,a)=>{if(t in r.metaData[e].dynamicAnchors)return Ga.interpretSchema(a[t],n,r,a);{const i=Wa.getAnchorPointer(r.metaData[e],t);return Ga.interpretSchema(`${e}#${encodeURI(i)}`,n,r,a)}},collectEvaluatedProperties:Ga.collectEvaluatedProperties,collectEvaluatedItems:Ga.collectEvaluatedItems};const{Core:Qa,Schema:Ya}=Yt;var ei={compile:async(e,t)=>{const n=await Ya.get(Ya.value(e),e);return Qa.compileSchema(n,t)},interpret:Qa.interpretSchema,collectEvaluatedProperties:Qa.collectEvaluatedProperties,collectEvaluatedItems:Qa.collectEvaluatedItems};const{Schema:ti,Instance:ni}=Yt;var ri={compile:e=>ti.value(e),interpret:(e,t)=>!ni.typeOf(t,"object")||e.every((e=>Object.prototype.hasOwnProperty.call(ni.value(t),e)))};const{Core:ai,Schema:ii,Instance:oi}=Yt,si=Ue,ci=(e,t,n,r)=>!oi.typeOf(t,"array")||oi.every(((t,a)=>!(a in e)||ai.interpretSchema(e[a],t,n,r)),t);var mi={compile:(e,t)=>si.pipeline([ii.map((e=>ai.compileSchema(e,t))),si.all],e),interpret:ci,collectEvaluatedItems:(e,t,n,r)=>ci(e,t,n,r)&&new Set(e.map(((e,t)=>t)))};const{Schema:li,Instance:pi}=Yt;var di={compile:e=>li.value(e),interpret:(e,t)=>"string"==typeof e?pi.typeOf(t,e):e.some(pi.typeOf(t))};const{Core:ui,Schema:fi,Instance:yi}=Yt,hi=([e,t],n,r,a)=>{if(!yi.typeOf(n,"array"))return!0;const i=ui.collectEvaluatedItems(e,n,r,a,!0);return!1===i||yi.every(((e,o)=>i.has(o)||ui.interpretSchema(t,yi.step(o,n),r,a)),n)};var vi={compile:async(e,t,n)=>[fi.uri(n),await ui.compileSchema(e,t)],interpret:hi,collectEvaluatedItems:(e,t,n,r)=>hi(e,t,n,r)&&new Set(yi.map(((e,t)=>t),t))};const{Core:gi,Schema:bi,Instance:$i}=Yt,Ii=([e,t],n,r,a)=>{if(!$i.typeOf(n,"object"))return!0;const i=gi.collectEvaluatedProperties(e,n,r,a,!0);return!i||$i.entries(n).filter((([e])=>!i.some((t=>e.match(t))))).every((([,e])=>gi.interpretSchema(t,e,r,a)))};var wi={compile:async(e,t,n)=>[bi.uri(n),await gi.compileSchema(e,t)],interpret:Ii,collectEvaluatedProperties:(e,t,n,r)=>Ii(e,t,n,r)&&[new RegExp("")]};const{Schema:Oi,Instance:xi}=Yt,Si=Cn;var ji={compile:e=>Oi.value(e),interpret:(e,t)=>{if(!xi.typeOf(t,"array")||!1===e)return!0;const n=xi.map((e=>Si(xi.value(e))),t);return new Set(n).size===n.length}};const{Keywords:Ei}=Yt;var Pi={additionalItems:rn,additionalItems6:mn,additionalProperties:un,additionalProperties6:gn,allOf:wn,anyOf:jn,const:Dn,contains:qn,containsMinContainsMaxContains:_n,definitions:Bn,dependencies:Hn,dependentRequired:tr,dependentSchemas:or,enum:lr,exclusiveMaximum:ur,exclusiveMinimum:hr,if:gr,then:wr,else:jr,items:Nr,items202012:Tr,maxItems:kr,maxLength:_r,maxLength6:Fr,maxProperties:Gr,maximumExclusiveMaximum:Hr,maximum:ea,metaData:Ei.metaData,minItems:ra,minLength:oa,minLength6:ma,minProperties:da,minimumExclusiveMinimum:ya,minimum:ga,multipleOf:wa,not:xa,oneOf:Ea,pattern:Ca,patternProperties:Ta,properties:za,propertyNames:Za,dynamicRef:Ha,ref:ei,required:ri,tupleItems:mi,type:di,unevaluatedItems:vi,unevaluatedProperties:wi,uniqueItems:ji,validate:Ei.validate};const{Core:Ai,Schema:Ci}=Yt,Ni=Pi,Ki="http://json-schema.org/draft-04/schema";Ci.setConfig(Ki,"baseToken","id"),Ci.setConfig(Ki,"embeddedToken","id"),Ci.setConfig(Ki,"anchorToken","id"),Ci.setConfig(Ki,"jrefToken","$ref"),Ci.add(JSON.parse('{\n    "id": "http://json-schema.org/draft-04/schema#",\n    "$schema": "http://json-schema.org/draft-04/schema#",\n    "description": "Core schema meta-schema",\n    "definitions": {\n        "schemaArray": {\n            "type": "array",\n            "minItems": 1,\n            "items": { "$ref": "#" }\n        },\n        "positiveInteger": {\n            "type": "integer",\n            "minimum": 0\n        },\n        "positiveIntegerDefault0": {\n            "allOf": [ { "$ref": "#/definitions/positiveInteger" }, { "default": 0 } ]\n        },\n        "simpleTypes": {\n            "enum": [ "array", "boolean", "integer", "null", "number", "object", "string" ]\n        },\n        "stringArray": {\n            "type": "array",\n            "items": { "type": "string" },\n            "minItems": 1,\n            "uniqueItems": true\n        }\n    },\n    "type": "object",\n    "properties": {\n        "id": {\n            "type": "string"\n        },\n        "$schema": {\n            "type": "string"\n        },\n        "title": {\n            "type": "string"\n        },\n        "description": {\n            "type": "string"\n        },\n        "default": {},\n        "multipleOf": {\n            "type": "number",\n            "minimum": 0,\n            "exclusiveMinimum": true\n        },\n        "maximum": {\n            "type": "number"\n        },\n        "exclusiveMaximum": {\n            "type": "boolean",\n            "default": false\n        },\n        "minimum": {\n            "type": "number"\n        },\n        "exclusiveMinimum": {\n            "type": "boolean",\n            "default": false\n        },\n        "maxLength": { "$ref": "#/definitions/positiveInteger" },\n        "minLength": { "$ref": "#/definitions/positiveIntegerDefault0" },\n        "pattern": {\n            "type": "string",\n            "format": "regex"\n        },\n        "additionalItems": {\n            "anyOf": [\n                { "type": "boolean" },\n                { "$ref": "#" }\n            ],\n            "default": {}\n        },\n        "items": {\n            "anyOf": [\n                { "$ref": "#" },\n                { "$ref": "#/definitions/schemaArray" }\n            ],\n            "default": {}\n        },\n        "maxItems": { "$ref": "#/definitions/positiveInteger" },\n        "minItems": { "$ref": "#/definitions/positiveIntegerDefault0" },\n        "uniqueItems": {\n            "type": "boolean",\n            "default": false\n        },\n        "maxProperties": { "$ref": "#/definitions/positiveInteger" },\n        "minProperties": { "$ref": "#/definitions/positiveIntegerDefault0" },\n        "required": { "$ref": "#/definitions/stringArray" },\n        "additionalProperties": {\n            "anyOf": [\n                { "type": "boolean" },\n                { "$ref": "#" }\n            ],\n            "default": {}\n        },\n        "definitions": {\n            "type": "object",\n            "additionalProperties": { "$ref": "#" },\n            "default": {}\n        },\n        "properties": {\n            "type": "object",\n            "additionalProperties": { "$ref": "#" },\n            "default": {}\n        },\n        "patternProperties": {\n            "type": "object",\n            "additionalProperties": { "$ref": "#" },\n            "default": {}\n        },\n        "dependencies": {\n            "type": "object",\n            "additionalProperties": {\n                "anyOf": [\n                    { "$ref": "#" },\n                    { "$ref": "#/definitions/stringArray" }\n                ]\n            }\n        },\n        "enum": {\n            "type": "array",\n            "minItems": 1,\n            "uniqueItems": true\n        },\n        "type": {\n            "anyOf": [\n                { "$ref": "#/definitions/simpleTypes" },\n                {\n                    "type": "array",\n                    "items": { "$ref": "#/definitions/simpleTypes" },\n                    "minItems": 1,\n                    "uniqueItems": true\n                }\n            ]\n        },\n        "format": { "type": "string" },\n        "allOf": { "$ref": "#/definitions/schemaArray" },\n        "anyOf": { "$ref": "#/definitions/schemaArray" },\n        "oneOf": { "$ref": "#/definitions/schemaArray" },\n        "not": { "$ref": "#" }\n    },\n    "dependencies": {\n        "exclusiveMaximum": [ "maximum" ],\n        "exclusiveMinimum": [ "minimum" ]\n    },\n    "default": {}\n}')),Ai.defineVocabulary(Ki,{validate:Ni.validate,additionalItems:Ni.additionalItems,additionalProperties:Ni.additionalProperties,allOf:Ni.allOf,anyOf:Ni.anyOf,default:Ni.metaData,definitions:Ni.definitions,dependencies:Ni.dependencies,description:Ni.metaData,enum:Ni.enum,format:Ni.metaData,items:Ni.items,maxItems:Ni.maxItems,maxLength:Ni.maxLength,maxProperties:Ni.maxProperties,maximum:Ni.maximumExclusiveMaximum,minItems:Ni.minItems,minLength:Ni.minLength,minProperties:Ni.minProperties,minimum:Ni.minimumExclusiveMinimum,multipleOf:Ni.multipleOf,not:Ni.not,oneOf:Ni.oneOf,pattern:Ni.pattern,patternProperties:Ni.patternProperties,properties:Ni.properties,required:Ni.required,title:Ni.metaData,type:Ni.type,uniqueItems:Ni.uniqueItems});const{Core:Ri,Schema:Di}=Yt,Mi=Pi,Ti="http://json-schema.org/draft-06/schema";Di.setConfig(Ti,"baseToken","$id"),Di.setConfig(Ti,"embeddedToken","$id"),Di.setConfig(Ti,"anchorToken","$id"),Di.setConfig(Ti,"jrefToken","$ref"),Di.add(JSON.parse('{\n    "$schema": "http://json-schema.org/draft-06/schema#",\n    "$id": "http://json-schema.org/draft-06/schema#",\n    "title": "Core schema meta-schema",\n    "definitions": {\n        "schemaArray": {\n            "type": "array",\n            "minItems": 1,\n            "items": { "$ref": "#" }\n        },\n        "nonNegativeInteger": {\n            "type": "integer",\n            "minimum": 0\n        },\n        "nonNegativeIntegerDefault0": {\n            "allOf": [\n                { "$ref": "#/definitions/nonNegativeInteger" },\n                { "default": 0 }\n            ]\n        },\n        "simpleTypes": {\n            "enum": [\n                "array",\n                "boolean",\n                "integer",\n                "null",\n                "number",\n                "object",\n                "string"\n            ]\n        },\n        "stringArray": {\n            "type": "array",\n            "items": { "type": "string" },\n            "uniqueItems": true,\n            "default": []\n        }\n    },\n    "type": ["object", "boolean"],\n    "properties": {\n        "$id": {\n            "type": "string",\n            "format": "uri-reference"\n        },\n        "$schema": {\n            "type": "string",\n            "format": "uri"\n        },\n        "$ref": {\n            "type": "string",\n            "format": "uri-reference"\n        },\n        "title": {\n            "type": "string"\n        },\n        "description": {\n            "type": "string"\n        },\n        "default": {},\n        "examples": {\n            "type": "array",\n            "items": {}\n        },\n        "multipleOf": {\n            "type": "number",\n            "exclusiveMinimum": 0\n        },\n        "maximum": {\n            "type": "number"\n        },\n        "exclusiveMaximum": {\n            "type": "number"\n        },\n        "minimum": {\n            "type": "number"\n        },\n        "exclusiveMinimum": {\n            "type": "number"\n        },\n        "maxLength": { "$ref": "#/definitions/nonNegativeInteger" },\n        "minLength": { "$ref": "#/definitions/nonNegativeIntegerDefault0" },\n        "pattern": {\n            "type": "string",\n            "format": "regex"\n        },\n        "additionalItems": { "$ref": "#" },\n        "items": {\n            "anyOf": [\n                { "$ref": "#" },\n                { "$ref": "#/definitions/schemaArray" }\n            ],\n            "default": {}\n        },\n        "maxItems": { "$ref": "#/definitions/nonNegativeInteger" },\n        "minItems": { "$ref": "#/definitions/nonNegativeIntegerDefault0" },\n        "uniqueItems": {\n            "type": "boolean",\n            "default": false\n        },\n        "contains": { "$ref": "#" },\n        "maxProperties": { "$ref": "#/definitions/nonNegativeInteger" },\n        "minProperties": { "$ref": "#/definitions/nonNegativeIntegerDefault0" },\n        "required": { "$ref": "#/definitions/stringArray" },\n        "additionalProperties": { "$ref": "#" },\n        "definitions": {\n            "type": "object",\n            "additionalProperties": { "$ref": "#" },\n            "default": {}\n        },\n        "properties": {\n            "type": "object",\n            "additionalProperties": { "$ref": "#" },\n            "default": {}\n        },\n        "patternProperties": {\n            "type": "object",\n            "additionalProperties": { "$ref": "#" },\n            "default": {}\n        },\n        "dependencies": {\n            "type": "object",\n            "additionalProperties": {\n                "anyOf": [\n                    { "$ref": "#" },\n                    { "$ref": "#/definitions/stringArray" }\n                ]\n            }\n        },\n        "propertyNames": { "$ref": "#" },\n        "const": {},\n        "enum": {\n            "type": "array",\n            "minItems": 1,\n            "uniqueItems": true\n        },\n        "type": {\n            "anyOf": [\n                { "$ref": "#/definitions/simpleTypes" },\n                {\n                    "type": "array",\n                    "items": { "$ref": "#/definitions/simpleTypes" },\n                    "minItems": 1,\n                    "uniqueItems": true\n                }\n            ]\n        },\n        "format": { "type": "string" },\n        "allOf": { "$ref": "#/definitions/schemaArray" },\n        "anyOf": { "$ref": "#/definitions/schemaArray" },\n        "oneOf": { "$ref": "#/definitions/schemaArray" },\n        "not": { "$ref": "#" }\n    },\n    "default": {}\n}')),Ri.defineVocabulary(Ti,{validate:Mi.validate,additionalItems:Mi.additionalItems6,additionalProperties:Mi.additionalProperties6,allOf:Mi.allOf,anyOf:Mi.anyOf,const:Mi.const,contains:Mi.contains,default:Mi.metaData,definitions:Mi.definitions,dependencies:Mi.dependencies,description:Mi.metaData,enum:Mi.enum,examples:Mi.metaData,exclusiveMaximum:Mi.exclusiveMaximum,exclusiveMinimum:Mi.exclusiveMinimum,format:Mi.metaData,items:Mi.items,maxItems:Mi.maxItems,maxLength:Mi.maxLength6,maxProperties:Mi.maxProperties,maximum:Mi.maximum,minItems:Mi.minItems,minLength:Mi.minLength6,minProperties:Mi.minProperties,minimum:Mi.minimum,multipleOf:Mi.multipleOf,not:Mi.not,oneOf:Mi.oneOf,pattern:Mi.pattern,patternProperties:Mi.patternProperties,properties:Mi.properties,propertyNames:Mi.propertyNames,required:Mi.required,title:Mi.metaData,type:Mi.type,uniqueItems:Mi.uniqueItems});const{Core:qi,Schema:Li}=Yt,ki=Pi,Vi="http://json-schema.org/draft-07/schema";Li.setConfig(Vi,"baseToken","$id"),Li.setConfig(Vi,"embeddedToken","$id"),Li.setConfig(Vi,"anchorToken","$id"),Li.setConfig(Vi,"jrefToken","$ref"),Li.add(JSON.parse('{\n    "$schema": "http://json-schema.org/draft-07/schema#",\n    "$id": "http://json-schema.org/draft-07/schema#",\n    "title": "Core schema meta-schema",\n    "definitions": {\n        "schemaArray": {\n            "type": "array",\n            "minItems": 1,\n            "items": { "$ref": "#" }\n        },\n        "nonNegativeInteger": {\n            "type": "integer",\n            "minimum": 0\n        },\n        "nonNegativeIntegerDefault0": {\n            "allOf": [\n                { "$ref": "#/definitions/nonNegativeInteger" },\n                { "default": 0 }\n            ]\n        },\n        "simpleTypes": {\n            "enum": [\n                "array",\n                "boolean",\n                "integer",\n                "null",\n                "number",\n                "object",\n                "string"\n            ]\n        },\n        "stringArray": {\n            "type": "array",\n            "items": { "type": "string" },\n            "uniqueItems": true,\n            "default": []\n        }\n    },\n    "type": ["object", "boolean"],\n    "properties": {\n        "$id": {\n            "type": "string",\n            "format": "uri-reference"\n        },\n        "$schema": {\n            "type": "string",\n            "format": "uri"\n        },\n        "$ref": {\n            "type": "string",\n            "format": "uri-reference"\n        },\n        "$comment": {\n            "type": "string"\n        },\n        "title": {\n            "type": "string"\n        },\n        "description": {\n            "type": "string"\n        },\n        "default": true,\n        "readOnly": {\n            "type": "boolean",\n            "default": false\n        },\n        "writeOnly": {\n            "type": "boolean",\n            "default": false\n        },\n        "examples": {\n            "type": "array",\n            "items": true\n        },\n        "multipleOf": {\n            "type": "number",\n            "exclusiveMinimum": 0\n        },\n        "maximum": {\n            "type": "number"\n        },\n        "exclusiveMaximum": {\n            "type": "number"\n        },\n        "minimum": {\n            "type": "number"\n        },\n        "exclusiveMinimum": {\n            "type": "number"\n        },\n        "maxLength": { "$ref": "#/definitions/nonNegativeInteger" },\n        "minLength": { "$ref": "#/definitions/nonNegativeIntegerDefault0" },\n        "pattern": {\n            "type": "string",\n            "format": "regex"\n        },\n        "additionalItems": { "$ref": "#" },\n        "items": {\n            "anyOf": [\n                { "$ref": "#" },\n                { "$ref": "#/definitions/schemaArray" }\n            ],\n            "default": true\n        },\n        "maxItems": { "$ref": "#/definitions/nonNegativeInteger" },\n        "minItems": { "$ref": "#/definitions/nonNegativeIntegerDefault0" },\n        "uniqueItems": {\n            "type": "boolean",\n            "default": false\n        },\n        "contains": { "$ref": "#" },\n        "maxProperties": { "$ref": "#/definitions/nonNegativeInteger" },\n        "minProperties": { "$ref": "#/definitions/nonNegativeIntegerDefault0" },\n        "required": { "$ref": "#/definitions/stringArray" },\n        "additionalProperties": { "$ref": "#" },\n        "definitions": {\n            "type": "object",\n            "additionalProperties": { "$ref": "#" },\n            "default": {}\n        },\n        "properties": {\n            "type": "object",\n            "additionalProperties": { "$ref": "#" },\n            "default": {}\n        },\n        "patternProperties": {\n            "type": "object",\n            "additionalProperties": { "$ref": "#" },\n            "propertyNames": { "format": "regex" },\n            "default": {}\n        },\n        "dependencies": {\n            "type": "object",\n            "additionalProperties": {\n                "anyOf": [\n                    { "$ref": "#" },\n                    { "$ref": "#/definitions/stringArray" }\n                ]\n            }\n        },\n        "propertyNames": { "$ref": "#" },\n        "const": true,\n        "enum": {\n            "type": "array",\n            "items": true,\n            "minItems": 1,\n            "uniqueItems": true\n        },\n        "type": {\n            "anyOf": [\n                { "$ref": "#/definitions/simpleTypes" },\n                {\n                    "type": "array",\n                    "items": { "$ref": "#/definitions/simpleTypes" },\n                    "minItems": 1,\n                    "uniqueItems": true\n                }\n            ]\n        },\n        "format": { "type": "string" },\n        "contentMediaType": { "type": "string" },\n        "contentEncoding": { "type": "string" },\n        "if": { "$ref": "#" },\n        "then": { "$ref": "#" },\n        "else": { "$ref": "#" },\n        "allOf": { "$ref": "#/definitions/schemaArray" },\n        "anyOf": { "$ref": "#/definitions/schemaArray" },\n        "oneOf": { "$ref": "#/definitions/schemaArray" },\n        "not": { "$ref": "#" }\n    },\n    "default": true\n}')),qi.defineVocabulary(Vi,{validate:ki.validate,additionalItems:ki.additionalItems6,additionalProperties:ki.additionalProperties6,allOf:ki.allOf,anyOf:ki.anyOf,const:ki.const,contains:ki.contains,default:ki.metaData,definitions:ki.definitions,dependencies:ki.dependencies,description:ki.metaData,enum:ki.enum,exclusiveMaximum:ki.exclusiveMaximum,exclusiveMinimum:ki.exclusiveMinimum,format:ki.metaData,if:ki.if,then:ki.then,else:ki.else,items:ki.items,maxItems:ki.maxItems,maxLength:ki.maxLength6,maxProperties:ki.maxProperties,maximum:ki.maximum,minItems:ki.minItems,minLength:ki.minLength6,minProperties:ki.minProperties,minimum:ki.minimum,multipleOf:ki.multipleOf,not:ki.not,oneOf:ki.oneOf,pattern:ki.pattern,patternProperties:ki.patternProperties,properties:ki.properties,propertyNames:ki.propertyNames,readOnly:ki.metaData,required:ki.required,title:ki.metaData,type:ki.type,uniqueItems:ki.uniqueItems,writeOnly:ki.metaData});const{Core:Ui,Schema:_i}=Yt,Ji=Pi,zi="https://json-schema.org/draft/2019-09/schema";_i.setConfig(zi,"baseToken","$id"),_i.setConfig(zi,"embeddedToken","$id"),_i.setConfig(zi,"anchorToken","$anchor"),_i.setConfig(zi,"recursiveAnchorToken","$recursiveAnchor"),_i.setConfig(zi,"vocabularyToken","$vocabulary"),_i.setConfig(zi,"mandatoryVocabularies",["https://json-schema.org/draft/2019-09/vocab/core"]),_i.add(JSON.parse('{\n    "$schema": "https://json-schema.org/draft/2019-09/schema",\n    "$id": "https://json-schema.org/draft/2019-09/schema",\n    "$vocabulary": {\n        "https://json-schema.org/draft/2019-09/vocab/core": true,\n        "https://json-schema.org/draft/2019-09/vocab/applicator": true,\n        "https://json-schema.org/draft/2019-09/vocab/validation": true,\n        "https://json-schema.org/draft/2019-09/vocab/meta-data": true,\n        "https://json-schema.org/draft/2019-09/vocab/format": false,\n        "https://json-schema.org/draft/2019-09/vocab/content": true\n    },\n    "$recursiveAnchor": true,\n\n    "title": "Core and Validation specifications meta-schema",\n    "allOf": [\n        {"$ref": "meta/core"},\n        {"$ref": "meta/applicator"},\n        {"$ref": "meta/validation"},\n        {"$ref": "meta/meta-data"},\n        {"$ref": "meta/format"},\n        {"$ref": "meta/content"}\n    ],\n    "type": ["object", "boolean"],\n    "properties": {\n        "definitions": {\n            "$comment": "While no longer an official keyword as it is replaced by $defs, this keyword is retained in the meta-schema to prevent incompatible extensions as it remains in common use.",\n            "type": "object",\n            "additionalProperties": { "$recursiveRef": "#" },\n            "default": {}\n        },\n        "dependencies": {\n            "$comment": "\\"dependencies\\" is no longer a keyword, but schema authors should avoid redefining it to facilitate a smooth transition to \\"dependentSchemas\\" and \\"dependentRequired\\"",\n            "type": "object",\n            "additionalProperties": {\n                "anyOf": [\n                    { "$recursiveRef": "#" },\n                    { "$ref": "meta/validation#/$defs/stringArray" }\n                ]\n            }\n        }\n    }\n}')),_i.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/2019-09/meta/core",\n    "$schema": "https://json-schema.org/draft/2019-09/schema",\n    "$vocabulary": {\n      "https://json-schema.org/draft/2019-09/vocab/core": true\n    },\n    "$recursiveAnchor": true,\n\n    "title": "Core vocabulary meta-schema",\n    "type": ["object", "boolean"],\n    "properties": {\n        "$id": {\n            "type": "string",\n            "format": "uri-reference",\n            "$comment": "Non-empty fragments not allowed.",\n            "pattern": "^[^#]*#?$"\n        },\n        "$schema": {\n            "type": "string",\n            "format": "uri"\n        },\n        "$anchor": {\n            "type": "string",\n            "pattern": "^[A-Za-z][-A-Za-z0-9.:_]*$"\n        },\n        "$ref": {\n            "type": "string",\n            "format": "uri-reference"\n        },\n        "$recursiveRef": {\n            "type": "string",\n            "format": "uri-reference"\n        },\n        "$recursiveAnchor": {\n            "type": "boolean",\n            "default": false\n        },\n        "$vocabulary": {\n            "type": "object",\n            "propertyNames": {\n                "type": "string",\n                "format": "uri"\n            },\n            "additionalProperties": {\n                "type": "boolean"\n            }\n        },\n        "$comment": {\n            "type": "string"\n        },\n        "$defs": {\n            "type": "object",\n            "additionalProperties": { "$recursiveRef": "#" },\n            "default": {}\n        }\n    }\n}')),Ui.defineVocabulary("https://json-schema.org/draft/2019-09/vocab/core",{validate:Ji.validate,$defs:Ji.definitions,$recursiveRef:Ji.dynamicRef,$ref:Ji.ref}),_i.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/2019-09/meta/applicator",\n    "$schema": "https://json-schema.org/draft/2019-09/schema",\n    "$vocabulary": {\n        "https://json-schema.org/draft/2019-09/vocab/applicator": true\n    },\n    "$recursiveAnchor": true,\n\n    "title": "Applicator vocabulary meta-schema",\n    "properties": {\n        "additionalItems": { "$recursiveRef": "#" },\n        "unevaluatedItems": { "$recursiveRef": "#" },\n        "items": {\n            "anyOf": [\n                { "$recursiveRef": "#" },\n                { "$ref": "#/$defs/schemaArray" }\n            ]\n        },\n        "contains": { "$recursiveRef": "#" },\n        "additionalProperties": { "$recursiveRef": "#" },\n        "unevaluatedProperties": { "$recursiveRef": "#" },\n        "properties": {\n            "type": "object",\n            "additionalProperties": { "$recursiveRef": "#" },\n            "default": {}\n        },\n        "patternProperties": {\n            "type": "object",\n            "additionalProperties": { "$recursiveRef": "#" },\n            "propertyNames": { "format": "regex" },\n            "default": {}\n        },\n        "dependentSchemas": {\n            "type": "object",\n            "additionalProperties": {\n                "$recursiveRef": "#"\n            }\n        },\n        "propertyNames": { "$recursiveRef": "#" },\n        "if": { "$recursiveRef": "#" },\n        "then": { "$recursiveRef": "#" },\n        "else": { "$recursiveRef": "#" },\n        "allOf": { "$ref": "#/$defs/schemaArray" },\n        "anyOf": { "$ref": "#/$defs/schemaArray" },\n        "oneOf": { "$ref": "#/$defs/schemaArray" },\n        "not": { "$recursiveRef": "#" }\n    },\n    "$defs": {\n        "schemaArray": {\n            "type": "array",\n            "minItems": 1,\n            "items": { "$recursiveRef": "#" }\n        }\n    }\n}')),Ui.defineVocabulary("https://json-schema.org/draft/2019-09/vocab/applicator",{additionalItems:Ji.additionalItems6,additionalProperties:Ji.additionalProperties6,allOf:Ji.allOf,anyOf:Ji.anyOf,contains:Ji.containsMinContainsMaxContains,dependentSchemas:Ji.dependentSchemas,if:Ji.if,then:Ji.then,else:Ji.else,items:Ji.items,not:Ji.not,oneOf:Ji.oneOf,patternProperties:Ji.patternProperties,properties:Ji.properties,propertyNames:Ji.propertyNames,unevaluatedItems:Ji.unevaluatedItems,unevaluatedProperties:Ji.unevaluatedProperties}),_i.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/2019-09/meta/validation",\n    "$schema": "https://json-schema.org/draft/2019-09/schema",\n    "$vocabulary": {\n      "https://json-schema.org/draft/2019-09/vocab/validation": true\n    },\n    "$recursiveAnchor": true,\n\n    "title": "Validation vocabulary meta-schema",\n    "type": ["object", "boolean"],\n    "properties": {\n        "multipleOf": {\n            "type": "number",\n            "exclusiveMinimum": 0\n        },\n        "maximum": {\n            "type": "number"\n        },\n        "exclusiveMaximum": {\n            "type": "number"\n        },\n        "minimum": {\n            "type": "number"\n        },\n        "exclusiveMinimum": {\n            "type": "number"\n        },\n        "maxLength": { "$ref": "#/$defs/nonNegativeInteger" },\n        "minLength": { "$ref": "#/$defs/nonNegativeIntegerDefault0" },\n        "pattern": {\n            "type": "string",\n            "format": "regex"\n        },\n        "maxItems": { "$ref": "#/$defs/nonNegativeInteger" },\n        "minItems": { "$ref": "#/$defs/nonNegativeIntegerDefault0" },\n        "uniqueItems": {\n            "type": "boolean",\n            "default": false\n        },\n        "maxContains": { "$ref": "#/$defs/nonNegativeInteger" },\n        "minContains": {\n            "$ref": "#/$defs/nonNegativeInteger",\n            "default": 1\n        },\n        "maxProperties": { "$ref": "#/$defs/nonNegativeInteger" },\n        "minProperties": { "$ref": "#/$defs/nonNegativeIntegerDefault0" },\n        "required": { "$ref": "#/$defs/stringArray" },\n        "dependentRequired": {\n            "type": "object",\n            "additionalProperties": {\n                "$ref": "#/$defs/stringArray"\n            }\n        },\n        "const": true,\n        "enum": {\n            "type": "array",\n            "items": true\n        },\n        "type": {\n            "anyOf": [\n                { "$ref": "#/$defs/simpleTypes" },\n                {\n                    "type": "array",\n                    "items": { "$ref": "#/$defs/simpleTypes" },\n                    "minItems": 1,\n                    "uniqueItems": true\n                }\n            ]\n        }\n    },\n    "$defs": {\n        "nonNegativeInteger": {\n            "type": "integer",\n            "minimum": 0\n        },\n        "nonNegativeIntegerDefault0": {\n            "$ref": "#/$defs/nonNegativeInteger",\n            "default": 0\n        },\n        "simpleTypes": {\n            "enum": [\n                "array",\n                "boolean",\n                "integer",\n                "null",\n                "number",\n                "object",\n                "string"\n            ]\n        },\n        "stringArray": {\n            "type": "array",\n            "items": { "type": "string" },\n            "uniqueItems": true,\n            "default": []\n        }\n    }\n}')),Ui.defineVocabulary("https://json-schema.org/draft/2019-09/vocab/validation",{const:Ji.const,dependentRequired:Ji.dependentRequired,enum:Ji.enum,exclusiveMaximum:Ji.exclusiveMaximum,exclusiveMinimum:Ji.exclusiveMinimum,maxItems:Ji.maxItems,maxLength:Ji.maxLength6,maxProperties:Ji.maxProperties,maximum:Ji.maximum,minItems:Ji.minItems,minLength:Ji.minLength6,minProperties:Ji.minProperties,minimum:Ji.minimum,multipleOf:Ji.multipleOf,pattern:Ji.pattern,required:Ji.required,type:Ji.type,uniqueItems:Ji.uniqueItems}),_i.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/2019-09/meta/meta-data",\n    "$schema": "https://json-schema.org/draft/2019-09/schema",\n    "$vocabulary": {\n      "https://json-schema.org/draft/2019-09/vocab/meta-data": true\n    },\n    "$recursiveAnchor": true,\n\n    "title": "Meta-data vocabulary meta-schema",\n\n    "type": ["object", "boolean"],\n    "properties": {\n        "title": {\n            "type": "string"\n        },\n        "description": {\n            "type": "string"\n        },\n        "default": true,\n        "deprecated": {\n            "type": "boolean",\n            "default": false\n        },\n        "readOnly": {\n            "type": "boolean",\n            "default": false\n        },\n        "writeOnly": {\n            "type": "boolean",\n            "default": false\n        },\n        "examples": {\n            "type": "array",\n            "items": true\n        }\n    }\n}')),Ui.defineVocabulary("https://json-schema.org/draft/2019-09/vocab/meta-data",{default:Ji.metaData,deprecated:Ji.metaData,description:Ji.metaData,examples:Ji.metaData,readOnly:Ji.metaData,title:Ji.metaData,writeOnly:Ji.metaData}),_i.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/2019-09/meta/format",\n    "$schema": "https://json-schema.org/draft/2019-09/schema",\n    "$vocabulary": {\n      "https://json-schema.org/draft/2019-09/vocab/format": true\n    },\n    "$recursiveAnchor": true,\n\n    "title": "Format vocabulary meta-schema",\n    "type": ["object", "boolean"],\n    "properties": {\n        "format": { "type": "string" }\n    }\n}')),_i.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/2019-09/meta/content",\n    "$schema": "https://json-schema.org/draft/2019-09/schema",\n    "$vocabulary": {\n      "https://json-schema.org/draft/2019-09/vocab/content": true\n    },\n    "$recursiveAnchor": true,\n\n    "title": "Content vocabulary meta-schema",\n\n    "type": ["object", "boolean"],\n    "properties": {\n        "contentMediaType": { "type": "string" },\n        "contentEncoding": { "type": "string" },\n        "contentSchema": { "$recursiveRef": "#" }\n    }\n}')),Ui.defineVocabulary("https://json-schema.org/draft/2019-09/vocab/content",{contentEncoding:Ji.metaData,contentMediaType:Ji.metaData,contentSchema:Ji.metaData});const{Core:Fi,Schema:Bi}=Yt,Zi=Pi,Gi="https://json-schema.org/draft/2020-12/schema";Bi.setConfig(Gi,"baseToken","$id"),Bi.setConfig(Gi,"embeddedToken","$id"),Bi.setConfig(Gi,"anchorToken","$anchor"),Bi.setConfig(Gi,"dynamicAnchorToken","$dynamicAnchor"),Bi.setConfig(Gi,"vocabularyToken","$vocabulary"),Bi.setConfig(Gi,"mandatoryVocabularies",["https://json-schema.org/draft/2020-12/vocab/core"]),Bi.add(JSON.parse('{\n    "$schema": "https://json-schema.org/draft/2020-12/schema",\n    "$id": "https://json-schema.org/draft/2020-12/schema",\n    "$vocabulary": {\n        "https://json-schema.org/draft/2020-12/vocab/core": true,\n        "https://json-schema.org/draft/2020-12/vocab/applicator": true,\n        "https://json-schema.org/draft/2020-12/vocab/unevaluated": true,\n        "https://json-schema.org/draft/2020-12/vocab/validation": true,\n        "https://json-schema.org/draft/2020-12/vocab/meta-data": true,\n        "https://json-schema.org/draft/2020-12/vocab/format-annotation": true,\n        "https://json-schema.org/draft/2020-12/vocab/content": true\n    },\n    "$dynamicAnchor": "meta",\n\n    "title": "Core and Validation specifications meta-schema",\n    "allOf": [\n        {"$ref": "meta/core"},\n        {"$ref": "meta/applicator"},\n        {"$ref": "meta/unevaluated"},\n        {"$ref": "meta/validation"},\n        {"$ref": "meta/meta-data"},\n        {"$ref": "meta/format-annotation"},\n        {"$ref": "meta/content"}\n    ],\n    "type": ["object", "boolean"],\n    "properties": {\n        "definitions": {\n            "$comment": "While no longer an official keyword as it is replaced by $defs, this keyword is retained in the meta-schema to prevent incompatible extensions as it remains in common use.",\n            "type": "object",\n            "additionalProperties": { "$dynamicRef": "#meta" },\n            "default": {}\n        },\n        "dependencies": {\n            "$comment": "\\"dependencies\\" is no longer a keyword, but schema authors should avoid redefining it to facilitate a smooth transition to \\"dependentSchemas\\" and \\"dependentRequired\\"",\n            "type": "object",\n            "additionalProperties": {\n                "anyOf": [\n                    { "$dynamicRef": "#meta" },\n                    { "$ref": "meta/validation#/$defs/stringArray" }\n                ]\n            }\n        }\n    }\n}')),Bi.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/2020-12/meta/core",\n    "$schema": "https://json-schema.org/draft/2020-12/schema",\n    "$vocabulary": {\n        "https://json-schema.org/draft/2020-12/vocab/core": true\n    },\n    "$dynamicAnchor": "meta",\n\n    "title": "Core vocabulary meta-schema",\n    "type": ["object", "boolean"],\n    "properties": {\n        "$id": {\n            "type": "string",\n            "format": "uri-reference",\n            "$comment": "Non-empty fragments not allowed.",\n            "pattern": "^[^#]*#?$"\n        },\n        "$schema": {\n            "type": "string",\n            "format": "uri"\n        },\n        "$anchor": {\n            "type": "string",\n            "pattern": "^[A-Za-z_][-A-Za-z0-9._]*$"\n        },\n        "$ref": {\n            "type": "string",\n            "format": "uri-reference"\n        },\n        "$dynamicRef": {\n            "type": "string",\n            "format": "uri-reference"\n        },\n        "$dynamicAnchor": {\n            "type": "string",\n            "pattern": "^[A-Za-z_][-A-Za-z0-9._]*$"\n        },\n        "$vocabulary": {\n            "type": "object",\n            "propertyNames": {\n                "type": "string",\n                "format": "uri"\n            },\n            "additionalProperties": {\n                "type": "boolean"\n            }\n        },\n        "$comment": {\n            "type": "string"\n        },\n        "$defs": {\n            "type": "object",\n            "additionalProperties": { "$dynamicRef": "#meta" },\n            "default": {}\n        }\n    }\n}')),Fi.defineVocabulary("https://json-schema.org/draft/2020-12/vocab/core",{validate:Zi.validate,$defs:Zi.definitions,$dynamicRef:Zi.dynamicRef,$ref:Zi.ref}),Bi.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/2020-12/meta/applicator",\n    "$schema": "https://json-schema.org/draft/2020-12/schema",\n    "$vocabulary": {\n        "https://json-schema.org/draft/2020-12/vocab/applicator": true\n    },\n    "$dynamicAnchor": "meta",\n\n    "title": "Applicator vocabulary meta-schema",\n    "type": ["object", "boolean"],\n    "properties": {\n        "prefixItems": { "$ref": "#/$defs/schemaArray" },\n        "items": { "$dynamicRef": "#meta" },\n        "contains": { "$dynamicRef": "#meta" },\n        "additionalProperties": { "$dynamicRef": "#meta" },\n        "properties": {\n            "type": "object",\n            "additionalProperties": { "$dynamicRef": "#meta" },\n            "default": {}\n        },\n        "patternProperties": {\n            "type": "object",\n            "additionalProperties": { "$dynamicRef": "#meta" },\n            "propertyNames": { "format": "regex" },\n            "default": {}\n        },\n        "dependentSchemas": {\n            "type": "object",\n            "additionalProperties": {\n                "$dynamicRef": "#meta"\n            }\n        },\n        "propertyNames": { "$dynamicRef": "#meta" },\n        "if": { "$dynamicRef": "#meta" },\n        "then": { "$dynamicRef": "#meta" },\n        "else": { "$dynamicRef": "#meta" },\n        "allOf": { "$ref": "#/$defs/schemaArray" },\n        "anyOf": { "$ref": "#/$defs/schemaArray" },\n        "oneOf": { "$ref": "#/$defs/schemaArray" },\n        "not": { "$dynamicRef": "#meta" }\n    },\n    "$defs": {\n        "schemaArray": {\n            "type": "array",\n            "minItems": 1,\n            "items": { "$dynamicRef": "#meta" }\n        }\n    }\n}')),Fi.defineVocabulary("https://json-schema.org/draft/2020-12/vocab/applicator",{additionalProperties:Zi.additionalProperties6,allOf:Zi.allOf,anyOf:Zi.anyOf,contains:Zi.containsMinContainsMaxContains,dependentSchemas:Zi.dependentSchemas,if:Zi.if,then:Zi.then,else:Zi.else,items:Zi.items202012,not:Zi.not,oneOf:Zi.oneOf,patternProperties:Zi.patternProperties,prefixItems:Zi.tupleItems,properties:Zi.properties,propertyNames:Zi.propertyNames}),Bi.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/2020-12/meta/validation",\n    "$schema": "https://json-schema.org/draft/2020-12/schema",\n    "$vocabulary": {\n        "https://json-schema.org/draft/2020-12/vocab/validation": true\n    },\n    "$dynamicAnchor": "meta",\n\n    "title": "Validation vocabulary meta-schema",\n    "type": ["object", "boolean"],\n    "properties": {\n        "multipleOf": {\n            "type": "number",\n            "exclusiveMinimum": 0\n        },\n        "maximum": {\n            "type": "number"\n        },\n        "exclusiveMaximum": {\n            "type": "number"\n        },\n        "minimum": {\n            "type": "number"\n        },\n        "exclusiveMinimum": {\n            "type": "number"\n        },\n        "maxLength": { "$ref": "#/$defs/nonNegativeInteger" },\n        "minLength": { "$ref": "#/$defs/nonNegativeIntegerDefault0" },\n        "pattern": {\n            "type": "string",\n            "format": "regex"\n        },\n        "maxItems": { "$ref": "#/$defs/nonNegativeInteger" },\n        "minItems": { "$ref": "#/$defs/nonNegativeIntegerDefault0" },\n        "uniqueItems": {\n            "type": "boolean",\n            "default": false\n        },\n        "maxContains": { "$ref": "#/$defs/nonNegativeInteger" },\n        "minContains": {\n            "$ref": "#/$defs/nonNegativeInteger",\n            "default": 1\n        },\n        "maxProperties": { "$ref": "#/$defs/nonNegativeInteger" },\n        "minProperties": { "$ref": "#/$defs/nonNegativeIntegerDefault0" },\n        "required": { "$ref": "#/$defs/stringArray" },\n        "dependentRequired": {\n            "type": "object",\n            "additionalProperties": {\n                "$ref": "#/$defs/stringArray"\n            }\n        },\n        "const": true,\n        "enum": {\n            "type": "array",\n            "items": true\n        },\n        "type": {\n            "anyOf": [\n                { "$ref": "#/$defs/simpleTypes" },\n                {\n                    "type": "array",\n                    "items": { "$ref": "#/$defs/simpleTypes" },\n                    "minItems": 1,\n                    "uniqueItems": true\n                }\n            ]\n        }\n    },\n    "$defs": {\n        "nonNegativeInteger": {\n            "type": "integer",\n            "minimum": 0\n        },\n        "nonNegativeIntegerDefault0": {\n            "$ref": "#/$defs/nonNegativeInteger",\n            "default": 0\n        },\n        "simpleTypes": {\n            "enum": [\n                "array",\n                "boolean",\n                "integer",\n                "null",\n                "number",\n                "object",\n                "string"\n            ]\n        },\n        "stringArray": {\n            "type": "array",\n            "items": { "type": "string" },\n            "uniqueItems": true,\n            "default": []\n        }\n    }\n}')),Fi.defineVocabulary("https://json-schema.org/draft/2020-12/vocab/validation",{const:Zi.const,dependentRequired:Zi.dependentRequired,enum:Zi.enum,exclusiveMaximum:Zi.exclusiveMaximum,exclusiveMinimum:Zi.exclusiveMinimum,maxItems:Zi.maxItems,maxLength:Zi.maxLength6,maxProperties:Zi.maxProperties,maximum:Zi.maximum,minItems:Zi.minItems,minLength:Zi.minLength6,minProperties:Zi.minProperties,minimum:Zi.minimum,multipleOf:Zi.multipleOf,pattern:Zi.pattern,required:Zi.required,type:Zi.type,uniqueItems:Zi.uniqueItems}),Bi.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/2020-12/meta/meta-data",\n    "$schema": "https://json-schema.org/draft/2020-12/schema",\n    "$vocabulary": {\n        "https://json-schema.org/draft/2020-12/vocab/meta-data": true\n    },\n    "$dynamicAnchor": "meta",\n\n    "title": "Meta-data vocabulary meta-schema",\n\n    "type": ["object", "boolean"],\n    "properties": {\n        "title": {\n            "type": "string"\n        },\n        "description": {\n            "type": "string"\n        },\n        "default": true,\n        "deprecated": {\n            "type": "boolean",\n            "default": false\n        },\n        "readOnly": {\n            "type": "boolean",\n            "default": false\n        },\n        "writeOnly": {\n            "type": "boolean",\n            "default": false\n        },\n        "examples": {\n            "type": "array",\n            "items": true\n        }\n    }\n}')),Fi.defineVocabulary("https://json-schema.org/draft/2020-12/vocab/meta-data",{default:Zi.metaData,deprecated:Zi.metaData,description:Zi.metaData,examples:Zi.metaData,readOnly:Zi.metaData,title:Zi.metaData,writeOnly:Zi.metaData}),Bi.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/2020-12/meta/format-annotation",\n    "$schema": "https://json-schema.org/draft/2020-12/schema",\n    "$vocabulary": {\n        "https://json-schema.org/draft/2020-12/vocab/format-annotation": true\n    },\n    "$dynamicAnchor": "meta",\n\n    "title": "Format vocabulary meta-schema for annotation results",\n    "type": ["object", "boolean"],\n    "properties": {\n        "format": { "type": "string" }\n    }\n}')),Fi.defineVocabulary("https://json-schema.org/draft/2020-12/vocab/format-annotation",{format:Zi.metaData}),Bi.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/2020-12/meta/format-assertion",\n    "$schema": "https://json-schema.org/draft/2020-12/schema",\n    "$vocabulary": {\n        "https://json-schema.org/draft/2020-12/vocab/format-assertion": true\n    },\n    "$dynamicAnchor": "meta",\n\n    "title": "Format vocabulary meta-schema for assertion results",\n    "type": ["object", "boolean"],\n    "properties": {\n        "format": { "type": "string" }\n    }\n}')),Bi.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/2020-12/meta/content",\n    "$schema": "https://json-schema.org/draft/2020-12/schema",\n    "$vocabulary": {\n        "https://json-schema.org/draft/2020-12/vocab/content": true\n    },\n    "$dynamicAnchor": "meta",\n\n    "title": "Content vocabulary meta-schema",\n\n    "type": ["object", "boolean"],\n    "properties": {\n        "contentMediaType": { "type": "string" },\n        "contentEncoding": { "type": "string" },\n        "contentSchema": { "$dynamicRef": "#meta" }\n    }\n}')),Fi.defineVocabulary("https://json-schema.org/draft/2020-12/vocab/content",{contentEncoding:Zi.metaData,contentMediaType:Zi.metaData,contentSchema:Zi.metaData}),Bi.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/2020-12/meta/unevaluated",\n    "$schema": "https://json-schema.org/draft/2020-12/schema",\n    "$vocabulary": {\n        "https://json-schema.org/draft/2020-12/vocab/unevaluated": true\n    },\n    "$dynamicAnchor": "meta",\n\n    "title": "Unevaluated applicator vocabulary meta-schema",\n    "type": ["object", "boolean"],\n    "properties": {\n        "unevaluatedItems": { "$dynamicRef": "#meta" },\n        "unevaluatedProperties": { "$dynamicRef": "#meta" }\n    }\n}')),Fi.defineVocabulary("https://json-schema.org/draft/2020-12/vocab/unevaluated",{unevaluatedItems:Zi.unevaluatedItems,unevaluatedProperties:Zi.unevaluatedProperties});const{Core:Wi,Schema:Xi,InvalidSchemaError:Hi}=Yt,Qi=Pi;var Yi={add:Wi.add,get:Xi.get,validate:Wi.validate,compile:Wi.compile,interpret:Wi.interpret,setMetaOutputFormat:Wi.setMetaOutputFormat,setShouldMetaValidate:Wi.setShouldMetaValidate,FLAG:Wi.FLAG,BASIC:Wi.BASIC,DETAILED:Wi.DETAILED,VERBOSE:Wi.VERBOSE,Keywords:Qi,InvalidSchemaError:Hi};var eo={splitUri:e=>{const t=e.indexOf("#"),n=-1===t?e.length:t,r=e.slice(0,n),a=e.slice(n+1);return[decodeURI(r),decodeURI(a)]}};const{Core:to}=Yt,{splitUri:no}=eo;var ro={collectExternalIds:(e,t,n,r)=>{const a=n[e][0],i=no(e)[0];to.getKeyword(a).collectExternalIds(e,t,n,{...n.metaData[i].dynamicAnchors,...r})}};const ao=Yi,{Core:io}=Yt,oo=ro,so={...ao.Keywords.validate,collectExternalIds:(e,t,n,r)=>{const a=n[e][2];if(!t.has(e)&&"boolean"!=typeof a){t.add(e);for(const[e,,i]of a){const a=io.getKeyword(e);a.collectExternalIds&&a.collectExternalIds(i,t,n,r)}}}},co={...ao.Keywords.ref,collectExternalIds:oo.collectExternalIds},mo={...ao.Keywords.additionalItems,collectExternalIds:([,e],t,n,r)=>{"string"==typeof e&&oo.collectExternalIds(e,t,n,r)}},lo={...ao.Keywords.additionalProperties,collectExternalIds:([,,e],t,n,r)=>{"string"==typeof e&&oo.collectExternalIds(e,t,n,r)}},po={...ao.Keywords.additionalItems6,collectExternalIds:([,e],t,n,r)=>{oo.collectExternalIds(e,t,n,r)}},uo={...ao.Keywords.additionalProperties6,collectExternalIds:([,,e],t,n,r)=>{oo.collectExternalIds(e,t,n,r)}},fo={...ao.Keywords.allOf,collectExternalIds:(e,t,n,r)=>{e.forEach((e=>oo.collectExternalIds(e,t,n,r)))}},yo={...ao.Keywords.anyOf,collectExternalIds:(e,t,n,r)=>{e.forEach((e=>oo.collectExternalIds(e,t,n,r)))}},ho={...ao.Keywords.contains,collectExternalIds:oo.collectExternalIds},vo={...ao.Keywords.containsMinContainsMaxContains,collectExternalIds:({contains:e},t,n,r)=>{oo.collectExternalIds(e,t,n,r)}},go={...ao.Keywords.dependencies,collectExternalIds:(e,t,n,r)=>{Object.values(e).forEach((([,e])=>{"string"==typeof e&&oo.collectExternalIds(e,t,n,r)}))}},bo={...ao.Keywords.dependentSchemas,collectExternalIds:(e,t,n,r)=>{Object.values(e).forEach((([,e])=>oo.collectExternalIds(e,t,n,r)))}},$o={...ao.Keywords.if,collectExternalIds:oo.collectExternalIds},Io={...ao.Keywords.then,collectExternalIds:([,e],t,n,r)=>{oo.collectExternalIds(e,t,n,r)}},wo={...ao.Keywords.else,collectExternalIds:([,e],t,n,r)=>{oo.collectExternalIds(e,t,n,r)}},Oo={...ao.Keywords.items,collectExternalIds:(e,t,n,r)=>{"string"==typeof e?oo.collectExternalIds(e,t,n,r):e.forEach((e=>oo.collectExternalIds(e,t,n,r)))}},xo={...ao.Keywords.items202012,collectExternalIds:([,e],t,n,r)=>{oo.collectExternalIds(e,t,n,r)}};var So={validate:so,ref:co,additionalItems:mo,additionalItems6:po,additionalProperties:lo,additionalProperties6:uo,allOf:fo,anyOf:yo,contains:ho,containsMinContainsMaxContains:vo,dependencies:go,dependentSchemas:bo,if:$o,then:Io,else:wo,items:Oo,items202012:xo,not:{...ao.Keywords.not,collectExternalIds:oo.collectExternalIds},oneOf:{...ao.Keywords.oneOf,collectExternalIds:(e,t,n,r)=>{e.forEach((e=>oo.collectExternalIds(e,t,n,r)))}},patternProperties:{...ao.Keywords.patternProperties,collectExternalIds:(e,t,n,r)=>{e.forEach((([,e])=>oo.collectExternalIds(e,t,n,r)))}},tupleItems:{...ao.Keywords.tupleItems,collectExternalIds:(e,t,n,r)=>{e.forEach((e=>oo.collectExternalIds(e,t,n,r)))}},properties:{...ao.Keywords.properties,collectExternalIds:(e,t,n,r)=>{Object.values(e).forEach((e=>oo.collectExternalIds(e,t,n,r)))}},propertyNames:{...ao.Keywords.propertyNames,collectExternalIds:oo.collectExternalIds},unevaluatedItems:{...ao.Keywords.unevaluatedItems,collectExternalIds:([,e],t,n,r)=>{oo.collectExternalIds(e,t,n,r)}},unevaluatedProperties:{...ao.Keywords.unevaluatedProperties,collectExternalIds:([,e],t,n,r)=>{oo.collectExternalIds(e,t,n,r)}}};const jo=Yi,{Core:Eo,Schema:Po}=Yt,Ao=So;Po.setConfig("http://json-schema.org/draft-04/schema","bundlingLocation","/definitions"),Eo.defineVocabulary("http://json-schema.org/draft-04/schema",{validate:Ao.validate,additionalItems:Ao.additionalItems,additionalProperties:Ao.additionalProperties,allOf:Ao.allOf,anyOf:Ao.anyOf,default:jo.Keywords.metaData,definitions:jo.Keywords.definitions,dependencies:Ao.dependencies,description:jo.Keywords.metaData,enum:jo.Keywords.enum,format:jo.Keywords.metaData,items:Ao.items,maxItems:jo.Keywords.maxItems,maxLength:jo.Keywords.maxLength,maxProperties:jo.Keywords.maxProperties,maximum:jo.Keywords.maximumExclusiveMaximum,minItems:jo.Keywords.minItems,minLength:jo.Keywords.minLength,minProperties:jo.Keywords.minProperties,minimum:jo.Keywords.minimumExclusiveMinimum,multipleOf:jo.Keywords.multipleOf,not:Ao.not,oneOf:Ao.oneOf,pattern:jo.Keywords.pattern,patternProperties:Ao.patternProperties,properties:Ao.properties,required:jo.Keywords.required,title:jo.Keywords.metaData,type:jo.Keywords.type,uniqueItems:jo.Keywords.uniqueItems});const Co=Yi,{Core:No,Schema:Ko}=Yt,Ro=So;Ko.setConfig("http://json-schema.org/draft-06/schema","bundlingLocation","/definitions"),No.defineVocabulary("http://json-schema.org/draft-06/schema",{validate:Ro.validate,additionalItems:Ro.additionalItems6,additionalProperties:Ro.additionalProperties6,allOf:Ro.allOf,anyOf:Ro.anyOf,const:Co.Keywords.const,contains:Ro.contains,default:Co.Keywords.metaData,definitions:Co.Keywords.definitions,dependencies:Ro.dependencies,description:Co.Keywords.metaData,enum:Co.Keywords.enum,examples:Co.Keywords.metaData,exclusiveMaximum:Co.Keywords.exclusiveMaximum,exclusiveMinimum:Co.Keywords.exclusiveMinimum,format:Co.Keywords.metaData,items:Ro.items,maxItems:Co.Keywords.maxItems,maxLength:Co.Keywords.maxLength6,maxProperties:Co.Keywords.maxProperties,maximum:Co.Keywords.maximum,minItems:Co.Keywords.minItems,minLength:Co.Keywords.minLength6,minProperties:Co.Keywords.minProperties,minimum:Co.Keywords.minimum,multipleOf:Co.Keywords.multipleOf,not:Ro.not,oneOf:Ro.oneOf,pattern:Co.Keywords.pattern,patternProperties:Ro.patternProperties,properties:Ro.properties,propertyNames:Ro.propertyNames,required:Co.Keywords.required,title:Co.Keywords.metaData,type:Co.Keywords.type,uniqueItems:Co.Keywords.uniqueItems});const Do=Yi,{Core:Mo,Schema:To}=Yt,qo=So;To.setConfig("http://json-schema.org/draft-07/schema","bundlingLocation","/definitions"),Mo.defineVocabulary("http://json-schema.org/draft-07/schema",{validate:qo.validate,additionalItems:qo.additionalItems6,additionalProperties:qo.additionalProperties6,allOf:qo.allOf,anyOf:qo.anyOf,const:Do.Keywords.const,contains:qo.contains,default:Do.Keywords.metaData,definitions:Do.Keywords.definitions,dependencies:qo.dependencies,description:Do.Keywords.metaData,enum:Do.Keywords.enum,exclusiveMaximum:Do.Keywords.exclusiveMaximum,exclusiveMinimum:Do.Keywords.exclusiveMinimum,format:Do.Keywords.metaData,if:qo.if,then:qo.then,else:qo.else,items:qo.items,maxItems:Do.Keywords.maxItems,maxLength:Do.Keywords.maxLength6,maxProperties:Do.Keywords.maxProperties,maximum:Do.Keywords.maximum,minItems:Do.Keywords.minItems,minLength:Do.Keywords.minLength6,minProperties:Do.Keywords.minProperties,minimum:Do.Keywords.minimum,multipleOf:Do.Keywords.multipleOf,not:qo.not,oneOf:qo.oneOf,pattern:Do.Keywords.pattern,patternProperties:qo.patternProperties,properties:qo.properties,propertyNames:qo.propertyNames,readOnly:Do.Keywords.metaData,required:Do.Keywords.required,title:Do.Keywords.metaData,type:Do.Keywords.type,uniqueItems:Do.Keywords.uniqueItems,writeOnly:Do.Keywords.metaData});const Lo=Yi,{Core:ko,Schema:Vo}=Yt,Uo=So;Vo.setConfig("https://json-schema.org/draft/2019-09/schema","bundlingLocation","/$defs"),ko.defineVocabulary("https://json-schema.org/draft/2019-09/vocab/core",{validate:Uo.validate,$defs:Lo.Keywords.definitions,$recursiveRef:Lo.Keywords.dynamicRef,$ref:Uo.ref}),ko.defineVocabulary("https://json-schema.org/draft/2019-09/vocab/applicator",{additionalItems:Uo.additionalItems6,additionalProperties:Uo.additionalProperties6,allOf:Uo.allOf,anyOf:Uo.anyOf,contains:Uo.containsMinContainsMaxContains,dependentSchemas:Uo.dependentSchemas,if:Uo.if,then:Uo.then,else:Uo.else,items:Uo.items,not:Uo.not,oneOf:Uo.oneOf,patternProperties:Uo.patternProperties,properties:Uo.properties,propertyNames:Uo.propertyNames,unevaluatedItems:Uo.unevaluatedItems,unevaluatedProperties:Uo.unevaluatedProperties});const _o=Yi,{Core:Jo,Schema:zo}=Yt,Fo=So;zo.setConfig("https://json-schema.org/draft/2020-12/schema","bundlingLocation","/$defs"),Jo.defineVocabulary("https://json-schema.org/draft/2020-12/vocab/core",{validate:Fo.validate,$defs:_o.Keywords.definitions,$dynamicRef:_o.Keywords.dynamicRef,$ref:Fo.ref}),Jo.defineVocabulary("https://json-schema.org/draft/2020-12/vocab/applicator",{additionalProperties:Fo.additionalProperties6,allOf:Fo.allOf,anyOf:Fo.anyOf,contains:Fo.containsMinContainsMaxContains,dependentSchemas:Fo.dependentSchemas,if:Fo.if,then:Fo.then,else:Fo.else,items:Fo.items202012,not:Fo.not,oneOf:Fo.oneOf,patternProperties:Fo.patternProperties,prefixItems:Fo.tupleItems,properties:Fo.properties,propertyNames:Fo.propertyNames}),Jo.defineVocabulary("https://json-schema.org/draft/2020-12/vocab/unevaluated",{unevaluatedItems:Fo.unevaluatedItems,unevaluatedProperties:Fo.unevaluatedProperties});const{v4:Bo}=N,Zo=Yi,Go=te,{Core:Wo,Schema:Xo,InvalidSchemaError:Ho}=Yt,Qo=ro,{splitUri:Yo}=eo,es="full",ts="flat",ns="uri",rs="uuid",as={alwaysIncludeDialect:!1,bundleMode:ts,definitionNamingStrategy:ns};var is={add:Zo.add,get:Xo.get,bundle:async(e,t={})=>{const n={...as,...t},{ast:r,schemaUri:a}=await Wo.compile(e),i=new Set;Qo.collectExternalIds(a,i,r,{});const o=new Set([...i].map((e=>Yo(e)[0])));o.delete(e.id);const s=Xo.toSchema(e,{includeEmbedded:n.bundleMode===es}),c=Xo.getConfig(e.schemaVersion,"bundlingLocation");void 0===Go.get(c,s)&&o.size>0&&Go.assign(c,s,{});for(const t of o.values()){const r=await Zo.get(t),a=Xo.toSchema(r,{parentId:e.id,parentDialect:n.alwaysIncludeDialect?"":e.schemaVersion,includeEmbedded:n.bundleMode===es});let i;if(n.definitionNamingStrategy===ns){i=a[Xo.getConfig(r.schemaVersion,"embeddedToken")]}else{if(n.definitionNamingStrategy!==rs)throw Error(`Unknown definition naming stragety: ${n.definitionNamingStrategy}`);i=Bo()}const o=Go.append(i,c);Go.assign(o,s,a)}return s},FULL:es,FLAT:ts,URI:ns,UUID:rs,setMetaOutputFormat:Wo.setMetaOutputFormat,setShouldMetaValidate:Wo.setShouldMetaValidate,FLAG:Wo.FLAG,BASIC:Wo.BASIC,DETAILED:Wo.DETAILED,VERBOSE:Wo.VERBOSE,InvalidSchemaError:Ho};e.default=is,Object.defineProperty(e,"__esModule",{value:!0})}));
//# sourceMappingURL=json-schema-bundler-amd.min.js.map
