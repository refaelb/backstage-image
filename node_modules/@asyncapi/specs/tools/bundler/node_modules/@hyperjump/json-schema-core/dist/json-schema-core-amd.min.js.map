{"version":3,"file":"json-schema-core-amd.min.js","sources":["../node_modules/just-curry-it/index.js","../node_modules/pubsub-js/src/pubsub.js","../node_modules/url-resolve-browser/index.js","../lib/common.js","../node_modules/@hyperjump/json-pointer/lib/index.js","../lib/reference.js","../lib/instance.js","../node_modules/content-type/index.js","../node_modules/@hyperjump/pact/lib/entries.js","../node_modules/@hyperjump/pact/lib/map.js","../node_modules/@hyperjump/pact/lib/reduce.js","../node_modules/@hyperjump/pact/lib/filter.js","../node_modules/@hyperjump/pact/lib/some.js","../node_modules/@hyperjump/pact/lib/every.js","../node_modules/@hyperjump/pact/lib/pipeline.js","../node_modules/@hyperjump/pact/lib/index.js","../node_modules/@hyperjump/pact/lib/all.js","../node_modules/@hyperjump/pact/lib/allValues.js","../lib/fetch.browser.js","../lib/schema.js","../lib/invalid-schema-error.js","../lib/core.js","../lib/keywords/meta-data.js","../lib/keywords/validate.js","../lib/keywords/index.js","../lib/index.js"],"sourcesContent":["module.exports = curry;\n\n/*\n  function add(a, b, c) {\n    return a + b + c;\n  }\n  curry(add)(1)(2)(3); // 6\n  curry(add)(1)(2)(2); // 5\n  curry(add)(2)(4, 3); // 9\n\n  function add(...args) {\n    return args.reduce((sum, n) => sum + n, 0)\n  }\n  var curryAdd4 = curry(add, 4)\n  curryAdd4(1)(2, 3)(4); // 10\n\n  function converter(ratio, input) {\n    return (input*ratio).toFixed(1);\n  }\n  const curriedConverter = curry(converter)\n  const milesToKm = curriedConverter(1.62);\n  milesToKm(35); // 56.7\n  milesToKm(10); // 16.2\n*/\n\nfunction curry(fn, arity) {\n  return function curried() {\n    if (arity == null) {\n      arity = fn.length;\n    }\n    var args = [].slice.call(arguments);\n    if (args.length >= arity) {\n      return fn.apply(this, args);\n    } else {\n      return function() {\n        return curried.apply(this, args.concat([].slice.call(arguments)));\n      };\n    }\n  };\n}\n","/**\n * Copyright (c) 2010,2011,2012,2013,2014 Morgan Roderick http://roderick.dk\n * License: MIT - http://mrgnrdrck.mit-license.org\n *\n * https://github.com/mroderick/PubSubJS\n */\n\n(function (root, factory){\n    'use strict';\n\n    var PubSub = {};\n    root.PubSub = PubSub;\n    factory(PubSub);\n    // CommonJS and Node.js module support\n    if (typeof exports === 'object'){\n        if (module !== undefined && module.exports) {\n            exports = module.exports = PubSub; // Node.js specific `module.exports`\n        }\n        exports.PubSub = PubSub; // CommonJS module 1.1.1 spec\n        module.exports = exports = PubSub; // CommonJS\n    }\n    // AMD support\n    /* eslint-disable no-undef */\n    else if (typeof define === 'function' && define.amd){\n        define(function() { return PubSub; });\n        /* eslint-enable no-undef */\n    }\n\n}(( typeof window === 'object' && window ) || this, function (PubSub){\n    'use strict';\n\n    var messages = {},\n        lastUid = -1,\n        ALL_SUBSCRIBING_MSG = '*';\n\n    function hasKeys(obj){\n        var key;\n\n        for (key in obj){\n            if ( Object.prototype.hasOwnProperty.call(obj, key) ){\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Returns a function that throws the passed exception, for use as argument for setTimeout\n     * @alias throwException\n     * @function\n     * @param { Object } ex An Error object\n     */\n    function throwException( ex ){\n        return function reThrowException(){\n            throw ex;\n        };\n    }\n\n    function callSubscriberWithDelayedExceptions( subscriber, message, data ){\n        try {\n            subscriber( message, data );\n        } catch( ex ){\n            setTimeout( throwException( ex ), 0);\n        }\n    }\n\n    function callSubscriberWithImmediateExceptions( subscriber, message, data ){\n        subscriber( message, data );\n    }\n\n    function deliverMessage( originalMessage, matchedMessage, data, immediateExceptions ){\n        var subscribers = messages[matchedMessage],\n            callSubscriber = immediateExceptions ? callSubscriberWithImmediateExceptions : callSubscriberWithDelayedExceptions,\n            s;\n\n        if ( !Object.prototype.hasOwnProperty.call( messages, matchedMessage ) ) {\n            return;\n        }\n\n        for (s in subscribers){\n            if ( Object.prototype.hasOwnProperty.call(subscribers, s)){\n                callSubscriber( subscribers[s], originalMessage, data );\n            }\n        }\n    }\n\n    function createDeliveryFunction( message, data, immediateExceptions ){\n        return function deliverNamespaced(){\n            var topic = String( message ),\n                position = topic.lastIndexOf( '.' );\n\n            // deliver the message as it is now\n            deliverMessage(message, message, data, immediateExceptions);\n\n            // trim the hierarchy and deliver message to each level\n            while( position !== -1 ){\n                topic = topic.substr( 0, position );\n                position = topic.lastIndexOf('.');\n                deliverMessage( message, topic, data, immediateExceptions );\n            }\n\n            deliverMessage(message, ALL_SUBSCRIBING_MSG, data, immediateExceptions);\n        };\n    }\n\n    function hasDirectSubscribersFor( message ) {\n        var topic = String( message ),\n            found = Boolean(Object.prototype.hasOwnProperty.call( messages, topic ) && hasKeys(messages[topic]));\n\n        return found;\n    }\n\n    function messageHasSubscribers( message ){\n        var topic = String( message ),\n            found = hasDirectSubscribersFor(topic) || hasDirectSubscribersFor(ALL_SUBSCRIBING_MSG),\n            position = topic.lastIndexOf( '.' );\n\n        while ( !found && position !== -1 ){\n            topic = topic.substr( 0, position );\n            position = topic.lastIndexOf( '.' );\n            found = hasDirectSubscribersFor(topic);\n        }\n\n        return found;\n    }\n\n    function publish( message, data, sync, immediateExceptions ){\n        message = (typeof message === 'symbol') ? message.toString() : message;\n\n        var deliver = createDeliveryFunction( message, data, immediateExceptions ),\n            hasSubscribers = messageHasSubscribers( message );\n\n        if ( !hasSubscribers ){\n            return false;\n        }\n\n        if ( sync === true ){\n            deliver();\n        } else {\n            setTimeout( deliver, 0 );\n        }\n        return true;\n    }\n\n    /**\n     * Publishes the message, passing the data to it's subscribers\n     * @function\n     * @alias publish\n     * @param { String } message The message to publish\n     * @param {} data The data to pass to subscribers\n     * @return { Boolean }\n     */\n    PubSub.publish = function( message, data ){\n        return publish( message, data, false, PubSub.immediateExceptions );\n    };\n\n    /**\n     * Publishes the message synchronously, passing the data to it's subscribers\n     * @function\n     * @alias publishSync\n     * @param { String } message The message to publish\n     * @param {} data The data to pass to subscribers\n     * @return { Boolean }\n     */\n    PubSub.publishSync = function( message, data ){\n        return publish( message, data, true, PubSub.immediateExceptions );\n    };\n\n    /**\n     * Subscribes the passed function to the passed message. Every returned token is unique and should be stored if you need to unsubscribe\n     * @function\n     * @alias subscribe\n     * @param { String } message The message to subscribe to\n     * @param { Function } func The function to call when a new message is published\n     * @return { String }\n     */\n    PubSub.subscribe = function( message, func ){\n        if ( typeof func !== 'function'){\n            return false;\n        }\n\n        message = (typeof message === 'symbol') ? message.toString() : message;\n\n        // message is not registered yet\n        if ( !Object.prototype.hasOwnProperty.call( messages, message ) ){\n            messages[message] = {};\n        }\n\n        // forcing token as String, to allow for future expansions without breaking usage\n        // and allow for easy use as key names for the 'messages' object\n        var token = 'uid_' + String(++lastUid);\n        messages[message][token] = func;\n\n        // return token for unsubscribing\n        return token;\n    };\n\n    PubSub.subscribeAll = function( func ){\n        return PubSub.subscribe(ALL_SUBSCRIBING_MSG, func);\n    };\n\n    /**\n     * Subscribes the passed function to the passed message once\n     * @function\n     * @alias subscribeOnce\n     * @param { String } message The message to subscribe to\n     * @param { Function } func The function to call when a new message is published\n     * @return { PubSub }\n     */\n    PubSub.subscribeOnce = function( message, func ){\n        var token = PubSub.subscribe( message, function(){\n            // before func apply, unsubscribe message\n            PubSub.unsubscribe( token );\n            func.apply( this, arguments );\n        });\n        return PubSub;\n    };\n\n    /**\n     * Clears all subscriptions\n     * @function\n     * @public\n     * @alias clearAllSubscriptions\n     */\n    PubSub.clearAllSubscriptions = function clearAllSubscriptions(){\n        messages = {};\n    };\n\n    /**\n     * Clear subscriptions by the topic\n     * @function\n     * @public\n     * @alias clearAllSubscriptions\n     * @return { int }\n     */\n    PubSub.clearSubscriptions = function clearSubscriptions(topic){\n        var m;\n        for (m in messages){\n            if (Object.prototype.hasOwnProperty.call(messages, m) && m.indexOf(topic) === 0){\n                delete messages[m];\n            }\n        }\n    };\n\n    /**\n       Count subscriptions by the topic\n     * @function\n     * @public\n     * @alias countSubscriptions\n     * @return { Array }\n    */\n    PubSub.countSubscriptions = function countSubscriptions(topic){\n        var m;\n        // eslint-disable-next-line no-unused-vars\n        var token;\n        var count = 0;\n        for (m in messages) {\n            if (Object.prototype.hasOwnProperty.call(messages, m) && m.indexOf(topic) === 0) {\n                for (token in messages[m]) {\n                    count++;\n                }\n                break;\n            }\n        }\n        return count;\n    };\n\n\n    /**\n       Gets subscriptions by the topic\n     * @function\n     * @public\n     * @alias getSubscriptions\n    */\n    PubSub.getSubscriptions = function getSubscriptions(topic){\n        var m;\n        var list = [];\n        for (m in messages){\n            if (Object.prototype.hasOwnProperty.call(messages, m) && m.indexOf(topic) === 0){\n                list.push(m);\n            }\n        }\n        return list;\n    };\n\n    /**\n     * Removes subscriptions\n     *\n     * - When passed a token, removes a specific subscription.\n     *\n\t * - When passed a function, removes all subscriptions for that function\n     *\n\t * - When passed a topic, removes all subscriptions for that topic (hierarchy)\n     * @function\n     * @public\n     * @alias subscribeOnce\n     * @param { String | Function } value A token, function or topic to unsubscribe from\n     * @example // Unsubscribing with a token\n     * var token = PubSub.subscribe('mytopic', myFunc);\n     * PubSub.unsubscribe(token);\n     * @example // Unsubscribing with a function\n     * PubSub.unsubscribe(myFunc);\n     * @example // Unsubscribing from a topic\n     * PubSub.unsubscribe('mytopic');\n     */\n    PubSub.unsubscribe = function(value){\n        var descendantTopicExists = function(topic) {\n                var m;\n                for ( m in messages ){\n                    if ( Object.prototype.hasOwnProperty.call(messages, m) && m.indexOf(topic) === 0 ){\n                        // a descendant of the topic exists:\n                        return true;\n                    }\n                }\n\n                return false;\n            },\n            isTopic    = typeof value === 'string' && ( Object.prototype.hasOwnProperty.call(messages, value) || descendantTopicExists(value) ),\n            isToken    = !isTopic && typeof value === 'string',\n            isFunction = typeof value === 'function',\n            result = false,\n            m, message, t;\n\n        if (isTopic){\n            PubSub.clearSubscriptions(value);\n            return;\n        }\n\n        for ( m in messages ){\n            if ( Object.prototype.hasOwnProperty.call( messages, m ) ){\n                message = messages[m];\n\n                if ( isToken && message[value] ){\n                    delete message[value];\n                    result = value;\n                    // tokens are unique, so we can just stop here\n                    break;\n                }\n\n                if (isFunction) {\n                    for ( t in message ){\n                        if (Object.prototype.hasOwnProperty.call(message, t) && message[t] === value){\n                            delete message[t];\n                            result = true;\n                        }\n                    }\n                }\n            }\n        }\n\n        return result;\n    };\n}));\n","'use strict';\nmodule.exports = urlResolve;\n\n/*\nThe majority of the module is built by following RFC1808\nurl: https://tools.ietf.org/html/rfc1808\n*/\n\n// adds a slash at end if not present\nfunction _addSlash (url) {\n  return url + (url[url.length-1] === '/' ? '' : '/');\n}\n\n// resolve the ..'s (directory up) and such\nfunction _pathResolve (path) {\n  let pathSplit = path.split('/');\n\n  // happens when path starts with /\n  if (pathSplit[0] === '') {\n    pathSplit = pathSplit.slice(1);\n  }\n\n  // let segmentCount = 0; // number of segments that have been passed\n  let resultArray = [];\n  pathSplit.forEach((current, index) => {\n    // skip occurances of '.'\n    if (current !== '.') {\n      if (current === '..') {\n        resultArray.pop(); // remove previous\n      } else if (current !== '' || index === pathSplit.length - 1) {\n        resultArray.push(current);\n      }\n    }\n  });\n  return '/' + resultArray.join('/');\n}\n\n// parses a base url string into an object containing host, path and query\nfunction _baseParse (base) {\n  const resultObject = {\n    host: '',\n    path: '',\n    query: '',\n    protocol: ''\n  };\n\n  let path = base;\n  let protocolEndIndex = base.indexOf('//');\n\n  resultObject.protocol = path.substring(0, protocolEndIndex);\n\n  protocolEndIndex += 2; // add two to pass double slash\n\n  const pathIndex = base.indexOf('/', protocolEndIndex);\n  const queryIndex = base.indexOf('?');\n  const hashIndex = base.indexOf('#');\n\n  if (hashIndex !== -1) {\n    path = path.substring(0, hashIndex); // remove hash, not needed for base\n  }\n\n  if (queryIndex !== -1) {\n    const query = path.substring(queryIndex); // remove query, save in return obj\n    resultObject.query = query;\n    path = path.substring(0, queryIndex);\n  }\n\n  if (pathIndex !== -1) {\n    const host = path.substring(0, pathIndex); // separate host & path\n    resultObject.host = host;\n    path = path.substring(pathIndex);\n    resultObject.path = path;\n  } else {\n    resultObject.host = path; // there was no path, therefore path is host\n  }\n\n  return resultObject;\n}\n\n// https://tools.ietf.org/html/rfc3986#section-3.1\nconst _scheme = '[a-z][a-z0-9+.-]*'; // ALPHA *( ALPHA / DIGIT / \"+\" / \"-\" / \".\"  )]\nconst _isAbsolute = new RegExp(`^(${_scheme}:)?//`, 'i');\n\n// parses a relative url string into an object containing the href,\n// hash, query and whether it is a net path, absolute path or relative path\nfunction _relativeParse (relative) {\n  const resultObject = {\n    href: relative, // href is always what was passed through\n    hash: '',\n    query: '',\n    netPath: false,\n    absolutePath: false,\n    relativePath: false\n  };\n  // check for protocol\n  // if protocol exists, is net path (absolute URL)\n  if (_isAbsolute.test(relative)) {\n    resultObject.netPath = true;\n    // return, in this case the relative is the resolved url, no need to parse.\n    return resultObject;\n  }\n\n  // if / is first, this is an absolute path,\n  // I.E. it overwrites the base URL's path\n  if (relative[0] === '/') {\n    resultObject.absolutePath = true;\n    // return resultObject\n  } else if (relative !== '') {\n    resultObject.relativePath = true;\n  }\n\n  let path = relative;\n  const queryIndex = relative.indexOf('?');\n  const hashIndex = relative.indexOf('#');\n\n  if (hashIndex !== -1) {\n    const hash = path.substring(hashIndex);\n    resultObject.hash = hash;\n    path = path.substring(0, hashIndex);\n  }\n\n  if (queryIndex !== -1) {\n    const query = path.substring(queryIndex);\n    resultObject.query = query;\n    path = path.substring(0, queryIndex);\n  }\n\n  resultObject.path = path; // whatever is left is path\n  return resultObject;\n}\n\nfunction _shouldAddSlash (url) {\n  const protocolIndex = url.indexOf('//') + 2;\n  const noPath = !(url.includes('/', protocolIndex));\n  const noQuery = !(url.includes('?', protocolIndex));\n  const noHash = !(url.includes('#', protocolIndex));\n  return (noPath && noQuery && noHash);\n}\n\nfunction _shouldAddProtocol (url) {\n  return url.startsWith('//');\n}\n\n/*\n* PRECONDITION: Base is a fully qualified URL. e.g. http://example.com/\n* optional: path, query or hash\n* returns the resolved url\n*/\nfunction urlResolve (base, relative) {\n  base = base.trim();\n  relative = relative.trim();\n\n  // about is always absolute\n  if (relative.startsWith('about:')) {\n    return relative;\n  }\n\n  const baseObj = _baseParse(base);\n  const relativeObj = _relativeParse(relative);\n\n  if (!baseObj.protocol && !relativeObj.netPath) {\n    throw new Error('Error, protocol is not specified');\n  }\n\n  if (relativeObj.netPath) { // relative is full qualified URL\n    if (_shouldAddProtocol(relativeObj.href)) {\n      relativeObj.href = baseObj.protocol + relativeObj.href;\n    }\n\n    if (_shouldAddSlash(relativeObj.href)) {\n      return _addSlash(relativeObj.href);\n    }\n\n    return relativeObj.href;\n  } else if (relativeObj.absolutePath) { // relative is an absolute path\n    const {path, query, hash} = relativeObj;\n\n    return baseObj.host + _pathResolve(path) + query + hash;\n  } else if (relativeObj.relativePath) { // relative is a relative path\n    const {path, query, hash} = relativeObj;\n\n    let basePath = baseObj.path;\n    let resultString = baseObj.host;\n\n    let resolvePath;\n\n    if (path.length === 0) {\n      resolvePath = basePath;\n    } else {\n      // remove last segment if no slash at end\n      basePath = basePath.substring(0, basePath.lastIndexOf('/'));\n      resolvePath = _pathResolve(basePath + '/' + path);\n    }\n\n    // if result is just the base host, add /\n    if ((resolvePath === '') && (!query) && (!hash)) {\n      resultString += '/';\n    } else {\n      resultString += resolvePath + query + hash;\n    }\n\n    return resultString;\n  } else {\n    const {host, path, query} = baseObj;\n    // when path and query aren't supplied add slash\n    if ((!path) && (!query)) {\n      return _addSlash(host);\n    }\n    return host + path + query + relativeObj.hash;\n  }\n}\n","const resolveUrl = require(\"url-resolve-browser\");\n\n\nconst isObject = (value) => typeof value === \"object\" && !Array.isArray(value) && value !== null;\nconst isType = {\n  null: (value) => value === null,\n  boolean: (value) => typeof value === \"boolean\",\n  object: isObject,\n  array: (value) => Array.isArray(value),\n  number: (value) => typeof value === \"number\",\n  integer: (value) => Number.isInteger(value),\n  string: (value) => typeof value === \"string\"\n};\nconst jsonTypeOf = (value, type) => isType[type](value);\n\nconst splitUrl = (url) => {\n  const indexOfHash = url.indexOf(\"#\");\n  const ndx = indexOfHash === -1 ? url.length : indexOfHash;\n  const urlReference = url.slice(0, ndx);\n  const urlFragment = url.slice(ndx + 1);\n\n  return [decodeURI(urlReference), decodeURI(urlFragment)];\n};\n\nconst getScheme = (url) => {\n  const matches = RegExp(/^(.+):\\/\\//).exec(url);\n  return matches ? matches[1] : \"\";\n};\n\nconst safeResolveUrl = (contextUrl, url) => {\n  const resolvedUrl = resolveUrl(contextUrl, url);\n  const contextId = splitUrl(contextUrl)[0];\n  if (contextId && getScheme(resolvedUrl) === \"file\" && getScheme(contextId) !== \"file\") {\n    throw Error(`Can't access file '${resolvedUrl}' resource from network context '${contextUrl}'`);\n  }\n  return resolvedUrl;\n};\n\nconst CHAR_BACKWARD_SLASH = 47;\n\nconst pathRelative = (from, to) => {\n  if (from === to) {\n    return \"\";\n  }\n\n  let toStart = 1;\n  const fromLen = from.length - 1;\n  const toLen = to.length - toStart;\n\n  // Compare paths to find the longest common path from root\n  const length = fromLen < toLen ? fromLen : toLen;\n  let lastCommonSep = -1;\n  let i = 0;\n  for (; i < length; i++) {\n    const fromCode = from.charCodeAt(i + 1);\n    if (fromCode !== to.charCodeAt(toStart + i)) {\n      break;\n    } else if (fromCode === CHAR_BACKWARD_SLASH) {\n      lastCommonSep = i;\n    }\n  }\n\n  if (toLen > length) {\n    if (to.charCodeAt(toStart + i) === CHAR_BACKWARD_SLASH) {\n      return to.slice(toStart + i + 1);\n    }\n    if (i === 0) {\n      return to.slice(toStart + i);\n    }\n  }\n  if (fromLen > length) {\n    if (from.charCodeAt(i + 1) === CHAR_BACKWARD_SLASH) {\n      lastCommonSep = i;\n    } else if (length === 0) {\n      lastCommonSep = 0;\n    }\n  }\n\n  let out = \"\";\n  // Generate the relative path based on the path difference between `to` and `from`\n  for (i = lastCommonSep + 2; i <= from.length; ++i) {\n    if (i === from.length || from.charCodeAt(i) === CHAR_BACKWARD_SLASH) {\n      out += out.length === 0 ? \"..\" : \"/..\";\n    }\n  }\n\n  toStart += lastCommonSep;\n\n  // Lastly, append the rest of the destination (`to`) path that comes after\n  // the common path parts\n  if (out.length > 0) {\n    return `${out}${to.slice(toStart, to.length)}`;\n  }\n\n  if (to.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) {\n    ++toStart;\n  }\n\n  return to.slice(toStart, to.length);\n};\n\nmodule.exports = { jsonTypeOf, splitUrl, safeResolveUrl, pathRelative };\n","const curry = require(\"just-curry-it\");\n\n\nconst nil = \"\";\n\nconst compile = (pointer) => {\n  if (pointer.length > 0 && pointer[0] !== \"/\") {\n    throw Error(\"Invalid JSON Pointer\");\n  }\n\n  return pointer.split(\"/\").slice(1).map(unescape);\n};\n\nconst get = (pointer, value = undefined) => {\n  const ptr = compile(pointer);\n\n  const fn = (value) => ptr.reduce(([value, pointer], segment) => {\n    return [applySegment(value, segment, pointer), append(segment, pointer)];\n  }, [value, \"\"])[0];\n\n  return value === undefined ? fn : fn(value);\n};\n\nconst set = (pointer, subject = undefined, value = undefined) => {\n  const ptr = compile(pointer);\n  const fn = curry((subject, value) => _set(ptr, subject, value, nil));\n  return subject === undefined ? fn : fn(subject, value);\n};\n\nconst _set = (pointer, subject, value, cursor) => {\n  if (pointer.length === 0) {\n    return value;\n  } else if (pointer.length > 1) {\n    const segment = pointer.shift();\n    return { ...subject, [segment]: _set(pointer, applySegment(subject, segment, cursor), value, append(segment, cursor)) };\n  } else if (Array.isArray(subject)) {\n    const clonedSubject = [...subject];\n    const segment = computeSegment(subject, pointer[0]);\n    clonedSubject[segment] = value;\n    return clonedSubject;\n  } else if (typeof subject === \"object\" && subject !== null) {\n    return { ...subject, [pointer[0]]: value };\n  } else {\n    return applySegment(subject, pointer[0], cursor);\n  }\n};\n\nconst assign = (pointer, subject = undefined, value = undefined) => {\n  const ptr = compile(pointer);\n  const fn = curry((subject, value) => _assign(ptr, subject, value, nil));\n  return subject === undefined ? fn : fn(subject, value);\n};\n\nconst _assign = (pointer, subject, value, cursor) => {\n  if (pointer.length === 0) {\n    return;\n  } else if (pointer.length === 1 && !isScalar(subject)) {\n    const segment = computeSegment(subject, pointer[0]);\n    subject[segment] = value;\n  } else {\n    const segment = pointer.shift();\n    _assign(pointer, applySegment(subject, segment, cursor), value, append(segment, cursor));\n  }\n};\n\nconst unset = (pointer, subject = undefined) => {\n  const ptr = compile(pointer);\n  const fn = (subject) => _unset(ptr, subject, nil);\n  return subject === undefined ? fn : fn(subject);\n};\n\nconst _unset = (pointer, subject, cursor) => {\n  if (pointer.length == 0) {\n    return undefined;\n  } else if (pointer.length > 1) {\n    const segment = pointer.shift();\n    const value = applySegment(subject, segment, cursor);\n    return { ...subject, [segment]: _unset(pointer, value, append(segment, cursor)) };\n  } else if (Array.isArray(subject)) {\n    return subject.filter((_, ndx) => ndx != pointer[0]);\n  } else if (typeof subject === \"object\" && subject !== null) {\n    // eslint-disable-next-line no-unused-vars\n    const { [pointer[0]]: _, ...result } = subject;\n    return result;\n  } else {\n    return applySegment(subject, pointer[0], cursor);\n  }\n};\n\nconst remove = (pointer, subject = undefined) => {\n  const ptr = compile(pointer);\n  const fn = (subject) => _remove(ptr, subject, nil);\n  return subject === undefined ? fn : fn(subject);\n};\n\nconst _remove = (pointer, subject, cursor) => {\n  if (pointer.length === 0) {\n    return;\n  } else if (pointer.length > 1) {\n    const segment = pointer.shift();\n    const value = applySegment(subject, segment, cursor);\n    _remove(pointer, value, append(segment, cursor));\n  } else if (Array.isArray(subject)) {\n    subject.splice(pointer[0], 1);\n  } else if (typeof subject === \"object\" && subject !== null) {\n    delete subject[pointer[0]];\n  } else {\n    applySegment(subject, pointer[0], cursor);\n  }\n};\n\nconst append = curry((segment, pointer) => pointer + \"/\" + escape(segment));\n\nconst escape = (segment) => segment.toString().replace(/~/g, \"~0\").replace(/\\//g, \"~1\");\nconst unescape = (segment) => segment.toString().replace(/~1/g, \"/\").replace(/~0/g, \"~\");\nconst computeSegment = (value, segment) => Array.isArray(value) && segment === \"-\" ? value.length : segment;\n\nconst applySegment = (value, segment, cursor = \"\") => {\n  if (value === undefined) {\n    throw TypeError(`Value at '${cursor}' is undefined and does not have property '${segment}'`);\n  } else if (value === null) {\n    throw TypeError(`Value at '${cursor}' is null and does not have property '${segment}'`);\n  } else if (isScalar(value)) {\n    throw TypeError(`Value at '${cursor}' is a ${typeof value} and does not have property '${segment}'`);\n  } else {\n    const computedSegment = computeSegment(value, segment);\n    return value[computedSegment];\n  }\n};\n\nconst isScalar = (value) => value === null || typeof value !== \"object\";\n\nmodule.exports = { nil, append, get, set, assign, unset, remove };\n","const $__value = Symbol(\"$__value\");\nconst $__href = Symbol(\"$__href\");\n\nconst cons = (href, value) => Object.freeze({\n  [$__href]: href,\n  [$__value]: value\n});\n\nconst isReference = (ref) => ref && ref[$__href] !== undefined;\nconst href = (ref) => ref[$__href];\nconst value = (ref) => ref[$__value];\n\nmodule.exports = { cons, isReference, href, value };\n","const JsonPointer = require(\"@hyperjump/json-pointer\");\nconst curry = require(\"just-curry-it\");\nconst { jsonTypeOf } = require(\"./common\");\nconst Reference = require(\"./reference\");\n\n\nconst nil = Object.freeze({ id: \"\", pointer: \"\", instance: undefined, value: undefined });\nconst cons = (instance, id = \"\") => Object.freeze({ ...nil, id, instance, value: instance });\nconst uri = (doc) => `${doc.id}#${encodeURI(doc.pointer)}`;\nconst value = (doc) => Reference.isReference(doc.value) ? Reference.value(doc.value) : doc.value;\nconst has = (key, doc) => key in value(doc);\nconst typeOf = curry((doc, type) => jsonTypeOf(value(doc), type));\n\nconst step = (key, doc) => Object.freeze({\n  ...doc,\n  pointer: JsonPointer.append(key, doc.pointer),\n  value: value(doc)[key]\n});\n\nconst entries = (doc) => Object.keys(value(doc))\n  .map((key) => [key, step(key, doc)]);\n\nconst keys = (doc) => Object.keys(value(doc));\n\nconst map = curry((fn, doc) => value(doc)\n  .map((item, ndx, array, thisArg) => fn(step(ndx, doc), ndx, array, thisArg)));\n\nconst filter = curry((fn, doc) => value(doc)\n  .map((item, ndx, array, thisArg) => step(ndx, doc, array, thisArg))\n  .filter((item, ndx, array, thisArg) => fn(item, ndx, array, thisArg)));\n\nconst reduce = curry((fn, acc, doc) => value(doc)\n  .reduce((acc, item, ndx) => fn(acc, step(ndx, doc), ndx), acc));\n\nconst every = curry((fn, doc) => value(doc)\n  .every((item, ndx, array, thisArg) => fn(step(ndx, doc), ndx, array, thisArg)));\n\nconst some = curry((fn, doc) => value(doc)\n  .some((item, ndx, array, thisArg) => fn(step(ndx, doc), ndx, array, thisArg)));\n\nconst length = (doc) => value(doc).length;\n\nmodule.exports = { nil, cons, uri, value, has, typeOf, step, entries, keys, map, filter, reduce, every, some, length };\n","/*!\n * content-type\n * Copyright(c) 2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * RegExp to match *( \";\" parameter ) in RFC 7231 sec 3.1.1.1\n *\n * parameter     = token \"=\" ( token / quoted-string )\n * token         = 1*tchar\n * tchar         = \"!\" / \"#\" / \"$\" / \"%\" / \"&\" / \"'\" / \"*\"\n *               / \"+\" / \"-\" / \".\" / \"^\" / \"_\" / \"`\" / \"|\" / \"~\"\n *               / DIGIT / ALPHA\n *               ; any VCHAR, except delimiters\n * quoted-string = DQUOTE *( qdtext / quoted-pair ) DQUOTE\n * qdtext        = HTAB / SP / %x21 / %x23-5B / %x5D-7E / obs-text\n * obs-text      = %x80-FF\n * quoted-pair   = \"\\\" ( HTAB / SP / VCHAR / obs-text )\n */\nvar PARAM_REGEXP = /; *([!#$%&'*+.^_`|~0-9A-Za-z-]+) *= *(\"(?:[\\u000b\\u0020\\u0021\\u0023-\\u005b\\u005d-\\u007e\\u0080-\\u00ff]|\\\\[\\u000b\\u0020-\\u00ff])*\"|[!#$%&'*+.^_`|~0-9A-Za-z-]+) */g\nvar TEXT_REGEXP = /^[\\u000b\\u0020-\\u007e\\u0080-\\u00ff]+$/\nvar TOKEN_REGEXP = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+$/\n\n/**\n * RegExp to match quoted-pair in RFC 7230 sec 3.2.6\n *\n * quoted-pair = \"\\\" ( HTAB / SP / VCHAR / obs-text )\n * obs-text    = %x80-FF\n */\nvar QESC_REGEXP = /\\\\([\\u000b\\u0020-\\u00ff])/g\n\n/**\n * RegExp to match chars that must be quoted-pair in RFC 7230 sec 3.2.6\n */\nvar QUOTE_REGEXP = /([\\\\\"])/g\n\n/**\n * RegExp to match type in RFC 7231 sec 3.1.1.1\n *\n * media-type = type \"/\" subtype\n * type       = token\n * subtype    = token\n */\nvar TYPE_REGEXP = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+\\/[!#$%&'*+.^_`|~0-9A-Za-z-]+$/\n\n/**\n * Module exports.\n * @public\n */\n\nexports.format = format\nexports.parse = parse\n\n/**\n * Format object to media type.\n *\n * @param {object} obj\n * @return {string}\n * @public\n */\n\nfunction format (obj) {\n  if (!obj || typeof obj !== 'object') {\n    throw new TypeError('argument obj is required')\n  }\n\n  var parameters = obj.parameters\n  var type = obj.type\n\n  if (!type || !TYPE_REGEXP.test(type)) {\n    throw new TypeError('invalid type')\n  }\n\n  var string = type\n\n  // append parameters\n  if (parameters && typeof parameters === 'object') {\n    var param\n    var params = Object.keys(parameters).sort()\n\n    for (var i = 0; i < params.length; i++) {\n      param = params[i]\n\n      if (!TOKEN_REGEXP.test(param)) {\n        throw new TypeError('invalid parameter name')\n      }\n\n      string += '; ' + param + '=' + qstring(parameters[param])\n    }\n  }\n\n  return string\n}\n\n/**\n * Parse media type to object.\n *\n * @param {string|object} string\n * @return {Object}\n * @public\n */\n\nfunction parse (string) {\n  if (!string) {\n    throw new TypeError('argument string is required')\n  }\n\n  // support req/res-like objects as argument\n  var header = typeof string === 'object'\n    ? getcontenttype(string)\n    : string\n\n  if (typeof header !== 'string') {\n    throw new TypeError('argument string is required to be a string')\n  }\n\n  var index = header.indexOf(';')\n  var type = index !== -1\n    ? header.substr(0, index).trim()\n    : header.trim()\n\n  if (!TYPE_REGEXP.test(type)) {\n    throw new TypeError('invalid media type')\n  }\n\n  var obj = new ContentType(type.toLowerCase())\n\n  // parse parameters\n  if (index !== -1) {\n    var key\n    var match\n    var value\n\n    PARAM_REGEXP.lastIndex = index\n\n    while ((match = PARAM_REGEXP.exec(header))) {\n      if (match.index !== index) {\n        throw new TypeError('invalid parameter format')\n      }\n\n      index += match[0].length\n      key = match[1].toLowerCase()\n      value = match[2]\n\n      if (value[0] === '\"') {\n        // remove quotes and escapes\n        value = value\n          .substr(1, value.length - 2)\n          .replace(QESC_REGEXP, '$1')\n      }\n\n      obj.parameters[key] = value\n    }\n\n    if (index !== header.length) {\n      throw new TypeError('invalid parameter format')\n    }\n  }\n\n  return obj\n}\n\n/**\n * Get content-type from req/res objects.\n *\n * @param {object}\n * @return {Object}\n * @private\n */\n\nfunction getcontenttype (obj) {\n  var header\n\n  if (typeof obj.getHeader === 'function') {\n    // res-like\n    header = obj.getHeader('content-type')\n  } else if (typeof obj.headers === 'object') {\n    // req-like\n    header = obj.headers && obj.headers['content-type']\n  }\n\n  if (typeof header !== 'string') {\n    throw new TypeError('content-type header is missing from object')\n  }\n\n  return header\n}\n\n/**\n * Quote a string if necessary.\n *\n * @param {string} val\n * @return {string}\n * @private\n */\n\nfunction qstring (val) {\n  var str = String(val)\n\n  // no need to quote tokens\n  if (TOKEN_REGEXP.test(str)) {\n    return str\n  }\n\n  if (str.length > 0 && !TEXT_REGEXP.test(str)) {\n    throw new TypeError('invalid parameter value')\n  }\n\n  return '\"' + str.replace(QUOTE_REGEXP, '\\\\$1') + '\"'\n}\n\n/**\n * Class to represent a content type.\n * @private\n */\nfunction ContentType (type) {\n  this.parameters = Object.create(null)\n  this.type = type\n}\n","module.exports = async (doc) => Object.entries(await doc);\n","const curry = require(\"just-curry-it\");\n\n\nmodule.exports = curry(async (fn, doc) => (await doc).map(fn));\n","const curry = require(\"just-curry-it\");\n\n\nmodule.exports = curry(async (fn, acc, doc) => {\n  return (await doc).reduce(async (acc, item) => fn(await acc, item), acc);\n});\n","const curry = require(\"just-curry-it\");\nconst reduce = require(\"./reduce\");\n\n\nmodule.exports = curry(async (fn, doc, options = {}) => {\n  return reduce(async (acc, item) => {\n    return (await fn(item)) ? acc.concat([item]) : acc;\n  }, [], doc, options);\n});\n","const curry = require(\"just-curry-it\");\nconst map = require(\"./map\");\n\n\nmodule.exports = curry(async (fn, doc) => {\n  const results = await map(fn, doc);\n  return (await Promise.all(results))\n    .some((a) => a);\n});\n","const curry = require(\"just-curry-it\");\nconst map = require(\"./map\");\n\n\nmodule.exports = curry(async (fn, doc) => {\n  const results = await map(fn, doc);\n  return (await Promise.all(results))\n    .every((a) => a);\n});\n","const curry = require(\"just-curry-it\");\n\n\nmodule.exports = curry((fns, doc) => {\n  return fns.reduce(async (acc, fn) => fn(await acc), doc);\n});\n","module.exports = {\n  entries: require(\"./entries\"),\n  map: require(\"./map\"),\n  filter: require(\"./filter\"),\n  reduce: require(\"./reduce\"),\n  some: require(\"./some\"),\n  every: require(\"./every\"),\n  pipeline: require(\"./pipeline\"),\n  all: require(\"./all\"),\n  allValues: require(\"./allValues\")\n};\n","module.exports = (doc) => Promise.all(doc);\n","const pipeline = require(\"./pipeline\");\nconst entries = require(\"./entries\");\nconst reduce = require(\"./reduce\");\n\n\nmodule.exports = (doc) => {\n  return pipeline([\n    entries,\n    reduce(async (acc, [propertyName, propertyValue]) => {\n      acc[propertyName] = await propertyValue;\n      return acc;\n    }, {})\n  ], doc);\n};\n","module.exports = fetch;\n","const contentTypeParser = require(\"content-type\");\nconst curry = require(\"just-curry-it\");\nconst Pact = require(\"@hyperjump/pact\");\nconst JsonPointer = require(\"@hyperjump/json-pointer\");\nconst { jsonTypeOf, splitUrl, safeResolveUrl, pathRelative } = require(\"./common\");\nconst fetch = require(\"./fetch\");\nconst Reference = require(\"./reference\");\n\n\n// Config\nconst config = {};\nconst configAlias = {};\n\nconst setConfig = (schemaVersion, key, value) => {\n  if (!config[schemaVersion]) {\n    config[schemaVersion] = {};\n  }\n  config[schemaVersion][key] = value;\n};\n\nconst getConfig = (schemaVersion, key) => {\n  const configVersion = schemaVersion in configAlias ? configAlias[schemaVersion] : schemaVersion;\n  if (configVersion in config) {\n    return config[configVersion][key];\n  }\n};\n\n// Schema Management\nconst schemaStore = {};\nconst schemaStoreAlias = {};\n\nconst add = (schema, url = \"\", defaultSchemaVersion = \"\") => {\n  schema = JSON.parse(JSON.stringify(schema));\n\n  // Schema Version\n  const schemaVersion = splitUrl(schema[\"$schema\"] || defaultSchemaVersion)[0];\n  if (!schemaVersion) {\n    throw Error(\"Couldn't determine schema version\");\n  }\n  delete schema[\"$schema\"];\n\n  // Identifier\n  const baseToken = getConfig(schemaVersion, \"baseToken\");\n  const anchorToken = getConfig(schemaVersion, \"anchorToken\");\n  const externalId = splitUrl(url)[0];\n  if (!externalId && !splitUrl(schema[baseToken] || \"\")[0]) {\n    throw Error(\"Couldn't determine an identifier for the schema\");\n  }\n  const internalUrl = safeResolveUrl(externalId, schema[baseToken] || \"\");\n  const [id, fragment] = splitUrl(internalUrl);\n  delete schema[baseToken];\n  if (fragment && baseToken === anchorToken) {\n    schema[anchorToken] = anchorToken !== baseToken ? encodeURI(fragment) : `#${encodeURI(fragment)}`;\n  }\n  if (externalId) {\n    schemaStoreAlias[externalId] = id;\n  }\n\n  // recursiveAnchor\n  const dynamicAnchors = {};\n  const recursiveAnchorToken = getConfig(schemaVersion, \"recursiveAnchorToken\");\n  if (schema[recursiveAnchorToken] === true) {\n    dynamicAnchors[\"\"] = `${id}#`;\n    schema[anchorToken] = \"\";\n    delete schema[recursiveAnchorToken];\n  }\n\n  // Vocabulary\n  let vocabulary;\n  const vocabularyToken = getConfig(schemaVersion, \"vocabularyToken\");\n  if (jsonTypeOf(schema[vocabularyToken], \"object\")) {\n    configAlias[id] = schemaVersion;\n    vocabulary = schema[vocabularyToken];\n    delete schema[vocabularyToken];\n  } else {\n    configAlias[id] = schemaVersion;\n    vocabulary = { [schemaVersion]: true };\n  }\n\n  // Store Schema\n  const anchors = { \"\": \"\" };\n  schemaStore[id] = {\n    id: id,\n    schemaVersion: schemaVersion,\n    schema: processSchema(schema, id, schemaVersion, JsonPointer.nil, anchors, dynamicAnchors),\n    anchors: anchors,\n    dynamicAnchors: dynamicAnchors,\n    vocabulary: vocabulary,\n    validated: false\n  };\n\n  return id;\n};\n\nconst processSchema = (subject, id, schemaVersion, pointer, anchors, dynamicAnchors) => {\n  if (jsonTypeOf(subject, \"object\")) {\n    const embeddedSchemaVersion = typeof subject[\"$schema\"] === \"string\" ? splitUrl(subject[\"$schema\"])[0] : schemaVersion;\n    const embeddedEmbeddedToken = getConfig(embeddedSchemaVersion, \"embeddedToken\");\n    const embeddedAnchorToken = getConfig(embeddedSchemaVersion, \"anchorToken\");\n    if (typeof subject[embeddedEmbeddedToken] === \"string\" && (embeddedEmbeddedToken !== embeddedAnchorToken || subject[embeddedEmbeddedToken][0] !== \"#\")) {\n      const ref = safeResolveUrl(id, subject[embeddedEmbeddedToken]);\n      subject[embeddedEmbeddedToken] = ref;\n      add(subject, ref, schemaVersion);\n      return Reference.cons(subject[embeddedEmbeddedToken], subject);\n    }\n\n    const anchorToken = getConfig(schemaVersion, \"anchorToken\");\n    const dynamicAnchorToken = getConfig(schemaVersion, \"dynamicAnchorToken\");\n    if (typeof subject[dynamicAnchorToken] === \"string\") {\n      dynamicAnchors[subject[dynamicAnchorToken]] = `${id}#${encodeURI(pointer)}`;\n      anchors[subject[dynamicAnchorToken]] = pointer;\n      delete subject[dynamicAnchorToken];\n    }\n\n    const embeddedToken = getConfig(schemaVersion, \"embeddedToken\");\n    if (typeof subject[anchorToken] === \"string\") {\n      const anchor = anchorToken !== embeddedToken ? subject[anchorToken] : subject[anchorToken].slice(1);\n      anchors[anchor] = pointer;\n      delete subject[anchorToken];\n    }\n\n    const jrefToken = getConfig(schemaVersion, \"jrefToken\");\n    if (typeof subject[jrefToken] === \"string\") {\n      return Reference.cons(subject[jrefToken], subject);\n    }\n\n    for (const key in subject) {\n      subject[key] = processSchema(subject[key], id, schemaVersion, JsonPointer.append(key, pointer), anchors, dynamicAnchors);\n    }\n\n    return subject;\n  } else if (Array.isArray(subject)) {\n    return subject.map((item, ndx) => processSchema(item, id, schemaVersion, JsonPointer.append(ndx, pointer), anchors, dynamicAnchors));\n  } else {\n    return subject;\n  }\n};\n\nconst hasStoredSchema = (id) => id in schemaStore || id in schemaStoreAlias;\nconst getStoredSchema = (id) => schemaStore[schemaStoreAlias[id]] || schemaStore[id];\n\nconst markValidated = (id) => {\n  schemaStore[id].validated = true;\n};\n\n// Schema Retrieval\nconst nil = Object.freeze({\n  id: \"\",\n  schemaVersion: undefined,\n  vocabulary: {},\n  pointer: JsonPointer.nil,\n  schema: undefined,\n  value: undefined,\n  anchors: {},\n  dynamicAnchors: {},\n  validated: true\n});\n\nconst get = async (url, contextDoc = nil) => {\n  const resolvedUrl = safeResolveUrl(uri(contextDoc), url);\n  const [id, fragment] = splitUrl(resolvedUrl);\n\n  if (!hasStoredSchema(id)) {\n    const response = await fetch(id, { headers: { Accept: \"application/schema+json\" } });\n    if (response.status >= 400) {\n      await response.text(); // Sometimes node hangs without this hack\n      throw Error(`Failed to retrieve schema with id: ${id}`);\n    }\n\n    if (response.headers.has(\"content-type\")) {\n      const contentType = contentTypeParser.parse(response.headers.get(\"content-type\")).type;\n      if (contentType !== \"application/schema+json\") {\n        throw Error(`${id} is not a schema. Found a document with media type: ${contentType}`);\n      }\n    }\n\n    add(await response.json(), id);\n  }\n\n  const storedSchema = getStoredSchema(id);\n  const pointer = fragment[0] !== \"/\" ? getAnchorPointer(storedSchema, fragment) : fragment;\n  const doc = Object.freeze({\n    ...storedSchema,\n    pointer: pointer,\n    value: JsonPointer.get(pointer, storedSchema.schema)\n  });\n\n  return followReferences(doc);\n};\n\nconst followReferences = (doc) => Reference.isReference(doc.value) ? get(Reference.href(doc.value), doc) : doc;\n\nconst getAnchorPointer = (schema, fragment) => {\n  if (!(fragment in schema.anchors)) {\n    throw Error(`No such anchor '${encodeURI(schema.id)}#${encodeURI(fragment)}'`);\n  }\n\n  return schema.anchors[fragment];\n};\n\n// Utility Functions\nconst uri = (doc) => `${doc.id}#${encodeURI(doc.pointer)}`;\nconst value = (doc) => Reference.isReference(doc.value) ? Reference.value(doc.value) : doc.value;\nconst has = (key, doc) => key in value(doc);\nconst typeOf = (doc, type) => jsonTypeOf(value(doc), type);\n\nconst step = (key, doc) => {\n  const storedSchema = getStoredSchema(doc.id);\n  const nextDoc = Object.freeze({\n    ...doc,\n    pointer: JsonPointer.append(key, doc.pointer),\n    value: value(doc)[key],\n    validated: storedSchema.validated\n  });\n  return followReferences(nextDoc);\n};\n\nconst keys = (doc) => Object.keys(value(doc));\n\nconst entries = (doc) => Pact.pipeline([\n  value,\n  Object.keys,\n  Pact.map(async (key) => [key, await step(key, doc)]),\n  Pact.all\n], doc);\n\nconst map = curry((fn, doc) => Pact.pipeline([\n  value,\n  Pact.map(async (item, ndx) => fn(await step(ndx, doc), ndx)),\n  Pact.all\n], doc));\n\nconst length = (doc) => value(doc).length;\n\nconst toSchemaDefaultOptions = {\n  parentId: \"\",\n  parentDialect: \"\",\n  includeEmbedded: true\n};\nconst toSchema = (schemaDoc, options = {}) => {\n  const fullOptions = { ...toSchemaDefaultOptions, ...options };\n\n  const schema = JSON.parse(JSON.stringify(schemaDoc.schema, (key, value) => {\n    if (!Reference.isReference(value)) {\n      return value;\n    }\n\n    const refValue = Reference.value(value);\n    const embeddedDialect = refValue.$schema || schemaDoc.schemaVersion;\n    const embeddedToken = getConfig(embeddedDialect, \"embeddedToken\");\n    if (!fullOptions.includeEmbedded && embeddedToken in refValue) {\n      return;\n    } else {\n      return Reference.value(value);\n    }\n  }));\n\n  const dynamicAnchorToken = getConfig(schemaDoc.schemaVersion, \"dynamicAnchorToken\");\n  Object.entries(schemaDoc.dynamicAnchors)\n    .forEach(([anchor, uri]) => {\n      const pointer = splitUrl(uri)[1];\n      JsonPointer.assign(pointer, schema, {\n        [dynamicAnchorToken]: anchor,\n        ...JsonPointer.get(pointer, schema)\n      });\n    });\n\n  const anchorToken = getConfig(schemaDoc.schemaVersion, \"anchorToken\");\n  Object.entries(schemaDoc.anchors)\n    .filter(([anchor]) => anchor !== \"\")\n    .forEach(([anchor, pointer]) => {\n      JsonPointer.assign(pointer, schema, {\n        [anchorToken]: anchor,\n        ...JsonPointer.get(pointer, schema)\n      });\n    });\n\n  const baseToken = getConfig(schemaDoc.schemaVersion, \"baseToken\");\n  const id = relativeUri(fullOptions.parentId, schemaDoc.id);\n  const dialect = fullOptions.parentDialect === schemaDoc.schemaVersion ? \"\" : schemaDoc.schemaVersion;\n  return {\n    ...(id && { [baseToken]: id }),\n    ...(dialect && { $schema: dialect }),\n    ...schema\n  };\n};\n\nconst relativeUri = (from, to) => {\n  if (to.startsWith(\"file://\")) {\n    const pathToSchema = from.slice(7, from.lastIndexOf(\"/\"));\n    return from === \"\" ? \"\" : pathRelative(pathToSchema, to.slice(7));\n  } else {\n    return to;\n  }\n};\n\nmodule.exports = {\n  setConfig, getConfig,\n  add, get, markValidated,\n  uri, value, getAnchorPointer, typeOf, has, step, keys, entries, map, length,\n  toSchema\n};\n","class InvalidSchemaError extends Error {\n  constructor(output) {\n    super(\"Invalid Schema\");\n    this.name = this.constructor.name;\n    this.output = output;\n  }\n}\n\nmodule.exports = InvalidSchemaError;\n","const curry = require(\"just-curry-it\");\nconst PubSub = require(\"pubsub-js\");\nconst { splitUrl } = require(\"./common\");\nconst Instance = require(\"./instance\");\nconst Schema = require(\"./schema\");\nconst InvalidSchemaError = require(\"./invalid-schema-error\");\n\n\nconst FLAG = \"FLAG\", BASIC = \"BASIC\", DETAILED = \"DETAILED\", VERBOSE = \"VERBOSE\";\n\nlet metaOutputFormat = DETAILED;\nlet shouldMetaValidate = true;\n\nconst validate = async (schema, value = undefined, outputFormat = undefined) => {\n  const compiled = await compile(schema);\n  const interpretAst = (value, outputFormat) => interpret(compiled, Instance.cons(value), outputFormat);\n\n  return value === undefined ? interpretAst : interpretAst(value, outputFormat);\n};\n\nconst compile = async (schema) => {\n  const ast = { metaData: {} };\n  const schemaUri = await compileSchema(schema, ast);\n  return { ast, schemaUri };\n};\n\nconst interpret = curry(({ ast, schemaUri }, value, outputFormat = FLAG) => {\n  if (![FLAG, BASIC, DETAILED, VERBOSE].includes(outputFormat)) {\n    throw Error(`The '${outputFormat}' error format is not supported`);\n  }\n\n  const output = [];\n  const subscriptionToken = PubSub.subscribe(\"result\", outputHandler(outputFormat, output));\n  interpretSchema(schemaUri, value, ast, {});\n  PubSub.unsubscribe(subscriptionToken);\n\n  return output[0];\n});\n\nconst outputHandler = (outputFormat, output) => {\n  const resultStack = [];\n\n  return (message, keywordResult) => {\n    if (message === \"result\") {\n      const { keyword, absoluteKeywordLocation, instanceLocation, valid } = keywordResult;\n      const result = { keyword, absoluteKeywordLocation, instanceLocation, valid, errors: [] };\n      resultStack.push(result);\n    } else if (message === \"result.start\") {\n      resultStack.push(message);\n    } else if (message === \"result.end\") {\n      const result = resultStack.pop();\n      while (resultStack[resultStack.length - 1] !== \"result.start\") {\n        const topResult = resultStack.pop();\n\n        const errors = [topResult];\n        if (outputFormat === BASIC) {\n          errors.push(...topResult.errors);\n          delete topResult.errors;\n        }\n\n        if (outputFormat === VERBOSE || (outputFormat !== FLAG && !topResult.valid)) {\n          result.errors.unshift(...errors);\n        }\n      }\n      resultStack[resultStack.length - 1] = result;\n\n      output[0] = result;\n    }\n  };\n};\n\nconst setMetaOutputFormat = (format) => {\n  metaOutputFormat = format;\n};\n\nconst setShouldMetaValidate = (isEnabled) => {\n  shouldMetaValidate = isEnabled;\n};\n\nconst _keywords = {};\nconst getKeyword = (id) => _keywords[id];\nconst hasKeyword = (id) => id in _keywords;\nconst addKeyword = (id, keywordHandler) => {\n  _keywords[id] = {\n    collectEvaluatedItems: (keywordValue, instance, ast, dynamicAnchors, isTop) => keywordHandler.interpret(keywordValue, instance, ast, dynamicAnchors, isTop) && new Set(),\n    collectEvaluatedProperties: (keywordValue, instance, ast, dynamicAnchors, isTop) => keywordHandler.interpret(keywordValue, instance, ast, dynamicAnchors, isTop) && [],\n    ...keywordHandler\n  };\n};\n\nconst _vocabularies = {};\nconst defineVocabulary = (id, keywords) => {\n  _vocabularies[id] = keywords;\n};\n\nconst metaValidators = {};\nconst compileSchema = async (schema, ast) => {\n  schema = await followReferences(schema);\n\n  // Vocabularies\n  if (!hasKeyword(`${schema.schemaVersion}#validate`)) {\n    const metaSchema = await Schema.get(schema.schemaVersion);\n\n    // Check for mandatory vocabularies\n    const mandatoryVocabularies = Schema.getConfig(metaSchema.id, \"mandatoryVocabularies\") || [];\n    mandatoryVocabularies.forEach((vocabularyId) => {\n      if (!metaSchema.vocabulary[vocabularyId]) {\n        throw Error(`Vocabulary '${vocabularyId}' must be explicitly declared and required`);\n      }\n    });\n\n    // Load vocabularies\n    Object.entries(metaSchema.vocabulary)\n      .forEach(([vocabularyId, isRequired]) => {\n        if (vocabularyId in _vocabularies) {\n          Object.entries(_vocabularies[vocabularyId])\n            .forEach(([keyword, keywordHandler]) => {\n              addKeyword(`${metaSchema.id}#${keyword}`, keywordHandler);\n            });\n        } else if (isRequired) {\n          throw Error(`Missing required vocabulary: ${vocabularyId}`);\n        }\n      });\n  }\n\n  // Meta validation\n  if (shouldMetaValidate && !schema.validated) {\n    Schema.markValidated(schema.id);\n\n    // Compile\n    if (!(schema.schemaVersion in metaValidators)) {\n      const metaSchema = await Schema.get(schema.schemaVersion);\n      const compiledSchema = await compile(metaSchema);\n      metaValidators[metaSchema.id] = interpret(compiledSchema);\n    }\n\n    // Interpret\n    const schemaInstance = Instance.cons(schema.schema, schema.id);\n    const metaResults = metaValidators[schema.schemaVersion](schemaInstance, metaOutputFormat);\n    if (!metaResults.valid) {\n      throw new InvalidSchemaError(metaResults);\n    }\n  }\n\n  // Compile\n  if (!(schema.id in ast.metaData)) {\n    ast.metaData[schema.id] = {\n      id: schema.id,\n      dynamicAnchors: schema.dynamicAnchors,\n      anchors: schema.anchors\n    };\n  }\n  return getKeyword(`${schema.schemaVersion}#validate`).compile(schema, ast);\n};\n\nconst followReferences = async (doc) => {\n  return Schema.typeOf(doc, \"string\") ? followReferences(await Schema.get(Schema.value(doc), doc)) : doc;\n};\n\nconst interpretSchema = (schemaUri, instance, ast, dynamicAnchors) => {\n  const keywordId = getKeywordId(schemaUri, ast);\n  const id = splitUrl(schemaUri)[0];\n  return getKeyword(keywordId).interpret(schemaUri, instance, ast, { ...ast.metaData[id].dynamicAnchors, ...dynamicAnchors });\n};\n\nconst collectEvaluatedProperties = (schemaUri, instance, ast, dynamicAnchors, isTop) => {\n  const keywordId = getKeywordId(schemaUri, ast);\n  return getKeyword(keywordId).collectEvaluatedProperties(schemaUri, instance, ast, dynamicAnchors, isTop);\n};\n\nconst collectEvaluatedItems = (schemaUri, instance, ast, dynamicAnchors, isTop) => {\n  const keywordId = getKeywordId(schemaUri, ast);\n  return getKeyword(keywordId).collectEvaluatedItems(schemaUri, instance, ast, dynamicAnchors, isTop);\n};\n\nconst getKeywordId = (schemaUri, ast) => {\n  if (!(schemaUri in ast)) {\n    throw Error(`No schema found at ${schemaUri}`);\n  }\n\n  return ast[schemaUri][0];\n};\n\nconst add = (schema, url = \"\", defaultSchemaVersion = \"\") => {\n  const id = Schema.add(schema, url, defaultSchemaVersion);\n  delete metaValidators[id];\n};\n\nmodule.exports = {\n  validate, compile, interpret,\n  setMetaOutputFormat, setShouldMetaValidate, FLAG, BASIC, DETAILED, VERBOSE,\n  add, getKeyword, hasKeyword, defineVocabulary,\n  compileSchema, interpretSchema, collectEvaluatedProperties, collectEvaluatedItems\n};\n","const Schema = require(\"../schema\");\n\n\nconst compile = (schema) => Schema.value(schema);\nconst interpret = () => true;\n\nmodule.exports = { compile, interpret };\n","const Pact = require(\"@hyperjump/pact\");\nconst PubSub = require(\"pubsub-js\");\nconst Core = require(\"../core\");\nconst Instance = require(\"../instance\");\nconst Schema = require(\"../schema\");\n\n\nconst compile = async (schema, ast) => {\n  const url = Schema.uri(schema);\n  if (!(url in ast)) {\n    ast[url] = false; // Place dummy entry in ast to avoid recursive loops\n\n    const schemaValue = Schema.value(schema);\n    if (![\"object\", \"boolean\"].includes(typeof schemaValue)) {\n      throw Error(`No schema found at '${Schema.uri(schema)}'`);\n    }\n\n    ast[url] = [\n      `${schema.schemaVersion}#validate`,\n      Schema.uri(schema),\n      typeof schemaValue === \"boolean\" ? schemaValue : await Pact.pipeline([\n        Schema.entries,\n        Pact.map(([keyword, keywordSchema]) => [`${schema.schemaVersion}#${keyword}`, keywordSchema]),\n        Pact.filter(([keywordId]) => Core.hasKeyword(keywordId) && keywordId !== `${schema.schemaVersion}#validate`),\n        Pact.map(async ([keywordId, keywordSchema]) => {\n          const keywordAst = await Core.getKeyword(keywordId).compile(keywordSchema, ast, schema);\n          return [keywordId, Schema.uri(keywordSchema), keywordAst];\n        }),\n        Pact.all\n      ], schema)\n    ];\n  }\n\n  return url;\n};\n\nconst interpret = (uri, instance, ast, dynamicAnchors) => {\n  const [keywordId, schemaUrl, nodes] = ast[uri];\n\n  PubSub.publishSync(\"result.start\");\n  const isValid = typeof nodes === \"boolean\" ? nodes : nodes\n    .every(([keywordId, schemaUrl, keywordValue]) => {\n      PubSub.publishSync(\"result.start\");\n      const isValid = Core.getKeyword(keywordId).interpret(keywordValue, instance, ast, dynamicAnchors);\n\n      PubSub.publishSync(\"result\", {\n        keyword: keywordId,\n        absoluteKeywordLocation: schemaUrl,\n        instanceLocation: Instance.uri(instance),\n        valid: isValid,\n        ast: keywordValue\n      });\n      PubSub.publishSync(\"result.end\");\n      return isValid;\n    });\n\n  PubSub.publishSync(\"result\", {\n    keyword: keywordId,\n    absoluteKeywordLocation: schemaUrl,\n    instanceLocation: Instance.uri(instance),\n    valid: isValid,\n    ast: uri\n  });\n  PubSub.publishSync(\"result.end\");\n  return isValid;\n};\n\nconst collectEvaluatedProperties = (uri, instance, ast, dynamicAnchors, isTop = false) => {\n  const nodes = ast[uri][2];\n\n  if (typeof nodes === \"boolean\") {\n    return nodes ? [] : false;\n  }\n\n  return nodes\n    .filter(([keywordId]) => !isTop || !keywordId.endsWith(\"#unevaluatedProperties\"))\n    .reduce((acc, [keywordId, , keywordValue]) => {\n      const propertyNames = acc && Core.getKeyword(keywordId).collectEvaluatedProperties(keywordValue, instance, ast, dynamicAnchors);\n      return propertyNames !== false && [...acc, ...propertyNames];\n    }, []);\n};\n\nconst collectEvaluatedItems = (uri, instance, ast, dynamicAnchors, isTop = false) => {\n  const nodes = ast[uri][2];\n\n  if (typeof nodes === \"boolean\") {\n    return nodes ? new Set() : false;\n  }\n\n  return nodes\n    .filter(([keywordId]) => !isTop || !keywordId.endsWith(\"#unevaluatedItems\"))\n    .reduce((acc, [keywordId, , keywordValue]) => {\n      const itemIndexes = acc !== false && Core.getKeyword(keywordId).collectEvaluatedItems(keywordValue, instance, ast, dynamicAnchors);\n      return itemIndexes !== false && new Set([...acc, ...itemIndexes]);\n    }, new Set());\n};\n\nmodule.exports = { compile, interpret, collectEvaluatedProperties, collectEvaluatedItems };\n","const metaData = require(\"./meta-data\");\nconst validate = require(\"./validate\");\n\n\nmodule.exports = { metaData, validate };\n","const Core = require(\"./core\");\nconst Schema = require(\"./schema\");\nconst Instance = require(\"./instance\");\nconst Reference = require(\"./reference\");\nconst Keywords = require(\"./keywords\");\nconst InvalidSchemaError = require(\"./invalid-schema-error\");\n\n\nmodule.exports = { Core, Schema, Instance, Reference, Keywords, InvalidSchemaError };\n"],"names":["fn","arity","curried","length","args","slice","call","arguments","apply","this","concat","root","PubSub","window","messages","lastUid","ALL_SUBSCRIBING_MSG","hasKeys","obj","key","Object","prototype","hasOwnProperty","throwException","ex","callSubscriberWithDelayedExceptions","subscriber","message","data","setTimeout","callSubscriberWithImmediateExceptions","deliverMessage","originalMessage","matchedMessage","immediateExceptions","s","subscribers","callSubscriber","createDeliveryFunction","topic","String","position","lastIndexOf","substr","hasDirectSubscribersFor","Boolean","messageHasSubscribers","found","publish","sync","deliver","toString","publishSync","subscribe","func","token","subscribeAll","subscribeOnce","unsubscribe","clearAllSubscriptions","clearSubscriptions","m","indexOf","countSubscriptions","count","getSubscriptions","list","push","value","t","descendantTopicExists","isTopic","isToken","isFunction","result","factory","undefined","module","exports","base","relative","trim","startsWith","baseObj","resultObject","host","path","query","protocol","protocolEndIndex","substring","pathIndex","queryIndex","hashIndex","_baseParse","relativeObj","href","hash","netPath","absolutePath","relativePath","_isAbsolute","test","_relativeParse","Error","url","protocolIndex","noPath","includes","noQuery","noHash","_shouldAddSlash","_addSlash","_pathResolve","resolvePath","basePath","resultString","pathSplit","split","resultArray","forEach","current","index","pop","join","RegExp","isType","null","boolean","object","Array","isArray","array","number","integer","Number","isInteger","string","splitUrl","indexOfHash","ndx","urlReference","urlFragment","decodeURI","getScheme","matches","exec","type","contextUrl","resolvedUrl","resolveUrl","contextId","from","to","toStart","fromLen","toLen","lastCommonSep","i","fromCode","charCodeAt","out","compile","pointer","map","unescape","_set","subject","cursor","segment","shift","applySegment","append","clonedSubject","computeSegment","_assign","isScalar","_unset","filter","_","_remove","splice","curry","escape","replace","TypeError","ptr","reduce","set","assign","unset","remove","$__value","Symbol","$__href","freeze","isReference","ref","jsonTypeOf","require$$0","nil","id","instance","doc","Reference","typeOf","step","JsonPointer","item","thisArg","acc","every","some","cons","encodeURI","keys","PARAM_REGEXP","TEXT_REGEXP","TOKEN_REGEXP","QESC_REGEXP","QUOTE_REGEXP","TYPE_REGEXP","qstring","val","str","ContentType","parameters","create","param","params","sort","header","getHeader","headers","getcontenttype","toLowerCase","match","lastIndex","async","entries","options","results","Promise","all","a","fns","require$$1","require$$2","require$$3","require$$4","require$$5","pipeline","require$$6","allValues","propertyName","propertyValue","fetch","safeResolveUrl","pathRelative","config","configAlias","getConfig","schemaVersion","configVersion","schemaStore","schemaStoreAlias","add","schema","defaultSchemaVersion","JSON","parse","stringify","baseToken","anchorToken","externalId","internalUrl","fragment","dynamicAnchors","recursiveAnchorToken","vocabulary","vocabularyToken","anchors","processSchema","validated","embeddedSchemaVersion","embeddedEmbeddedToken","embeddedAnchorToken","dynamicAnchorToken","embeddedToken","anchor","jrefToken","getStoredSchema","get","contextDoc","uri","hasStoredSchema","response","Accept","status","text","has","contentType","contentTypeParser","json","storedSchema","getAnchorPointer","followReferences","nextDoc","Pact","toSchemaDefaultOptions","parentId","parentDialect","includeEmbedded","relativeUri","pathToSchema","setConfig","markValidated","toSchema","schemaDoc","fullOptions","refValue","embeddedDialect","$schema","dialect","InvalidSchemaError","constructor","output","super","name","FLAG","BASIC","DETAILED","VERBOSE","metaOutputFormat","shouldMetaValidate","ast","metaData","schemaUri","compileSchema","interpret","outputFormat","subscriptionToken","outputHandler","interpretSchema","resultStack","keywordResult","keyword","absoluteKeywordLocation","instanceLocation","valid","errors","topResult","unshift","_keywords","getKeyword","hasKeyword","_vocabularies","metaValidators","metaSchema","Schema","vocabularyId","isRequired","keywordHandler","collectEvaluatedItems","keywordValue","isTop","Set","collectEvaluatedProperties","addKeyword","compiledSchema","schemaInstance","Instance","metaResults","keywordId","getKeywordId","compiled","interpretAst","setMetaOutputFormat","format","setShouldMetaValidate","isEnabled","defineVocabulary","keywords","schemaValue","keywordSchema","Core","keywordAst","schemaUrl","nodes","isValid","endsWith","propertyNames","itemIndexes","validate","Keywords"],"mappings":"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"}