"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var e=function(e,t){return function r(){null==t&&(t=e.length);var n=[].slice.call(arguments);return n.length>=t?e.apply(this,n):function(){return r.apply(this,n.concat([].slice.call(arguments)))}}};var t="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:{};var r,n=(function(e,r){var n;n={},("object"==typeof window&&window||t).PubSub=n,function(e){var t={},r=-1,n="*";function o(e){var t;for(t in e)if(Object.prototype.hasOwnProperty.call(e,t))return!0;return!1}function a(e){return function(){throw e}}function i(e,t,r){try{e(t,r)}catch(e){setTimeout(a(e),0)}}function s(e,t,r){e(t,r)}function c(e,r,n,o){var a,c=t[r],l=o?s:i;if(Object.prototype.hasOwnProperty.call(t,r))for(a in c)Object.prototype.hasOwnProperty.call(c,a)&&l(c[a],e,n)}function l(e,t,r){return function(){var o=String(e),a=o.lastIndexOf(".");for(c(e,e,t,r);-1!==a;)a=(o=o.substr(0,a)).lastIndexOf("."),c(e,o,t,r);c(e,n,t,r)}}function u(e){var r=String(e);return Boolean(Object.prototype.hasOwnProperty.call(t,r)&&o(t[r]))}function f(e){for(var t=String(e),r=u(t)||u(n),o=t.lastIndexOf(".");!r&&-1!==o;)o=(t=t.substr(0,o)).lastIndexOf("."),r=u(t);return r}function p(e,t,r,n){var o=l(e="symbol"==typeof e?e.toString():e,t,n);return!!f(e)&&(!0===r?o():setTimeout(o,0),!0)}e.publish=function(t,r){return p(t,r,!1,e.immediateExceptions)},e.publishSync=function(t,r){return p(t,r,!0,e.immediateExceptions)},e.subscribe=function(e,n){if("function"!=typeof n)return!1;e="symbol"==typeof e?e.toString():e,Object.prototype.hasOwnProperty.call(t,e)||(t[e]={});var o="uid_"+String(++r);return t[e][o]=n,o},e.subscribeAll=function(t){return e.subscribe(n,t)},e.subscribeOnce=function(t,r){var n=e.subscribe(t,(function(){e.unsubscribe(n),r.apply(this,arguments)}));return e},e.clearAllSubscriptions=function(){t={}},e.clearSubscriptions=function(e){var r;for(r in t)Object.prototype.hasOwnProperty.call(t,r)&&0===r.indexOf(e)&&delete t[r]},e.countSubscriptions=function(e){var r,n,o=0;for(r in t)if(Object.prototype.hasOwnProperty.call(t,r)&&0===r.indexOf(e)){for(n in t[r])o++;break}return o},e.getSubscriptions=function(e){var r,n=[];for(r in t)Object.prototype.hasOwnProperty.call(t,r)&&0===r.indexOf(e)&&n.push(r);return n},e.unsubscribe=function(r){var n,o,a,i=function(e){var r;for(r in t)if(Object.prototype.hasOwnProperty.call(t,r)&&0===r.indexOf(e))return!0;return!1},s="string"==typeof r&&(Object.prototype.hasOwnProperty.call(t,r)||i(r)),c=!s&&"string"==typeof r,l="function"==typeof r,u=!1;if(!s){for(n in t)if(Object.prototype.hasOwnProperty.call(t,n)){if(o=t[n],c&&o[r]){delete o[r],u=r;break}if(l)for(a in o)Object.prototype.hasOwnProperty.call(o,a)&&o[a]===r&&(delete o[a],u=!0)}return u}e.clearSubscriptions(r)}}(n),void 0!==e&&e.exports&&(r=e.exports=n),r.PubSub=n,e.exports=r=n}(r={exports:{}},r.exports),r.exports);n.PubSub;var o=function(e,t){if(e=e.trim(),(t=t.trim()).startsWith("about:"))return t;const r=function(e){const t={host:"",path:"",query:"",protocol:""};let r=e,n=e.indexOf("//");t.protocol=r.substring(0,n),n+=2;const o=e.indexOf("/",n),a=e.indexOf("?"),i=e.indexOf("#");-1!==i&&(r=r.substring(0,i));if(-1!==a){const e=r.substring(a);t.query=e,r=r.substring(0,a)}if(-1!==o){const e=r.substring(0,o);t.host=e,r=r.substring(o),t.path=r}else t.host=r;return t}(e),n=function(e){const t={href:e,hash:"",query:"",netPath:!1,absolutePath:!1,relativePath:!1};if(s.test(e))return t.netPath=!0,t;"/"===e[0]?t.absolutePath=!0:""!==e&&(t.relativePath=!0);let r=e;const n=e.indexOf("?"),o=e.indexOf("#");if(-1!==o){const e=r.substring(o);t.hash=e,r=r.substring(0,o)}if(-1!==n){const e=r.substring(n);t.query=e,r=r.substring(0,n)}return t.path=r,t}(t);if(!r.protocol&&!n.netPath)throw new Error("Error, protocol is not specified");if(n.netPath)return n.href.startsWith("//")&&(n.href=r.protocol+n.href),function(e){const t=e.indexOf("//")+2,r=!e.includes("/",t),n=!e.includes("?",t),o=!e.includes("#",t);return r&&n&&o}(n.href)?a(n.href):n.href;if(n.absolutePath){const{path:e,query:t,hash:o}=n;return r.host+i(e)+t+o}if(n.relativePath){const{path:e,query:t,hash:o}=n;let a,s=r.path,c=r.host;return 0===e.length?a=s:(s=s.substring(0,s.lastIndexOf("/")),a=i(s+"/"+e)),c+=""!==a||t||o?a+t+o:"/",c}{const{host:e,path:t,query:o}=r;return t||o?e+t+o+n.hash:a(e)}};function a(e){return e+("/"===e[e.length-1]?"":"/")}function i(e){let t=e.split("/");""===t[0]&&(t=t.slice(1));let r=[];return t.forEach(((e,n)=>{"."!==e&&(".."===e?r.pop():""===e&&n!==t.length-1||r.push(e))})),"/"+r.join("/")}const s=new RegExp("^([a-z][a-z0-9+.-]*:)?//","i");const c={null:e=>null===e,boolean:e=>"boolean"==typeof e,object:e=>"object"==typeof e&&!Array.isArray(e)&&null!==e,array:e=>Array.isArray(e),number:e=>"number"==typeof e,integer:e=>Number.isInteger(e),string:e=>"string"==typeof e},l=e=>{const t=e.indexOf("#"),r=-1===t?e.length:t,n=e.slice(0,r),o=e.slice(r+1);return[decodeURI(n),decodeURI(o)]},u=e=>{const t=RegExp(/^(.+):\/\//).exec(e);return t?t[1]:""};var f={jsonTypeOf:(e,t)=>c[t](e),splitUrl:l,safeResolveUrl:(e,t)=>{const r=o(e,t),n=l(e)[0];if(n&&"file"===u(r)&&"file"!==u(n))throw Error(`Can't access file '${r}' resource from network context '${e}'`);return r},pathRelative:(e,t)=>{if(e===t)return"";let r=1;const n=e.length-1,o=t.length-r,a=n<o?n:o;let i=-1,s=0;for(;s<a;s++){const n=e.charCodeAt(s+1);if(n!==t.charCodeAt(r+s))break;47===n&&(i=s)}if(o>a){if(47===t.charCodeAt(r+s))return t.slice(r+s+1);if(0===s)return t.slice(r+s)}n>a&&(47===e.charCodeAt(s+1)?i=s:0===a&&(i=0));let c="";for(s=i+2;s<=e.length;++s)s!==e.length&&47!==e.charCodeAt(s)||(c+=0===c.length?"..":"/..");return r+=i,c.length>0?`${c}${t.slice(r,t.length)}`:(47===t.charCodeAt(r)&&++r,t.slice(r,t.length))}};const p=e=>{if(e.length>0&&"/"!==e[0])throw Error("Invalid JSON Pointer");return e.split("/").slice(1).map(g)},d=(e,t,r,n)=>{if(0===e.length)return r;if(e.length>1){const o=e.shift();return{...t,[o]:d(e,O(t,o,n),r,b(o,n))}}if(Array.isArray(t)){const n=[...t];return n[w(t,e[0])]=r,n}return"object"==typeof t&&null!==t?{...t,[e[0]]:r}:O(t,e[0],n)},h=(e,t,r,n)=>{if(0!==e.length)if(1!==e.length||E(t)){const o=e.shift();h(e,O(t,o,n),r,b(o,n))}else{t[w(t,e[0])]=r}},y=(e,t,r)=>{if(0!=e.length){if(e.length>1){const n=e.shift(),o=O(t,n,r);return{...t,[n]:y(e,o,b(n,r))}}if(Array.isArray(t))return t.filter(((t,r)=>r!=e[0]));if("object"==typeof t&&null!==t){const{[e[0]]:r,...n}=t;return n}return O(t,e[0],r)}},m=(e,t,r)=>{if(0!==e.length)if(e.length>1){const n=e.shift(),o=O(t,n,r);m(e,o,b(n,r))}else Array.isArray(t)?t.splice(e[0],1):"object"==typeof t&&null!==t?delete t[e[0]]:O(t,e[0],r)},b=e(((e,t)=>t+"/"+v(e))),v=e=>e.toString().replace(/~/g,"~0").replace(/\//g,"~1"),g=e=>e.toString().replace(/~1/g,"/").replace(/~0/g,"~"),w=(e,t)=>Array.isArray(e)&&"-"===t?e.length:t,O=(e,t,r="")=>{if(void 0===e)throw TypeError(`Value at '${r}' is undefined and does not have property '${t}'`);if(null===e)throw TypeError(`Value at '${r}' is null and does not have property '${t}'`);if(E(e))throw TypeError(`Value at '${r}' is a ${typeof e} and does not have property '${t}'`);return e[w(e,t)]},E=e=>null===e||"object"!=typeof e;var j={nil:"",append:b,get:(e,t)=>{const r=p(e),n=e=>r.reduce((([e,t],r)=>[O(e,r,t),b(r,t)]),[e,""])[0];return void 0===t?n:n(t)},set:(t,r,n)=>{const o=p(t),a=e(((e,t)=>d(o,e,t,"")));return void 0===r?a:a(r,n)},assign:(t,r,n)=>{const o=p(t),a=e(((e,t)=>h(o,e,t,"")));return void 0===r?a:a(r,n)},unset:(e,t)=>{const r=p(e),n=e=>y(r,e,"");return void 0===t?n:n(t)},remove:(e,t)=>{const r=p(e),n=e=>m(r,e,"");return void 0===t?n:n(t)}};j.nil,j.append,j.get,j.set,j.assign,j.unset,j.remove;const $=Symbol("$__value"),S=Symbol("$__href");var x={cons:(e,t)=>Object.freeze({[S]:e,[$]:t}),isReference:e=>e&&void 0!==e[S],href:e=>e[S],value:e=>e[$]};const{jsonTypeOf:A}=f,P=Object.freeze({id:"",pointer:"",instance:void 0,value:void 0}),I=e=>x.isReference(e.value)?x.value(e.value):e.value,T=e(((e,t)=>A(I(e),t))),k=(e,t)=>Object.freeze({...t,pointer:j.append(e,t.pointer),value:I(t)[e]}),V=e(((e,t)=>I(t).map(((r,n,o,a)=>e(k(n,t),n,o,a))))),R=e(((e,t)=>I(t).map(((e,r,n,o)=>k(r,t))).filter(((t,r,n,o)=>e(t,r,n,o))))),C=e(((e,t,r)=>I(r).reduce(((t,n,o)=>e(t,k(o,r),o)),t))),U=e(((e,t)=>I(t).every(((r,n,o,a)=>e(k(n,t),n,o,a))))),z=e(((e,t)=>I(t).some(((r,n,o,a)=>e(k(n,t),n,o,a)))));var K={nil:P,cons:(e,t="")=>Object.freeze({...P,id:t,instance:e,value:e}),uri:e=>`${e.id}#${encodeURI(e.pointer)}`,value:I,has:(e,t)=>e in I(t),typeOf:T,step:k,entries:e=>Object.keys(I(e)).map((t=>[t,k(t,e)])),keys:e=>Object.keys(I(e)),map:V,filter:R,reduce:C,every:U,some:z,length:e=>I(e).length},L=/; *([!#$%&'*+.^_`|~0-9A-Za-z-]+) *= *("(?:[\u000b\u0020\u0021\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u000b\u0020-\u00ff])*"|[!#$%&'*+.^_`|~0-9A-Za-z-]+) */g,q=/^[\u000b\u0020-\u007e\u0080-\u00ff]+$/,_=/^[!#$%&'*+.^_`|~0-9A-Za-z-]+$/,D=/\\([\u000b\u0020-\u00ff])/g,N=/([\\"])/g,B=/^[!#$%&'*+.^_`|~0-9A-Za-z-]+\/[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;function F(e){var t=String(e);if(_.test(t))return t;if(t.length>0&&!q.test(t))throw new TypeError("invalid parameter value");return'"'+t.replace(N,"\\$1")+'"'}function J(e){this.parameters=Object.create(null),this.type=e}var W={format:function(e){if(!e||"object"!=typeof e)throw new TypeError("argument obj is required");var t=e.parameters,r=e.type;if(!r||!B.test(r))throw new TypeError("invalid type");var n=r;if(t&&"object"==typeof t)for(var o,a=Object.keys(t).sort(),i=0;i<a.length;i++){if(o=a[i],!_.test(o))throw new TypeError("invalid parameter name");n+="; "+o+"="+F(t[o])}return n},parse:function(e){if(!e)throw new TypeError("argument string is required");var t="object"==typeof e?function(e){var t;"function"==typeof e.getHeader?t=e.getHeader("content-type"):"object"==typeof e.headers&&(t=e.headers&&e.headers["content-type"]);if("string"!=typeof t)throw new TypeError("content-type header is missing from object");return t}(e):e;if("string"!=typeof t)throw new TypeError("argument string is required to be a string");var r=t.indexOf(";"),n=-1!==r?t.substr(0,r).trim():t.trim();if(!B.test(n))throw new TypeError("invalid media type");var o=new J(n.toLowerCase());if(-1!==r){var a,i,s;for(L.lastIndex=r;i=L.exec(t);){if(i.index!==r)throw new TypeError("invalid parameter format");r+=i[0].length,a=i[1].toLowerCase(),'"'===(s=i[2])[0]&&(s=s.substr(1,s.length-2).replace(D,"$1")),o.parameters[a]=s}if(r!==t.length)throw new TypeError("invalid parameter format")}return o}},Z=async e=>Object.entries(await e),M=e((async(e,t)=>(await t).map(e))),G=e((async(e,t,r)=>(await r).reduce((async(t,r)=>e(await t,r)),t))),H=e((async(e,t,r={})=>G((async(t,r)=>await e(r)?t.concat([r]):t),[],t,r))),Q=e((async(e,t)=>{const r=await M(e,t);return(await Promise.all(r)).some((e=>e))})),X=e((async(e,t)=>{const r=await M(e,t);return(await Promise.all(r)).every((e=>e))})),Y=e(((e,t)=>e.reduce((async(e,t)=>t(await e)),t))),ee={entries:Z,map:M,filter:H,reduce:G,some:Q,every:X,pipeline:Y,all:e=>Promise.all(e),allValues:e=>Y([Z,G((async(e,[t,r])=>(e[t]=await r,e)),{})],e)};ee.entries,ee.map,ee.filter,ee.reduce,ee.some,ee.every,ee.pipeline,ee.all,ee.allValues;var te=fetch;const{jsonTypeOf:re,splitUrl:ne,safeResolveUrl:oe,pathRelative:ae}=f,ie={},se={},ce=(e,t)=>{const r=e in se?se[e]:e;if(r in ie)return ie[r][t]},le={},ue={},fe=(e,t="",r="")=>{e=JSON.parse(JSON.stringify(e));const n=ne(e.$schema||r)[0];if(!n)throw Error("Couldn't determine schema version");delete e.$schema;const o=ce(n,"baseToken"),a=ce(n,"anchorToken"),i=ne(t)[0];if(!i&&!ne(e[o]||"")[0])throw Error("Couldn't determine an identifier for the schema");const s=oe(i,e[o]||""),[c,l]=ne(s);delete e[o],l&&o===a&&(e[a]=a!==o?encodeURI(l):`#${encodeURI(l)}`),i&&(ue[i]=c);const u={},f=ce(n,"recursiveAnchorToken");let p;!0===e[f]&&(u[""]=`${c}#`,e[a]="",delete e[f]);const d=ce(n,"vocabularyToken");re(e[d],"object")?(se[c]=n,p=e[d],delete e[d]):(se[c]=n,p={[n]:!0});const h={"":""};return le[c]={id:c,schemaVersion:n,schema:pe(e,c,n,j.nil,h,u),anchors:h,dynamicAnchors:u,vocabulary:p,validated:!1},c},pe=(e,t,r,n,o,a)=>{if(re(e,"object")){const i="string"==typeof e.$schema?ne(e.$schema)[0]:r,s=ce(i,"embeddedToken"),c=ce(i,"anchorToken");if("string"==typeof e[s]&&(s!==c||"#"!==e[s][0])){const n=oe(t,e[s]);return e[s]=n,fe(e,n,r),x.cons(e[s],e)}const l=ce(r,"anchorToken"),u=ce(r,"dynamicAnchorToken");"string"==typeof e[u]&&(a[e[u]]=`${t}#${encodeURI(n)}`,o[e[u]]=n,delete e[u]);const f=ce(r,"embeddedToken");if("string"==typeof e[l]){const t=l!==f?e[l]:e[l].slice(1);o[t]=n,delete e[l]}const p=ce(r,"jrefToken");if("string"==typeof e[p])return x.cons(e[p],e);for(const i in e)e[i]=pe(e[i],t,r,j.append(i,n),o,a);return e}return Array.isArray(e)?e.map(((e,i)=>pe(e,t,r,j.append(i,n),o,a))):e},de=e=>le[ue[e]]||le[e],he=Object.freeze({id:"",schemaVersion:void 0,vocabulary:{},pointer:j.nil,schema:void 0,value:void 0,anchors:{},dynamicAnchors:{},validated:!0}),ye=async(e,t=he)=>{const r=oe(ve(t),e),[n,o]=ne(r);if(!(e=>e in le||e in ue)(n)){const e=await te(n,{headers:{Accept:"application/schema+json"}});if(e.status>=400)throw await e.text(),Error(`Failed to retrieve schema with id: ${n}`);if(e.headers.has("content-type")){const t=W.parse(e.headers.get("content-type")).type;if("application/schema+json"!==t)throw Error(`${n} is not a schema. Found a document with media type: ${t}`)}fe(await e.json(),n)}const a=de(n),i="/"!==o[0]?be(a,o):o,s=Object.freeze({...a,pointer:i,value:j.get(i,a.schema)});return me(s)},me=e=>x.isReference(e.value)?ye(x.href(e.value),e):e,be=(e,t)=>{if(!(t in e.anchors))throw Error(`No such anchor '${encodeURI(e.id)}#${encodeURI(t)}'`);return e.anchors[t]},ve=e=>`${e.id}#${encodeURI(e.pointer)}`,ge=e=>x.isReference(e.value)?x.value(e.value):e.value,we=(e,t)=>{const r=de(t.id),n=Object.freeze({...t,pointer:j.append(e,t.pointer),value:ge(t)[e],validated:r.validated});return me(n)},Oe=e(((e,t)=>ee.pipeline([ge,ee.map((async(r,n)=>e(await we(n,t),n))),ee.all],t))),Ee={parentId:"",parentDialect:"",includeEmbedded:!0},je=(e,t)=>{if(t.startsWith("file://")){const r=e.slice(7,e.lastIndexOf("/"));return""===e?"":ae(r,t.slice(7))}return t};var $e={setConfig:(e,t,r)=>{ie[e]||(ie[e]={}),ie[e][t]=r},getConfig:ce,add:fe,get:ye,markValidated:e=>{le[e].validated=!0},uri:ve,value:ge,getAnchorPointer:be,typeOf:(e,t)=>re(ge(e),t),has:(e,t)=>e in ge(t),step:we,keys:e=>Object.keys(ge(e)),entries:e=>ee.pipeline([ge,Object.keys,ee.map((async t=>[t,await we(t,e)])),ee.all],e),map:Oe,length:e=>ge(e).length,toSchema:(e,t={})=>{const r={...Ee,...t},n=JSON.parse(JSON.stringify(e.schema,((t,n)=>{if(!x.isReference(n))return n;const o=x.value(n),a=o.$schema||e.schemaVersion,i=ce(a,"embeddedToken");return!r.includeEmbedded&&i in o?void 0:x.value(n)}))),o=ce(e.schemaVersion,"dynamicAnchorToken");Object.entries(e.dynamicAnchors).forEach((([e,t])=>{const r=ne(t)[1];j.assign(r,n,{[o]:e,...j.get(r,n)})}));const a=ce(e.schemaVersion,"anchorToken");Object.entries(e.anchors).filter((([e])=>""!==e)).forEach((([e,t])=>{j.assign(t,n,{[a]:e,...j.get(t,n)})}));const i=ce(e.schemaVersion,"baseToken"),s=je(r.parentId,e.id),c=r.parentDialect===e.schemaVersion?"":e.schemaVersion;return{...s&&{[i]:s},...c&&{$schema:c},...n}}};$e.setConfig,$e.getConfig,$e.add,$e.get,$e.markValidated,$e.uri,$e.value,$e.getAnchorPointer,$e.typeOf,$e.has,$e.step,$e.keys,$e.entries,$e.map,$e.length,$e.toSchema;class Se extends Error{constructor(e){super("Invalid Schema"),this.name=this.constructor.name,this.output=e}}var xe=Se;const{splitUrl:Ae}=f,Pe="FLAG",Ie="BASIC",Te="DETAILED",ke="VERBOSE";let Ve=Te,Re=!0;const Ce=async e=>{const t={metaData:{}};return{ast:t,schemaUri:await Ne(e,t)}},Ue=e((({ast:e,schemaUri:t},r,o=Pe)=>{if(![Pe,Ie,Te,ke].includes(o))throw Error(`The '${o}' error format is not supported`);const a=[],i=n.subscribe("result",ze(o,a));return Fe(t,r,e,{}),n.unsubscribe(i),a[0]})),ze=(e,t)=>{const r=[];return(n,o)=>{if("result"===n){const{keyword:e,absoluteKeywordLocation:t,instanceLocation:n,valid:a}=o,i={keyword:e,absoluteKeywordLocation:t,instanceLocation:n,valid:a,errors:[]};r.push(i)}else if("result.start"===n)r.push(n);else if("result.end"===n){const n=r.pop();for(;"result.start"!==r[r.length-1];){const t=r.pop(),o=[t];e===Ie&&(o.push(...t.errors),delete t.errors),(e===ke||e!==Pe&&!t.valid)&&n.errors.unshift(...o)}r[r.length-1]=n,t[0]=n}}},Ke={},Le=e=>Ke[e],qe=e=>e in Ke,_e={},De={},Ne=async(e,t)=>{if(e=await Be(e),!qe(`${e.schemaVersion}#validate`)){const t=await $e.get(e.schemaVersion);($e.getConfig(t.id,"mandatoryVocabularies")||[]).forEach((e=>{if(!t.vocabulary[e])throw Error(`Vocabulary '${e}' must be explicitly declared and required`)})),Object.entries(t.vocabulary).forEach((([e,r])=>{if(e in _e)Object.entries(_e[e]).forEach((([e,r])=>{((e,t)=>{Ke[e]={collectEvaluatedItems:(e,r,n,o,a)=>t.interpret(e,r,n,o,a)&&new Set,collectEvaluatedProperties:(e,r,n,o,a)=>t.interpret(e,r,n,o,a)&&[],...t}})(`${t.id}#${e}`,r)}));else if(r)throw Error(`Missing required vocabulary: ${e}`)}))}if(Re&&!e.validated){if($e.markValidated(e.id),!(e.schemaVersion in De)){const t=await $e.get(e.schemaVersion),r=await Ce(t);De[t.id]=Ue(r)}const t=K.cons(e.schema,e.id),r=De[e.schemaVersion](t,Ve);if(!r.valid)throw new xe(r)}return e.id in t.metaData||(t.metaData[e.id]={id:e.id,dynamicAnchors:e.dynamicAnchors,anchors:e.anchors}),Le(`${e.schemaVersion}#validate`).compile(e,t)},Be=async e=>$e.typeOf(e,"string")?Be(await $e.get($e.value(e),e)):e,Fe=(e,t,r,n)=>{const o=Je(e,r),a=Ae(e)[0];return Le(o).interpret(e,t,r,{...r.metaData[a].dynamicAnchors,...n})},Je=(e,t)=>{if(!(e in t))throw Error(`No schema found at ${e}`);return t[e][0]};var We={validate:async(e,t,r)=>{const n=await Ce(e),o=(e,t)=>Ue(n,K.cons(e),t);return void 0===t?o:o(t,r)},compile:Ce,interpret:Ue,setMetaOutputFormat:e=>{Ve=e},setShouldMetaValidate:e=>{Re=e},FLAG:Pe,BASIC:Ie,DETAILED:Te,VERBOSE:ke,add:(e,t="",r="")=>{const n=$e.add(e,t,r);delete De[n]},getKeyword:Le,hasKeyword:qe,defineVocabulary:(e,t)=>{_e[e]=t},compileSchema:Ne,interpretSchema:Fe,collectEvaluatedProperties:(e,t,r,n,o)=>{const a=Je(e,r);return Le(a).collectEvaluatedProperties(e,t,r,n,o)},collectEvaluatedItems:(e,t,r,n,o)=>{const a=Je(e,r);return Le(a).collectEvaluatedItems(e,t,r,n,o)}};var Ze={compile:e=>$e.value(e),interpret:()=>!0};var Me={compile:async(e,t)=>{const r=$e.uri(e);if(!(r in t)){t[r]=!1;const n=$e.value(e);if(!["object","boolean"].includes(typeof n))throw Error(`No schema found at '${$e.uri(e)}'`);t[r]=[`${e.schemaVersion}#validate`,$e.uri(e),"boolean"==typeof n?n:await ee.pipeline([$e.entries,ee.map((([t,r])=>[`${e.schemaVersion}#${t}`,r])),ee.filter((([t])=>We.hasKeyword(t)&&t!==`${e.schemaVersion}#validate`)),ee.map((async([r,n])=>{const o=await We.getKeyword(r).compile(n,t,e);return[r,$e.uri(n),o]})),ee.all],e)]}return r},interpret:(e,t,r,o)=>{const[a,i,s]=r[e];n.publishSync("result.start");const c="boolean"==typeof s?s:s.every((([e,a,i])=>{n.publishSync("result.start");const s=We.getKeyword(e).interpret(i,t,r,o);return n.publishSync("result",{keyword:e,absoluteKeywordLocation:a,instanceLocation:K.uri(t),valid:s,ast:i}),n.publishSync("result.end"),s}));return n.publishSync("result",{keyword:a,absoluteKeywordLocation:i,instanceLocation:K.uri(t),valid:c,ast:e}),n.publishSync("result.end"),c},collectEvaluatedProperties:(e,t,r,n,o=!1)=>{const a=r[e][2];return"boolean"==typeof a?!!a&&[]:a.filter((([e])=>!o||!e.endsWith("#unevaluatedProperties"))).reduce(((e,[o,,a])=>{const i=e&&We.getKeyword(o).collectEvaluatedProperties(a,t,r,n);return!1!==i&&[...e,...i]}),[])},collectEvaluatedItems:(e,t,r,n,o=!1)=>{const a=r[e][2];return"boolean"==typeof a?!!a&&new Set:a.filter((([e])=>!o||!e.endsWith("#unevaluatedItems"))).reduce(((e,[o,,a])=>{const i=!1!==e&&We.getKeyword(o).collectEvaluatedItems(a,t,r,n);return!1!==i&&new Set([...e,...i])}),new Set)}},Ge={metaData:Ze,validate:Me},He={Core:We,Schema:$e,Instance:K,Reference:x,Keywords:Ge,InvalidSchemaError:xe},Qe=He.Core,Xe=He.Schema,Ye=He.Instance,et=He.Reference,tt=He.Keywords,rt=He.InvalidSchemaError;exports.Core=Qe,exports.Instance=Ye,exports.InvalidSchemaError=rt,exports.Keywords=tt,exports.Reference=et,exports.Schema=Xe,exports.default=He;
//# sourceMappingURL=json-schema-core-cjs.min.js.map
