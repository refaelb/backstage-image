var JsonSchema=function(e){"use strict";var n=function(e,n){return function t(){null==n&&(n=e.length);var r=[].slice.call(arguments);return r.length>=n?e.apply(this,r):function(){return t.apply(this,r.concat([].slice.call(arguments)))}}};var t="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:{};var r=function(e,n){return e(n={exports:{}},n.exports),n.exports}((function(e,n){var r,a;r="object"==typeof window&&window||t,a={},r.PubSub?(a=r.PubSub,console.warn("PubSub already loaded, using existing version")):(r.PubSub=a,function(e){var n={},t=-1;function r(e,n,t){try{e(n,t)}catch(e){setTimeout(function(e){return function(){throw e}}(e),0)}}function a(e,n,t){e(n,t)}function i(e,t,i,o){var s,c=n[t],m=o?a:r;if(Object.prototype.hasOwnProperty.call(n,t))for(s in c)Object.prototype.hasOwnProperty.call(c,s)&&m(c[s],e,i)}function o(e){var t=String(e);return Boolean(Object.prototype.hasOwnProperty.call(n,t)&&function(e){var n;for(n in e)if(Object.prototype.hasOwnProperty.call(e,n))return!0;return!1}(n[t]))}function s(e,n,t,r){var a=function(e,n,t){return function(){var r=String(e),a=r.lastIndexOf(".");for(i(e,e,n,t);-1!==a;)a=(r=r.substr(0,a)).lastIndexOf("."),i(e,r,n,t);i(e,"*",n,t)}}(e="symbol"==typeof e?e.toString():e,n,r);return!!function(e){for(var n=String(e),t=o(n)||o("*"),r=n.lastIndexOf(".");!t&&-1!==r;)r=(n=n.substr(0,r)).lastIndexOf("."),t=o(n);return t}(e)&&(!0===t?a():setTimeout(a,0),!0)}e.publish=function(n,t){return s(n,t,!1,e.immediateExceptions)},e.publishSync=function(n,t){return s(n,t,!0,e.immediateExceptions)},e.subscribe=function(e,r){if("function"!=typeof r)return!1;e="symbol"==typeof e?e.toString():e,Object.prototype.hasOwnProperty.call(n,e)||(n[e]={});var a="uid_"+String(++t);return n[e][a]=r,a},e.subscribeAll=function(n){return e.subscribe("*",n)},e.subscribeOnce=function(n,t){var r=e.subscribe(n,(function(){e.unsubscribe(r),t.apply(this,arguments)}));return e},e.clearAllSubscriptions=function(){n={}},e.clearSubscriptions=function(e){var t;for(t in n)Object.prototype.hasOwnProperty.call(n,t)&&0===t.indexOf(e)&&delete n[t]},e.countSubscriptions=function(e){var t,r,a=0;for(t in n)if(Object.prototype.hasOwnProperty.call(n,t)&&0===t.indexOf(e)){for(r in n[t])a++;break}return a},e.getSubscriptions=function(e){var t,r=[];for(t in n)Object.prototype.hasOwnProperty.call(n,t)&&0===t.indexOf(e)&&r.push(t);return r},e.unsubscribe=function(t){var r,a,i,o="string"==typeof t&&(Object.prototype.hasOwnProperty.call(n,t)||function(e){var t;for(t in n)if(Object.prototype.hasOwnProperty.call(n,t)&&0===t.indexOf(e))return!0;return!1}(t)),s=!o&&"string"==typeof t,c="function"==typeof t,m=!1;if(!o){for(r in n)if(Object.prototype.hasOwnProperty.call(n,r)){if(a=n[r],s&&a[t]){delete a[t],m=t;break}if(c)for(i in a)Object.prototype.hasOwnProperty.call(a,i)&&a[i]===t&&(delete a[i],m=!0)}return m}e.clearSubscriptions(t)}}(a)),void 0!==e&&e.exports&&(n=e.exports=a),n.PubSub=a,e.exports=n=a}));r.PubSub;var a=function(e,n){if(e=e.trim(),(n=n.trim()).startsWith("about:"))return n;const t=function(e){const n={host:"",path:"",query:"",protocol:""};let t=e,r=e.indexOf("//");n.protocol=t.substring(0,r),r+=2;const a=e.indexOf("/",r),i=e.indexOf("?"),o=e.indexOf("#");-1!==o&&(t=t.substring(0,o));if(-1!==i){const e=t.substring(i);n.query=e,t=t.substring(0,i)}if(-1!==a){const e=t.substring(0,a);n.host=e,t=t.substring(a),n.path=t}else n.host=t;return n}(e),r=function(e){const n={href:e,hash:"",query:"",netPath:!1,absolutePath:!1,relativePath:!1};if(s.test(e))return n.netPath=!0,n;"/"===e[0]?n.absolutePath=!0:""!==e&&(n.relativePath=!0);let t=e;const r=e.indexOf("?"),a=e.indexOf("#");if(-1!==a){const e=t.substring(a);n.hash=e,t=t.substring(0,a)}if(-1!==r){const e=t.substring(r);n.query=e,t=t.substring(0,r)}return n.path=t,n}(n);if(!t.protocol&&!r.netPath)throw new Error("Error, protocol is not specified");if(r.netPath)return r.href.startsWith("//")&&(r.href=t.protocol+r.href),function(e){const n=e.indexOf("//")+2,t=!e.includes("/",n),r=!e.includes("?",n),a=!e.includes("#",n);return t&&r&&a}(r.href)?i(r.href):r.href;if(r.absolutePath){const{path:e,query:n,hash:a}=r;return t.host+o(e)+n+a}if(r.relativePath){const{path:e,query:n,hash:a}=r;let i,s=t.path,c=t.host;return 0===e.length?i=s:(s=s.substring(0,s.lastIndexOf("/")),i=o(s+"/"+e)),c+=""!==i||n||a?i+n+a:"/",c}{const{host:e,path:n,query:a}=t;return n||a?e+n+a+r.hash:i(e)}};function i(e){return e+("/"===e[e.length-1]?"":"/")}function o(e){let n=e.split("/");""===n[0]&&(n=n.slice(1));let t=[];return n.forEach((e,r)=>{"."!==e&&(".."===e?t.pop():""===e&&r!==n.length-1||t.push(e))}),"/"+t.join("/")}const s=new RegExp("^([a-z][a-z0-9+.-]*:)?//","i");const c={null:e=>null===e,boolean:e=>"boolean"==typeof e,object:e=>"object"==typeof e&&!Array.isArray(e)&&null!==e,array:e=>Array.isArray(e),number:e=>"number"==typeof e,integer:e=>Number.isInteger(e),string:e=>"string"==typeof e},m=e=>{const n=e.indexOf("#"),t=-1===n?e.length:n,r=e.slice(0,t),a=e.slice(t+1);return[decodeURI(r),decodeURI(a)]},l=e=>{const n=RegExp(/^(.+):\/\//).exec(e);return n?n[1]:""};var p={jsonTypeOf:(e,n)=>c[n](e),splitUrl:m,safeResolveUrl:(e,n)=>{const t=a(e,n),r=m(e)[0];if(r&&"file"===l(t)&&"file"!==l(r))throw Error(`Can't access file '${t}' resource from network context '${e}'`);return t},pathRelative:(e,n)=>{if(e===n)return"";let t=1;const r=e.length-1,a=n.length-t,i=r<a?r:a;let o=-1,s=0;for(;s<i;s++){const r=e.charCodeAt(s+1);if(r!==n.charCodeAt(t+s))break;47===r&&(o=s)}if(a>i){if(47===n.charCodeAt(t+s))return n.slice(t+s+1);if(0===s)return n.slice(t+s)}r>i&&(47===e.charCodeAt(s+1)?o=s:0===i&&(o=0));let c="";for(s=o+2;s<=e.length;++s)s!==e.length&&47!==e.charCodeAt(s)||(c+=0===c.length?"..":"/..");return t+=o,c.length>0?`${c}${n.slice(t,n.length)}`:(47===n.charCodeAt(t)&&++t,n.slice(t,n.length))}};const u=e=>{if(e.length>0&&"/"!==e[0])throw Error("Invalid JSON Pointer");return e.split("/").slice(1).map(b)},d=(e,n,t,r)=>{if(0===e.length)return t;if(e.length>1){const a=e.shift();return{...n,[a]:d(e,O(n,a,r),t,v(a,r))}}if(Array.isArray(n)){const r=[...n];return r[$(n,e[0])]=t,r}return"object"==typeof n&&null!==n?{...n,[e[0]]:t}:O(n,e[0],r)},f=(e,n,t,r)=>{if(0!==e.length)if(1!==e.length||I(n)){const a=e.shift();f(e,O(n,a,r),t,v(a,r))}else{n[$(n,e[0])]=t}},y=(e,n,t)=>{if(0!=e.length){if(e.length>1){const r=e.shift(),a=O(n,r,t);return{...n,[r]:y(e,a,v(r,t))}}if(Array.isArray(n))return n.filter((n,t)=>t!=e[0]);if("object"==typeof n&&null!==n){const{[e[0]]:t,...r}=n;return r}return O(n,e[0],t)}},h=(e,n,t)=>{if(0!==e.length)if(e.length>1){const r=e.shift(),a=O(n,r,t);h(e,a,v(r,t))}else Array.isArray(n)?n.splice(e[0],1):"object"==typeof n&&null!==n?delete n[e[0]]:O(n,e[0],t)},v=n((e,n)=>n+"/"+g(e)),g=e=>e.toString().replace(/~/g,"~0").replace(/\//g,"~1"),b=e=>e.toString().replace(/~1/g,"/").replace(/~0/g,"~"),$=(e,n)=>Array.isArray(e)&&"-"===n?e.length:n,O=(e,n,t="")=>{if(void 0===e)throw TypeError(`Value at '${t}' is undefined and does not have property '${n}'`);if(null===e)throw TypeError(`Value at '${t}' is null and does not have property '${n}'`);if(I(e))throw TypeError(`Value at '${t}' is a ${typeof e} and does not have property '${n}'`);return e[$(e,n)]},I=e=>null===e||"object"!=typeof e;var S={nil:"",append:v,get:(e,n)=>{const t=u(e),r=e=>t.reduce(([e,n],t)=>[O(e,t,n),v(t,n)],[e,""])[0];return void 0===n?r:r(n)},set:(e,t,r)=>{const a=u(e),i=n((e,n)=>d(a,e,n,""));return void 0===t?i:i(t,r)},assign:(e,t,r)=>{const a=u(e),i=n((e,n)=>f(a,e,n,""));return void 0===t?i:i(t,r)},unset:(e,n)=>{const t=u(e),r=e=>y(t,e,"");return void 0===n?r:r(n)},remove:(e,n)=>{const t=u(e),r=e=>h(t,e,"");return void 0===n?r:r(n)}};S.nil,S.append,S.get,S.set,S.assign,S.unset,S.remove;const j=Symbol("$__value"),x=Symbol("$__href");var w={cons:(e,n)=>Object.freeze({[x]:e,[j]:n}),isReference:e=>e&&void 0!==e[x],href:e=>e[x],value:e=>e[j]};const{jsonTypeOf:P}=p,E=Object.freeze({id:"",pointer:"",instance:void 0,value:void 0}),A=e=>w.isReference(e.value)?w.value(e.value):e.value,C=n((e,n)=>P(A(e),n)),N=(e,n)=>Object.freeze({...n,pointer:S.append(e,n.pointer),value:A(n)[e]}),R=n((e,n)=>A(n).map((t,r,a,i)=>e(N(r,n),r,a,i))),T=n((e,n)=>A(n).map((e,t,r,a)=>N(t,n)).filter((n,t,r,a)=>e(n,t,r,a))),D=n((e,n,t)=>A(t).reduce((n,r,a)=>e(n,N(a,t),a),n)),k=n((e,n)=>A(n).every((t,r,a,i)=>e(N(r,n),r,a,i))),M=n((e,n)=>A(n).some((t,r,a,i)=>e(N(r,n),r,a,i)));var q={nil:E,cons:(e,n="")=>Object.freeze({...E,id:n,instance:e,value:e}),uri:e=>`${e.id}#${encodeURI(e.pointer)}`,value:A,has:(e,n)=>e in A(n),typeOf:C,step:N,entries:e=>Object.keys(A(e)).map(n=>[n,N(n,e)]),keys:e=>Object.keys(A(e)),map:R,filter:T,reduce:D,every:k,some:M,length:e=>A(e).length},V=/; *([!#$%&'*+.^_`|~0-9A-Za-z-]+) *= *("(?:[\u000b\u0020\u0021\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u000b\u0020-\u00ff])*"|[!#$%&'*+.^_`|~0-9A-Za-z-]+) */g,L=/^[\u000b\u0020-\u007e\u0080-\u00ff]+$/,J=/^[!#$%&'*+.^_`|~0-9A-Za-z-]+$/,_=/\\([\u000b\u0020-\u00ff])/g,U=/([\\"])/g,z=/^[!#$%&'*+.^_`|~0-9A-Za-z-]+\/[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;function F(e){var n=String(e);if(J.test(n))return n;if(n.length>0&&!L.test(n))throw new TypeError("invalid parameter value");return'"'+n.replace(U,"\\$1")+'"'}function K(e){this.parameters=Object.create(null),this.type=e}var B={format:function(e){if(!e||"object"!=typeof e)throw new TypeError("argument obj is required");var n=e.parameters,t=e.type;if(!t||!z.test(t))throw new TypeError("invalid type");var r=t;if(n&&"object"==typeof n)for(var a,i=Object.keys(n).sort(),o=0;o<i.length;o++){if(a=i[o],!J.test(a))throw new TypeError("invalid parameter name");r+="; "+a+"="+F(n[a])}return r},parse:function(e){if(!e)throw new TypeError("argument string is required");var n="object"==typeof e?function(e){var n;"function"==typeof e.getHeader?n=e.getHeader("content-type"):"object"==typeof e.headers&&(n=e.headers&&e.headers["content-type"]);if("string"!=typeof n)throw new TypeError("content-type header is missing from object");return n}(e):e;if("string"!=typeof n)throw new TypeError("argument string is required to be a string");var t=n.indexOf(";"),r=-1!==t?n.substr(0,t).trim():n.trim();if(!z.test(r))throw new TypeError("invalid media type");var a=new K(r.toLowerCase());if(-1!==t){var i,o,s;for(V.lastIndex=t;o=V.exec(n);){if(o.index!==t)throw new TypeError("invalid parameter format");t+=o[0].length,i=o[1].toLowerCase(),'"'===(s=o[2])[0]&&(s=s.substr(1,s.length-2).replace(_,"$1")),a.parameters[i]=s}if(t!==n.length)throw new TypeError("invalid parameter format")}return a}},Z=async e=>Object.entries(await e),G=n(async(e,n)=>(await n).map(e)),W=n(async(e,n,t)=>(await t).reduce(async(n,t)=>e(await n,t),n)),X=n(async(e,n,t={})=>W(async(n,t)=>await e(t)?n.concat([t]):n,[],n,t)),H=n(async(e,n)=>{const t=await G(e,n);return(await Promise.all(t)).some(e=>e)}),Q=n(async(e,n)=>{const t=await G(e,n);return(await Promise.all(t)).every(e=>e)}),Y=n((e,n)=>e.reduce(async(e,n)=>n(await e),n)),ee={entries:Z,map:G,filter:X,reduce:W,some:H,every:Q,pipeline:Y,all:e=>Promise.all(e),allValues:e=>Y([Z,W(async(e,[n,t])=>(e[n]=await t,e),{})],e)};ee.entries,ee.map,ee.filter,ee.reduce,ee.some,ee.every,ee.pipeline,ee.all,ee.allValues;var ne=fetch;const{jsonTypeOf:te,splitUrl:re,safeResolveUrl:ae,pathRelative:ie}=p,oe={},se={},ce=(e,n)=>{const t=e in se?se[e]:e;if(t in oe)return oe[t][n]},me={},le={},pe=(e,n="",t="")=>{e=JSON.parse(JSON.stringify(e));const r=re(e.$schema||t)[0];if(!r)throw Error("Couldn't determine schema version");delete e.$schema;const a=ce(r,"baseToken"),i=ce(r,"anchorToken"),o=re(n)[0];if(!o&&!re(e[a]||"")[0])throw Error("Couldn't determine an identifier for the schema");const s=ae(o,e[a]||""),[c,m]=re(s);delete e[a],m&&a===i&&(e[i]=i!==a?encodeURI(m):"#"+encodeURI(m)),o&&(le[o]=c);const l={},p=ce(r,"recursiveAnchorToken");let u;!0===e[p]&&(l[""]=c+"#",e[i]="",delete e[p]);const d=ce(r,"vocabularyToken");te(e[d],"object")?(se[c]=r,u=e[d],delete e[d]):(se[c]=r,u={[r]:!0});const f={"":""};return me[c]={id:c,schemaVersion:r,schema:ue(e,c,r,S.nil,f,l),anchors:f,dynamicAnchors:l,vocabulary:u,validated:!1},c},ue=(e,n,t,r,a,i)=>{if(te(e,"object")){const o="string"==typeof e.$schema?re(e.$schema)[0]:t,s=ce(o,"embeddedToken"),c=ce(o,"anchorToken");if("string"==typeof e[s]&&(s!==c||"#"!==e[s][0])){const r=ae(n,e[s]);return e[s]=r,pe(e,r,t),w.cons(e[s],e)}const m=ce(t,"anchorToken"),l=ce(t,"dynamicAnchorToken");"string"==typeof e[l]&&(i[e[l]]=`${n}#${encodeURI(r)}`,a[e[l]]=r,delete e[l]);const p=ce(t,"embeddedToken");if("string"==typeof e[m]){const n=m!==p?e[m]:e[m].slice(1);a[n]=r,delete e[m]}const u=ce(t,"jrefToken");if("string"==typeof e[u])return w.cons(e[u],e);for(const o in e)e[o]=ue(e[o],n,t,S.append(o,r),a,i);return e}return Array.isArray(e)?e.map((e,o)=>ue(e,n,t,S.append(o,r),a,i)):e},de=e=>me[le[e]]||me[e],fe=Object.freeze({id:"",schemaVersion:void 0,vocabulary:{},pointer:S.nil,schema:void 0,value:void 0,anchors:{},dynamicAnchors:{},validated:!0}),ye=async(e,n=fe)=>{const t=ae(ge(n),e),[r,a]=re(t);if(!(e=>e in me||e in le)(r)){const e=await ne(r,{headers:{Accept:"application/schema+json"}});if(e.status>=400)throw await e.text(),Error("Failed to retrieve schema with id: "+r);if(e.headers.has("content-type")){const n=B.parse(e.headers.get("content-type")).type;if("application/schema+json"!==n)throw Error(`${r} is not a schema. Found a document with media type: ${n}`)}pe(await e.json(),r)}const i=de(r),o="/"!==a[0]?ve(i,a):a,s=Object.freeze({...i,pointer:o,value:S.get(o,i.schema)});return he(s)},he=e=>w.isReference(e.value)?ye(w.href(e.value),e):e,ve=(e,n)=>{if(!(n in e.anchors))throw Error(`No such anchor '${encodeURI(e.id)}#${encodeURI(n)}'`);return e.anchors[n]},ge=e=>`${e.id}#${encodeURI(e.pointer)}`,be=e=>w.isReference(e.value)?w.value(e.value):e.value,$e=(e,n)=>{const t=de(n.id),r=Object.freeze({...n,pointer:S.append(e,n.pointer),value:be(n)[e],validated:t.validated});return he(r)},Oe=n((e,n)=>ee.pipeline([be,ee.map(async(t,r)=>e(await $e(r,n),r)),ee.all],n)),Ie={parentId:"",parentDialect:"",includeEmbedded:!0},Se=(e,n)=>{if(n.startsWith("file://")){const t=e.slice(7,e.lastIndexOf("/"));return""===e?"":ie(t,n.slice(7))}return n};var je={setConfig:(e,n,t)=>{oe[e]||(oe[e]={}),oe[e][n]=t},getConfig:ce,add:pe,get:ye,markValidated:e=>{me[e].validated=!0},uri:ge,value:be,getAnchorPointer:ve,typeOf:(e,n)=>te(be(e),n),has:(e,n)=>e in be(n),step:$e,keys:e=>Object.keys(be(e)),entries:e=>ee.pipeline([be,Object.keys,ee.map(async n=>[n,await $e(n,e)]),ee.all],e),map:Oe,length:e=>be(e).length,toSchema:(e,n={})=>{const t={...Ie,...n},r=JSON.parse(JSON.stringify(e.schema,(n,r)=>{if(!w.isReference(r))return r;const a=w.value(r),i=a.$schema||e.schemaVersion,o=ce(i,"embeddedToken");return!t.includeEmbedded&&o in a?void 0:w.value(r)})),a=ce(e.schemaVersion,"dynamicAnchorToken");Object.entries(e.dynamicAnchors).forEach(([e,n])=>{const t=re(n)[1];S.assign(t,r,{[a]:e,...S.get(t,r)})});const i=ce(e.schemaVersion,"anchorToken");Object.entries(e.anchors).filter(([e])=>""!==e).forEach(([e,n])=>{S.assign(n,r,{[i]:e,...S.get(n,r)})});const o=ce(e.schemaVersion,"baseToken"),s=Se(t.parentId,e.id),c=t.parentDialect===e.schemaVersion?"":e.schemaVersion;return{...s&&{[o]:s},...c&&{$schema:c},...r}}};je.setConfig,je.getConfig,je.add,je.get,je.markValidated,je.uri,je.value,je.getAnchorPointer,je.typeOf,je.has,je.step,je.keys,je.entries,je.map,je.length,je.toSchema;class xe extends Error{constructor(e){super("Invalid Schema"),this.name=this.constructor.name,this.output=e}}var we=xe;const{splitUrl:Pe}=p,Ee="FLAG",Ae="BASIC",Ce="DETAILED",Ne="VERBOSE";let Re=Ce,Te=!0;const De=async e=>{const n={metaData:{}};return{ast:n,schemaUri:await Ue(e,n)}},ke=n(({ast:e,schemaUri:n},t,a=Ee)=>{if(![Ee,Ae,Ce,Ne].includes(a))throw Error(`The '${a}' error format is not supported`);const i=[],o=r.subscribe("result",Me(a,i));return Fe(n,t,e,{}),r.unsubscribe(o),i[0]}),Me=(e,n)=>{const t=[];return(r,a)=>{if("result"===r){const{keyword:e,absoluteKeywordLocation:n,instanceLocation:r,valid:i}=a,o={keyword:e,absoluteKeywordLocation:n,instanceLocation:r,valid:i,errors:[]};t.push(o)}else if("result.start"===r)t.push(r);else if("result.end"===r){const r=t.pop();for(;"result.start"!==t[t.length-1];){const n=t.pop(),a=[n];e===Ae&&(a.push(...n.errors),delete n.errors),(e===Ne||e!==Ee&&!n.valid)&&r.errors.unshift(...a)}t[t.length-1]=r,n[0]=r}}},qe={},Ve=e=>qe[e],Le=e=>e in qe,Je={},_e={},Ue=async(e,n)=>{if(e=await ze(e),!Le(e.schemaVersion+"#validate")){const n=await je.get(e.schemaVersion);(je.getConfig(n.id,"mandatoryVocabularies")||[]).forEach(e=>{if(!n.vocabulary[e])throw Error(`Vocabulary '${e}' must be explicitly declared and required`)}),Object.entries(n.vocabulary).forEach(([e,t])=>{if(e in Je)Object.entries(Je[e]).forEach(([e,t])=>{((e,n)=>{qe[e]={collectEvaluatedItems:(e,t,r,a,i)=>n.interpret(e,t,r,a,i)&&new Set,collectEvaluatedProperties:(e,t,r,a,i)=>n.interpret(e,t,r,a,i)&&[],...n}})(`${n.id}#${e}`,t)});else if(t)throw Error("Missing required vocabulary: "+e)})}if(Te&&!e.validated){if(je.markValidated(e.id),!(e.schemaVersion in _e)){const n=await je.get(e.schemaVersion),t=await De(n);_e[n.id]=ke(t)}const n=q.cons(e.schema,e.id),t=_e[e.schemaVersion](n,Re);if(!t.valid)throw new we(t)}return e.id in n.metaData||(n.metaData[e.id]={id:e.id,dynamicAnchors:e.dynamicAnchors,anchors:e.anchors}),Ve(e.schemaVersion+"#validate").compile(e,n)},ze=async e=>je.typeOf(e,"string")?ze(await je.get(je.value(e),e)):e,Fe=(e,n,t,r)=>{const a=Ke(e,t),i=Pe(e)[0];return Ve(a).interpret(e,n,t,{...t.metaData[i].dynamicAnchors,...r})},Ke=(e,n)=>{if(!(e in n))throw Error("No schema found at "+e);return n[e][0]};var Be={validate:async(e,n,t)=>{const r=await De(e),a=(e,n)=>ke(r,q.cons(e),n);return void 0===n?a:a(n,t)},compile:De,interpret:ke,setMetaOutputFormat:e=>{Re=e},setShouldMetaValidate:e=>{Te=e},FLAG:Ee,BASIC:Ae,DETAILED:Ce,VERBOSE:Ne,add:(e,n="",t="")=>{const r=je.add(e,n,t);delete _e[r]},getKeyword:Ve,hasKeyword:Le,defineVocabulary:(e,n)=>{Je[e]=n},compileSchema:Ue,interpretSchema:Fe,collectEvaluatedProperties:(e,n,t,r,a)=>{const i=Ke(e,t);return Ve(i).collectEvaluatedProperties(e,n,t,r,a)},collectEvaluatedItems:(e,n,t,r,a)=>{const i=Ke(e,t);return Ve(i).collectEvaluatedItems(e,n,t,r,a)}};var Ze={compile:e=>je.value(e),interpret:()=>!0};var Ge={compile:async(e,n)=>{const t=je.uri(e);if(!(t in n)){n[t]=!1;const r=je.value(e);if(!["object","boolean"].includes(typeof r))throw Error(`No schema found at '${je.uri(e)}'`);n[t]=[e.schemaVersion+"#validate",je.uri(e),"boolean"==typeof r?r:await ee.pipeline([je.entries,ee.map(([n,t])=>[`${e.schemaVersion}#${n}`,t]),ee.filter(([n])=>Be.hasKeyword(n)&&n!==e.schemaVersion+"#validate"),ee.map(async([t,r])=>{const a=await Be.getKeyword(t).compile(r,n,e);return[t,je.uri(r),a]}),ee.all],e)]}return t},interpret:(e,n,t,a)=>{const[i,o,s]=t[e];r.publishSync("result.start");const c="boolean"==typeof s?s:s.every(([e,i,o])=>{r.publishSync("result.start");const s=Be.getKeyword(e).interpret(o,n,t,a);return r.publishSync("result",{keyword:e,absoluteKeywordLocation:i,instanceLocation:q.uri(n),valid:s,ast:o}),r.publishSync("result.end"),s});return r.publishSync("result",{keyword:i,absoluteKeywordLocation:o,instanceLocation:q.uri(n),valid:c,ast:e}),r.publishSync("result.end"),c},collectEvaluatedProperties:(e,n,t,r,a=!1)=>{const i=t[e][2];return"boolean"==typeof i?!!i&&[]:i.filter(([e])=>!a||!e.endsWith("#unevaluatedProperties")).reduce((e,[a,,i])=>{const o=e&&Be.getKeyword(a).collectEvaluatedProperties(i,n,t,r);return!1!==o&&[...e,...o]},[])},collectEvaluatedItems:(e,n,t,r,a=!1)=>{const i=t[e][2];return"boolean"==typeof i?!!i&&new Set:i.filter(([e])=>!a||!e.endsWith("#unevaluatedItems")).reduce((e,[a,,i])=>{const o=!1!==e&&Be.getKeyword(a).collectEvaluatedItems(i,n,t,r);return!1!==o&&new Set([...e,...o])},new Set)}},We={metaData:Ze,validate:Ge},Xe={Core:Be,Schema:je,Instance:q,Reference:w,Keywords:We,InvalidSchemaError:we};const{Core:He,Schema:Qe,Instance:Ye}=Xe;var en={compile:async(e,n,t)=>{const r=await Qe.step("items",t),a=Qe.typeOf(r,"array")?Qe.length(r):Number.MAX_SAFE_INTEGER;return Qe.typeOf(e,"boolean")?[a,Qe.value(e)]:[a,await He.compileSchema(e,n)]},interpret:([e,n],t,r,a)=>!Ye.typeOf(t,"array")||("string"==typeof n?Ye.every((t,i)=>i<e||He.interpretSchema(n,t,r,a),t):Ye.every((t,r)=>r<e||n,t))};const{Core:nn,Schema:tn,Instance:rn}=Xe,an=([e,n],t,r,a)=>!rn.typeOf(t,"array")||rn.every((t,i)=>i<e||nn.interpretSchema(n,t,r,a),t);var on={compile:async(e,n,t)=>{const r=await tn.step("items",t);return[tn.typeOf(r,"array")?tn.length(r):Number.MAX_SAFE_INTEGER,await nn.compileSchema(e,n)]},interpret:an,collectEvaluatedItems:(e,n,t,r)=>an(e,n,t,r)&&new Set(rn.map((e,n)=>n,n))};const{Core:sn,Schema:cn,Instance:mn}=Xe;var ln={compile:async(e,n,t)=>{const r=await cn.step("properties",t),a=cn.typeOf(r,"object")?cn.keys(r):[],i=await cn.step("patternProperties",t),o=cn.typeOf(i,"object")?cn.keys(i).map(e=>new RegExp(e)):[];return cn.typeOf(e,"boolean")?[a,o,cn.value(e)]:[a,o,await sn.compileSchema(e,n)]},interpret:([e,n,t],r,a,i)=>{if(!mn.typeOf(r,"object"))return!0;const o=mn.entries(r).filter(([t])=>!e.includes(t)&&!n.some(e=>e.test(t)));return"string"==typeof t?o.every(([,e])=>sn.interpretSchema(t,e,a,i)):0===o.length||t}};const{Core:pn,Schema:un,Instance:dn}=Xe,fn=([e,n,t],r,a,i)=>!dn.typeOf(r,"object")||dn.entries(r).filter(([t])=>!e.includes(t)&&!n.some(e=>e.test(t))).every(([,e])=>pn.interpretSchema(t,e,a,i));var yn={compile:async(e,n,t)=>{const r=await un.step("properties",t),a=un.typeOf(r,"object")?un.keys(r):[],i=await un.step("patternProperties",t);return[a,un.typeOf(i,"object")?un.keys(i).map(e=>new RegExp(e)):[],await pn.compileSchema(e,n)]},interpret:fn,collectEvaluatedProperties:(e,n,t,r)=>fn(e,n,t,r)&&[new RegExp("")]};const{Core:hn,Schema:vn}=Xe;var gn={compile:(e,n)=>ee.pipeline([vn.map(async e=>hn.compileSchema(await e,n)),ee.all],e),interpret:(e,n,t,r)=>e.every(e=>hn.interpretSchema(e,n,t,r)),collectEvaluatedProperties:(e,n,t,r)=>e.reduce((e,a)=>{const i=e&&hn.collectEvaluatedProperties(a,n,t,r);return!1!==i&&[...e,...i]},[]),collectEvaluatedItems:(e,n,t,r)=>e.reduce((e,a)=>{const i=!1!==e&&hn.collectEvaluatedItems(a,n,t,r);return!1!==i&&new Set([...e,...i])},new Set)};const{Core:bn,Schema:$n}=Xe;var On={compile:(e,n)=>ee.pipeline([$n.map(async e=>bn.compileSchema(await e,n)),ee.all],e),interpret:(e,n,t,r)=>e.filter(e=>bn.interpretSchema(e,n,t,r)).length>0,collectEvaluatedProperties:(e,n,t,r)=>e.reduce((e,a)=>{const i=bn.collectEvaluatedProperties(a,n,t,r);return!1!==i?[...e||[],...i]:e},!1),collectEvaluatedItems:(e,n,t,r)=>e.reduce((e,a)=>{const i=bn.collectEvaluatedItems(a,n,t,r);return!1!==i?new Set([...e||[],...i]):e},!1)},In=Object.keys,Sn=JSON.stringify;var jn=function(e){return""+function e(n,t){var r,a,i,o,s,c,m;if("string"===(m=typeof n))return Sn(n);if(!0===n)return"true";if(!1===n)return"false";if(null===n)return"null";if(n instanceof Array){for(i="[",a=n.length-1,r=0;r<a;r++)i+=e(n[r],!1)+",";return a>-1&&(i+=e(n[r],!1)),i+"]"}if(n instanceof Object){if("function"==typeof n.toJSON)return e(n.toJSON(),t);for(a=(o=In(n).sort()).length,i="",r=0;r<a;)void 0!==(c=e(n[s=o[r]],!0))&&(r&&""!==i&&(i+=","),i+=Sn(s)+":"+c),r++;return"{"+i+"}"}switch(m){case"function":case"undefined":return t?void 0:null;default:return isFinite(n)?n:null}}(e,!1)};const{Schema:xn,Instance:wn}=Xe;var Pn={compile:e=>jn(xn.value(e)),interpret:(e,n)=>jn(wn.value(n))===e};const{Core:En,Instance:An}=Xe;var Cn={compile:(e,n)=>En.compileSchema(e,n),interpret:(e,n,t,r)=>!An.typeOf(n,"array")||An.some(n=>En.interpretSchema(e,n,t,r),n)};const{Core:Nn,Schema:Rn,Instance:Tn}=Xe,Dn=({contains:e,minContains:n,maxContains:t},r,a,i)=>{if(!Tn.typeOf(r,"array"))return!0;const o=Tn.reduce((n,t)=>Nn.interpretSchema(e,t,a,i)?n+1:n,0,r);return o>=n&&o<=t};var kn={compile:async(e,n,t)=>{const r=await Nn.compileSchema(e,n),a=await Rn.step("minContains",t),i=Rn.typeOf(a,"number")?Rn.value(a):1,o=await Rn.step("maxContains",t);return{contains:r,minContains:i,maxContains:Rn.typeOf(o,"number")?Rn.value(o):Number.MAX_SAFE_INTEGER}},interpret:Dn,collectEvaluatedItems:(e,n,t,r)=>Dn(e,n,t,r)&&Tn.reduce((n,a,i)=>Nn.interpretSchema(e.contains,a,t,r)?n.add(i):n,new Set,n)};const{Core:Mn,Schema:qn}=Xe;var Vn={compile:async(e,n)=>{await ee.pipeline([qn.entries,ee.map(([,e])=>Mn.compileSchema(e,n)),ee.all],e)},interpret:()=>!0};const{Core:Ln,Schema:Jn,Instance:_n}=Xe;var Un={compile:(e,n)=>ee.pipeline([Jn.entries,ee.map(async([e,t])=>[e,Jn.typeOf(t,"array")?Jn.value(t):await Ln.compileSchema(t,n)]),ee.all],e),interpret:(e,n,t,r)=>{const a=_n.value(n);return!_n.typeOf(n,"object")||e.every(([e,i])=>!(e in a)||(Array.isArray(i)?i.every(e=>e in a):Ln.interpretSchema(i,n,t,r)))}};const{Schema:zn,Instance:Fn}=Xe;var Kn={compile:e=>ee.pipeline([zn.entries,ee.map(([e,n])=>[e,zn.value(n)]),ee.all],e),interpret:(e,n)=>{const t=Fn.value(n);return!Fn.typeOf(n,"object")||e.every(([e,n])=>!(e in t)||n.every(e=>e in t))}};const{Core:Bn,Schema:Zn,Instance:Gn}=Xe;var Wn={compile:(e,n)=>ee.pipeline([Zn.entries,ee.map(async([e,t])=>[e,await Bn.compileSchema(t,n)]),ee.all],e),interpret:(e,n,t,r)=>{const a=Gn.value(n);return!Gn.typeOf(n,"object")||e.every(([e,i])=>!(e in a)||Bn.interpretSchema(i,n,t,r))},collectEvaluatedProperties:(e,n,t,r)=>e.reduce((e,[a,i])=>{if(!e||!Gn.has(a,n))return e;const o=Bn.collectEvaluatedProperties(i,n,t,r);return!1!==o&&e.concat(o)},[])};const{Schema:Xn,Instance:Hn}=Xe;var Qn={compile:e=>Xn.value(e).map(jn),interpret:(e,n)=>e.some(e=>jn(Hn.value(n))===e)};const{Schema:Yn,Instance:et}=Xe;var nt={compile:async e=>Yn.value(e),interpret:(e,n)=>!et.typeOf(n,"number")||et.value(n)<e};const{Schema:tt,Instance:rt}=Xe;var at={compile:async e=>tt.value(e),interpret:(e,n)=>!rt.typeOf(n,"number")||rt.value(n)>e};const{Core:it}=Xe;var ot={compile:(e,n)=>it.compileSchema(e,n),interpret:(e,n,t,r)=>(it.interpretSchema(e,n,t,r),!0),collectEvaluatedProperties:(e,n,t,r)=>it.collectEvaluatedProperties(e,n,t,r)||[],collectEvaluatedItems:(e,n,t,r)=>it.collectEvaluatedItems(e,n,t,r)||new Set};const{Core:st,Schema:ct}=Xe,mt=(e,n,t,r)=>{const a=t[e][2];return"boolean"==typeof a?a:a.every(([e,,a])=>st.getKeyword(e).interpret(a,n,t,r))};var lt={compile:async(e,n,t)=>{if(ct.has("if",t)){const r=await ct.step("if",t);return[await st.compileSchema(r,n),await st.compileSchema(e,n)]}return[]},interpret:([e,n],t,r,a)=>void 0===e||!mt(e,t,r,a)||st.interpretSchema(n,t,r,a),collectEvaluatedProperties:([e,n],t,r,a)=>void 0!==e&&mt(e,t,r,a)?st.collectEvaluatedProperties(n,t,r,a):[],collectEvaluatedItems:([e,n],t,r,a)=>void 0!==e&&mt(e,t,r,a)?st.collectEvaluatedItems(n,t,r,a):new Set};const{Core:pt,Schema:ut}=Xe,dt=(e,n,t,r)=>{const a=t[e][2];return"boolean"==typeof a?a:a.every(([e,,a])=>pt.getKeyword(e).interpret(a,n,t,r))};var ft={compile:async(e,n,t)=>{if(ut.has("if",t)){const r=await ut.step("if",t);return[await pt.compileSchema(r,n),await pt.compileSchema(e,n)]}return[]},interpret:([e,n],t,r,a)=>void 0===e||dt(e,t,r,a)||pt.interpretSchema(n,t,r,a),collectEvaluatedProperties:([e,n],t,r,a)=>void 0===e||dt(e,t,r,a)?[]:pt.collectEvaluatedProperties(n,t,r,a),collectEvaluatedItems:([e,n],t,r,a)=>void 0===e||dt(e,t,r,a)?new Set:pt.collectEvaluatedItems(n,t,r,a)};const{Core:yt,Schema:ht,Instance:vt}=Xe,gt=(e,n,t,r)=>!vt.typeOf(n,"array")||("string"==typeof e?vt.every(n=>yt.interpretSchema(e,n,t,r),n):vt.every((n,a)=>!(a in e)||yt.interpretSchema(e[a],n,t,r),n));var bt={compile:async(e,n)=>{if(ht.typeOf(e,"array")){const t=await ht.map(e=>yt.compileSchema(e,n),e);return Promise.all(t)}return yt.compileSchema(e,n)},interpret:gt,collectEvaluatedItems:(e,n,t,r)=>gt(e,n,t,r)&&("string"==typeof e?new Set(vt.map((e,n)=>n,n)):new Set(e.map((e,n)=>n)))};const{Core:$t,Schema:Ot,Instance:It}=Xe,St=([e,n],t,r,a)=>!It.typeOf(t,"array")||It.every((t,i)=>i<e||$t.interpretSchema(n,t,r,a),t);var jt={compile:async(e,n,t)=>{const r=await Ot.step("prefixItems",t);return[Ot.typeOf(r,"array")?Ot.length(r):0,await $t.compileSchema(e,n)]},interpret:St,collectEvaluatedItems:(e,n,t,r)=>St(e,n,t,r)&&new Set(It.map((e,n)=>n,n))};const{Schema:xt,Instance:wt}=Xe;var Pt={compile:e=>xt.value(e),interpret:(e,n)=>!wt.typeOf(n,"array")||wt.length(n)<=e};const{Schema:Et,Instance:At}=Xe;var Ct={compile:e=>Et.value(e),interpret:(e,n)=>!At.typeOf(n,"string")||At.length(n)<=e};const{Schema:Nt,Instance:Rt}=Xe;var Tt={compile:e=>Nt.value(e),interpret:(e,n)=>!Rt.typeOf(n,"string")||[...Rt.value(n)].length<=e};const{Schema:Dt,Instance:kt}=Xe;var Mt={compile:e=>Dt.value(e),interpret:(e,n)=>!kt.typeOf(n,"object")||kt.keys(n).length<=e};const{Schema:qt,Instance:Vt}=Xe;var Lt={compile:async(e,n,t)=>{const r=await qt.step("exclusiveMaximum",t),a=qt.value(r);return[qt.value(e),a]},interpret:([e,n],t)=>{if(!Vt.typeOf(t,"number"))return!0;const r=Vt.value(t);return n?r<e:r<=e}};const{Schema:Jt,Instance:_t}=Xe;var Ut={compile:async e=>Jt.value(e),interpret:(e,n)=>!_t.typeOf(n,"number")||_t.value(n)<=e};const{Schema:zt,Instance:Ft}=Xe;var Kt={compile:e=>zt.value(e),interpret:(e,n)=>!Ft.typeOf(n,"array")||Ft.length(n)>=e};const{Schema:Bt,Instance:Zt}=Xe;var Gt={compile:e=>Bt.value(e),interpret:(e,n)=>!Zt.typeOf(n,"string")||Zt.length(n)>=e};const{Schema:Wt,Instance:Xt}=Xe;var Ht={compile:e=>Wt.value(e),interpret:(e,n)=>!Xt.typeOf(n,"string")||[...Xt.value(n)].length>=e};const{Schema:Qt,Instance:Yt}=Xe;var er={compile:e=>Qt.value(e),interpret:(e,n)=>!Yt.typeOf(n,"object")||Yt.keys(n).length>=e};const{Schema:nr,Instance:tr}=Xe;var rr={compile:async(e,n,t)=>{const r=await nr.step("exclusiveMinimum",t),a=nr.value(r);return[nr.value(e),a]},interpret:([e,n],t)=>{if(!tr.typeOf(t,"number"))return!0;const r=tr.value(t);return n?r>e:r>=e}};const{Schema:ar,Instance:ir}=Xe;var or={compile:async e=>ar.value(e),interpret:(e,n)=>!ir.typeOf(n,"number")||ir.value(n)>=e};const{Schema:sr,Instance:cr}=Xe,mr=(e,n)=>Math.abs(e-n)<1.1920929e-7;var lr={compile:e=>sr.value(e),interpret:(e,n)=>{if(!cr.typeOf(n,"number"))return!0;const t=cr.value(n)%e;return mr(0,t)||mr(e,t)}};const{Core:pr}=Xe;var ur={compile:pr.compileSchema,interpret:(e,n,t,r)=>!pr.interpretSchema(e,n,t,r)};const{Core:dr,Schema:fr}=Xe;var yr={compile:async(e,n)=>{const t=await fr.map(e=>dr.compileSchema(e,n),e);return Promise.all(t)},interpret:(e,n,t,r)=>{let a=0;for(const i of e)if(dr.interpretSchema(i,n,t,r)&&a++,a>1)break;return 1===a},collectEvaluatedProperties:(e,n,t,r)=>{let a=0;return e.reduce((e,i)=>{if(a>1)return!1;const o=dr.collectEvaluatedProperties(i,n,t,r);return o?0==a++&&o:e},!1)},collectEvaluatedItems:(e,n,t,r)=>{let a=0;return e.reduce((e,i)=>{if(a>1)return!1;const o=dr.collectEvaluatedItems(i,n,t,r);return o?0==a++&&o:e},!1)}};const{Schema:hr,Instance:vr}=Xe;var gr={compile:e=>new RegExp(hr.value(e),"u"),interpret:(e,n)=>!vr.typeOf(n,"string")||e.test(vr.value(n))};const{Core:br,Schema:$r,Instance:Or}=Xe,Ir=(e,n,t,r)=>!Or.typeOf(n,"object")||e.every(([e,a])=>Or.entries(n).filter(([n])=>e.test(n)).every(([,e])=>br.interpretSchema(a,e,t,r)));var Sr={compile:(e,n)=>ee.pipeline([$r.entries,ee.map(async([e,t])=>[new RegExp(e,"u"),await br.compileSchema(t,n)]),ee.all],e),interpret:Ir,collectEvaluatedProperties:(e,n,t,r)=>Ir(e,n,t,r)&&e.map(([e])=>e)};var jr={isObject:e=>"object"==typeof e&&!Array.isArray(e)&&null!==e,escapeRegExp:e=>e.replace(/[.*+\-?^${}()|[\]\\]/g,"\\$&"),splitUrl:e=>{const n=e.indexOf("#"),t=-1===n?e.length:n,r=e.slice(0,t),a=e.slice(t+1);return[decodeURI(r),decodeURI(a)]}};const{Core:xr,Schema:wr,Instance:Pr}=Xe,{escapeRegExp:Er}=jr,Ar=(e,n,t,r)=>!Pr.typeOf(n,"object")||Pr.entries(n).filter(([n])=>n in e).every(([n,a])=>xr.interpretSchema(e[n],a,t,r));var Cr={compile:(e,n)=>ee.pipeline([wr.entries,ee.reduce(async(e,[t,r])=>(e[t]=await xr.compileSchema(r,n),e),Object.create(null))],e),interpret:Ar,collectEvaluatedProperties:(e,n,t,r)=>Ar(e,n,t,r)&&Object.keys(e).map(e=>new RegExp(`^${Er(e)}$`))};const{Core:Nr,Instance:Rr}=Xe;var Tr={compile:(e,n)=>Nr.compileSchema(e,n),interpret:(e,n,t,r)=>!Rr.typeOf(n,"object")||Rr.keys(n).every(n=>Nr.interpretSchema(e,Rr.cons(n),t,r))};const{Core:Dr,Schema:kr}=Xe,{splitUrl:Mr}=jr;var qr={compile:async(e,n)=>{const[,t]=Mr(kr.value(e)),r=await kr.get(kr.value(e),e);return await Dr.compileSchema(r,n),[r.id,t]},interpret:([e,n],t,r,a)=>{if(n in r.metaData[e].dynamicAnchors)return Dr.interpretSchema(a[n],t,r,a);{const i=kr.getAnchorPointer(r.metaData[e],n);return Dr.interpretSchema(`${e}#${encodeURI(i)}`,t,r,a)}},collectEvaluatedProperties:Dr.collectEvaluatedProperties,collectEvaluatedItems:Dr.collectEvaluatedItems};const{Core:Vr,Schema:Lr}=Xe;var Jr={compile:async(e,n)=>{const t=await Lr.get(Lr.value(e),e);return Vr.compileSchema(t,n)},interpret:Vr.interpretSchema,collectEvaluatedProperties:Vr.collectEvaluatedProperties,collectEvaluatedItems:Vr.collectEvaluatedItems};const{Schema:_r,Instance:Ur}=Xe;var zr={compile:e=>_r.value(e),interpret:(e,n)=>!Ur.typeOf(n,"object")||e.every(e=>Object.prototype.hasOwnProperty.call(Ur.value(n),e))};const{Core:Fr,Schema:Kr,Instance:Br}=Xe,Zr=(e,n,t,r)=>!Br.typeOf(n,"array")||Br.every((n,a)=>!(a in e)||Fr.interpretSchema(e[a],n,t,r),n);var Gr={compile:(e,n)=>ee.pipeline([Kr.map(e=>Fr.compileSchema(e,n)),ee.all],e),interpret:Zr,collectEvaluatedItems:(e,n,t,r)=>Zr(e,n,t,r)&&new Set(e.map((e,n)=>n))};const{Schema:Wr,Instance:Xr}=Xe;var Hr={compile:e=>Wr.value(e),interpret:(e,n)=>"string"==typeof e?Xr.typeOf(n,e):e.some(Xr.typeOf(n))};const{Core:Qr,Schema:Yr,Instance:ea}=Xe,na=([e,n],t,r,a)=>{if(!ea.typeOf(t,"array"))return!0;const i=Qr.collectEvaluatedItems(e,t,r,a,!0);return!1===i||ea.every((e,o)=>i.has(o)||Qr.interpretSchema(n,ea.step(o,t),r,a),t)};var ta={compile:async(e,n,t)=>[Yr.uri(t),await Qr.compileSchema(e,n)],interpret:na,collectEvaluatedItems:(e,n,t,r)=>na(e,n,t,r)&&new Set(ea.map((e,n)=>n,n))};const{Core:ra,Schema:aa,Instance:ia}=Xe,oa=([e,n],t,r,a)=>{if(!ia.typeOf(t,"object"))return!0;const i=ra.collectEvaluatedProperties(e,t,r,a,!0);return!i||ia.entries(t).filter(([e])=>!i.some(n=>e.match(n))).every(([,e])=>ra.interpretSchema(n,e,r,a))};var sa={compile:async(e,n,t)=>[aa.uri(t),await ra.compileSchema(e,n)],interpret:oa,collectEvaluatedProperties:(e,n,t,r)=>oa(e,n,t,r)&&[new RegExp("")]};const{Schema:ca,Instance:ma}=Xe;var la={compile:e=>ca.value(e),interpret:(e,n)=>{if(!ma.typeOf(n,"array")||!1===e)return!0;const t=ma.map(e=>jn(ma.value(e)),n);return new Set(t).size===t.length}};const{Keywords:pa}=Xe;var ua={additionalItems:en,additionalItems6:on,additionalProperties:ln,additionalProperties6:yn,allOf:gn,anyOf:On,const:Pn,contains:Cn,containsMinContainsMaxContains:kn,definitions:Vn,dependencies:Un,dependentRequired:Kn,dependentSchemas:Wn,enum:Qn,exclusiveMaximum:nt,exclusiveMinimum:at,if:ot,then:lt,else:ft,items:bt,items202012:jt,maxItems:Pt,maxLength:Ct,maxLength6:Tt,maxProperties:Mt,maximumExclusiveMaximum:Lt,maximum:Ut,metaData:pa.metaData,minItems:Kt,minLength:Gt,minLength6:Ht,minProperties:er,minimumExclusiveMinimum:rr,minimum:or,multipleOf:lr,not:ur,oneOf:yr,pattern:gr,patternProperties:Sr,properties:Cr,propertyNames:Tr,dynamicRef:qr,ref:Jr,required:zr,tupleItems:Gr,type:Hr,unevaluatedItems:ta,unevaluatedProperties:sa,uniqueItems:la,validate:pa.validate};const{Core:da,Schema:fa}=Xe,ya="http://json-schema.org/draft-04/schema";fa.setConfig(ya,"baseToken","id"),fa.setConfig(ya,"embeddedToken","id"),fa.setConfig(ya,"anchorToken","id"),fa.setConfig(ya,"jrefToken","$ref"),fa.add(JSON.parse('{\n    "id": "http://json-schema.org/draft-04/schema#",\n    "$schema": "http://json-schema.org/draft-04/schema#",\n    "description": "Core schema meta-schema",\n    "definitions": {\n        "schemaArray": {\n            "type": "array",\n            "minItems": 1,\n            "items": { "$ref": "#" }\n        },\n        "positiveInteger": {\n            "type": "integer",\n            "minimum": 0\n        },\n        "positiveIntegerDefault0": {\n            "allOf": [ { "$ref": "#/definitions/positiveInteger" }, { "default": 0 } ]\n        },\n        "simpleTypes": {\n            "enum": [ "array", "boolean", "integer", "null", "number", "object", "string" ]\n        },\n        "stringArray": {\n            "type": "array",\n            "items": { "type": "string" },\n            "minItems": 1,\n            "uniqueItems": true\n        }\n    },\n    "type": "object",\n    "properties": {\n        "id": {\n            "type": "string"\n        },\n        "$schema": {\n            "type": "string"\n        },\n        "title": {\n            "type": "string"\n        },\n        "description": {\n            "type": "string"\n        },\n        "default": {},\n        "multipleOf": {\n            "type": "number",\n            "minimum": 0,\n            "exclusiveMinimum": true\n        },\n        "maximum": {\n            "type": "number"\n        },\n        "exclusiveMaximum": {\n            "type": "boolean",\n            "default": false\n        },\n        "minimum": {\n            "type": "number"\n        },\n        "exclusiveMinimum": {\n            "type": "boolean",\n            "default": false\n        },\n        "maxLength": { "$ref": "#/definitions/positiveInteger" },\n        "minLength": { "$ref": "#/definitions/positiveIntegerDefault0" },\n        "pattern": {\n            "type": "string",\n            "format": "regex"\n        },\n        "additionalItems": {\n            "anyOf": [\n                { "type": "boolean" },\n                { "$ref": "#" }\n            ],\n            "default": {}\n        },\n        "items": {\n            "anyOf": [\n                { "$ref": "#" },\n                { "$ref": "#/definitions/schemaArray" }\n            ],\n            "default": {}\n        },\n        "maxItems": { "$ref": "#/definitions/positiveInteger" },\n        "minItems": { "$ref": "#/definitions/positiveIntegerDefault0" },\n        "uniqueItems": {\n            "type": "boolean",\n            "default": false\n        },\n        "maxProperties": { "$ref": "#/definitions/positiveInteger" },\n        "minProperties": { "$ref": "#/definitions/positiveIntegerDefault0" },\n        "required": { "$ref": "#/definitions/stringArray" },\n        "additionalProperties": {\n            "anyOf": [\n                { "type": "boolean" },\n                { "$ref": "#" }\n            ],\n            "default": {}\n        },\n        "definitions": {\n            "type": "object",\n            "additionalProperties": { "$ref": "#" },\n            "default": {}\n        },\n        "properties": {\n            "type": "object",\n            "additionalProperties": { "$ref": "#" },\n            "default": {}\n        },\n        "patternProperties": {\n            "type": "object",\n            "additionalProperties": { "$ref": "#" },\n            "default": {}\n        },\n        "dependencies": {\n            "type": "object",\n            "additionalProperties": {\n                "anyOf": [\n                    { "$ref": "#" },\n                    { "$ref": "#/definitions/stringArray" }\n                ]\n            }\n        },\n        "enum": {\n            "type": "array",\n            "minItems": 1,\n            "uniqueItems": true\n        },\n        "type": {\n            "anyOf": [\n                { "$ref": "#/definitions/simpleTypes" },\n                {\n                    "type": "array",\n                    "items": { "$ref": "#/definitions/simpleTypes" },\n                    "minItems": 1,\n                    "uniqueItems": true\n                }\n            ]\n        },\n        "format": { "type": "string" },\n        "allOf": { "$ref": "#/definitions/schemaArray" },\n        "anyOf": { "$ref": "#/definitions/schemaArray" },\n        "oneOf": { "$ref": "#/definitions/schemaArray" },\n        "not": { "$ref": "#" }\n    },\n    "dependencies": {\n        "exclusiveMaximum": [ "maximum" ],\n        "exclusiveMinimum": [ "minimum" ]\n    },\n    "default": {}\n}')),da.defineVocabulary(ya,{validate:ua.validate,additionalItems:ua.additionalItems,additionalProperties:ua.additionalProperties,allOf:ua.allOf,anyOf:ua.anyOf,default:ua.metaData,definitions:ua.definitions,dependencies:ua.dependencies,description:ua.metaData,enum:ua.enum,format:ua.metaData,items:ua.items,maxItems:ua.maxItems,maxLength:ua.maxLength,maxProperties:ua.maxProperties,maximum:ua.maximumExclusiveMaximum,minItems:ua.minItems,minLength:ua.minLength,minProperties:ua.minProperties,minimum:ua.minimumExclusiveMinimum,multipleOf:ua.multipleOf,not:ua.not,oneOf:ua.oneOf,pattern:ua.pattern,patternProperties:ua.patternProperties,properties:ua.properties,required:ua.required,title:ua.metaData,type:ua.type,uniqueItems:ua.uniqueItems});const{Core:ha,Schema:va}=Xe,ga="http://json-schema.org/draft-06/schema";va.setConfig(ga,"baseToken","$id"),va.setConfig(ga,"embeddedToken","$id"),va.setConfig(ga,"anchorToken","$id"),va.setConfig(ga,"jrefToken","$ref"),va.add(JSON.parse('{\n    "$schema": "http://json-schema.org/draft-06/schema#",\n    "$id": "http://json-schema.org/draft-06/schema#",\n    "title": "Core schema meta-schema",\n    "definitions": {\n        "schemaArray": {\n            "type": "array",\n            "minItems": 1,\n            "items": { "$ref": "#" }\n        },\n        "nonNegativeInteger": {\n            "type": "integer",\n            "minimum": 0\n        },\n        "nonNegativeIntegerDefault0": {\n            "allOf": [\n                { "$ref": "#/definitions/nonNegativeInteger" },\n                { "default": 0 }\n            ]\n        },\n        "simpleTypes": {\n            "enum": [\n                "array",\n                "boolean",\n                "integer",\n                "null",\n                "number",\n                "object",\n                "string"\n            ]\n        },\n        "stringArray": {\n            "type": "array",\n            "items": { "type": "string" },\n            "uniqueItems": true,\n            "default": []\n        }\n    },\n    "type": ["object", "boolean"],\n    "properties": {\n        "$id": {\n            "type": "string",\n            "format": "uri-reference"\n        },\n        "$schema": {\n            "type": "string",\n            "format": "uri"\n        },\n        "$ref": {\n            "type": "string",\n            "format": "uri-reference"\n        },\n        "title": {\n            "type": "string"\n        },\n        "description": {\n            "type": "string"\n        },\n        "default": {},\n        "examples": {\n            "type": "array",\n            "items": {}\n        },\n        "multipleOf": {\n            "type": "number",\n            "exclusiveMinimum": 0\n        },\n        "maximum": {\n            "type": "number"\n        },\n        "exclusiveMaximum": {\n            "type": "number"\n        },\n        "minimum": {\n            "type": "number"\n        },\n        "exclusiveMinimum": {\n            "type": "number"\n        },\n        "maxLength": { "$ref": "#/definitions/nonNegativeInteger" },\n        "minLength": { "$ref": "#/definitions/nonNegativeIntegerDefault0" },\n        "pattern": {\n            "type": "string",\n            "format": "regex"\n        },\n        "additionalItems": { "$ref": "#" },\n        "items": {\n            "anyOf": [\n                { "$ref": "#" },\n                { "$ref": "#/definitions/schemaArray" }\n            ],\n            "default": {}\n        },\n        "maxItems": { "$ref": "#/definitions/nonNegativeInteger" },\n        "minItems": { "$ref": "#/definitions/nonNegativeIntegerDefault0" },\n        "uniqueItems": {\n            "type": "boolean",\n            "default": false\n        },\n        "contains": { "$ref": "#" },\n        "maxProperties": { "$ref": "#/definitions/nonNegativeInteger" },\n        "minProperties": { "$ref": "#/definitions/nonNegativeIntegerDefault0" },\n        "required": { "$ref": "#/definitions/stringArray" },\n        "additionalProperties": { "$ref": "#" },\n        "definitions": {\n            "type": "object",\n            "additionalProperties": { "$ref": "#" },\n            "default": {}\n        },\n        "properties": {\n            "type": "object",\n            "additionalProperties": { "$ref": "#" },\n            "default": {}\n        },\n        "patternProperties": {\n            "type": "object",\n            "additionalProperties": { "$ref": "#" },\n            "default": {}\n        },\n        "dependencies": {\n            "type": "object",\n            "additionalProperties": {\n                "anyOf": [\n                    { "$ref": "#" },\n                    { "$ref": "#/definitions/stringArray" }\n                ]\n            }\n        },\n        "propertyNames": { "$ref": "#" },\n        "const": {},\n        "enum": {\n            "type": "array",\n            "minItems": 1,\n            "uniqueItems": true\n        },\n        "type": {\n            "anyOf": [\n                { "$ref": "#/definitions/simpleTypes" },\n                {\n                    "type": "array",\n                    "items": { "$ref": "#/definitions/simpleTypes" },\n                    "minItems": 1,\n                    "uniqueItems": true\n                }\n            ]\n        },\n        "format": { "type": "string" },\n        "allOf": { "$ref": "#/definitions/schemaArray" },\n        "anyOf": { "$ref": "#/definitions/schemaArray" },\n        "oneOf": { "$ref": "#/definitions/schemaArray" },\n        "not": { "$ref": "#" }\n    },\n    "default": {}\n}')),ha.defineVocabulary(ga,{validate:ua.validate,additionalItems:ua.additionalItems6,additionalProperties:ua.additionalProperties6,allOf:ua.allOf,anyOf:ua.anyOf,const:ua.const,contains:ua.contains,default:ua.metaData,definitions:ua.definitions,dependencies:ua.dependencies,description:ua.metaData,enum:ua.enum,examples:ua.metaData,exclusiveMaximum:ua.exclusiveMaximum,exclusiveMinimum:ua.exclusiveMinimum,format:ua.metaData,items:ua.items,maxItems:ua.maxItems,maxLength:ua.maxLength6,maxProperties:ua.maxProperties,maximum:ua.maximum,minItems:ua.minItems,minLength:ua.minLength6,minProperties:ua.minProperties,minimum:ua.minimum,multipleOf:ua.multipleOf,not:ua.not,oneOf:ua.oneOf,pattern:ua.pattern,patternProperties:ua.patternProperties,properties:ua.properties,propertyNames:ua.propertyNames,required:ua.required,title:ua.metaData,type:ua.type,uniqueItems:ua.uniqueItems});const{Core:ba,Schema:$a}=Xe,Oa="http://json-schema.org/draft-07/schema";$a.setConfig(Oa,"baseToken","$id"),$a.setConfig(Oa,"embeddedToken","$id"),$a.setConfig(Oa,"anchorToken","$id"),$a.setConfig(Oa,"jrefToken","$ref"),$a.add(JSON.parse('{\n    "$schema": "http://json-schema.org/draft-07/schema#",\n    "$id": "http://json-schema.org/draft-07/schema#",\n    "title": "Core schema meta-schema",\n    "definitions": {\n        "schemaArray": {\n            "type": "array",\n            "minItems": 1,\n            "items": { "$ref": "#" }\n        },\n        "nonNegativeInteger": {\n            "type": "integer",\n            "minimum": 0\n        },\n        "nonNegativeIntegerDefault0": {\n            "allOf": [\n                { "$ref": "#/definitions/nonNegativeInteger" },\n                { "default": 0 }\n            ]\n        },\n        "simpleTypes": {\n            "enum": [\n                "array",\n                "boolean",\n                "integer",\n                "null",\n                "number",\n                "object",\n                "string"\n            ]\n        },\n        "stringArray": {\n            "type": "array",\n            "items": { "type": "string" },\n            "uniqueItems": true,\n            "default": []\n        }\n    },\n    "type": ["object", "boolean"],\n    "properties": {\n        "$id": {\n            "type": "string",\n            "format": "uri-reference"\n        },\n        "$schema": {\n            "type": "string",\n            "format": "uri"\n        },\n        "$ref": {\n            "type": "string",\n            "format": "uri-reference"\n        },\n        "$comment": {\n            "type": "string"\n        },\n        "title": {\n            "type": "string"\n        },\n        "description": {\n            "type": "string"\n        },\n        "default": true,\n        "readOnly": {\n            "type": "boolean",\n            "default": false\n        },\n        "writeOnly": {\n            "type": "boolean",\n            "default": false\n        },\n        "examples": {\n            "type": "array",\n            "items": true\n        },\n        "multipleOf": {\n            "type": "number",\n            "exclusiveMinimum": 0\n        },\n        "maximum": {\n            "type": "number"\n        },\n        "exclusiveMaximum": {\n            "type": "number"\n        },\n        "minimum": {\n            "type": "number"\n        },\n        "exclusiveMinimum": {\n            "type": "number"\n        },\n        "maxLength": { "$ref": "#/definitions/nonNegativeInteger" },\n        "minLength": { "$ref": "#/definitions/nonNegativeIntegerDefault0" },\n        "pattern": {\n            "type": "string",\n            "format": "regex"\n        },\n        "additionalItems": { "$ref": "#" },\n        "items": {\n            "anyOf": [\n                { "$ref": "#" },\n                { "$ref": "#/definitions/schemaArray" }\n            ],\n            "default": true\n        },\n        "maxItems": { "$ref": "#/definitions/nonNegativeInteger" },\n        "minItems": { "$ref": "#/definitions/nonNegativeIntegerDefault0" },\n        "uniqueItems": {\n            "type": "boolean",\n            "default": false\n        },\n        "contains": { "$ref": "#" },\n        "maxProperties": { "$ref": "#/definitions/nonNegativeInteger" },\n        "minProperties": { "$ref": "#/definitions/nonNegativeIntegerDefault0" },\n        "required": { "$ref": "#/definitions/stringArray" },\n        "additionalProperties": { "$ref": "#" },\n        "definitions": {\n            "type": "object",\n            "additionalProperties": { "$ref": "#" },\n            "default": {}\n        },\n        "properties": {\n            "type": "object",\n            "additionalProperties": { "$ref": "#" },\n            "default": {}\n        },\n        "patternProperties": {\n            "type": "object",\n            "additionalProperties": { "$ref": "#" },\n            "propertyNames": { "format": "regex" },\n            "default": {}\n        },\n        "dependencies": {\n            "type": "object",\n            "additionalProperties": {\n                "anyOf": [\n                    { "$ref": "#" },\n                    { "$ref": "#/definitions/stringArray" }\n                ]\n            }\n        },\n        "propertyNames": { "$ref": "#" },\n        "const": true,\n        "enum": {\n            "type": "array",\n            "items": true,\n            "minItems": 1,\n            "uniqueItems": true\n        },\n        "type": {\n            "anyOf": [\n                { "$ref": "#/definitions/simpleTypes" },\n                {\n                    "type": "array",\n                    "items": { "$ref": "#/definitions/simpleTypes" },\n                    "minItems": 1,\n                    "uniqueItems": true\n                }\n            ]\n        },\n        "format": { "type": "string" },\n        "contentMediaType": { "type": "string" },\n        "contentEncoding": { "type": "string" },\n        "if": { "$ref": "#" },\n        "then": { "$ref": "#" },\n        "else": { "$ref": "#" },\n        "allOf": { "$ref": "#/definitions/schemaArray" },\n        "anyOf": { "$ref": "#/definitions/schemaArray" },\n        "oneOf": { "$ref": "#/definitions/schemaArray" },\n        "not": { "$ref": "#" }\n    },\n    "default": true\n}')),ba.defineVocabulary(Oa,{validate:ua.validate,additionalItems:ua.additionalItems6,additionalProperties:ua.additionalProperties6,allOf:ua.allOf,anyOf:ua.anyOf,const:ua.const,contains:ua.contains,default:ua.metaData,definitions:ua.definitions,dependencies:ua.dependencies,description:ua.metaData,enum:ua.enum,exclusiveMaximum:ua.exclusiveMaximum,exclusiveMinimum:ua.exclusiveMinimum,format:ua.metaData,if:ua.if,then:ua.then,else:ua.else,items:ua.items,maxItems:ua.maxItems,maxLength:ua.maxLength6,maxProperties:ua.maxProperties,maximum:ua.maximum,minItems:ua.minItems,minLength:ua.minLength6,minProperties:ua.minProperties,minimum:ua.minimum,multipleOf:ua.multipleOf,not:ua.not,oneOf:ua.oneOf,pattern:ua.pattern,patternProperties:ua.patternProperties,properties:ua.properties,propertyNames:ua.propertyNames,readOnly:ua.metaData,required:ua.required,title:ua.metaData,type:ua.type,uniqueItems:ua.uniqueItems,writeOnly:ua.metaData});const{Core:Ia,Schema:Sa}=Xe,ja="https://json-schema.org/draft/2019-09/schema";Sa.setConfig(ja,"baseToken","$id"),Sa.setConfig(ja,"embeddedToken","$id"),Sa.setConfig(ja,"anchorToken","$anchor"),Sa.setConfig(ja,"recursiveAnchorToken","$recursiveAnchor"),Sa.setConfig(ja,"vocabularyToken","$vocabulary"),Sa.setConfig(ja,"mandatoryVocabularies",["https://json-schema.org/draft/2019-09/vocab/core"]),Sa.add(JSON.parse('{\n    "$schema": "https://json-schema.org/draft/2019-09/schema",\n    "$id": "https://json-schema.org/draft/2019-09/schema",\n    "$vocabulary": {\n        "https://json-schema.org/draft/2019-09/vocab/core": true,\n        "https://json-schema.org/draft/2019-09/vocab/applicator": true,\n        "https://json-schema.org/draft/2019-09/vocab/validation": true,\n        "https://json-schema.org/draft/2019-09/vocab/meta-data": true,\n        "https://json-schema.org/draft/2019-09/vocab/format": false,\n        "https://json-schema.org/draft/2019-09/vocab/content": true\n    },\n    "$recursiveAnchor": true,\n\n    "title": "Core and Validation specifications meta-schema",\n    "allOf": [\n        {"$ref": "meta/core"},\n        {"$ref": "meta/applicator"},\n        {"$ref": "meta/validation"},\n        {"$ref": "meta/meta-data"},\n        {"$ref": "meta/format"},\n        {"$ref": "meta/content"}\n    ],\n    "type": ["object", "boolean"],\n    "properties": {\n        "definitions": {\n            "$comment": "While no longer an official keyword as it is replaced by $defs, this keyword is retained in the meta-schema to prevent incompatible extensions as it remains in common use.",\n            "type": "object",\n            "additionalProperties": { "$recursiveRef": "#" },\n            "default": {}\n        },\n        "dependencies": {\n            "$comment": "\\"dependencies\\" is no longer a keyword, but schema authors should avoid redefining it to facilitate a smooth transition to \\"dependentSchemas\\" and \\"dependentRequired\\"",\n            "type": "object",\n            "additionalProperties": {\n                "anyOf": [\n                    { "$recursiveRef": "#" },\n                    { "$ref": "meta/validation#/$defs/stringArray" }\n                ]\n            }\n        }\n    }\n}')),Sa.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/2019-09/meta/core",\n    "$schema": "https://json-schema.org/draft/2019-09/schema",\n    "$vocabulary": {\n      "https://json-schema.org/draft/2019-09/vocab/core": true\n    },\n    "$recursiveAnchor": true,\n\n    "title": "Core vocabulary meta-schema",\n    "type": ["object", "boolean"],\n    "properties": {\n        "$id": {\n            "type": "string",\n            "format": "uri-reference",\n            "$comment": "Non-empty fragments not allowed.",\n            "pattern": "^[^#]*#?$"\n        },\n        "$schema": {\n            "type": "string",\n            "format": "uri"\n        },\n        "$anchor": {\n            "type": "string",\n            "pattern": "^[A-Za-z][-A-Za-z0-9.:_]*$"\n        },\n        "$ref": {\n            "type": "string",\n            "format": "uri-reference"\n        },\n        "$recursiveRef": {\n            "type": "string",\n            "format": "uri-reference"\n        },\n        "$recursiveAnchor": {\n            "type": "boolean",\n            "default": false\n        },\n        "$vocabulary": {\n            "type": "object",\n            "propertyNames": {\n                "type": "string",\n                "format": "uri"\n            },\n            "additionalProperties": {\n                "type": "boolean"\n            }\n        },\n        "$comment": {\n            "type": "string"\n        },\n        "$defs": {\n            "type": "object",\n            "additionalProperties": { "$recursiveRef": "#" },\n            "default": {}\n        }\n    }\n}')),Ia.defineVocabulary("https://json-schema.org/draft/2019-09/vocab/core",{validate:ua.validate,$defs:ua.definitions,$recursiveRef:ua.dynamicRef,$ref:ua.ref}),Sa.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/2019-09/meta/applicator",\n    "$schema": "https://json-schema.org/draft/2019-09/schema",\n    "$vocabulary": {\n        "https://json-schema.org/draft/2019-09/vocab/applicator": true\n    },\n    "$recursiveAnchor": true,\n\n    "title": "Applicator vocabulary meta-schema",\n    "properties": {\n        "additionalItems": { "$recursiveRef": "#" },\n        "unevaluatedItems": { "$recursiveRef": "#" },\n        "items": {\n            "anyOf": [\n                { "$recursiveRef": "#" },\n                { "$ref": "#/$defs/schemaArray" }\n            ]\n        },\n        "contains": { "$recursiveRef": "#" },\n        "additionalProperties": { "$recursiveRef": "#" },\n        "unevaluatedProperties": { "$recursiveRef": "#" },\n        "properties": {\n            "type": "object",\n            "additionalProperties": { "$recursiveRef": "#" },\n            "default": {}\n        },\n        "patternProperties": {\n            "type": "object",\n            "additionalProperties": { "$recursiveRef": "#" },\n            "propertyNames": { "format": "regex" },\n            "default": {}\n        },\n        "dependentSchemas": {\n            "type": "object",\n            "additionalProperties": {\n                "$recursiveRef": "#"\n            }\n        },\n        "propertyNames": { "$recursiveRef": "#" },\n        "if": { "$recursiveRef": "#" },\n        "then": { "$recursiveRef": "#" },\n        "else": { "$recursiveRef": "#" },\n        "allOf": { "$ref": "#/$defs/schemaArray" },\n        "anyOf": { "$ref": "#/$defs/schemaArray" },\n        "oneOf": { "$ref": "#/$defs/schemaArray" },\n        "not": { "$recursiveRef": "#" }\n    },\n    "$defs": {\n        "schemaArray": {\n            "type": "array",\n            "minItems": 1,\n            "items": { "$recursiveRef": "#" }\n        }\n    }\n}')),Ia.defineVocabulary("https://json-schema.org/draft/2019-09/vocab/applicator",{additionalItems:ua.additionalItems6,additionalProperties:ua.additionalProperties6,allOf:ua.allOf,anyOf:ua.anyOf,contains:ua.containsMinContainsMaxContains,dependentSchemas:ua.dependentSchemas,if:ua.if,then:ua.then,else:ua.else,items:ua.items,not:ua.not,oneOf:ua.oneOf,patternProperties:ua.patternProperties,properties:ua.properties,propertyNames:ua.propertyNames,unevaluatedItems:ua.unevaluatedItems,unevaluatedProperties:ua.unevaluatedProperties}),Sa.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/2019-09/meta/validation",\n    "$schema": "https://json-schema.org/draft/2019-09/schema",\n    "$vocabulary": {\n      "https://json-schema.org/draft/2019-09/vocab/validation": true\n    },\n    "$recursiveAnchor": true,\n\n    "title": "Validation vocabulary meta-schema",\n    "type": ["object", "boolean"],\n    "properties": {\n        "multipleOf": {\n            "type": "number",\n            "exclusiveMinimum": 0\n        },\n        "maximum": {\n            "type": "number"\n        },\n        "exclusiveMaximum": {\n            "type": "number"\n        },\n        "minimum": {\n            "type": "number"\n        },\n        "exclusiveMinimum": {\n            "type": "number"\n        },\n        "maxLength": { "$ref": "#/$defs/nonNegativeInteger" },\n        "minLength": { "$ref": "#/$defs/nonNegativeIntegerDefault0" },\n        "pattern": {\n            "type": "string",\n            "format": "regex"\n        },\n        "maxItems": { "$ref": "#/$defs/nonNegativeInteger" },\n        "minItems": { "$ref": "#/$defs/nonNegativeIntegerDefault0" },\n        "uniqueItems": {\n            "type": "boolean",\n            "default": false\n        },\n        "maxContains": { "$ref": "#/$defs/nonNegativeInteger" },\n        "minContains": {\n            "$ref": "#/$defs/nonNegativeInteger",\n            "default": 1\n        },\n        "maxProperties": { "$ref": "#/$defs/nonNegativeInteger" },\n        "minProperties": { "$ref": "#/$defs/nonNegativeIntegerDefault0" },\n        "required": { "$ref": "#/$defs/stringArray" },\n        "dependentRequired": {\n            "type": "object",\n            "additionalProperties": {\n                "$ref": "#/$defs/stringArray"\n            }\n        },\n        "const": true,\n        "enum": {\n            "type": "array",\n            "items": true\n        },\n        "type": {\n            "anyOf": [\n                { "$ref": "#/$defs/simpleTypes" },\n                {\n                    "type": "array",\n                    "items": { "$ref": "#/$defs/simpleTypes" },\n                    "minItems": 1,\n                    "uniqueItems": true\n                }\n            ]\n        }\n    },\n    "$defs": {\n        "nonNegativeInteger": {\n            "type": "integer",\n            "minimum": 0\n        },\n        "nonNegativeIntegerDefault0": {\n            "$ref": "#/$defs/nonNegativeInteger",\n            "default": 0\n        },\n        "simpleTypes": {\n            "enum": [\n                "array",\n                "boolean",\n                "integer",\n                "null",\n                "number",\n                "object",\n                "string"\n            ]\n        },\n        "stringArray": {\n            "type": "array",\n            "items": { "type": "string" },\n            "uniqueItems": true,\n            "default": []\n        }\n    }\n}')),Ia.defineVocabulary("https://json-schema.org/draft/2019-09/vocab/validation",{const:ua.const,dependentRequired:ua.dependentRequired,enum:ua.enum,exclusiveMaximum:ua.exclusiveMaximum,exclusiveMinimum:ua.exclusiveMinimum,maxItems:ua.maxItems,maxLength:ua.maxLength6,maxProperties:ua.maxProperties,maximum:ua.maximum,minItems:ua.minItems,minLength:ua.minLength6,minProperties:ua.minProperties,minimum:ua.minimum,multipleOf:ua.multipleOf,pattern:ua.pattern,required:ua.required,type:ua.type,uniqueItems:ua.uniqueItems}),Sa.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/2019-09/meta/meta-data",\n    "$schema": "https://json-schema.org/draft/2019-09/schema",\n    "$vocabulary": {\n      "https://json-schema.org/draft/2019-09/vocab/meta-data": true\n    },\n    "$recursiveAnchor": true,\n\n    "title": "Meta-data vocabulary meta-schema",\n\n    "type": ["object", "boolean"],\n    "properties": {\n        "title": {\n            "type": "string"\n        },\n        "description": {\n            "type": "string"\n        },\n        "default": true,\n        "deprecated": {\n            "type": "boolean",\n            "default": false\n        },\n        "readOnly": {\n            "type": "boolean",\n            "default": false\n        },\n        "writeOnly": {\n            "type": "boolean",\n            "default": false\n        },\n        "examples": {\n            "type": "array",\n            "items": true\n        }\n    }\n}')),Ia.defineVocabulary("https://json-schema.org/draft/2019-09/vocab/meta-data",{default:ua.metaData,deprecated:ua.metaData,description:ua.metaData,examples:ua.metaData,readOnly:ua.metaData,title:ua.metaData,writeOnly:ua.metaData}),Sa.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/2019-09/meta/format",\n    "$schema": "https://json-schema.org/draft/2019-09/schema",\n    "$vocabulary": {\n      "https://json-schema.org/draft/2019-09/vocab/format": true\n    },\n    "$recursiveAnchor": true,\n\n    "title": "Format vocabulary meta-schema",\n    "type": ["object", "boolean"],\n    "properties": {\n        "format": { "type": "string" }\n    }\n}')),Sa.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/2019-09/meta/content",\n    "$schema": "https://json-schema.org/draft/2019-09/schema",\n    "$vocabulary": {\n      "https://json-schema.org/draft/2019-09/vocab/content": true\n    },\n    "$recursiveAnchor": true,\n\n    "title": "Content vocabulary meta-schema",\n\n    "type": ["object", "boolean"],\n    "properties": {\n        "contentMediaType": { "type": "string" },\n        "contentEncoding": { "type": "string" },\n        "contentSchema": { "$recursiveRef": "#" }\n    }\n}')),Ia.defineVocabulary("https://json-schema.org/draft/2019-09/vocab/content",{contentEncoding:ua.metaData,contentMediaType:ua.metaData,contentSchema:ua.metaData});const{Core:xa,Schema:wa}=Xe,Pa="https://json-schema.org/draft/2020-12/schema";wa.setConfig(Pa,"baseToken","$id"),wa.setConfig(Pa,"embeddedToken","$id"),wa.setConfig(Pa,"anchorToken","$anchor"),wa.setConfig(Pa,"dynamicAnchorToken","$dynamicAnchor"),wa.setConfig(Pa,"vocabularyToken","$vocabulary"),wa.setConfig(Pa,"mandatoryVocabularies",["https://json-schema.org/draft/2020-12/vocab/core"]),wa.add(JSON.parse('{\n    "$schema": "https://json-schema.org/draft/2020-12/schema",\n    "$id": "https://json-schema.org/draft/2020-12/schema",\n    "$vocabulary": {\n        "https://json-schema.org/draft/2020-12/vocab/core": true,\n        "https://json-schema.org/draft/2020-12/vocab/applicator": true,\n        "https://json-schema.org/draft/2020-12/vocab/unevaluated": true,\n        "https://json-schema.org/draft/2020-12/vocab/validation": true,\n        "https://json-schema.org/draft/2020-12/vocab/meta-data": true,\n        "https://json-schema.org/draft/2020-12/vocab/format-annotation": true,\n        "https://json-schema.org/draft/2020-12/vocab/content": true\n    },\n    "$dynamicAnchor": "meta",\n\n    "title": "Core and Validation specifications meta-schema",\n    "allOf": [\n        {"$ref": "meta/core"},\n        {"$ref": "meta/applicator"},\n        {"$ref": "meta/unevaluated"},\n        {"$ref": "meta/validation"},\n        {"$ref": "meta/meta-data"},\n        {"$ref": "meta/format-annotation"},\n        {"$ref": "meta/content"}\n    ],\n    "type": ["object", "boolean"],\n    "properties": {\n        "definitions": {\n            "$comment": "While no longer an official keyword as it is replaced by $defs, this keyword is retained in the meta-schema to prevent incompatible extensions as it remains in common use.",\n            "type": "object",\n            "additionalProperties": { "$dynamicRef": "#meta" },\n            "default": {}\n        },\n        "dependencies": {\n            "$comment": "\\"dependencies\\" is no longer a keyword, but schema authors should avoid redefining it to facilitate a smooth transition to \\"dependentSchemas\\" and \\"dependentRequired\\"",\n            "type": "object",\n            "additionalProperties": {\n                "anyOf": [\n                    { "$dynamicRef": "#meta" },\n                    { "$ref": "meta/validation#/$defs/stringArray" }\n                ]\n            }\n        }\n    }\n}')),wa.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/2020-12/meta/core",\n    "$schema": "https://json-schema.org/draft/2020-12/schema",\n    "$vocabulary": {\n        "https://json-schema.org/draft/2020-12/vocab/core": true\n    },\n    "$dynamicAnchor": "meta",\n\n    "title": "Core vocabulary meta-schema",\n    "type": ["object", "boolean"],\n    "properties": {\n        "$id": {\n            "type": "string",\n            "format": "uri-reference",\n            "$comment": "Non-empty fragments not allowed.",\n            "pattern": "^[^#]*#?$"\n        },\n        "$schema": {\n            "type": "string",\n            "format": "uri"\n        },\n        "$anchor": {\n            "type": "string",\n            "pattern": "^[A-Za-z_][-A-Za-z0-9._]*$"\n        },\n        "$ref": {\n            "type": "string",\n            "format": "uri-reference"\n        },\n        "$dynamicRef": {\n            "type": "string",\n            "format": "uri-reference"\n        },\n        "$dynamicAnchor": {\n            "type": "string",\n            "pattern": "^[A-Za-z_][-A-Za-z0-9._]*$"\n        },\n        "$vocabulary": {\n            "type": "object",\n            "propertyNames": {\n                "type": "string",\n                "format": "uri"\n            },\n            "additionalProperties": {\n                "type": "boolean"\n            }\n        },\n        "$comment": {\n            "type": "string"\n        },\n        "$defs": {\n            "type": "object",\n            "additionalProperties": { "$dynamicRef": "#meta" },\n            "default": {}\n        }\n    }\n}')),xa.defineVocabulary("https://json-schema.org/draft/2020-12/vocab/core",{validate:ua.validate,$defs:ua.definitions,$dynamicRef:ua.dynamicRef,$ref:ua.ref}),wa.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/2020-12/meta/applicator",\n    "$schema": "https://json-schema.org/draft/2020-12/schema",\n    "$vocabulary": {\n        "https://json-schema.org/draft/2020-12/vocab/applicator": true\n    },\n    "$dynamicAnchor": "meta",\n\n    "title": "Applicator vocabulary meta-schema",\n    "type": ["object", "boolean"],\n    "properties": {\n        "prefixItems": { "$ref": "#/$defs/schemaArray" },\n        "items": { "$dynamicRef": "#meta" },\n        "contains": { "$dynamicRef": "#meta" },\n        "additionalProperties": { "$dynamicRef": "#meta" },\n        "properties": {\n            "type": "object",\n            "additionalProperties": { "$dynamicRef": "#meta" },\n            "default": {}\n        },\n        "patternProperties": {\n            "type": "object",\n            "additionalProperties": { "$dynamicRef": "#meta" },\n            "propertyNames": { "format": "regex" },\n            "default": {}\n        },\n        "dependentSchemas": {\n            "type": "object",\n            "additionalProperties": {\n                "$dynamicRef": "#meta"\n            }\n        },\n        "propertyNames": { "$dynamicRef": "#meta" },\n        "if": { "$dynamicRef": "#meta" },\n        "then": { "$dynamicRef": "#meta" },\n        "else": { "$dynamicRef": "#meta" },\n        "allOf": { "$ref": "#/$defs/schemaArray" },\n        "anyOf": { "$ref": "#/$defs/schemaArray" },\n        "oneOf": { "$ref": "#/$defs/schemaArray" },\n        "not": { "$dynamicRef": "#meta" }\n    },\n    "$defs": {\n        "schemaArray": {\n            "type": "array",\n            "minItems": 1,\n            "items": { "$dynamicRef": "#meta" }\n        }\n    }\n}')),xa.defineVocabulary("https://json-schema.org/draft/2020-12/vocab/applicator",{additionalProperties:ua.additionalProperties6,allOf:ua.allOf,anyOf:ua.anyOf,contains:ua.containsMinContainsMaxContains,dependentSchemas:ua.dependentSchemas,if:ua.if,then:ua.then,else:ua.else,items:ua.items202012,not:ua.not,oneOf:ua.oneOf,patternProperties:ua.patternProperties,prefixItems:ua.tupleItems,properties:ua.properties,propertyNames:ua.propertyNames}),wa.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/2020-12/meta/validation",\n    "$schema": "https://json-schema.org/draft/2020-12/schema",\n    "$vocabulary": {\n        "https://json-schema.org/draft/2020-12/vocab/validation": true\n    },\n    "$dynamicAnchor": "meta",\n\n    "title": "Validation vocabulary meta-schema",\n    "type": ["object", "boolean"],\n    "properties": {\n        "multipleOf": {\n            "type": "number",\n            "exclusiveMinimum": 0\n        },\n        "maximum": {\n            "type": "number"\n        },\n        "exclusiveMaximum": {\n            "type": "number"\n        },\n        "minimum": {\n            "type": "number"\n        },\n        "exclusiveMinimum": {\n            "type": "number"\n        },\n        "maxLength": { "$ref": "#/$defs/nonNegativeInteger" },\n        "minLength": { "$ref": "#/$defs/nonNegativeIntegerDefault0" },\n        "pattern": {\n            "type": "string",\n            "format": "regex"\n        },\n        "maxItems": { "$ref": "#/$defs/nonNegativeInteger" },\n        "minItems": { "$ref": "#/$defs/nonNegativeIntegerDefault0" },\n        "uniqueItems": {\n            "type": "boolean",\n            "default": false\n        },\n        "maxContains": { "$ref": "#/$defs/nonNegativeInteger" },\n        "minContains": {\n            "$ref": "#/$defs/nonNegativeInteger",\n            "default": 1\n        },\n        "maxProperties": { "$ref": "#/$defs/nonNegativeInteger" },\n        "minProperties": { "$ref": "#/$defs/nonNegativeIntegerDefault0" },\n        "required": { "$ref": "#/$defs/stringArray" },\n        "dependentRequired": {\n            "type": "object",\n            "additionalProperties": {\n                "$ref": "#/$defs/stringArray"\n            }\n        },\n        "const": true,\n        "enum": {\n            "type": "array",\n            "items": true\n        },\n        "type": {\n            "anyOf": [\n                { "$ref": "#/$defs/simpleTypes" },\n                {\n                    "type": "array",\n                    "items": { "$ref": "#/$defs/simpleTypes" },\n                    "minItems": 1,\n                    "uniqueItems": true\n                }\n            ]\n        }\n    },\n    "$defs": {\n        "nonNegativeInteger": {\n            "type": "integer",\n            "minimum": 0\n        },\n        "nonNegativeIntegerDefault0": {\n            "$ref": "#/$defs/nonNegativeInteger",\n            "default": 0\n        },\n        "simpleTypes": {\n            "enum": [\n                "array",\n                "boolean",\n                "integer",\n                "null",\n                "number",\n                "object",\n                "string"\n            ]\n        },\n        "stringArray": {\n            "type": "array",\n            "items": { "type": "string" },\n            "uniqueItems": true,\n            "default": []\n        }\n    }\n}')),xa.defineVocabulary("https://json-schema.org/draft/2020-12/vocab/validation",{const:ua.const,dependentRequired:ua.dependentRequired,enum:ua.enum,exclusiveMaximum:ua.exclusiveMaximum,exclusiveMinimum:ua.exclusiveMinimum,maxItems:ua.maxItems,maxLength:ua.maxLength6,maxProperties:ua.maxProperties,maximum:ua.maximum,minItems:ua.minItems,minLength:ua.minLength6,minProperties:ua.minProperties,minimum:ua.minimum,multipleOf:ua.multipleOf,pattern:ua.pattern,required:ua.required,type:ua.type,uniqueItems:ua.uniqueItems}),wa.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/2020-12/meta/meta-data",\n    "$schema": "https://json-schema.org/draft/2020-12/schema",\n    "$vocabulary": {\n        "https://json-schema.org/draft/2020-12/vocab/meta-data": true\n    },\n    "$dynamicAnchor": "meta",\n\n    "title": "Meta-data vocabulary meta-schema",\n\n    "type": ["object", "boolean"],\n    "properties": {\n        "title": {\n            "type": "string"\n        },\n        "description": {\n            "type": "string"\n        },\n        "default": true,\n        "deprecated": {\n            "type": "boolean",\n            "default": false\n        },\n        "readOnly": {\n            "type": "boolean",\n            "default": false\n        },\n        "writeOnly": {\n            "type": "boolean",\n            "default": false\n        },\n        "examples": {\n            "type": "array",\n            "items": true\n        }\n    }\n}')),xa.defineVocabulary("https://json-schema.org/draft/2020-12/vocab/meta-data",{default:ua.metaData,deprecated:ua.metaData,description:ua.metaData,examples:ua.metaData,readOnly:ua.metaData,title:ua.metaData,writeOnly:ua.metaData}),wa.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/2020-12/meta/format-annotation",\n    "$schema": "https://json-schema.org/draft/2020-12/schema",\n    "$vocabulary": {\n        "https://json-schema.org/draft/2020-12/vocab/format-annotation": true\n    },\n    "$dynamicAnchor": "meta",\n\n    "title": "Format vocabulary meta-schema for annotation results",\n    "type": ["object", "boolean"],\n    "properties": {\n        "format": { "type": "string" }\n    }\n}')),xa.defineVocabulary("https://json-schema.org/draft/2020-12/vocab/format-annotation",{format:ua.metaData}),wa.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/2020-12/meta/format-assertion",\n    "$schema": "https://json-schema.org/draft/2020-12/schema",\n    "$vocabulary": {\n        "https://json-schema.org/draft/2020-12/vocab/format-assertion": true\n    },\n    "$dynamicAnchor": "meta",\n\n    "title": "Format vocabulary meta-schema for assertion results",\n    "type": ["object", "boolean"],\n    "properties": {\n        "format": { "type": "string" }\n    }\n}')),wa.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/2020-12/meta/content",\n    "$schema": "https://json-schema.org/draft/2020-12/schema",\n    "$vocabulary": {\n        "https://json-schema.org/draft/2020-12/vocab/content": true\n    },\n    "$dynamicAnchor": "meta",\n\n    "title": "Content vocabulary meta-schema",\n\n    "type": ["object", "boolean"],\n    "properties": {\n        "contentMediaType": { "type": "string" },\n        "contentEncoding": { "type": "string" },\n        "contentSchema": { "$dynamicRef": "#meta" }\n    }\n}')),xa.defineVocabulary("https://json-schema.org/draft/2020-12/vocab/content",{contentEncoding:ua.metaData,contentMediaType:ua.metaData,contentSchema:ua.metaData}),wa.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/2020-12/meta/unevaluated",\n    "$schema": "https://json-schema.org/draft/2020-12/schema",\n    "$vocabulary": {\n        "https://json-schema.org/draft/2020-12/vocab/unevaluated": true\n    },\n    "$dynamicAnchor": "meta",\n\n    "title": "Unevaluated applicator vocabulary meta-schema",\n    "type": ["object", "boolean"],\n    "properties": {\n        "unevaluatedItems": { "$dynamicRef": "#meta" },\n        "unevaluatedProperties": { "$dynamicRef": "#meta" }\n    }\n}')),xa.defineVocabulary("https://json-schema.org/draft/2020-12/vocab/unevaluated",{unevaluatedItems:ua.unevaluatedItems,unevaluatedProperties:ua.unevaluatedProperties});const{Core:Ea,Schema:Aa,InvalidSchemaError:Ca}=Xe;var Na={add:Ea.add,get:Aa.get,validate:Ea.validate,compile:Ea.compile,interpret:Ea.interpret,setMetaOutputFormat:Ea.setMetaOutputFormat,setShouldMetaValidate:Ea.setShouldMetaValidate,FLAG:Ea.FLAG,BASIC:Ea.BASIC,DETAILED:Ea.DETAILED,VERBOSE:Ea.VERBOSE,Keywords:ua,InvalidSchemaError:Ca},Ra=Na.add,Ta=Na.get,Da=Na.validate,ka=Na.compile,Ma=Na.interpret,qa=Na.setMetaOutputFormat,Va=Na.setShouldMetaValidate,La=Na.FLAG,Ja=Na.BASIC,_a=Na.DETAILED,Ua=Na.VERBOSE,za=Na.Keywords,Fa=Na.InvalidSchemaError;return e.BASIC=Ja,e.DETAILED=_a,e.FLAG=La,e.InvalidSchemaError=Fa,e.Keywords=za,e.VERBOSE=Ua,e.add=Ra,e.compile=ka,e.default=Na,e.get=Ta,e.interpret=Ma,e.setMetaOutputFormat=qa,e.setShouldMetaValidate=Va,e.validate=Da,Object.defineProperty(e,"__esModule",{value:!0}),e}({});
//# sourceMappingURL=json-schema-iife.min.js.map
