"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var e=function(e,n){return function t(){null==n&&(n=e.length);var r=[].slice.call(arguments);return r.length>=n?e.apply(this,r):function(){return t.apply(this,r.concat([].slice.call(arguments)))}}};var n="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:{};var t=function(e,n){return e(n={exports:{}},n.exports),n.exports}((function(e,t){var r,a;r="object"==typeof window&&window||n,a={},r.PubSub?(a=r.PubSub,console.warn("PubSub already loaded, using existing version")):(r.PubSub=a,function(e){var n={},t=-1;function r(e,n,t){try{e(n,t)}catch(e){setTimeout(function(e){return function(){throw e}}(e),0)}}function a(e,n,t){e(n,t)}function i(e,t,i,o){var s,c=n[t],m=o?a:r;if(Object.prototype.hasOwnProperty.call(n,t))for(s in c)Object.prototype.hasOwnProperty.call(c,s)&&m(c[s],e,i)}function o(e){var t=String(e);return Boolean(Object.prototype.hasOwnProperty.call(n,t)&&function(e){var n;for(n in e)if(Object.prototype.hasOwnProperty.call(e,n))return!0;return!1}(n[t]))}function s(e,n,t,r){var a=function(e,n,t){return function(){var r=String(e),a=r.lastIndexOf(".");for(i(e,e,n,t);-1!==a;)a=(r=r.substr(0,a)).lastIndexOf("."),i(e,r,n,t);i(e,"*",n,t)}}(e="symbol"==typeof e?e.toString():e,n,r);return!!function(e){for(var n=String(e),t=o(n)||o("*"),r=n.lastIndexOf(".");!t&&-1!==r;)r=(n=n.substr(0,r)).lastIndexOf("."),t=o(n);return t}(e)&&(!0===t?a():setTimeout(a,0),!0)}e.publish=function(n,t){return s(n,t,!1,e.immediateExceptions)},e.publishSync=function(n,t){return s(n,t,!0,e.immediateExceptions)},e.subscribe=function(e,r){if("function"!=typeof r)return!1;e="symbol"==typeof e?e.toString():e,Object.prototype.hasOwnProperty.call(n,e)||(n[e]={});var a="uid_"+String(++t);return n[e][a]=r,a},e.subscribeAll=function(n){return e.subscribe("*",n)},e.subscribeOnce=function(n,t){var r=e.subscribe(n,(function(){e.unsubscribe(r),t.apply(this,arguments)}));return e},e.clearAllSubscriptions=function(){n={}},e.clearSubscriptions=function(e){var t;for(t in n)Object.prototype.hasOwnProperty.call(n,t)&&0===t.indexOf(e)&&delete n[t]},e.countSubscriptions=function(e){var t,r,a=0;for(t in n)if(Object.prototype.hasOwnProperty.call(n,t)&&0===t.indexOf(e)){for(r in n[t])a++;break}return a},e.getSubscriptions=function(e){var t,r=[];for(t in n)Object.prototype.hasOwnProperty.call(n,t)&&0===t.indexOf(e)&&r.push(t);return r},e.unsubscribe=function(t){var r,a,i,o="string"==typeof t&&(Object.prototype.hasOwnProperty.call(n,t)||function(e){var t;for(t in n)if(Object.prototype.hasOwnProperty.call(n,t)&&0===t.indexOf(e))return!0;return!1}(t)),s=!o&&"string"==typeof t,c="function"==typeof t,m=!1;if(!o){for(r in n)if(Object.prototype.hasOwnProperty.call(n,r)){if(a=n[r],s&&a[t]){delete a[t],m=t;break}if(c)for(i in a)Object.prototype.hasOwnProperty.call(a,i)&&a[i]===t&&(delete a[i],m=!0)}return m}e.clearSubscriptions(t)}}(a)),void 0!==e&&e.exports&&(t=e.exports=a),t.PubSub=a,e.exports=t=a}));t.PubSub;var r=function(e,n){if(e=e.trim(),(n=n.trim()).startsWith("about:"))return n;const t=function(e){const n={host:"",path:"",query:"",protocol:""};let t=e,r=e.indexOf("//");n.protocol=t.substring(0,r),r+=2;const a=e.indexOf("/",r),i=e.indexOf("?"),o=e.indexOf("#");-1!==o&&(t=t.substring(0,o));if(-1!==i){const e=t.substring(i);n.query=e,t=t.substring(0,i)}if(-1!==a){const e=t.substring(0,a);n.host=e,t=t.substring(a),n.path=t}else n.host=t;return n}(e),r=function(e){const n={href:e,hash:"",query:"",netPath:!1,absolutePath:!1,relativePath:!1};if(o.test(e))return n.netPath=!0,n;"/"===e[0]?n.absolutePath=!0:""!==e&&(n.relativePath=!0);let t=e;const r=e.indexOf("?"),a=e.indexOf("#");if(-1!==a){const e=t.substring(a);n.hash=e,t=t.substring(0,a)}if(-1!==r){const e=t.substring(r);n.query=e,t=t.substring(0,r)}return n.path=t,n}(n);if(!t.protocol&&!r.netPath)throw new Error("Error, protocol is not specified");if(r.netPath)return r.href.startsWith("//")&&(r.href=t.protocol+r.href),function(e){const n=e.indexOf("//")+2,t=!e.includes("/",n),r=!e.includes("?",n),a=!e.includes("#",n);return t&&r&&a}(r.href)?a(r.href):r.href;if(r.absolutePath){const{path:e,query:n,hash:a}=r;return t.host+i(e)+n+a}if(r.relativePath){const{path:e,query:n,hash:a}=r;let o,s=t.path,c=t.host;return 0===e.length?o=s:(s=s.substring(0,s.lastIndexOf("/")),o=i(s+"/"+e)),c+=""!==o||n||a?o+n+a:"/",c}{const{host:e,path:n,query:i}=t;return n||i?e+n+i+r.hash:a(e)}};function a(e){return e+("/"===e[e.length-1]?"":"/")}function i(e){let n=e.split("/");""===n[0]&&(n=n.slice(1));let t=[];return n.forEach((e,r)=>{"."!==e&&(".."===e?t.pop():""===e&&r!==n.length-1||t.push(e))}),"/"+t.join("/")}const o=new RegExp("^([a-z][a-z0-9+.-]*:)?//","i");const s={null:e=>null===e,boolean:e=>"boolean"==typeof e,object:e=>"object"==typeof e&&!Array.isArray(e)&&null!==e,array:e=>Array.isArray(e),number:e=>"number"==typeof e,integer:e=>Number.isInteger(e),string:e=>"string"==typeof e},c=e=>{const n=e.indexOf("#"),t=-1===n?e.length:n,r=e.slice(0,t),a=e.slice(t+1);return[decodeURI(r),decodeURI(a)]},m=e=>{const n=RegExp(/^(.+):\/\//).exec(e);return n?n[1]:""};var p={jsonTypeOf:(e,n)=>s[n](e),splitUrl:c,safeResolveUrl:(e,n)=>{const t=r(e,n),a=c(e)[0];if(a&&"file"===m(t)&&"file"!==m(a))throw Error(`Can't access file '${t}' resource from network context '${e}'`);return t},pathRelative:(e,n)=>{if(e===n)return"";let t=1;const r=e.length-1,a=n.length-t,i=r<a?r:a;let o=-1,s=0;for(;s<i;s++){const r=e.charCodeAt(s+1);if(r!==n.charCodeAt(t+s))break;47===r&&(o=s)}if(a>i){if(47===n.charCodeAt(t+s))return n.slice(t+s+1);if(0===s)return n.slice(t+s)}r>i&&(47===e.charCodeAt(s+1)?o=s:0===i&&(o=0));let c="";for(s=o+2;s<=e.length;++s)s!==e.length&&47!==e.charCodeAt(s)||(c+=0===c.length?"..":"/..");return t+=o,c.length>0?`${c}${n.slice(t,n.length)}`:(47===n.charCodeAt(t)&&++t,n.slice(t,n.length))}};const l=e=>{if(e.length>0&&"/"!==e[0])throw Error("Invalid JSON Pointer");return e.split("/").slice(1).map(g)},u=(e,n,t,r)=>{if(0===e.length)return t;if(e.length>1){const a=e.shift();return{...n,[a]:u(e,$(n,a,r),t,h(a,r))}}if(Array.isArray(n)){const r=[...n];return r[b(n,e[0])]=t,r}return"object"==typeof n&&null!==n?{...n,[e[0]]:t}:$(n,e[0],r)},d=(e,n,t,r)=>{if(0!==e.length)if(1!==e.length||O(n)){const a=e.shift();d(e,$(n,a,r),t,h(a,r))}else{n[b(n,e[0])]=t}},f=(e,n,t)=>{if(0!=e.length){if(e.length>1){const r=e.shift(),a=$(n,r,t);return{...n,[r]:f(e,a,h(r,t))}}if(Array.isArray(n))return n.filter((n,t)=>t!=e[0]);if("object"==typeof n&&null!==n){const{[e[0]]:t,...r}=n;return r}return $(n,e[0],t)}},y=(e,n,t)=>{if(0!==e.length)if(e.length>1){const r=e.shift(),a=$(n,r,t);y(e,a,h(r,t))}else Array.isArray(n)?n.splice(e[0],1):"object"==typeof n&&null!==n?delete n[e[0]]:$(n,e[0],t)},h=e((e,n)=>n+"/"+v(e)),v=e=>e.toString().replace(/~/g,"~0").replace(/\//g,"~1"),g=e=>e.toString().replace(/~1/g,"/").replace(/~0/g,"~"),b=(e,n)=>Array.isArray(e)&&"-"===n?e.length:n,$=(e,n,t="")=>{if(void 0===e)throw TypeError(`Value at '${t}' is undefined and does not have property '${n}'`);if(null===e)throw TypeError(`Value at '${t}' is null and does not have property '${n}'`);if(O(e))throw TypeError(`Value at '${t}' is a ${typeof e} and does not have property '${n}'`);return e[b(e,n)]},O=e=>null===e||"object"!=typeof e;var I={nil:"",append:h,get:(e,n)=>{const t=l(e),r=e=>t.reduce(([e,n],t)=>[$(e,t,n),h(t,n)],[e,""])[0];return void 0===n?r:r(n)},set:(n,t,r)=>{const a=l(n),i=e((e,n)=>u(a,e,n,""));return void 0===t?i:i(t,r)},assign:(n,t,r)=>{const a=l(n),i=e((e,n)=>d(a,e,n,""));return void 0===t?i:i(t,r)},unset:(e,n)=>{const t=l(e),r=e=>f(t,e,"");return void 0===n?r:r(n)},remove:(e,n)=>{const t=l(e),r=e=>y(t,e,"");return void 0===n?r:r(n)}};I.nil,I.append,I.get,I.set,I.assign,I.unset,I.remove;const S=Symbol("$__value"),x=Symbol("$__href");var j={cons:(e,n)=>Object.freeze({[x]:e,[S]:n}),isReference:e=>e&&void 0!==e[x],href:e=>e[x],value:e=>e[S]};const{jsonTypeOf:w}=p,P=Object.freeze({id:"",pointer:"",instance:void 0,value:void 0}),E=e=>j.isReference(e.value)?j.value(e.value):e.value,A=e((e,n)=>w(E(e),n)),C=(e,n)=>Object.freeze({...n,pointer:I.append(e,n.pointer),value:E(n)[e]}),N=e((e,n)=>E(n).map((t,r,a,i)=>e(C(r,n),r,a,i))),R=e((e,n)=>E(n).map((e,t,r,a)=>C(t,n)).filter((n,t,r,a)=>e(n,t,r,a))),T=e((e,n,t)=>E(t).reduce((n,r,a)=>e(n,C(a,t),a),n)),D=e((e,n)=>E(n).every((t,r,a,i)=>e(C(r,n),r,a,i))),k=e((e,n)=>E(n).some((t,r,a,i)=>e(C(r,n),r,a,i)));var M={nil:P,cons:(e,n="")=>Object.freeze({...P,id:n,instance:e,value:e}),uri:e=>`${e.id}#${encodeURI(e.pointer)}`,value:E,has:(e,n)=>e in E(n),typeOf:A,step:C,entries:e=>Object.keys(E(e)).map(n=>[n,C(n,e)]),keys:e=>Object.keys(E(e)),map:N,filter:R,reduce:T,every:D,some:k,length:e=>E(e).length},q=/; *([!#$%&'*+.^_`|~0-9A-Za-z-]+) *= *("(?:[\u000b\u0020\u0021\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u000b\u0020-\u00ff])*"|[!#$%&'*+.^_`|~0-9A-Za-z-]+) */g,V=/^[\u000b\u0020-\u007e\u0080-\u00ff]+$/,L=/^[!#$%&'*+.^_`|~0-9A-Za-z-]+$/,J=/\\([\u000b\u0020-\u00ff])/g,_=/([\\"])/g,U=/^[!#$%&'*+.^_`|~0-9A-Za-z-]+\/[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;function z(e){var n=String(e);if(L.test(n))return n;if(n.length>0&&!V.test(n))throw new TypeError("invalid parameter value");return'"'+n.replace(_,"\\$1")+'"'}function F(e){this.parameters=Object.create(null),this.type=e}var K={format:function(e){if(!e||"object"!=typeof e)throw new TypeError("argument obj is required");var n=e.parameters,t=e.type;if(!t||!U.test(t))throw new TypeError("invalid type");var r=t;if(n&&"object"==typeof n)for(var a,i=Object.keys(n).sort(),o=0;o<i.length;o++){if(a=i[o],!L.test(a))throw new TypeError("invalid parameter name");r+="; "+a+"="+z(n[a])}return r},parse:function(e){if(!e)throw new TypeError("argument string is required");var n="object"==typeof e?function(e){var n;"function"==typeof e.getHeader?n=e.getHeader("content-type"):"object"==typeof e.headers&&(n=e.headers&&e.headers["content-type"]);if("string"!=typeof n)throw new TypeError("content-type header is missing from object");return n}(e):e;if("string"!=typeof n)throw new TypeError("argument string is required to be a string");var t=n.indexOf(";"),r=-1!==t?n.substr(0,t).trim():n.trim();if(!U.test(r))throw new TypeError("invalid media type");var a=new F(r.toLowerCase());if(-1!==t){var i,o,s;for(q.lastIndex=t;o=q.exec(n);){if(o.index!==t)throw new TypeError("invalid parameter format");t+=o[0].length,i=o[1].toLowerCase(),'"'===(s=o[2])[0]&&(s=s.substr(1,s.length-2).replace(J,"$1")),a.parameters[i]=s}if(t!==n.length)throw new TypeError("invalid parameter format")}return a}},B=async e=>Object.entries(await e),Z=e(async(e,n)=>(await n).map(e)),G=e(async(e,n,t)=>(await t).reduce(async(n,t)=>e(await n,t),n)),W=e(async(e,n,t={})=>G(async(n,t)=>await e(t)?n.concat([t]):n,[],n,t)),X=e(async(e,n)=>{const t=await Z(e,n);return(await Promise.all(t)).some(e=>e)}),H=e(async(e,n)=>{const t=await Z(e,n);return(await Promise.all(t)).every(e=>e)}),Q=e((e,n)=>e.reduce(async(e,n)=>n(await e),n)),Y={entries:B,map:Z,filter:W,reduce:G,some:X,every:H,pipeline:Q,all:e=>Promise.all(e),allValues:e=>Q([B,G(async(e,[n,t])=>(e[n]=await t,e),{})],e)};Y.entries,Y.map,Y.filter,Y.reduce,Y.some,Y.every,Y.pipeline,Y.all,Y.allValues;var ee=fetch;const{jsonTypeOf:ne,splitUrl:te,safeResolveUrl:re,pathRelative:ae}=p,ie={},oe={},se=(e,n)=>{const t=e in oe?oe[e]:e;if(t in ie)return ie[t][n]},ce={},me={},pe=(e,n="",t="")=>{e=JSON.parse(JSON.stringify(e));const r=te(e.$schema||t)[0];if(!r)throw Error("Couldn't determine schema version");delete e.$schema;const a=se(r,"baseToken"),i=se(r,"anchorToken"),o=te(n)[0];if(!o&&!te(e[a]||"")[0])throw Error("Couldn't determine an identifier for the schema");const s=re(o,e[a]||""),[c,m]=te(s);delete e[a],m&&a===i&&(e[i]=i!==a?encodeURI(m):"#"+encodeURI(m)),o&&(me[o]=c);const p={},l=se(r,"recursiveAnchorToken");let u;!0===e[l]&&(p[""]=c+"#",e[i]="",delete e[l]);const d=se(r,"vocabularyToken");ne(e[d],"object")?(oe[c]=r,u=e[d],delete e[d]):(oe[c]=r,u={[r]:!0});const f={"":""};return ce[c]={id:c,schemaVersion:r,schema:le(e,c,r,I.nil,f,p),anchors:f,dynamicAnchors:p,vocabulary:u,validated:!1},c},le=(e,n,t,r,a,i)=>{if(ne(e,"object")){const o="string"==typeof e.$schema?te(e.$schema)[0]:t,s=se(o,"embeddedToken"),c=se(o,"anchorToken");if("string"==typeof e[s]&&(s!==c||"#"!==e[s][0])){const r=re(n,e[s]);return e[s]=r,pe(e,r,t),j.cons(e[s],e)}const m=se(t,"anchorToken"),p=se(t,"dynamicAnchorToken");"string"==typeof e[p]&&(i[e[p]]=`${n}#${encodeURI(r)}`,a[e[p]]=r,delete e[p]);const l=se(t,"embeddedToken");if("string"==typeof e[m]){const n=m!==l?e[m]:e[m].slice(1);a[n]=r,delete e[m]}const u=se(t,"jrefToken");if("string"==typeof e[u])return j.cons(e[u],e);for(const o in e)e[o]=le(e[o],n,t,I.append(o,r),a,i);return e}return Array.isArray(e)?e.map((e,o)=>le(e,n,t,I.append(o,r),a,i)):e},ue=e=>ce[me[e]]||ce[e],de=Object.freeze({id:"",schemaVersion:void 0,vocabulary:{},pointer:I.nil,schema:void 0,value:void 0,anchors:{},dynamicAnchors:{},validated:!0}),fe=async(e,n=de)=>{const t=re(ve(n),e),[r,a]=te(t);if(!(e=>e in ce||e in me)(r)){const e=await ee(r,{headers:{Accept:"application/schema+json"}});if(e.status>=400)throw await e.text(),Error("Failed to retrieve schema with id: "+r);if(e.headers.has("content-type")){const n=K.parse(e.headers.get("content-type")).type;if("application/schema+json"!==n)throw Error(`${r} is not a schema. Found a document with media type: ${n}`)}pe(await e.json(),r)}const i=ue(r),o="/"!==a[0]?he(i,a):a,s=Object.freeze({...i,pointer:o,value:I.get(o,i.schema)});return ye(s)},ye=e=>j.isReference(e.value)?fe(j.href(e.value),e):e,he=(e,n)=>{if(!(n in e.anchors))throw Error(`No such anchor '${encodeURI(e.id)}#${encodeURI(n)}'`);return e.anchors[n]},ve=e=>`${e.id}#${encodeURI(e.pointer)}`,ge=e=>j.isReference(e.value)?j.value(e.value):e.value,be=(e,n)=>{const t=ue(n.id),r=Object.freeze({...n,pointer:I.append(e,n.pointer),value:ge(n)[e],validated:t.validated});return ye(r)},$e=e((e,n)=>Y.pipeline([ge,Y.map(async(t,r)=>e(await be(r,n),r)),Y.all],n)),Oe={parentId:"",parentDialect:"",includeEmbedded:!0},Ie=(e,n)=>{if(n.startsWith("file://")){const t=e.slice(7,e.lastIndexOf("/"));return""===e?"":ae(t,n.slice(7))}return n};var Se={setConfig:(e,n,t)=>{ie[e]||(ie[e]={}),ie[e][n]=t},getConfig:se,add:pe,get:fe,markValidated:e=>{ce[e].validated=!0},uri:ve,value:ge,getAnchorPointer:he,typeOf:(e,n)=>ne(ge(e),n),has:(e,n)=>e in ge(n),step:be,keys:e=>Object.keys(ge(e)),entries:e=>Y.pipeline([ge,Object.keys,Y.map(async n=>[n,await be(n,e)]),Y.all],e),map:$e,length:e=>ge(e).length,toSchema:(e,n={})=>{const t={...Oe,...n},r=JSON.parse(JSON.stringify(e.schema,(n,r)=>{if(!j.isReference(r))return r;const a=j.value(r),i=a.$schema||e.schemaVersion,o=se(i,"embeddedToken");return!t.includeEmbedded&&o in a?void 0:j.value(r)})),a=se(e.schemaVersion,"dynamicAnchorToken");Object.entries(e.dynamicAnchors).forEach(([e,n])=>{const t=te(n)[1];I.assign(t,r,{[a]:e,...I.get(t,r)})});const i=se(e.schemaVersion,"anchorToken");Object.entries(e.anchors).filter(([e])=>""!==e).forEach(([e,n])=>{I.assign(n,r,{[i]:e,...I.get(n,r)})});const o=se(e.schemaVersion,"baseToken"),s=Ie(t.parentId,e.id),c=t.parentDialect===e.schemaVersion?"":e.schemaVersion;return{...s&&{[o]:s},...c&&{$schema:c},...r}}};Se.setConfig,Se.getConfig,Se.add,Se.get,Se.markValidated,Se.uri,Se.value,Se.getAnchorPointer,Se.typeOf,Se.has,Se.step,Se.keys,Se.entries,Se.map,Se.length,Se.toSchema;class xe extends Error{constructor(e){super("Invalid Schema"),this.name=this.constructor.name,this.output=e}}var je=xe;const{splitUrl:we}=p,Pe="FLAG",Ee="BASIC",Ae="DETAILED",Ce="VERBOSE";let Ne=Ae,Re=!0;const Te=async e=>{const n={metaData:{}};return{ast:n,schemaUri:await _e(e,n)}},De=e(({ast:e,schemaUri:n},r,a=Pe)=>{if(![Pe,Ee,Ae,Ce].includes(a))throw Error(`The '${a}' error format is not supported`);const i=[],o=t.subscribe("result",ke(a,i));return ze(n,r,e,{}),t.unsubscribe(o),i[0]}),ke=(e,n)=>{const t=[];return(r,a)=>{if("result"===r){const{keyword:e,absoluteKeywordLocation:n,instanceLocation:r,valid:i}=a,o={keyword:e,absoluteKeywordLocation:n,instanceLocation:r,valid:i,errors:[]};t.push(o)}else if("result.start"===r)t.push(r);else if("result.end"===r){const r=t.pop();for(;"result.start"!==t[t.length-1];){const n=t.pop(),a=[n];e===Ee&&(a.push(...n.errors),delete n.errors),(e===Ce||e!==Pe&&!n.valid)&&r.errors.unshift(...a)}t[t.length-1]=r,n[0]=r}}},Me={},qe=e=>Me[e],Ve=e=>e in Me,Le={},Je={},_e=async(e,n)=>{if(e=await Ue(e),!Ve(e.schemaVersion+"#validate")){const n=await Se.get(e.schemaVersion);(Se.getConfig(n.id,"mandatoryVocabularies")||[]).forEach(e=>{if(!n.vocabulary[e])throw Error(`Vocabulary '${e}' must be explicitly declared and required`)}),Object.entries(n.vocabulary).forEach(([e,t])=>{if(e in Le)Object.entries(Le[e]).forEach(([e,t])=>{((e,n)=>{Me[e]={collectEvaluatedItems:(e,t,r,a,i)=>n.interpret(e,t,r,a,i)&&new Set,collectEvaluatedProperties:(e,t,r,a,i)=>n.interpret(e,t,r,a,i)&&[],...n}})(`${n.id}#${e}`,t)});else if(t)throw Error("Missing required vocabulary: "+e)})}if(Re&&!e.validated){if(Se.markValidated(e.id),!(e.schemaVersion in Je)){const n=await Se.get(e.schemaVersion),t=await Te(n);Je[n.id]=De(t)}const n=M.cons(e.schema,e.id),t=Je[e.schemaVersion](n,Ne);if(!t.valid)throw new je(t)}return e.id in n.metaData||(n.metaData[e.id]={id:e.id,dynamicAnchors:e.dynamicAnchors,anchors:e.anchors}),qe(e.schemaVersion+"#validate").compile(e,n)},Ue=async e=>Se.typeOf(e,"string")?Ue(await Se.get(Se.value(e),e)):e,ze=(e,n,t,r)=>{const a=Fe(e,t),i=we(e)[0];return qe(a).interpret(e,n,t,{...t.metaData[i].dynamicAnchors,...r})},Fe=(e,n)=>{if(!(e in n))throw Error("No schema found at "+e);return n[e][0]};var Ke={validate:async(e,n,t)=>{const r=await Te(e),a=(e,n)=>De(r,M.cons(e),n);return void 0===n?a:a(n,t)},compile:Te,interpret:De,setMetaOutputFormat:e=>{Ne=e},setShouldMetaValidate:e=>{Re=e},FLAG:Pe,BASIC:Ee,DETAILED:Ae,VERBOSE:Ce,add:(e,n="",t="")=>{const r=Se.add(e,n,t);delete Je[r]},getKeyword:qe,hasKeyword:Ve,defineVocabulary:(e,n)=>{Le[e]=n},compileSchema:_e,interpretSchema:ze,collectEvaluatedProperties:(e,n,t,r,a)=>{const i=Fe(e,t);return qe(i).collectEvaluatedProperties(e,n,t,r,a)},collectEvaluatedItems:(e,n,t,r,a)=>{const i=Fe(e,t);return qe(i).collectEvaluatedItems(e,n,t,r,a)}};var Be={compile:e=>Se.value(e),interpret:()=>!0};var Ze={compile:async(e,n)=>{const t=Se.uri(e);if(!(t in n)){n[t]=!1;const r=Se.value(e);if(!["object","boolean"].includes(typeof r))throw Error(`No schema found at '${Se.uri(e)}'`);n[t]=[e.schemaVersion+"#validate",Se.uri(e),"boolean"==typeof r?r:await Y.pipeline([Se.entries,Y.map(([n,t])=>[`${e.schemaVersion}#${n}`,t]),Y.filter(([n])=>Ke.hasKeyword(n)&&n!==e.schemaVersion+"#validate"),Y.map(async([t,r])=>{const a=await Ke.getKeyword(t).compile(r,n,e);return[t,Se.uri(r),a]}),Y.all],e)]}return t},interpret:(e,n,r,a)=>{const[i,o,s]=r[e];t.publishSync("result.start");const c="boolean"==typeof s?s:s.every(([e,i,o])=>{t.publishSync("result.start");const s=Ke.getKeyword(e).interpret(o,n,r,a);return t.publishSync("result",{keyword:e,absoluteKeywordLocation:i,instanceLocation:M.uri(n),valid:s,ast:o}),t.publishSync("result.end"),s});return t.publishSync("result",{keyword:i,absoluteKeywordLocation:o,instanceLocation:M.uri(n),valid:c,ast:e}),t.publishSync("result.end"),c},collectEvaluatedProperties:(e,n,t,r,a=!1)=>{const i=t[e][2];return"boolean"==typeof i?!!i&&[]:i.filter(([e])=>!a||!e.endsWith("#unevaluatedProperties")).reduce((e,[a,,i])=>{const o=e&&Ke.getKeyword(a).collectEvaluatedProperties(i,n,t,r);return!1!==o&&[...e,...o]},[])},collectEvaluatedItems:(e,n,t,r,a=!1)=>{const i=t[e][2];return"boolean"==typeof i?!!i&&new Set:i.filter(([e])=>!a||!e.endsWith("#unevaluatedItems")).reduce((e,[a,,i])=>{const o=!1!==e&&Ke.getKeyword(a).collectEvaluatedItems(i,n,t,r);return!1!==o&&new Set([...e,...o])},new Set)}},Ge={metaData:Be,validate:Ze},We={Core:Ke,Schema:Se,Instance:M,Reference:j,Keywords:Ge,InvalidSchemaError:je};const{Core:Xe,Schema:He,Instance:Qe}=We;var Ye={compile:async(e,n,t)=>{const r=await He.step("items",t),a=He.typeOf(r,"array")?He.length(r):Number.MAX_SAFE_INTEGER;return He.typeOf(e,"boolean")?[a,He.value(e)]:[a,await Xe.compileSchema(e,n)]},interpret:([e,n],t,r,a)=>!Qe.typeOf(t,"array")||("string"==typeof n?Qe.every((t,i)=>i<e||Xe.interpretSchema(n,t,r,a),t):Qe.every((t,r)=>r<e||n,t))};const{Core:en,Schema:nn,Instance:tn}=We,rn=([e,n],t,r,a)=>!tn.typeOf(t,"array")||tn.every((t,i)=>i<e||en.interpretSchema(n,t,r,a),t);var an={compile:async(e,n,t)=>{const r=await nn.step("items",t);return[nn.typeOf(r,"array")?nn.length(r):Number.MAX_SAFE_INTEGER,await en.compileSchema(e,n)]},interpret:rn,collectEvaluatedItems:(e,n,t,r)=>rn(e,n,t,r)&&new Set(tn.map((e,n)=>n,n))};const{Core:on,Schema:sn,Instance:cn}=We;var mn={compile:async(e,n,t)=>{const r=await sn.step("properties",t),a=sn.typeOf(r,"object")?sn.keys(r):[],i=await sn.step("patternProperties",t),o=sn.typeOf(i,"object")?sn.keys(i).map(e=>new RegExp(e)):[];return sn.typeOf(e,"boolean")?[a,o,sn.value(e)]:[a,o,await on.compileSchema(e,n)]},interpret:([e,n,t],r,a,i)=>{if(!cn.typeOf(r,"object"))return!0;const o=cn.entries(r).filter(([t])=>!e.includes(t)&&!n.some(e=>e.test(t)));return"string"==typeof t?o.every(([,e])=>on.interpretSchema(t,e,a,i)):0===o.length||t}};const{Core:pn,Schema:ln,Instance:un}=We,dn=([e,n,t],r,a,i)=>!un.typeOf(r,"object")||un.entries(r).filter(([t])=>!e.includes(t)&&!n.some(e=>e.test(t))).every(([,e])=>pn.interpretSchema(t,e,a,i));var fn={compile:async(e,n,t)=>{const r=await ln.step("properties",t),a=ln.typeOf(r,"object")?ln.keys(r):[],i=await ln.step("patternProperties",t);return[a,ln.typeOf(i,"object")?ln.keys(i).map(e=>new RegExp(e)):[],await pn.compileSchema(e,n)]},interpret:dn,collectEvaluatedProperties:(e,n,t,r)=>dn(e,n,t,r)&&[new RegExp("")]};const{Core:yn,Schema:hn}=We;var vn={compile:(e,n)=>Y.pipeline([hn.map(async e=>yn.compileSchema(await e,n)),Y.all],e),interpret:(e,n,t,r)=>e.every(e=>yn.interpretSchema(e,n,t,r)),collectEvaluatedProperties:(e,n,t,r)=>e.reduce((e,a)=>{const i=e&&yn.collectEvaluatedProperties(a,n,t,r);return!1!==i&&[...e,...i]},[]),collectEvaluatedItems:(e,n,t,r)=>e.reduce((e,a)=>{const i=!1!==e&&yn.collectEvaluatedItems(a,n,t,r);return!1!==i&&new Set([...e,...i])},new Set)};const{Core:gn,Schema:bn}=We;var $n={compile:(e,n)=>Y.pipeline([bn.map(async e=>gn.compileSchema(await e,n)),Y.all],e),interpret:(e,n,t,r)=>e.filter(e=>gn.interpretSchema(e,n,t,r)).length>0,collectEvaluatedProperties:(e,n,t,r)=>e.reduce((e,a)=>{const i=gn.collectEvaluatedProperties(a,n,t,r);return!1!==i?[...e||[],...i]:e},!1),collectEvaluatedItems:(e,n,t,r)=>e.reduce((e,a)=>{const i=gn.collectEvaluatedItems(a,n,t,r);return!1!==i?new Set([...e||[],...i]):e},!1)},On=Object.keys,In=JSON.stringify;var Sn=function(e){return""+function e(n,t){var r,a,i,o,s,c,m;if("string"===(m=typeof n))return In(n);if(!0===n)return"true";if(!1===n)return"false";if(null===n)return"null";if(n instanceof Array){for(i="[",a=n.length-1,r=0;r<a;r++)i+=e(n[r],!1)+",";return a>-1&&(i+=e(n[r],!1)),i+"]"}if(n instanceof Object){if("function"==typeof n.toJSON)return e(n.toJSON(),t);for(a=(o=On(n).sort()).length,i="",r=0;r<a;)void 0!==(c=e(n[s=o[r]],!0))&&(r&&""!==i&&(i+=","),i+=In(s)+":"+c),r++;return"{"+i+"}"}switch(m){case"function":case"undefined":return t?void 0:null;default:return isFinite(n)?n:null}}(e,!1)};const{Schema:xn,Instance:jn}=We;var wn={compile:e=>Sn(xn.value(e)),interpret:(e,n)=>Sn(jn.value(n))===e};const{Core:Pn,Instance:En}=We;var An={compile:(e,n)=>Pn.compileSchema(e,n),interpret:(e,n,t,r)=>!En.typeOf(n,"array")||En.some(n=>Pn.interpretSchema(e,n,t,r),n)};const{Core:Cn,Schema:Nn,Instance:Rn}=We,Tn=({contains:e,minContains:n,maxContains:t},r,a,i)=>{if(!Rn.typeOf(r,"array"))return!0;const o=Rn.reduce((n,t)=>Cn.interpretSchema(e,t,a,i)?n+1:n,0,r);return o>=n&&o<=t};var Dn={compile:async(e,n,t)=>{const r=await Cn.compileSchema(e,n),a=await Nn.step("minContains",t),i=Nn.typeOf(a,"number")?Nn.value(a):1,o=await Nn.step("maxContains",t);return{contains:r,minContains:i,maxContains:Nn.typeOf(o,"number")?Nn.value(o):Number.MAX_SAFE_INTEGER}},interpret:Tn,collectEvaluatedItems:(e,n,t,r)=>Tn(e,n,t,r)&&Rn.reduce((n,a,i)=>Cn.interpretSchema(e.contains,a,t,r)?n.add(i):n,new Set,n)};const{Core:kn,Schema:Mn}=We;var qn={compile:async(e,n)=>{await Y.pipeline([Mn.entries,Y.map(([,e])=>kn.compileSchema(e,n)),Y.all],e)},interpret:()=>!0};const{Core:Vn,Schema:Ln,Instance:Jn}=We;var _n={compile:(e,n)=>Y.pipeline([Ln.entries,Y.map(async([e,t])=>[e,Ln.typeOf(t,"array")?Ln.value(t):await Vn.compileSchema(t,n)]),Y.all],e),interpret:(e,n,t,r)=>{const a=Jn.value(n);return!Jn.typeOf(n,"object")||e.every(([e,i])=>!(e in a)||(Array.isArray(i)?i.every(e=>e in a):Vn.interpretSchema(i,n,t,r)))}};const{Schema:Un,Instance:zn}=We;var Fn={compile:e=>Y.pipeline([Un.entries,Y.map(([e,n])=>[e,Un.value(n)]),Y.all],e),interpret:(e,n)=>{const t=zn.value(n);return!zn.typeOf(n,"object")||e.every(([e,n])=>!(e in t)||n.every(e=>e in t))}};const{Core:Kn,Schema:Bn,Instance:Zn}=We;var Gn={compile:(e,n)=>Y.pipeline([Bn.entries,Y.map(async([e,t])=>[e,await Kn.compileSchema(t,n)]),Y.all],e),interpret:(e,n,t,r)=>{const a=Zn.value(n);return!Zn.typeOf(n,"object")||e.every(([e,i])=>!(e in a)||Kn.interpretSchema(i,n,t,r))},collectEvaluatedProperties:(e,n,t,r)=>e.reduce((e,[a,i])=>{if(!e||!Zn.has(a,n))return e;const o=Kn.collectEvaluatedProperties(i,n,t,r);return!1!==o&&e.concat(o)},[])};const{Schema:Wn,Instance:Xn}=We;var Hn={compile:e=>Wn.value(e).map(Sn),interpret:(e,n)=>e.some(e=>Sn(Xn.value(n))===e)};const{Schema:Qn,Instance:Yn}=We;var et={compile:async e=>Qn.value(e),interpret:(e,n)=>!Yn.typeOf(n,"number")||Yn.value(n)<e};const{Schema:nt,Instance:tt}=We;var rt={compile:async e=>nt.value(e),interpret:(e,n)=>!tt.typeOf(n,"number")||tt.value(n)>e};const{Core:at}=We;var it={compile:(e,n)=>at.compileSchema(e,n),interpret:(e,n,t,r)=>(at.interpretSchema(e,n,t,r),!0),collectEvaluatedProperties:(e,n,t,r)=>at.collectEvaluatedProperties(e,n,t,r)||[],collectEvaluatedItems:(e,n,t,r)=>at.collectEvaluatedItems(e,n,t,r)||new Set};const{Core:ot,Schema:st}=We,ct=(e,n,t,r)=>{const a=t[e][2];return"boolean"==typeof a?a:a.every(([e,,a])=>ot.getKeyword(e).interpret(a,n,t,r))};var mt={compile:async(e,n,t)=>{if(st.has("if",t)){const r=await st.step("if",t);return[await ot.compileSchema(r,n),await ot.compileSchema(e,n)]}return[]},interpret:([e,n],t,r,a)=>void 0===e||!ct(e,t,r,a)||ot.interpretSchema(n,t,r,a),collectEvaluatedProperties:([e,n],t,r,a)=>void 0!==e&&ct(e,t,r,a)?ot.collectEvaluatedProperties(n,t,r,a):[],collectEvaluatedItems:([e,n],t,r,a)=>void 0!==e&&ct(e,t,r,a)?ot.collectEvaluatedItems(n,t,r,a):new Set};const{Core:pt,Schema:lt}=We,ut=(e,n,t,r)=>{const a=t[e][2];return"boolean"==typeof a?a:a.every(([e,,a])=>pt.getKeyword(e).interpret(a,n,t,r))};var dt={compile:async(e,n,t)=>{if(lt.has("if",t)){const r=await lt.step("if",t);return[await pt.compileSchema(r,n),await pt.compileSchema(e,n)]}return[]},interpret:([e,n],t,r,a)=>void 0===e||ut(e,t,r,a)||pt.interpretSchema(n,t,r,a),collectEvaluatedProperties:([e,n],t,r,a)=>void 0===e||ut(e,t,r,a)?[]:pt.collectEvaluatedProperties(n,t,r,a),collectEvaluatedItems:([e,n],t,r,a)=>void 0===e||ut(e,t,r,a)?new Set:pt.collectEvaluatedItems(n,t,r,a)};const{Core:ft,Schema:yt,Instance:ht}=We,vt=(e,n,t,r)=>!ht.typeOf(n,"array")||("string"==typeof e?ht.every(n=>ft.interpretSchema(e,n,t,r),n):ht.every((n,a)=>!(a in e)||ft.interpretSchema(e[a],n,t,r),n));var gt={compile:async(e,n)=>{if(yt.typeOf(e,"array")){const t=await yt.map(e=>ft.compileSchema(e,n),e);return Promise.all(t)}return ft.compileSchema(e,n)},interpret:vt,collectEvaluatedItems:(e,n,t,r)=>vt(e,n,t,r)&&("string"==typeof e?new Set(ht.map((e,n)=>n,n)):new Set(e.map((e,n)=>n)))};const{Core:bt,Schema:$t,Instance:Ot}=We,It=([e,n],t,r,a)=>!Ot.typeOf(t,"array")||Ot.every((t,i)=>i<e||bt.interpretSchema(n,t,r,a),t);var St={compile:async(e,n,t)=>{const r=await $t.step("prefixItems",t);return[$t.typeOf(r,"array")?$t.length(r):0,await bt.compileSchema(e,n)]},interpret:It,collectEvaluatedItems:(e,n,t,r)=>It(e,n,t,r)&&new Set(Ot.map((e,n)=>n,n))};const{Schema:xt,Instance:jt}=We;var wt={compile:e=>xt.value(e),interpret:(e,n)=>!jt.typeOf(n,"array")||jt.length(n)<=e};const{Schema:Pt,Instance:Et}=We;var At={compile:e=>Pt.value(e),interpret:(e,n)=>!Et.typeOf(n,"string")||Et.length(n)<=e};const{Schema:Ct,Instance:Nt}=We;var Rt={compile:e=>Ct.value(e),interpret:(e,n)=>!Nt.typeOf(n,"string")||[...Nt.value(n)].length<=e};const{Schema:Tt,Instance:Dt}=We;var kt={compile:e=>Tt.value(e),interpret:(e,n)=>!Dt.typeOf(n,"object")||Dt.keys(n).length<=e};const{Schema:Mt,Instance:qt}=We;var Vt={compile:async(e,n,t)=>{const r=await Mt.step("exclusiveMaximum",t),a=Mt.value(r);return[Mt.value(e),a]},interpret:([e,n],t)=>{if(!qt.typeOf(t,"number"))return!0;const r=qt.value(t);return n?r<e:r<=e}};const{Schema:Lt,Instance:Jt}=We;var _t={compile:async e=>Lt.value(e),interpret:(e,n)=>!Jt.typeOf(n,"number")||Jt.value(n)<=e};const{Schema:Ut,Instance:zt}=We;var Ft={compile:e=>Ut.value(e),interpret:(e,n)=>!zt.typeOf(n,"array")||zt.length(n)>=e};const{Schema:Kt,Instance:Bt}=We;var Zt={compile:e=>Kt.value(e),interpret:(e,n)=>!Bt.typeOf(n,"string")||Bt.length(n)>=e};const{Schema:Gt,Instance:Wt}=We;var Xt={compile:e=>Gt.value(e),interpret:(e,n)=>!Wt.typeOf(n,"string")||[...Wt.value(n)].length>=e};const{Schema:Ht,Instance:Qt}=We;var Yt={compile:e=>Ht.value(e),interpret:(e,n)=>!Qt.typeOf(n,"object")||Qt.keys(n).length>=e};const{Schema:er,Instance:nr}=We;var tr={compile:async(e,n,t)=>{const r=await er.step("exclusiveMinimum",t),a=er.value(r);return[er.value(e),a]},interpret:([e,n],t)=>{if(!nr.typeOf(t,"number"))return!0;const r=nr.value(t);return n?r>e:r>=e}};const{Schema:rr,Instance:ar}=We;var ir={compile:async e=>rr.value(e),interpret:(e,n)=>!ar.typeOf(n,"number")||ar.value(n)>=e};const{Schema:or,Instance:sr}=We,cr=(e,n)=>Math.abs(e-n)<1.1920929e-7;var mr={compile:e=>or.value(e),interpret:(e,n)=>{if(!sr.typeOf(n,"number"))return!0;const t=sr.value(n)%e;return cr(0,t)||cr(e,t)}};const{Core:pr}=We;var lr={compile:pr.compileSchema,interpret:(e,n,t,r)=>!pr.interpretSchema(e,n,t,r)};const{Core:ur,Schema:dr}=We;var fr={compile:async(e,n)=>{const t=await dr.map(e=>ur.compileSchema(e,n),e);return Promise.all(t)},interpret:(e,n,t,r)=>{let a=0;for(const i of e)if(ur.interpretSchema(i,n,t,r)&&a++,a>1)break;return 1===a},collectEvaluatedProperties:(e,n,t,r)=>{let a=0;return e.reduce((e,i)=>{if(a>1)return!1;const o=ur.collectEvaluatedProperties(i,n,t,r);return o?0==a++&&o:e},!1)},collectEvaluatedItems:(e,n,t,r)=>{let a=0;return e.reduce((e,i)=>{if(a>1)return!1;const o=ur.collectEvaluatedItems(i,n,t,r);return o?0==a++&&o:e},!1)}};const{Schema:yr,Instance:hr}=We;var vr={compile:e=>new RegExp(yr.value(e),"u"),interpret:(e,n)=>!hr.typeOf(n,"string")||e.test(hr.value(n))};const{Core:gr,Schema:br,Instance:$r}=We,Or=(e,n,t,r)=>!$r.typeOf(n,"object")||e.every(([e,a])=>$r.entries(n).filter(([n])=>e.test(n)).every(([,e])=>gr.interpretSchema(a,e,t,r)));var Ir={compile:(e,n)=>Y.pipeline([br.entries,Y.map(async([e,t])=>[new RegExp(e,"u"),await gr.compileSchema(t,n)]),Y.all],e),interpret:Or,collectEvaluatedProperties:(e,n,t,r)=>Or(e,n,t,r)&&e.map(([e])=>e)};var Sr={isObject:e=>"object"==typeof e&&!Array.isArray(e)&&null!==e,escapeRegExp:e=>e.replace(/[.*+\-?^${}()|[\]\\]/g,"\\$&"),splitUrl:e=>{const n=e.indexOf("#"),t=-1===n?e.length:n,r=e.slice(0,t),a=e.slice(t+1);return[decodeURI(r),decodeURI(a)]}};const{Core:xr,Schema:jr,Instance:wr}=We,{escapeRegExp:Pr}=Sr,Er=(e,n,t,r)=>!wr.typeOf(n,"object")||wr.entries(n).filter(([n])=>n in e).every(([n,a])=>xr.interpretSchema(e[n],a,t,r));var Ar={compile:(e,n)=>Y.pipeline([jr.entries,Y.reduce(async(e,[t,r])=>(e[t]=await xr.compileSchema(r,n),e),Object.create(null))],e),interpret:Er,collectEvaluatedProperties:(e,n,t,r)=>Er(e,n,t,r)&&Object.keys(e).map(e=>new RegExp(`^${Pr(e)}$`))};const{Core:Cr,Instance:Nr}=We;var Rr={compile:(e,n)=>Cr.compileSchema(e,n),interpret:(e,n,t,r)=>!Nr.typeOf(n,"object")||Nr.keys(n).every(n=>Cr.interpretSchema(e,Nr.cons(n),t,r))};const{Core:Tr,Schema:Dr}=We,{splitUrl:kr}=Sr;var Mr={compile:async(e,n)=>{const[,t]=kr(Dr.value(e)),r=await Dr.get(Dr.value(e),e);return await Tr.compileSchema(r,n),[r.id,t]},interpret:([e,n],t,r,a)=>{if(n in r.metaData[e].dynamicAnchors)return Tr.interpretSchema(a[n],t,r,a);{const i=Dr.getAnchorPointer(r.metaData[e],n);return Tr.interpretSchema(`${e}#${encodeURI(i)}`,t,r,a)}},collectEvaluatedProperties:Tr.collectEvaluatedProperties,collectEvaluatedItems:Tr.collectEvaluatedItems};const{Core:qr,Schema:Vr}=We;var Lr={compile:async(e,n)=>{const t=await Vr.get(Vr.value(e),e);return qr.compileSchema(t,n)},interpret:qr.interpretSchema,collectEvaluatedProperties:qr.collectEvaluatedProperties,collectEvaluatedItems:qr.collectEvaluatedItems};const{Schema:Jr,Instance:_r}=We;var Ur={compile:e=>Jr.value(e),interpret:(e,n)=>!_r.typeOf(n,"object")||e.every(e=>Object.prototype.hasOwnProperty.call(_r.value(n),e))};const{Core:zr,Schema:Fr,Instance:Kr}=We,Br=(e,n,t,r)=>!Kr.typeOf(n,"array")||Kr.every((n,a)=>!(a in e)||zr.interpretSchema(e[a],n,t,r),n);var Zr={compile:(e,n)=>Y.pipeline([Fr.map(e=>zr.compileSchema(e,n)),Y.all],e),interpret:Br,collectEvaluatedItems:(e,n,t,r)=>Br(e,n,t,r)&&new Set(e.map((e,n)=>n))};const{Schema:Gr,Instance:Wr}=We;var Xr={compile:e=>Gr.value(e),interpret:(e,n)=>"string"==typeof e?Wr.typeOf(n,e):e.some(Wr.typeOf(n))};const{Core:Hr,Schema:Qr,Instance:Yr}=We,ea=([e,n],t,r,a)=>{if(!Yr.typeOf(t,"array"))return!0;const i=Hr.collectEvaluatedItems(e,t,r,a,!0);return!1===i||Yr.every((e,o)=>i.has(o)||Hr.interpretSchema(n,Yr.step(o,t),r,a),t)};var na={compile:async(e,n,t)=>[Qr.uri(t),await Hr.compileSchema(e,n)],interpret:ea,collectEvaluatedItems:(e,n,t,r)=>ea(e,n,t,r)&&new Set(Yr.map((e,n)=>n,n))};const{Core:ta,Schema:ra,Instance:aa}=We,ia=([e,n],t,r,a)=>{if(!aa.typeOf(t,"object"))return!0;const i=ta.collectEvaluatedProperties(e,t,r,a,!0);return!i||aa.entries(t).filter(([e])=>!i.some(n=>e.match(n))).every(([,e])=>ta.interpretSchema(n,e,r,a))};var oa={compile:async(e,n,t)=>[ra.uri(t),await ta.compileSchema(e,n)],interpret:ia,collectEvaluatedProperties:(e,n,t,r)=>ia(e,n,t,r)&&[new RegExp("")]};const{Schema:sa,Instance:ca}=We;var ma={compile:e=>sa.value(e),interpret:(e,n)=>{if(!ca.typeOf(n,"array")||!1===e)return!0;const t=ca.map(e=>Sn(ca.value(e)),n);return new Set(t).size===t.length}};const{Keywords:pa}=We;var la={additionalItems:Ye,additionalItems6:an,additionalProperties:mn,additionalProperties6:fn,allOf:vn,anyOf:$n,const:wn,contains:An,containsMinContainsMaxContains:Dn,definitions:qn,dependencies:_n,dependentRequired:Fn,dependentSchemas:Gn,enum:Hn,exclusiveMaximum:et,exclusiveMinimum:rt,if:it,then:mt,else:dt,items:gt,items202012:St,maxItems:wt,maxLength:At,maxLength6:Rt,maxProperties:kt,maximumExclusiveMaximum:Vt,maximum:_t,metaData:pa.metaData,minItems:Ft,minLength:Zt,minLength6:Xt,minProperties:Yt,minimumExclusiveMinimum:tr,minimum:ir,multipleOf:mr,not:lr,oneOf:fr,pattern:vr,patternProperties:Ir,properties:Ar,propertyNames:Rr,dynamicRef:Mr,ref:Lr,required:Ur,tupleItems:Zr,type:Xr,unevaluatedItems:na,unevaluatedProperties:oa,uniqueItems:ma,validate:pa.validate};const{Core:ua,Schema:da}=We,fa="http://json-schema.org/draft-04/schema";da.setConfig(fa,"baseToken","id"),da.setConfig(fa,"embeddedToken","id"),da.setConfig(fa,"anchorToken","id"),da.setConfig(fa,"jrefToken","$ref"),da.add(JSON.parse('{\n    "id": "http://json-schema.org/draft-04/schema#",\n    "$schema": "http://json-schema.org/draft-04/schema#",\n    "description": "Core schema meta-schema",\n    "definitions": {\n        "schemaArray": {\n            "type": "array",\n            "minItems": 1,\n            "items": { "$ref": "#" }\n        },\n        "positiveInteger": {\n            "type": "integer",\n            "minimum": 0\n        },\n        "positiveIntegerDefault0": {\n            "allOf": [ { "$ref": "#/definitions/positiveInteger" }, { "default": 0 } ]\n        },\n        "simpleTypes": {\n            "enum": [ "array", "boolean", "integer", "null", "number", "object", "string" ]\n        },\n        "stringArray": {\n            "type": "array",\n            "items": { "type": "string" },\n            "minItems": 1,\n            "uniqueItems": true\n        }\n    },\n    "type": "object",\n    "properties": {\n        "id": {\n            "type": "string"\n        },\n        "$schema": {\n            "type": "string"\n        },\n        "title": {\n            "type": "string"\n        },\n        "description": {\n            "type": "string"\n        },\n        "default": {},\n        "multipleOf": {\n            "type": "number",\n            "minimum": 0,\n            "exclusiveMinimum": true\n        },\n        "maximum": {\n            "type": "number"\n        },\n        "exclusiveMaximum": {\n            "type": "boolean",\n            "default": false\n        },\n        "minimum": {\n            "type": "number"\n        },\n        "exclusiveMinimum": {\n            "type": "boolean",\n            "default": false\n        },\n        "maxLength": { "$ref": "#/definitions/positiveInteger" },\n        "minLength": { "$ref": "#/definitions/positiveIntegerDefault0" },\n        "pattern": {\n            "type": "string",\n            "format": "regex"\n        },\n        "additionalItems": {\n            "anyOf": [\n                { "type": "boolean" },\n                { "$ref": "#" }\n            ],\n            "default": {}\n        },\n        "items": {\n            "anyOf": [\n                { "$ref": "#" },\n                { "$ref": "#/definitions/schemaArray" }\n            ],\n            "default": {}\n        },\n        "maxItems": { "$ref": "#/definitions/positiveInteger" },\n        "minItems": { "$ref": "#/definitions/positiveIntegerDefault0" },\n        "uniqueItems": {\n            "type": "boolean",\n            "default": false\n        },\n        "maxProperties": { "$ref": "#/definitions/positiveInteger" },\n        "minProperties": { "$ref": "#/definitions/positiveIntegerDefault0" },\n        "required": { "$ref": "#/definitions/stringArray" },\n        "additionalProperties": {\n            "anyOf": [\n                { "type": "boolean" },\n                { "$ref": "#" }\n            ],\n            "default": {}\n        },\n        "definitions": {\n            "type": "object",\n            "additionalProperties": { "$ref": "#" },\n            "default": {}\n        },\n        "properties": {\n            "type": "object",\n            "additionalProperties": { "$ref": "#" },\n            "default": {}\n        },\n        "patternProperties": {\n            "type": "object",\n            "additionalProperties": { "$ref": "#" },\n            "default": {}\n        },\n        "dependencies": {\n            "type": "object",\n            "additionalProperties": {\n                "anyOf": [\n                    { "$ref": "#" },\n                    { "$ref": "#/definitions/stringArray" }\n                ]\n            }\n        },\n        "enum": {\n            "type": "array",\n            "minItems": 1,\n            "uniqueItems": true\n        },\n        "type": {\n            "anyOf": [\n                { "$ref": "#/definitions/simpleTypes" },\n                {\n                    "type": "array",\n                    "items": { "$ref": "#/definitions/simpleTypes" },\n                    "minItems": 1,\n                    "uniqueItems": true\n                }\n            ]\n        },\n        "format": { "type": "string" },\n        "allOf": { "$ref": "#/definitions/schemaArray" },\n        "anyOf": { "$ref": "#/definitions/schemaArray" },\n        "oneOf": { "$ref": "#/definitions/schemaArray" },\n        "not": { "$ref": "#" }\n    },\n    "dependencies": {\n        "exclusiveMaximum": [ "maximum" ],\n        "exclusiveMinimum": [ "minimum" ]\n    },\n    "default": {}\n}')),ua.defineVocabulary(fa,{validate:la.validate,additionalItems:la.additionalItems,additionalProperties:la.additionalProperties,allOf:la.allOf,anyOf:la.anyOf,default:la.metaData,definitions:la.definitions,dependencies:la.dependencies,description:la.metaData,enum:la.enum,format:la.metaData,items:la.items,maxItems:la.maxItems,maxLength:la.maxLength,maxProperties:la.maxProperties,maximum:la.maximumExclusiveMaximum,minItems:la.minItems,minLength:la.minLength,minProperties:la.minProperties,minimum:la.minimumExclusiveMinimum,multipleOf:la.multipleOf,not:la.not,oneOf:la.oneOf,pattern:la.pattern,patternProperties:la.patternProperties,properties:la.properties,required:la.required,title:la.metaData,type:la.type,uniqueItems:la.uniqueItems});const{Core:ya,Schema:ha}=We,va="http://json-schema.org/draft-06/schema";ha.setConfig(va,"baseToken","$id"),ha.setConfig(va,"embeddedToken","$id"),ha.setConfig(va,"anchorToken","$id"),ha.setConfig(va,"jrefToken","$ref"),ha.add(JSON.parse('{\n    "$schema": "http://json-schema.org/draft-06/schema#",\n    "$id": "http://json-schema.org/draft-06/schema#",\n    "title": "Core schema meta-schema",\n    "definitions": {\n        "schemaArray": {\n            "type": "array",\n            "minItems": 1,\n            "items": { "$ref": "#" }\n        },\n        "nonNegativeInteger": {\n            "type": "integer",\n            "minimum": 0\n        },\n        "nonNegativeIntegerDefault0": {\n            "allOf": [\n                { "$ref": "#/definitions/nonNegativeInteger" },\n                { "default": 0 }\n            ]\n        },\n        "simpleTypes": {\n            "enum": [\n                "array",\n                "boolean",\n                "integer",\n                "null",\n                "number",\n                "object",\n                "string"\n            ]\n        },\n        "stringArray": {\n            "type": "array",\n            "items": { "type": "string" },\n            "uniqueItems": true,\n            "default": []\n        }\n    },\n    "type": ["object", "boolean"],\n    "properties": {\n        "$id": {\n            "type": "string",\n            "format": "uri-reference"\n        },\n        "$schema": {\n            "type": "string",\n            "format": "uri"\n        },\n        "$ref": {\n            "type": "string",\n            "format": "uri-reference"\n        },\n        "title": {\n            "type": "string"\n        },\n        "description": {\n            "type": "string"\n        },\n        "default": {},\n        "examples": {\n            "type": "array",\n            "items": {}\n        },\n        "multipleOf": {\n            "type": "number",\n            "exclusiveMinimum": 0\n        },\n        "maximum": {\n            "type": "number"\n        },\n        "exclusiveMaximum": {\n            "type": "number"\n        },\n        "minimum": {\n            "type": "number"\n        },\n        "exclusiveMinimum": {\n            "type": "number"\n        },\n        "maxLength": { "$ref": "#/definitions/nonNegativeInteger" },\n        "minLength": { "$ref": "#/definitions/nonNegativeIntegerDefault0" },\n        "pattern": {\n            "type": "string",\n            "format": "regex"\n        },\n        "additionalItems": { "$ref": "#" },\n        "items": {\n            "anyOf": [\n                { "$ref": "#" },\n                { "$ref": "#/definitions/schemaArray" }\n            ],\n            "default": {}\n        },\n        "maxItems": { "$ref": "#/definitions/nonNegativeInteger" },\n        "minItems": { "$ref": "#/definitions/nonNegativeIntegerDefault0" },\n        "uniqueItems": {\n            "type": "boolean",\n            "default": false\n        },\n        "contains": { "$ref": "#" },\n        "maxProperties": { "$ref": "#/definitions/nonNegativeInteger" },\n        "minProperties": { "$ref": "#/definitions/nonNegativeIntegerDefault0" },\n        "required": { "$ref": "#/definitions/stringArray" },\n        "additionalProperties": { "$ref": "#" },\n        "definitions": {\n            "type": "object",\n            "additionalProperties": { "$ref": "#" },\n            "default": {}\n        },\n        "properties": {\n            "type": "object",\n            "additionalProperties": { "$ref": "#" },\n            "default": {}\n        },\n        "patternProperties": {\n            "type": "object",\n            "additionalProperties": { "$ref": "#" },\n            "default": {}\n        },\n        "dependencies": {\n            "type": "object",\n            "additionalProperties": {\n                "anyOf": [\n                    { "$ref": "#" },\n                    { "$ref": "#/definitions/stringArray" }\n                ]\n            }\n        },\n        "propertyNames": { "$ref": "#" },\n        "const": {},\n        "enum": {\n            "type": "array",\n            "minItems": 1,\n            "uniqueItems": true\n        },\n        "type": {\n            "anyOf": [\n                { "$ref": "#/definitions/simpleTypes" },\n                {\n                    "type": "array",\n                    "items": { "$ref": "#/definitions/simpleTypes" },\n                    "minItems": 1,\n                    "uniqueItems": true\n                }\n            ]\n        },\n        "format": { "type": "string" },\n        "allOf": { "$ref": "#/definitions/schemaArray" },\n        "anyOf": { "$ref": "#/definitions/schemaArray" },\n        "oneOf": { "$ref": "#/definitions/schemaArray" },\n        "not": { "$ref": "#" }\n    },\n    "default": {}\n}')),ya.defineVocabulary(va,{validate:la.validate,additionalItems:la.additionalItems6,additionalProperties:la.additionalProperties6,allOf:la.allOf,anyOf:la.anyOf,const:la.const,contains:la.contains,default:la.metaData,definitions:la.definitions,dependencies:la.dependencies,description:la.metaData,enum:la.enum,examples:la.metaData,exclusiveMaximum:la.exclusiveMaximum,exclusiveMinimum:la.exclusiveMinimum,format:la.metaData,items:la.items,maxItems:la.maxItems,maxLength:la.maxLength6,maxProperties:la.maxProperties,maximum:la.maximum,minItems:la.minItems,minLength:la.minLength6,minProperties:la.minProperties,minimum:la.minimum,multipleOf:la.multipleOf,not:la.not,oneOf:la.oneOf,pattern:la.pattern,patternProperties:la.patternProperties,properties:la.properties,propertyNames:la.propertyNames,required:la.required,title:la.metaData,type:la.type,uniqueItems:la.uniqueItems});const{Core:ga,Schema:ba}=We,$a="http://json-schema.org/draft-07/schema";ba.setConfig($a,"baseToken","$id"),ba.setConfig($a,"embeddedToken","$id"),ba.setConfig($a,"anchorToken","$id"),ba.setConfig($a,"jrefToken","$ref"),ba.add(JSON.parse('{\n    "$schema": "http://json-schema.org/draft-07/schema#",\n    "$id": "http://json-schema.org/draft-07/schema#",\n    "title": "Core schema meta-schema",\n    "definitions": {\n        "schemaArray": {\n            "type": "array",\n            "minItems": 1,\n            "items": { "$ref": "#" }\n        },\n        "nonNegativeInteger": {\n            "type": "integer",\n            "minimum": 0\n        },\n        "nonNegativeIntegerDefault0": {\n            "allOf": [\n                { "$ref": "#/definitions/nonNegativeInteger" },\n                { "default": 0 }\n            ]\n        },\n        "simpleTypes": {\n            "enum": [\n                "array",\n                "boolean",\n                "integer",\n                "null",\n                "number",\n                "object",\n                "string"\n            ]\n        },\n        "stringArray": {\n            "type": "array",\n            "items": { "type": "string" },\n            "uniqueItems": true,\n            "default": []\n        }\n    },\n    "type": ["object", "boolean"],\n    "properties": {\n        "$id": {\n            "type": "string",\n            "format": "uri-reference"\n        },\n        "$schema": {\n            "type": "string",\n            "format": "uri"\n        },\n        "$ref": {\n            "type": "string",\n            "format": "uri-reference"\n        },\n        "$comment": {\n            "type": "string"\n        },\n        "title": {\n            "type": "string"\n        },\n        "description": {\n            "type": "string"\n        },\n        "default": true,\n        "readOnly": {\n            "type": "boolean",\n            "default": false\n        },\n        "writeOnly": {\n            "type": "boolean",\n            "default": false\n        },\n        "examples": {\n            "type": "array",\n            "items": true\n        },\n        "multipleOf": {\n            "type": "number",\n            "exclusiveMinimum": 0\n        },\n        "maximum": {\n            "type": "number"\n        },\n        "exclusiveMaximum": {\n            "type": "number"\n        },\n        "minimum": {\n            "type": "number"\n        },\n        "exclusiveMinimum": {\n            "type": "number"\n        },\n        "maxLength": { "$ref": "#/definitions/nonNegativeInteger" },\n        "minLength": { "$ref": "#/definitions/nonNegativeIntegerDefault0" },\n        "pattern": {\n            "type": "string",\n            "format": "regex"\n        },\n        "additionalItems": { "$ref": "#" },\n        "items": {\n            "anyOf": [\n                { "$ref": "#" },\n                { "$ref": "#/definitions/schemaArray" }\n            ],\n            "default": true\n        },\n        "maxItems": { "$ref": "#/definitions/nonNegativeInteger" },\n        "minItems": { "$ref": "#/definitions/nonNegativeIntegerDefault0" },\n        "uniqueItems": {\n            "type": "boolean",\n            "default": false\n        },\n        "contains": { "$ref": "#" },\n        "maxProperties": { "$ref": "#/definitions/nonNegativeInteger" },\n        "minProperties": { "$ref": "#/definitions/nonNegativeIntegerDefault0" },\n        "required": { "$ref": "#/definitions/stringArray" },\n        "additionalProperties": { "$ref": "#" },\n        "definitions": {\n            "type": "object",\n            "additionalProperties": { "$ref": "#" },\n            "default": {}\n        },\n        "properties": {\n            "type": "object",\n            "additionalProperties": { "$ref": "#" },\n            "default": {}\n        },\n        "patternProperties": {\n            "type": "object",\n            "additionalProperties": { "$ref": "#" },\n            "propertyNames": { "format": "regex" },\n            "default": {}\n        },\n        "dependencies": {\n            "type": "object",\n            "additionalProperties": {\n                "anyOf": [\n                    { "$ref": "#" },\n                    { "$ref": "#/definitions/stringArray" }\n                ]\n            }\n        },\n        "propertyNames": { "$ref": "#" },\n        "const": true,\n        "enum": {\n            "type": "array",\n            "items": true,\n            "minItems": 1,\n            "uniqueItems": true\n        },\n        "type": {\n            "anyOf": [\n                { "$ref": "#/definitions/simpleTypes" },\n                {\n                    "type": "array",\n                    "items": { "$ref": "#/definitions/simpleTypes" },\n                    "minItems": 1,\n                    "uniqueItems": true\n                }\n            ]\n        },\n        "format": { "type": "string" },\n        "contentMediaType": { "type": "string" },\n        "contentEncoding": { "type": "string" },\n        "if": { "$ref": "#" },\n        "then": { "$ref": "#" },\n        "else": { "$ref": "#" },\n        "allOf": { "$ref": "#/definitions/schemaArray" },\n        "anyOf": { "$ref": "#/definitions/schemaArray" },\n        "oneOf": { "$ref": "#/definitions/schemaArray" },\n        "not": { "$ref": "#" }\n    },\n    "default": true\n}')),ga.defineVocabulary($a,{validate:la.validate,additionalItems:la.additionalItems6,additionalProperties:la.additionalProperties6,allOf:la.allOf,anyOf:la.anyOf,const:la.const,contains:la.contains,default:la.metaData,definitions:la.definitions,dependencies:la.dependencies,description:la.metaData,enum:la.enum,exclusiveMaximum:la.exclusiveMaximum,exclusiveMinimum:la.exclusiveMinimum,format:la.metaData,if:la.if,then:la.then,else:la.else,items:la.items,maxItems:la.maxItems,maxLength:la.maxLength6,maxProperties:la.maxProperties,maximum:la.maximum,minItems:la.minItems,minLength:la.minLength6,minProperties:la.minProperties,minimum:la.minimum,multipleOf:la.multipleOf,not:la.not,oneOf:la.oneOf,pattern:la.pattern,patternProperties:la.patternProperties,properties:la.properties,propertyNames:la.propertyNames,readOnly:la.metaData,required:la.required,title:la.metaData,type:la.type,uniqueItems:la.uniqueItems,writeOnly:la.metaData});const{Core:Oa,Schema:Ia}=We,Sa="https://json-schema.org/draft/2019-09/schema";Ia.setConfig(Sa,"baseToken","$id"),Ia.setConfig(Sa,"embeddedToken","$id"),Ia.setConfig(Sa,"anchorToken","$anchor"),Ia.setConfig(Sa,"recursiveAnchorToken","$recursiveAnchor"),Ia.setConfig(Sa,"vocabularyToken","$vocabulary"),Ia.setConfig(Sa,"mandatoryVocabularies",["https://json-schema.org/draft/2019-09/vocab/core"]),Ia.add(JSON.parse('{\n    "$schema": "https://json-schema.org/draft/2019-09/schema",\n    "$id": "https://json-schema.org/draft/2019-09/schema",\n    "$vocabulary": {\n        "https://json-schema.org/draft/2019-09/vocab/core": true,\n        "https://json-schema.org/draft/2019-09/vocab/applicator": true,\n        "https://json-schema.org/draft/2019-09/vocab/validation": true,\n        "https://json-schema.org/draft/2019-09/vocab/meta-data": true,\n        "https://json-schema.org/draft/2019-09/vocab/format": false,\n        "https://json-schema.org/draft/2019-09/vocab/content": true\n    },\n    "$recursiveAnchor": true,\n\n    "title": "Core and Validation specifications meta-schema",\n    "allOf": [\n        {"$ref": "meta/core"},\n        {"$ref": "meta/applicator"},\n        {"$ref": "meta/validation"},\n        {"$ref": "meta/meta-data"},\n        {"$ref": "meta/format"},\n        {"$ref": "meta/content"}\n    ],\n    "type": ["object", "boolean"],\n    "properties": {\n        "definitions": {\n            "$comment": "While no longer an official keyword as it is replaced by $defs, this keyword is retained in the meta-schema to prevent incompatible extensions as it remains in common use.",\n            "type": "object",\n            "additionalProperties": { "$recursiveRef": "#" },\n            "default": {}\n        },\n        "dependencies": {\n            "$comment": "\\"dependencies\\" is no longer a keyword, but schema authors should avoid redefining it to facilitate a smooth transition to \\"dependentSchemas\\" and \\"dependentRequired\\"",\n            "type": "object",\n            "additionalProperties": {\n                "anyOf": [\n                    { "$recursiveRef": "#" },\n                    { "$ref": "meta/validation#/$defs/stringArray" }\n                ]\n            }\n        }\n    }\n}')),Ia.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/2019-09/meta/core",\n    "$schema": "https://json-schema.org/draft/2019-09/schema",\n    "$vocabulary": {\n      "https://json-schema.org/draft/2019-09/vocab/core": true\n    },\n    "$recursiveAnchor": true,\n\n    "title": "Core vocabulary meta-schema",\n    "type": ["object", "boolean"],\n    "properties": {\n        "$id": {\n            "type": "string",\n            "format": "uri-reference",\n            "$comment": "Non-empty fragments not allowed.",\n            "pattern": "^[^#]*#?$"\n        },\n        "$schema": {\n            "type": "string",\n            "format": "uri"\n        },\n        "$anchor": {\n            "type": "string",\n            "pattern": "^[A-Za-z][-A-Za-z0-9.:_]*$"\n        },\n        "$ref": {\n            "type": "string",\n            "format": "uri-reference"\n        },\n        "$recursiveRef": {\n            "type": "string",\n            "format": "uri-reference"\n        },\n        "$recursiveAnchor": {\n            "type": "boolean",\n            "default": false\n        },\n        "$vocabulary": {\n            "type": "object",\n            "propertyNames": {\n                "type": "string",\n                "format": "uri"\n            },\n            "additionalProperties": {\n                "type": "boolean"\n            }\n        },\n        "$comment": {\n            "type": "string"\n        },\n        "$defs": {\n            "type": "object",\n            "additionalProperties": { "$recursiveRef": "#" },\n            "default": {}\n        }\n    }\n}')),Oa.defineVocabulary("https://json-schema.org/draft/2019-09/vocab/core",{validate:la.validate,$defs:la.definitions,$recursiveRef:la.dynamicRef,$ref:la.ref}),Ia.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/2019-09/meta/applicator",\n    "$schema": "https://json-schema.org/draft/2019-09/schema",\n    "$vocabulary": {\n        "https://json-schema.org/draft/2019-09/vocab/applicator": true\n    },\n    "$recursiveAnchor": true,\n\n    "title": "Applicator vocabulary meta-schema",\n    "properties": {\n        "additionalItems": { "$recursiveRef": "#" },\n        "unevaluatedItems": { "$recursiveRef": "#" },\n        "items": {\n            "anyOf": [\n                { "$recursiveRef": "#" },\n                { "$ref": "#/$defs/schemaArray" }\n            ]\n        },\n        "contains": { "$recursiveRef": "#" },\n        "additionalProperties": { "$recursiveRef": "#" },\n        "unevaluatedProperties": { "$recursiveRef": "#" },\n        "properties": {\n            "type": "object",\n            "additionalProperties": { "$recursiveRef": "#" },\n            "default": {}\n        },\n        "patternProperties": {\n            "type": "object",\n            "additionalProperties": { "$recursiveRef": "#" },\n            "propertyNames": { "format": "regex" },\n            "default": {}\n        },\n        "dependentSchemas": {\n            "type": "object",\n            "additionalProperties": {\n                "$recursiveRef": "#"\n            }\n        },\n        "propertyNames": { "$recursiveRef": "#" },\n        "if": { "$recursiveRef": "#" },\n        "then": { "$recursiveRef": "#" },\n        "else": { "$recursiveRef": "#" },\n        "allOf": { "$ref": "#/$defs/schemaArray" },\n        "anyOf": { "$ref": "#/$defs/schemaArray" },\n        "oneOf": { "$ref": "#/$defs/schemaArray" },\n        "not": { "$recursiveRef": "#" }\n    },\n    "$defs": {\n        "schemaArray": {\n            "type": "array",\n            "minItems": 1,\n            "items": { "$recursiveRef": "#" }\n        }\n    }\n}')),Oa.defineVocabulary("https://json-schema.org/draft/2019-09/vocab/applicator",{additionalItems:la.additionalItems6,additionalProperties:la.additionalProperties6,allOf:la.allOf,anyOf:la.anyOf,contains:la.containsMinContainsMaxContains,dependentSchemas:la.dependentSchemas,if:la.if,then:la.then,else:la.else,items:la.items,not:la.not,oneOf:la.oneOf,patternProperties:la.patternProperties,properties:la.properties,propertyNames:la.propertyNames,unevaluatedItems:la.unevaluatedItems,unevaluatedProperties:la.unevaluatedProperties}),Ia.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/2019-09/meta/validation",\n    "$schema": "https://json-schema.org/draft/2019-09/schema",\n    "$vocabulary": {\n      "https://json-schema.org/draft/2019-09/vocab/validation": true\n    },\n    "$recursiveAnchor": true,\n\n    "title": "Validation vocabulary meta-schema",\n    "type": ["object", "boolean"],\n    "properties": {\n        "multipleOf": {\n            "type": "number",\n            "exclusiveMinimum": 0\n        },\n        "maximum": {\n            "type": "number"\n        },\n        "exclusiveMaximum": {\n            "type": "number"\n        },\n        "minimum": {\n            "type": "number"\n        },\n        "exclusiveMinimum": {\n            "type": "number"\n        },\n        "maxLength": { "$ref": "#/$defs/nonNegativeInteger" },\n        "minLength": { "$ref": "#/$defs/nonNegativeIntegerDefault0" },\n        "pattern": {\n            "type": "string",\n            "format": "regex"\n        },\n        "maxItems": { "$ref": "#/$defs/nonNegativeInteger" },\n        "minItems": { "$ref": "#/$defs/nonNegativeIntegerDefault0" },\n        "uniqueItems": {\n            "type": "boolean",\n            "default": false\n        },\n        "maxContains": { "$ref": "#/$defs/nonNegativeInteger" },\n        "minContains": {\n            "$ref": "#/$defs/nonNegativeInteger",\n            "default": 1\n        },\n        "maxProperties": { "$ref": "#/$defs/nonNegativeInteger" },\n        "minProperties": { "$ref": "#/$defs/nonNegativeIntegerDefault0" },\n        "required": { "$ref": "#/$defs/stringArray" },\n        "dependentRequired": {\n            "type": "object",\n            "additionalProperties": {\n                "$ref": "#/$defs/stringArray"\n            }\n        },\n        "const": true,\n        "enum": {\n            "type": "array",\n            "items": true\n        },\n        "type": {\n            "anyOf": [\n                { "$ref": "#/$defs/simpleTypes" },\n                {\n                    "type": "array",\n                    "items": { "$ref": "#/$defs/simpleTypes" },\n                    "minItems": 1,\n                    "uniqueItems": true\n                }\n            ]\n        }\n    },\n    "$defs": {\n        "nonNegativeInteger": {\n            "type": "integer",\n            "minimum": 0\n        },\n        "nonNegativeIntegerDefault0": {\n            "$ref": "#/$defs/nonNegativeInteger",\n            "default": 0\n        },\n        "simpleTypes": {\n            "enum": [\n                "array",\n                "boolean",\n                "integer",\n                "null",\n                "number",\n                "object",\n                "string"\n            ]\n        },\n        "stringArray": {\n            "type": "array",\n            "items": { "type": "string" },\n            "uniqueItems": true,\n            "default": []\n        }\n    }\n}')),Oa.defineVocabulary("https://json-schema.org/draft/2019-09/vocab/validation",{const:la.const,dependentRequired:la.dependentRequired,enum:la.enum,exclusiveMaximum:la.exclusiveMaximum,exclusiveMinimum:la.exclusiveMinimum,maxItems:la.maxItems,maxLength:la.maxLength6,maxProperties:la.maxProperties,maximum:la.maximum,minItems:la.minItems,minLength:la.minLength6,minProperties:la.minProperties,minimum:la.minimum,multipleOf:la.multipleOf,pattern:la.pattern,required:la.required,type:la.type,uniqueItems:la.uniqueItems}),Ia.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/2019-09/meta/meta-data",\n    "$schema": "https://json-schema.org/draft/2019-09/schema",\n    "$vocabulary": {\n      "https://json-schema.org/draft/2019-09/vocab/meta-data": true\n    },\n    "$recursiveAnchor": true,\n\n    "title": "Meta-data vocabulary meta-schema",\n\n    "type": ["object", "boolean"],\n    "properties": {\n        "title": {\n            "type": "string"\n        },\n        "description": {\n            "type": "string"\n        },\n        "default": true,\n        "deprecated": {\n            "type": "boolean",\n            "default": false\n        },\n        "readOnly": {\n            "type": "boolean",\n            "default": false\n        },\n        "writeOnly": {\n            "type": "boolean",\n            "default": false\n        },\n        "examples": {\n            "type": "array",\n            "items": true\n        }\n    }\n}')),Oa.defineVocabulary("https://json-schema.org/draft/2019-09/vocab/meta-data",{default:la.metaData,deprecated:la.metaData,description:la.metaData,examples:la.metaData,readOnly:la.metaData,title:la.metaData,writeOnly:la.metaData}),Ia.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/2019-09/meta/format",\n    "$schema": "https://json-schema.org/draft/2019-09/schema",\n    "$vocabulary": {\n      "https://json-schema.org/draft/2019-09/vocab/format": true\n    },\n    "$recursiveAnchor": true,\n\n    "title": "Format vocabulary meta-schema",\n    "type": ["object", "boolean"],\n    "properties": {\n        "format": { "type": "string" }\n    }\n}')),Ia.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/2019-09/meta/content",\n    "$schema": "https://json-schema.org/draft/2019-09/schema",\n    "$vocabulary": {\n      "https://json-schema.org/draft/2019-09/vocab/content": true\n    },\n    "$recursiveAnchor": true,\n\n    "title": "Content vocabulary meta-schema",\n\n    "type": ["object", "boolean"],\n    "properties": {\n        "contentMediaType": { "type": "string" },\n        "contentEncoding": { "type": "string" },\n        "contentSchema": { "$recursiveRef": "#" }\n    }\n}')),Oa.defineVocabulary("https://json-schema.org/draft/2019-09/vocab/content",{contentEncoding:la.metaData,contentMediaType:la.metaData,contentSchema:la.metaData});const{Core:xa,Schema:ja}=We,wa="https://json-schema.org/draft/2020-12/schema";ja.setConfig(wa,"baseToken","$id"),ja.setConfig(wa,"embeddedToken","$id"),ja.setConfig(wa,"anchorToken","$anchor"),ja.setConfig(wa,"dynamicAnchorToken","$dynamicAnchor"),ja.setConfig(wa,"vocabularyToken","$vocabulary"),ja.setConfig(wa,"mandatoryVocabularies",["https://json-schema.org/draft/2020-12/vocab/core"]),ja.add(JSON.parse('{\n    "$schema": "https://json-schema.org/draft/2020-12/schema",\n    "$id": "https://json-schema.org/draft/2020-12/schema",\n    "$vocabulary": {\n        "https://json-schema.org/draft/2020-12/vocab/core": true,\n        "https://json-schema.org/draft/2020-12/vocab/applicator": true,\n        "https://json-schema.org/draft/2020-12/vocab/unevaluated": true,\n        "https://json-schema.org/draft/2020-12/vocab/validation": true,\n        "https://json-schema.org/draft/2020-12/vocab/meta-data": true,\n        "https://json-schema.org/draft/2020-12/vocab/format-annotation": true,\n        "https://json-schema.org/draft/2020-12/vocab/content": true\n    },\n    "$dynamicAnchor": "meta",\n\n    "title": "Core and Validation specifications meta-schema",\n    "allOf": [\n        {"$ref": "meta/core"},\n        {"$ref": "meta/applicator"},\n        {"$ref": "meta/unevaluated"},\n        {"$ref": "meta/validation"},\n        {"$ref": "meta/meta-data"},\n        {"$ref": "meta/format-annotation"},\n        {"$ref": "meta/content"}\n    ],\n    "type": ["object", "boolean"],\n    "properties": {\n        "definitions": {\n            "$comment": "While no longer an official keyword as it is replaced by $defs, this keyword is retained in the meta-schema to prevent incompatible extensions as it remains in common use.",\n            "type": "object",\n            "additionalProperties": { "$dynamicRef": "#meta" },\n            "default": {}\n        },\n        "dependencies": {\n            "$comment": "\\"dependencies\\" is no longer a keyword, but schema authors should avoid redefining it to facilitate a smooth transition to \\"dependentSchemas\\" and \\"dependentRequired\\"",\n            "type": "object",\n            "additionalProperties": {\n                "anyOf": [\n                    { "$dynamicRef": "#meta" },\n                    { "$ref": "meta/validation#/$defs/stringArray" }\n                ]\n            }\n        }\n    }\n}')),ja.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/2020-12/meta/core",\n    "$schema": "https://json-schema.org/draft/2020-12/schema",\n    "$vocabulary": {\n        "https://json-schema.org/draft/2020-12/vocab/core": true\n    },\n    "$dynamicAnchor": "meta",\n\n    "title": "Core vocabulary meta-schema",\n    "type": ["object", "boolean"],\n    "properties": {\n        "$id": {\n            "type": "string",\n            "format": "uri-reference",\n            "$comment": "Non-empty fragments not allowed.",\n            "pattern": "^[^#]*#?$"\n        },\n        "$schema": {\n            "type": "string",\n            "format": "uri"\n        },\n        "$anchor": {\n            "type": "string",\n            "pattern": "^[A-Za-z_][-A-Za-z0-9._]*$"\n        },\n        "$ref": {\n            "type": "string",\n            "format": "uri-reference"\n        },\n        "$dynamicRef": {\n            "type": "string",\n            "format": "uri-reference"\n        },\n        "$dynamicAnchor": {\n            "type": "string",\n            "pattern": "^[A-Za-z_][-A-Za-z0-9._]*$"\n        },\n        "$vocabulary": {\n            "type": "object",\n            "propertyNames": {\n                "type": "string",\n                "format": "uri"\n            },\n            "additionalProperties": {\n                "type": "boolean"\n            }\n        },\n        "$comment": {\n            "type": "string"\n        },\n        "$defs": {\n            "type": "object",\n            "additionalProperties": { "$dynamicRef": "#meta" },\n            "default": {}\n        }\n    }\n}')),xa.defineVocabulary("https://json-schema.org/draft/2020-12/vocab/core",{validate:la.validate,$defs:la.definitions,$dynamicRef:la.dynamicRef,$ref:la.ref}),ja.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/2020-12/meta/applicator",\n    "$schema": "https://json-schema.org/draft/2020-12/schema",\n    "$vocabulary": {\n        "https://json-schema.org/draft/2020-12/vocab/applicator": true\n    },\n    "$dynamicAnchor": "meta",\n\n    "title": "Applicator vocabulary meta-schema",\n    "type": ["object", "boolean"],\n    "properties": {\n        "prefixItems": { "$ref": "#/$defs/schemaArray" },\n        "items": { "$dynamicRef": "#meta" },\n        "contains": { "$dynamicRef": "#meta" },\n        "additionalProperties": { "$dynamicRef": "#meta" },\n        "properties": {\n            "type": "object",\n            "additionalProperties": { "$dynamicRef": "#meta" },\n            "default": {}\n        },\n        "patternProperties": {\n            "type": "object",\n            "additionalProperties": { "$dynamicRef": "#meta" },\n            "propertyNames": { "format": "regex" },\n            "default": {}\n        },\n        "dependentSchemas": {\n            "type": "object",\n            "additionalProperties": {\n                "$dynamicRef": "#meta"\n            }\n        },\n        "propertyNames": { "$dynamicRef": "#meta" },\n        "if": { "$dynamicRef": "#meta" },\n        "then": { "$dynamicRef": "#meta" },\n        "else": { "$dynamicRef": "#meta" },\n        "allOf": { "$ref": "#/$defs/schemaArray" },\n        "anyOf": { "$ref": "#/$defs/schemaArray" },\n        "oneOf": { "$ref": "#/$defs/schemaArray" },\n        "not": { "$dynamicRef": "#meta" }\n    },\n    "$defs": {\n        "schemaArray": {\n            "type": "array",\n            "minItems": 1,\n            "items": { "$dynamicRef": "#meta" }\n        }\n    }\n}')),xa.defineVocabulary("https://json-schema.org/draft/2020-12/vocab/applicator",{additionalProperties:la.additionalProperties6,allOf:la.allOf,anyOf:la.anyOf,contains:la.containsMinContainsMaxContains,dependentSchemas:la.dependentSchemas,if:la.if,then:la.then,else:la.else,items:la.items202012,not:la.not,oneOf:la.oneOf,patternProperties:la.patternProperties,prefixItems:la.tupleItems,properties:la.properties,propertyNames:la.propertyNames}),ja.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/2020-12/meta/validation",\n    "$schema": "https://json-schema.org/draft/2020-12/schema",\n    "$vocabulary": {\n        "https://json-schema.org/draft/2020-12/vocab/validation": true\n    },\n    "$dynamicAnchor": "meta",\n\n    "title": "Validation vocabulary meta-schema",\n    "type": ["object", "boolean"],\n    "properties": {\n        "multipleOf": {\n            "type": "number",\n            "exclusiveMinimum": 0\n        },\n        "maximum": {\n            "type": "number"\n        },\n        "exclusiveMaximum": {\n            "type": "number"\n        },\n        "minimum": {\n            "type": "number"\n        },\n        "exclusiveMinimum": {\n            "type": "number"\n        },\n        "maxLength": { "$ref": "#/$defs/nonNegativeInteger" },\n        "minLength": { "$ref": "#/$defs/nonNegativeIntegerDefault0" },\n        "pattern": {\n            "type": "string",\n            "format": "regex"\n        },\n        "maxItems": { "$ref": "#/$defs/nonNegativeInteger" },\n        "minItems": { "$ref": "#/$defs/nonNegativeIntegerDefault0" },\n        "uniqueItems": {\n            "type": "boolean",\n            "default": false\n        },\n        "maxContains": { "$ref": "#/$defs/nonNegativeInteger" },\n        "minContains": {\n            "$ref": "#/$defs/nonNegativeInteger",\n            "default": 1\n        },\n        "maxProperties": { "$ref": "#/$defs/nonNegativeInteger" },\n        "minProperties": { "$ref": "#/$defs/nonNegativeIntegerDefault0" },\n        "required": { "$ref": "#/$defs/stringArray" },\n        "dependentRequired": {\n            "type": "object",\n            "additionalProperties": {\n                "$ref": "#/$defs/stringArray"\n            }\n        },\n        "const": true,\n        "enum": {\n            "type": "array",\n            "items": true\n        },\n        "type": {\n            "anyOf": [\n                { "$ref": "#/$defs/simpleTypes" },\n                {\n                    "type": "array",\n                    "items": { "$ref": "#/$defs/simpleTypes" },\n                    "minItems": 1,\n                    "uniqueItems": true\n                }\n            ]\n        }\n    },\n    "$defs": {\n        "nonNegativeInteger": {\n            "type": "integer",\n            "minimum": 0\n        },\n        "nonNegativeIntegerDefault0": {\n            "$ref": "#/$defs/nonNegativeInteger",\n            "default": 0\n        },\n        "simpleTypes": {\n            "enum": [\n                "array",\n                "boolean",\n                "integer",\n                "null",\n                "number",\n                "object",\n                "string"\n            ]\n        },\n        "stringArray": {\n            "type": "array",\n            "items": { "type": "string" },\n            "uniqueItems": true,\n            "default": []\n        }\n    }\n}')),xa.defineVocabulary("https://json-schema.org/draft/2020-12/vocab/validation",{const:la.const,dependentRequired:la.dependentRequired,enum:la.enum,exclusiveMaximum:la.exclusiveMaximum,exclusiveMinimum:la.exclusiveMinimum,maxItems:la.maxItems,maxLength:la.maxLength6,maxProperties:la.maxProperties,maximum:la.maximum,minItems:la.minItems,minLength:la.minLength6,minProperties:la.minProperties,minimum:la.minimum,multipleOf:la.multipleOf,pattern:la.pattern,required:la.required,type:la.type,uniqueItems:la.uniqueItems}),ja.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/2020-12/meta/meta-data",\n    "$schema": "https://json-schema.org/draft/2020-12/schema",\n    "$vocabulary": {\n        "https://json-schema.org/draft/2020-12/vocab/meta-data": true\n    },\n    "$dynamicAnchor": "meta",\n\n    "title": "Meta-data vocabulary meta-schema",\n\n    "type": ["object", "boolean"],\n    "properties": {\n        "title": {\n            "type": "string"\n        },\n        "description": {\n            "type": "string"\n        },\n        "default": true,\n        "deprecated": {\n            "type": "boolean",\n            "default": false\n        },\n        "readOnly": {\n            "type": "boolean",\n            "default": false\n        },\n        "writeOnly": {\n            "type": "boolean",\n            "default": false\n        },\n        "examples": {\n            "type": "array",\n            "items": true\n        }\n    }\n}')),xa.defineVocabulary("https://json-schema.org/draft/2020-12/vocab/meta-data",{default:la.metaData,deprecated:la.metaData,description:la.metaData,examples:la.metaData,readOnly:la.metaData,title:la.metaData,writeOnly:la.metaData}),ja.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/2020-12/meta/format-annotation",\n    "$schema": "https://json-schema.org/draft/2020-12/schema",\n    "$vocabulary": {\n        "https://json-schema.org/draft/2020-12/vocab/format-annotation": true\n    },\n    "$dynamicAnchor": "meta",\n\n    "title": "Format vocabulary meta-schema for annotation results",\n    "type": ["object", "boolean"],\n    "properties": {\n        "format": { "type": "string" }\n    }\n}')),xa.defineVocabulary("https://json-schema.org/draft/2020-12/vocab/format-annotation",{format:la.metaData}),ja.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/2020-12/meta/format-assertion",\n    "$schema": "https://json-schema.org/draft/2020-12/schema",\n    "$vocabulary": {\n        "https://json-schema.org/draft/2020-12/vocab/format-assertion": true\n    },\n    "$dynamicAnchor": "meta",\n\n    "title": "Format vocabulary meta-schema for assertion results",\n    "type": ["object", "boolean"],\n    "properties": {\n        "format": { "type": "string" }\n    }\n}')),ja.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/2020-12/meta/content",\n    "$schema": "https://json-schema.org/draft/2020-12/schema",\n    "$vocabulary": {\n        "https://json-schema.org/draft/2020-12/vocab/content": true\n    },\n    "$dynamicAnchor": "meta",\n\n    "title": "Content vocabulary meta-schema",\n\n    "type": ["object", "boolean"],\n    "properties": {\n        "contentMediaType": { "type": "string" },\n        "contentEncoding": { "type": "string" },\n        "contentSchema": { "$dynamicRef": "#meta" }\n    }\n}')),xa.defineVocabulary("https://json-schema.org/draft/2020-12/vocab/content",{contentEncoding:la.metaData,contentMediaType:la.metaData,contentSchema:la.metaData}),ja.add(JSON.parse('{\n    "$id": "https://json-schema.org/draft/2020-12/meta/unevaluated",\n    "$schema": "https://json-schema.org/draft/2020-12/schema",\n    "$vocabulary": {\n        "https://json-schema.org/draft/2020-12/vocab/unevaluated": true\n    },\n    "$dynamicAnchor": "meta",\n\n    "title": "Unevaluated applicator vocabulary meta-schema",\n    "type": ["object", "boolean"],\n    "properties": {\n        "unevaluatedItems": { "$dynamicRef": "#meta" },\n        "unevaluatedProperties": { "$dynamicRef": "#meta" }\n    }\n}')),xa.defineVocabulary("https://json-schema.org/draft/2020-12/vocab/unevaluated",{unevaluatedItems:la.unevaluatedItems,unevaluatedProperties:la.unevaluatedProperties});const{Core:Pa,Schema:Ea,InvalidSchemaError:Aa}=We;var Ca={add:Pa.add,get:Ea.get,validate:Pa.validate,compile:Pa.compile,interpret:Pa.interpret,setMetaOutputFormat:Pa.setMetaOutputFormat,setShouldMetaValidate:Pa.setShouldMetaValidate,FLAG:Pa.FLAG,BASIC:Pa.BASIC,DETAILED:Pa.DETAILED,VERBOSE:Pa.VERBOSE,Keywords:la,InvalidSchemaError:Aa},Na=Ca.add,Ra=Ca.get,Ta=Ca.validate,Da=Ca.compile,ka=Ca.interpret,Ma=Ca.setMetaOutputFormat,qa=Ca.setShouldMetaValidate,Va=Ca.FLAG,La=Ca.BASIC,Ja=Ca.DETAILED,_a=Ca.VERBOSE,Ua=Ca.Keywords,za=Ca.InvalidSchemaError;exports.BASIC=La,exports.DETAILED=Ja,exports.FLAG=Va,exports.InvalidSchemaError=za,exports.Keywords=Ua,exports.VERBOSE=_a,exports.add=Na,exports.compile=Da,exports.default=Ca,exports.get=Ra,exports.interpret=ka,exports.setMetaOutputFormat=Ma,exports.setShouldMetaValidate=qa,exports.validate=Ta;
//# sourceMappingURL=json-schema-cjs.min.js.map
