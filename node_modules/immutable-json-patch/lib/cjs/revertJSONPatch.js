"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.revertJSONPatch = revertJSONPatch;
var _immutabilityHelpers = require("./immutabilityHelpers.js");
var _immutableJSONPatch = require("./immutableJSONPatch.js");
var _jsonPointer = require("./jsonPointer.js");
var _utils = require("./utils.js");
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
/**
 * Create the inverse of a set of json patch operations
 * @param document
 * @param operations Array with JSON patch actions
 * @param [options]
 * @return Returns the operations to revert the changes
 */
function revertJSONPatch(document, operations, options) {
  var allRevertOperations = [];
  (0, _immutableJSONPatch.immutableJSONPatch)(document, operations, {
    before: function before(document, operation) {
      var revertOperations;
      var path = (0, _immutableJSONPatch.parsePath)(document, operation.path);
      if (operation.op === 'add') {
        revertOperations = revertAdd(document, path);
      } else if (operation.op === 'remove') {
        revertOperations = revertRemove(document, path);
      } else if (operation.op === 'replace') {
        revertOperations = revertReplace(document, path);
      } else if (operation.op === 'copy') {
        revertOperations = revertCopy(document, path);
      } else if (operation.op === 'move') {
        revertOperations = revertMove(document, path, (0, _immutableJSONPatch.parseFrom)(operation.from));
      } else if (operation.op === 'test') {
        revertOperations = [];
      } else {
        throw new Error('Unknown JSONPatch operation ' + JSON.stringify(operation));
      }
      var updatedJson;
      if (options && options.before) {
        var res = options.before(document, operation, revertOperations);
        if (res && res.revertOperations) {
          revertOperations = res.revertOperations;
        }
        if (res && res.document) {
          updatedJson = res.document;
        }
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        if (res && res.json) {
          // TODO: deprecated since v5.0.0. Cleanup this warning some day
          throw new Error('Deprecation warning: returned object property ".json" has been renamed to ".document"');
        }
      }
      allRevertOperations = revertOperations.concat(allRevertOperations);
      if (updatedJson !== undefined) {
        return {
          document: updatedJson
        };
      }
    }
  });
  return allRevertOperations;
}
function revertReplace(document, path) {
  return [{
    op: 'replace',
    path: (0, _jsonPointer.compileJSONPointer)(path),
    value: (0, _immutabilityHelpers.getIn)(document, path)
  }];
}
function revertRemove(document, path) {
  return [{
    op: 'add',
    path: (0, _jsonPointer.compileJSONPointer)(path),
    value: (0, _immutabilityHelpers.getIn)(document, path)
  }];
}
function revertAdd(document, path) {
  if ((0, _immutableJSONPatch.isArrayItem)(document, path) || !(0, _immutabilityHelpers.existsIn)(document, path)) {
    return [{
      op: 'remove',
      path: (0, _jsonPointer.compileJSONPointer)(path)
    }];
  } else {
    return revertReplace(document, path);
  }
}
function revertCopy(document, path) {
  return revertAdd(document, path);
}
function revertMove(document, path, from) {
  if (path.length < from.length && (0, _utils.startsWith)(from, path)) {
    // replacing the parent with the child
    return [{
      op: 'replace',
      path: (0, _jsonPointer.compileJSONPointer)(path),
      value: document
    }];
  }
  var move = {
    op: 'move',
    from: (0, _jsonPointer.compileJSONPointer)(path),
    path: (0, _jsonPointer.compileJSONPointer)(from)
  };
  if (!(0, _immutableJSONPatch.isArrayItem)(document, path) && (0, _immutabilityHelpers.existsIn)(document, path)) {
    // the move replaces an existing value in an object
    return [move].concat(_toConsumableArray(revertRemove(document, path)));
  } else {
    return [move];
  }
}
//# sourceMappingURL=revertJSONPatch.js.map