function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
import { existsIn, getIn } from './immutabilityHelpers.js';
import { immutableJSONPatch, isArrayItem, parseFrom, parsePath } from './immutableJSONPatch.js';
import { compileJSONPointer } from './jsonPointer.js';
import { startsWith } from './utils.js';

/**
 * Create the inverse of a set of json patch operations
 * @param document
 * @param operations Array with JSON patch actions
 * @param [options]
 * @return Returns the operations to revert the changes
 */
export function revertJSONPatch(document, operations, options) {
  var allRevertOperations = [];
  immutableJSONPatch(document, operations, {
    before: function before(document, operation) {
      var revertOperations;
      var path = parsePath(document, operation.path);
      if (operation.op === 'add') {
        revertOperations = revertAdd(document, path);
      } else if (operation.op === 'remove') {
        revertOperations = revertRemove(document, path);
      } else if (operation.op === 'replace') {
        revertOperations = revertReplace(document, path);
      } else if (operation.op === 'copy') {
        revertOperations = revertCopy(document, path);
      } else if (operation.op === 'move') {
        revertOperations = revertMove(document, path, parseFrom(operation.from));
      } else if (operation.op === 'test') {
        revertOperations = [];
      } else {
        throw new Error('Unknown JSONPatch operation ' + JSON.stringify(operation));
      }
      var updatedJson;
      if (options && options.before) {
        var res = options.before(document, operation, revertOperations);
        if (res && res.revertOperations) {
          revertOperations = res.revertOperations;
        }
        if (res && res.document) {
          updatedJson = res.document;
        }
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        if (res && res.json) {
          // TODO: deprecated since v5.0.0. Cleanup this warning some day
          throw new Error('Deprecation warning: returned object property ".json" has been renamed to ".document"');
        }
      }
      allRevertOperations = revertOperations.concat(allRevertOperations);
      if (updatedJson !== undefined) {
        return {
          document: updatedJson
        };
      }
    }
  });
  return allRevertOperations;
}
function revertReplace(document, path) {
  return [{
    op: 'replace',
    path: compileJSONPointer(path),
    value: getIn(document, path)
  }];
}
function revertRemove(document, path) {
  return [{
    op: 'add',
    path: compileJSONPointer(path),
    value: getIn(document, path)
  }];
}
function revertAdd(document, path) {
  if (isArrayItem(document, path) || !existsIn(document, path)) {
    return [{
      op: 'remove',
      path: compileJSONPointer(path)
    }];
  } else {
    return revertReplace(document, path);
  }
}
function revertCopy(document, path) {
  return revertAdd(document, path);
}
function revertMove(document, path, from) {
  if (path.length < from.length && startsWith(from, path)) {
    // replacing the parent with the child
    return [{
      op: 'replace',
      path: compileJSONPointer(path),
      value: document
    }];
  }
  var move = {
    op: 'move',
    from: compileJSONPointer(path),
    path: compileJSONPointer(from)
  };
  if (!isArrayItem(document, path) && existsIn(document, path)) {
    // the move replaces an existing value in an object
    return [move].concat(_toConsumableArray(revertRemove(document, path)));
  } else {
    return [move];
  }
}
//# sourceMappingURL=revertJSONPatch.js.map