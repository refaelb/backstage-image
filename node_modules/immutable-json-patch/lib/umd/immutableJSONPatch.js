(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.immutableJSONPatch = {}));
})(this, (function (exports) { 'use strict';

  function _typeof$2(obj) { "@babel/helpers - typeof"; return _typeof$2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof$2(obj); }
  function isJSONArray(value) {
    return Array.isArray(value);
  }
  function isJSONObject(value) {
    return value !== null && _typeof$2(value) === 'object' && value.constructor === Object // do not match on classes or Array
    ;
  }

  function isJSONPatchOperation(value) {
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    return value && _typeof$2(value) === 'object' ? typeof value.op === 'string' : false;
  }
  function isJSONPatchAdd(value) {
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    return value && _typeof$2(value) === 'object' ? value.op === 'add' : false;
  }
  function isJSONPatchRemove(value) {
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    return value && _typeof$2(value) === 'object' ? value.op === 'remove' : false;
  }
  function isJSONPatchReplace(value) {
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    return value && _typeof$2(value) === 'object' ? value.op === 'replace' : false;
  }
  function isJSONPatchCopy(value) {
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    return value && _typeof$2(value) === 'object' ? value.op === 'copy' : false;
  }
  function isJSONPatchMove(value) {
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    return value && _typeof$2(value) === 'object' ? value.op === 'move' : false;
  }
  function isJSONPatchTest(value) {
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    return value && _typeof$2(value) === 'object' ? value.op === 'test' : false;
  }

  function _typeof$1(obj) { "@babel/helpers - typeof"; return _typeof$1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof$1(obj); }
  /**
   * Test deep equality of two JSON values, objects, or arrays
   */ // TODO: write unit tests
  function isEqual(a, b) {
    // FIXME: this function will return false for two objects with the same keys
    //  but different order of keys
    return JSON.stringify(a) === JSON.stringify(b);
  }

  /**
   * Test whether two values are strictly equal
   */
  function strictEqual(a, b) {
    return a === b;
  }

  /**
   * Get all but the last items from an array
   */
  // TODO: write unit tests
  function initial(array) {
    return array.slice(0, array.length - 1);
  }

  /**
   * Get the last item from an array
   */
  // TODO: write unit tests
  function last(array) {
    return array[array.length - 1];
  }

  /**
   * Test whether array1 starts with array2
   * @param array1
   * @param array2
   * @param [isEqual] Optional function to check equality
   */
  function startsWith(array1, array2) {
    var isEqual = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : strictEqual;
    if (array1.length < array2.length) {
      return false;
    }
    for (var i = 0; i < array2.length; i++) {
      if (!isEqual(array1[i], array2[i])) {
        return false;
      }
    }
    return true;
  }

  /**
   * Test whether a value is an Object or an Array (and not a primitive JSON value)
   */
  // TODO: write unit tests
  function isObjectOrArray(value) {
    return _typeof$1(value) === 'object' && value !== null;
  }

  function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
  function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
  function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
  function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
  function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
  function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }

  /**
   * Shallow clone of an Object, Array, or value
   * Symbols are cloned too.
   */
  function shallowClone(value) {
    if (isJSONArray(value)) {
      // copy array items
      var copy = value.slice();

      // copy all symbols
      Object.getOwnPropertySymbols(value).forEach(function (symbol) {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        copy[symbol] = value[symbol];
      });
      return copy;
    } else if (isJSONObject(value)) {
      // copy object properties
      var _copy = _objectSpread({}, value);

      // copy all symbols
      Object.getOwnPropertySymbols(value).forEach(function (symbol) {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        _copy[symbol] = value[symbol];
      });
      return _copy;
    } else {
      return value;
    }
  }

  /**
   * Update a value in an object in an immutable way.
   * If the value is unchanged, the original object will be returned
   */
  function applyProp(object, key, value) {
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    if (object[key] === value) {
      // return original object unchanged when the new value is identical to the old one
      return object;
    } else {
      var updatedObject = shallowClone(object);
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      updatedObject[key] = value;
      return updatedObject;
    }
  }

  /**
   * helper function to get a nested property in an object or array
   *
   * @return Returns the field when found, or undefined when the path doesn't exist
   */
  function getIn(object, path) {
    var value = object;
    var i = 0;
    while (i < path.length) {
      if (isJSONObject(value)) {
        value = value[path[i]];
      } else if (isJSONArray(value)) {
        value = value[parseInt(path[i])];
      } else {
        value = undefined;
      }
      i++;
    }
    return value;
  }

  /**
   * helper function to replace a nested property in an object with a new value
   * without mutating the object itself.
   *
   * @param object
   * @param path
   * @param value
   * @param [createPath=false]
   *                    If true, `path` will be created when (partly) missing in
   *                    the object. For correctly creating nested Arrays or
   *                    Objects, the function relies on `path` containing number
   *                    in case of array indexes.
   *                    If false (default), an error will be thrown when the
   *                    path doesn't exist.
   * @return Returns a new, updated object or array
   */
  function setIn(object, path, value) {
    var createPath = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    if (path.length === 0) {
      return value;
    }
    var key = path[0];
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    var updatedValue = setIn(object ? object[key] : undefined, path.slice(1), value, createPath);
    if (isJSONObject(object) || isJSONArray(object)) {
      return applyProp(object, key, updatedValue);
    } else {
      if (createPath) {
        var newObject = IS_INTEGER_REGEX.test(key) ? [] : {};
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        newObject[key] = updatedValue;
        return newObject;
      } else {
        throw new Error('Path does not exist');
      }
    }
  }
  var IS_INTEGER_REGEX = /^\d+$/;

  /**
   * helper function to replace a nested property in an object with a new value
   * without mutating the object itself.
   *
   * @return  Returns a new, updated object or array
   */
  function updateIn(object, path, callback) {
    if (path.length === 0) {
      return callback(object);
    }
    if (!isObjectOrArray(object)) {
      throw new Error('Path doesn\'t exist');
    }
    var key = path[0];
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    var updatedValue = updateIn(object[key], path.slice(1), callback);
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    return applyProp(object, key, updatedValue);
  }

  /**
   * helper function to delete a nested property in an object
   * without mutating the object itself.
   *
   * @return Returns a new, updated object or array
   */
  function deleteIn(object, path) {
    if (path.length === 0) {
      return object;
    }
    if (!isObjectOrArray(object)) {
      throw new Error('Path does not exist');
    }
    if (path.length === 1) {
      var _key = path[0];
      if (!(_key in object)) {
        // key doesn't exist. return object unchanged
        return object;
      } else {
        var updatedObject = shallowClone(object);
        if (isJSONArray(updatedObject)) {
          updatedObject.splice(parseInt(_key), 1);
        }
        if (isJSONObject(updatedObject)) {
          delete updatedObject[_key];
        }
        return updatedObject;
      }
    }
    var key = path[0];
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    var updatedValue = deleteIn(object[key], path.slice(1));
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    return applyProp(object, key, updatedValue);
  }

  /**
   * Insert a new item in an array at a specific index.
   * Example usage:
   *
   *     insertAt({arr: [1,2,3]}, ['arr', '2'], 'inserted')  // [1,2,'inserted',3]
   */
  function insertAt(document, path, value) {
    var parentPath = path.slice(0, path.length - 1);
    var index = path[path.length - 1];
    return updateIn(document, parentPath, function (items) {
      if (!Array.isArray(items)) {
        throw new TypeError('Array expected at path ' + JSON.stringify(parentPath));
      }
      var updatedItems = shallowClone(items);
      updatedItems.splice(parseInt(index), 0, value);
      return updatedItems;
    });
  }

  /**
   * Transform a JSON object, traverse over the whole object,
   * and allow replacing Objects/Arrays/values.
   */
  function transform(document, callback) {
    var path = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
    var updated1 = callback(document, path);
    if (isJSONArray(updated1)) {
      // array
      var updated2;
      for (var i = 0; i < updated1.length; i++) {
        var before = updated1[i];
        // we stringify the index here, so the path only contains strings and can be safely
        // stringified/parsed to JSONPointer without loosing information.
        // We do not want to rely on path keys being numeric/string.
        var after = transform(before, callback, path.concat(i + ''));
        if (after !== before) {
          if (!updated2) {
            updated2 = shallowClone(updated1);
          }
          updated2[i] = after;
        }
      }
      return updated2 || updated1;
    } else if (isJSONObject(updated1)) {
      // object
      var _updated;
      for (var key in updated1) {
        if (Object.hasOwnProperty.call(updated1, key)) {
          var _before = updated1[key];
          var _after = transform(_before, callback, path.concat(key));
          if (_after !== _before) {
            if (!_updated) {
              _updated = shallowClone(updated1);
            }
            _updated[key] = _after;
          }
        }
      }
      return _updated || updated1;
    } else {
      // number, string, boolean, null
      return updated1;
    }
  }

  /**
   * Test whether a path exists in a JSON object
   * @return Returns true if the path exists, else returns false
   */
  function existsIn(document, path) {
    if (document === undefined) {
      return false;
    }
    if (path.length === 0) {
      return true;
    }
    if (document === null) {
      return false;
    }

    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    return existsIn(document[path[0]], path.slice(1));
  }

  /**
   * Parse a JSON Pointer
   */
  function parseJSONPointer(pointer) {
    var path = pointer.split('/');
    path.shift(); // remove the first empty entry

    return path.map(function (p) {
      return p.replace(/~1/g, '/').replace(/~0/g, '~');
    });
  }

  /**
   * Compile a JSON Pointer
   */
  function compileJSONPointer(path) {
    return path.map(compileJSONPointerProp).join('');
  }

  /**
   * Compile a single path property from a JSONPath
   */
  function compileJSONPointerProp(pathProp) {
    return '/' + String(pathProp).replace(/~/g, '~0').replace(/\//g, '~1');
  }

  /**
   * Append a path property to a JSONPointer
   */
  function appendToJSONPointer(pointer, pathProp) {
    return pointer + compileJSONPointerProp(pathProp);
  }

  /**
   * Test whether `pointer` starts with `searchPointer`
   */
  function startsWithJSONPointer(pointer, searchPointer) {
    return pointer.startsWith(searchPointer) && (pointer.length === searchPointer.length || pointer[searchPointer.length] === '/');
  }

  /**
   * Apply a patch to a JSON object
   * The original JSON object will not be changed,
   * instead, the patch is applied in an immutable way
   */
  function immutableJSONPatch(document, operations, options) {
    var updatedDocument = document;
    for (var i = 0; i < operations.length; i++) {
      validateJSONPatchOperation(operations[i]);
      var operation = operations[i];

      // TODO: test before
      if (options && options.before) {
        var result = options.before(updatedDocument, operation);
        if (result !== undefined) {
          if (result.document !== undefined) {
            updatedDocument = result.document;
          }
          // eslint-disable-next-line @typescript-eslint/ban-ts-comment
          // @ts-ignore
          if (result.json !== undefined) {
            // TODO: deprecated since v5.0.0. Cleanup this warning some day
            throw new Error('Deprecation warning: returned object property ".json" has been renamed to ".document"');
          }
          if (result.operation !== undefined) {
            operation = result.operation;
          }
        }
      }
      var previousDocument = updatedDocument;
      var path = parsePath(updatedDocument, operation.path);
      if (operation.op === 'add') {
        updatedDocument = add(updatedDocument, path, operation.value);
      } else if (operation.op === 'remove') {
        updatedDocument = remove(updatedDocument, path);
      } else if (operation.op === 'replace') {
        updatedDocument = replace(updatedDocument, path, operation.value);
      } else if (operation.op === 'copy') {
        updatedDocument = copy(updatedDocument, path, parseFrom(operation.from));
      } else if (operation.op === 'move') {
        updatedDocument = move(updatedDocument, path, parseFrom(operation.from));
      } else if (operation.op === 'test') {
        test(updatedDocument, path, operation.value);
      } else {
        throw new Error('Unknown JSONPatch operation ' + JSON.stringify(operation));
      }

      // TODO: test after
      if (options && options.after) {
        var _result = options.after(updatedDocument, operation, previousDocument);
        if (_result !== undefined) {
          updatedDocument = _result;
        }
      }
    }
    return updatedDocument;
  }

  /**
   * Replace an existing item
   */
  function replace(document, path, value) {
    return setIn(document, path, value);
  }

  /**
   * Remove an item or property
   */
  function remove(document, path) {
    return deleteIn(document, path);
  }

  /**
   * Add an item or property
   */
  function add(document, path, value) {
    if (isArrayItem(document, path)) {
      return insertAt(document, path, value);
    } else {
      return setIn(document, path, value);
    }
  }

  /**
   * Copy a value
   */
  function copy(document, path, from) {
    var value = getIn(document, from);
    if (isArrayItem(document, path)) {
      return insertAt(document, path, value);
    } else {
      var _value = getIn(document, from);
      return setIn(document, path, _value);
    }
  }

  /**
   * Move a value
   */
  function move(document, path, from) {
    var value = getIn(document, from);
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    var removedJson = deleteIn(document, from);
    return isArrayItem(removedJson, path) ? insertAt(removedJson, path, value) : setIn(removedJson, path, value);
  }

  /**
   * Test whether the data contains the provided value at the specified path.
   * Throws an error when the test fails
   */
  function test(document, path, value) {
    if (value === undefined) {
      throw new Error("Test failed: no value provided (path: \"".concat(compileJSONPointer(path), "\")"));
    }
    if (!existsIn(document, path)) {
      throw new Error("Test failed: path not found (path: \"".concat(compileJSONPointer(path), "\")"));
    }
    var actualValue = getIn(document, path);
    if (!isEqual(actualValue, value)) {
      throw new Error("Test failed, value differs (path: \"".concat(compileJSONPointer(path), "\")"));
    }
  }
  function isArrayItem(document, path) {
    if (path.length === 0) {
      return false;
    }
    var parent = getIn(document, initial(path));
    return Array.isArray(parent);
  }

  /**
   * Resolve the path index of an array, resolves indexes '-'
   * @returns Returns the resolved path
   */
  function resolvePathIndex(document, path) {
    if (last(path) !== '-') {
      return path;
    }
    var parentPath = initial(path);
    var parent = getIn(document, parentPath);

    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    return parentPath.concat(parent.length);
  }

  /**
   * Validate a JSONPatch operation.
   * Throws an error when there is an issue
   */
  function validateJSONPatchOperation(operation) {
    // TODO: write unit tests
    var ops = ['add', 'remove', 'replace', 'copy', 'move', 'test'];
    if (!ops.includes(operation.op)) {
      throw new Error('Unknown JSONPatch op ' + JSON.stringify(operation.op));
    }
    if (typeof operation.path !== 'string') {
      throw new Error('Required property "path" missing or not a string in operation ' + JSON.stringify(operation));
    }
    if (operation.op === 'copy' || operation.op === 'move') {
      if (typeof operation.from !== 'string') {
        throw new Error('Required property "from" missing or not a string in operation ' + JSON.stringify(operation));
      }
    }
  }
  function parsePath(document, pointer) {
    return resolvePathIndex(document, parseJSONPointer(pointer));
  }
  function parseFrom(fromPointer) {
    return parseJSONPointer(fromPointer);
  }

  function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
  function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
  function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
  function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
  function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
  function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

  /**
   * Create the inverse of a set of json patch operations
   * @param document
   * @param operations Array with JSON patch actions
   * @param [options]
   * @return Returns the operations to revert the changes
   */
  function revertJSONPatch(document, operations, options) {
    var allRevertOperations = [];
    immutableJSONPatch(document, operations, {
      before: function before(document, operation) {
        var revertOperations;
        var path = parsePath(document, operation.path);
        if (operation.op === 'add') {
          revertOperations = revertAdd(document, path);
        } else if (operation.op === 'remove') {
          revertOperations = revertRemove(document, path);
        } else if (operation.op === 'replace') {
          revertOperations = revertReplace(document, path);
        } else if (operation.op === 'copy') {
          revertOperations = revertCopy(document, path);
        } else if (operation.op === 'move') {
          revertOperations = revertMove(document, path, parseFrom(operation.from));
        } else if (operation.op === 'test') {
          revertOperations = [];
        } else {
          throw new Error('Unknown JSONPatch operation ' + JSON.stringify(operation));
        }
        var updatedJson;
        if (options && options.before) {
          var res = options.before(document, operation, revertOperations);
          if (res && res.revertOperations) {
            revertOperations = res.revertOperations;
          }
          if (res && res.document) {
            updatedJson = res.document;
          }
          // eslint-disable-next-line @typescript-eslint/ban-ts-comment
          // @ts-ignore
          if (res && res.json) {
            // TODO: deprecated since v5.0.0. Cleanup this warning some day
            throw new Error('Deprecation warning: returned object property ".json" has been renamed to ".document"');
          }
        }
        allRevertOperations = revertOperations.concat(allRevertOperations);
        if (updatedJson !== undefined) {
          return {
            document: updatedJson
          };
        }
      }
    });
    return allRevertOperations;
  }
  function revertReplace(document, path) {
    return [{
      op: 'replace',
      path: compileJSONPointer(path),
      value: getIn(document, path)
    }];
  }
  function revertRemove(document, path) {
    return [{
      op: 'add',
      path: compileJSONPointer(path),
      value: getIn(document, path)
    }];
  }
  function revertAdd(document, path) {
    if (isArrayItem(document, path) || !existsIn(document, path)) {
      return [{
        op: 'remove',
        path: compileJSONPointer(path)
      }];
    } else {
      return revertReplace(document, path);
    }
  }
  function revertCopy(document, path) {
    return revertAdd(document, path);
  }
  function revertMove(document, path, from) {
    if (path.length < from.length && startsWith(from, path)) {
      // replacing the parent with the child
      return [{
        op: 'replace',
        path: compileJSONPointer(path),
        value: document
      }];
    }
    var move = {
      op: 'move',
      from: compileJSONPointer(path),
      path: compileJSONPointer(from)
    };
    if (!isArrayItem(document, path) && existsIn(document, path)) {
      // the move replaces an existing value in an object
      return [move].concat(_toConsumableArray(revertRemove(document, path)));
    } else {
      return [move];
    }
  }

  exports.appendToJSONPointer = appendToJSONPointer;
  exports.compileJSONPointer = compileJSONPointer;
  exports.compileJSONPointerProp = compileJSONPointerProp;
  exports.deleteIn = deleteIn;
  exports.existsIn = existsIn;
  exports.getIn = getIn;
  exports.immutableJSONPatch = immutableJSONPatch;
  exports.insertAt = insertAt;
  exports.isJSONArray = isJSONArray;
  exports.isJSONObject = isJSONObject;
  exports.isJSONPatchAdd = isJSONPatchAdd;
  exports.isJSONPatchCopy = isJSONPatchCopy;
  exports.isJSONPatchMove = isJSONPatchMove;
  exports.isJSONPatchOperation = isJSONPatchOperation;
  exports.isJSONPatchRemove = isJSONPatchRemove;
  exports.isJSONPatchReplace = isJSONPatchReplace;
  exports.isJSONPatchTest = isJSONPatchTest;
  exports.parseFrom = parseFrom;
  exports.parseJSONPointer = parseJSONPointer;
  exports.parsePath = parsePath;
  exports.revertJSONPatch = revertJSONPatch;
  exports.setIn = setIn;
  exports.startsWithJSONPointer = startsWithJSONPointer;
  exports.transform = transform;
  exports.updateIn = updateIn;

}));
//# sourceMappingURL=immutableJSONPatch.js.map
